{"version":3,"sources":["webpack:///bundle.db381.js","webpack:///webpack/bootstrap 2e3fd2c57d167260d556","webpack:///../~/pouchdb/lib/index-browser.es.js","webpack:///../~/spark-md5/spark-md5.js","webpack:///../~/pouchdb-collate/lib/index.es.js","webpack:///../~/ibm-shopping-list-model/src/ShoppingListRepository.js","webpack:///../~/argsarray/index.js","webpack:///../~/cuid/dist/browser-cuid.js","webpack:///../~/inherits/inherits_browser.js","webpack:///../~/pouchdb-promise/lib/index.es.js","webpack:///../~/ms/index.js","webpack:///../~/pouchdb-binary-utils/lib/index-browser.es.js","webpack:///./secret.js","webpack:///../~/pouchdb-selector-core/lib/index.es.js","webpack:///./components/ShoppingLists.js","webpack:///../~/ibm-shopping-list-model/src/index.js","webpack:////usr/local/lib/~/preact-cli/~/path-browserify/index.js","webpack:///./index.js","webpack:///../~/preact/dist/preact.min.js","webpack:///./components/ShoppingList.js","webpack:///../~/pouchdb-mapreduce-utils/lib/index.es.js","webpack:///./App.js","webpack:///../~/ibm-shopping-list-model/src/ShoppingListFactory.js","webpack:///../~/pouchdb-md5/lib/index-browser.es.js","webpack:///../~/immutable/dist/immutable.js","webpack:///../~/vuvuzela/index.js","webpack:///../~/ibm-shopping-list-model/~/immutable/dist/immutable.js","webpack:///../~/uuid/lib/bytesToUuid.js","webpack:///../~/uuid/lib/rng-browser.js","webpack:////usr/local/lib/~/preact-cli/~/events/events.js","webpack:///(webpack)/buildin/global.js","webpack:///../~/uuid/v1.js","webpack:///../~/uuid/v4.js","webpack:///../~/debug/src/browser.js","webpack:///../~/pouchdb-utils/lib/index-browser.es.js","webpack:////usr/local/lib/~/preact-cli/lib/lib/entry.js","webpack:///../~/uuid/index.js","webpack:///../~/pouchdb-errors/lib/index.es.js","webpack:///../~/pouchdb-abstract-mapreduce/lib/index.es.js","webpack:///../~/pouchdb-collections/lib/index.es.js","webpack:///../~/pouchdb-find/lib/index-browser.es.js","webpack:///../~/immediate/lib/browser.js","webpack:///../~/ibm-shopping-list-model/src/ShoppingListRepositoryPouchDB.js","webpack:////usr/local/lib/~/preact-cli/~/node-libs-browser/mock/process.js","webpack:///../~/lie/lib/browser.js","webpack:///../~/debug/src/debug.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","+bp/","__webpack_exports__","global","isBinaryObject","ArrayBuffer","Blob","cloneArrayBuffer","buff","slice","target","byteLength","Uint8Array","set","cloneBinaryObject","size","type","webkitSlice","isPlainObject","proto","getPrototypeOf","Ctor","constructor","funcToString","objectCtorString","clone","newObject","len","Array","isArray","length","Date","toISOString","once","fun","called","__WEBPACK_IMPORTED_MODULE_2_argsarray___default","args","Error","apply","this","toPromise","func","self","usedCB","pop","promise","PouchPromise$1","fulfill","reject","resp","callback","err","mesg","push","then","e","result","logApiCall","listeners","logArgs","emit","origCallback","res","responseArgs","concat","adapterFun","_closed","_destroyed","taskqueue","isReady","addTask","failed","mangle","key","unmangle","substring","Map$1","_store","Set$1","array","add","pick","obj","arr","prop","identityFunction","x","formatResultForOpenRevsGet","ok","bulkGet","db","opts","collapseResultsAndFinish","results","perDocResults","forEach","docs","info","id","checkDone","numDone","numDocs","gotResult","docIndex","nextBatch","allRequests","upTo","Math","min","MAX_NUM_CONCURRENT_REQUESTS","batch","processBatch","offset","docId","j","docIdx","docRequests","requestsById","docOpts","open_revs","map","request","rev","filter","formatResult","param","error","requests","ExportedMap","has","isChromeApp","chrome","storage","local","hasLocalStorage","hasLocal","attachBrowserEvents","onChanged","addListener","db_name","dbName","newValue","addEventListener","window","attachEvent","Changes","__WEBPACK_IMPORTED_MODULE_3_events__","_listeners","guardedConsole","method","console","arguments","randomNumber","max","parseInt","maxTimeout","random","defaultBackOff","explainError","status","str","PouchError","reason","message","createError","CustomPouchError","undefined","generateErrorFromResponse","data","UNKNOWN_ERROR","tryFilter","doc","req","msg","toString","BAD_REQUEST","filterChange","hasFilter","query","query_params","change","filterReturn","include_docs","attachments","att","_attachments","stub","flatten","arrs","f","invalidIdError","INVALID_ID","test","RESERVED_ID","MISSING_ID","isRemote","_remote","listenerCount","ee","parseDesignDocFunctionName","parts","split","normalizeDesignDocFunctionName","normalized","join","parseUri","parser","exec","uri","keys","encoded","indexOf","decodeURIComponent","qName","replace","qParser","$0","$1","$2","scopeEval","source","scope","values","Function","upsert","diffFun","docRev","_rev","newDoc","updated","_id","tryAndPut","put","__WEBPACK_IMPORTED_MODULE_0_uuid___default","a","v4","toLowerCase","winningRev","metadata","winningId","winningPos","winningDeleted","node","toVisit","rev_tree","tree","ids","branches","pos","deleted","traverseRevTree","revs","newCtx","ctx","sortByPos","b","collectLeaves","leaves","isLeaf","acc","sort","reverse","collectConflicts","win","conflicts","leaf","compactTree","revHash","rootToLeaf","paths","history","sortByPos$1","binarySearch","item","comparator","mid","low","high","insertSorted","splice","pathToTree","path","numStemmed","root","currentLeaf","compareTree","mergeTree","in_tree1","in_tree2","queue","tree1","tree2","merged","doMerge","dontExpand","restree","branch","t1","t2","diff","candidateParents","trees","parent","parentIdx","elements","elementsLen","el","stem","depth","stemmedRevs","stemmed","merge","newTree","revExists","splitRev","targetPos","targetId","getTrees","isDeleted","isLocalId","latest","historyNode","historyRev","tryCatchInChangeListener","Changes$2","onDestroy","cancel","complete","removeAllListeners","removeListener","on","onChange","isCancelled","bind","validateChanges","processChange","changeList","style","changes","_conflicts","compare","left","right","yankError","cleanDocs","_deleted","atts","compareByIdThenRev","idCompare","_revisions","start","computeHeight","height","edges","prnt","rev$$1","from","to","edge","allDocsKeysQuery","api","skip","limit","descending","_allDocs","finalResults","all","subOpts","$inject_Object_assign","optKey","resolve","total_rows","rows","doNextCompaction","task","_compactionQueue","catch","last_seq","_compact","__WEBPACK_IMPORTED_MODULE_5_immediate___default","shift","attachmentNameError","charAt","AbstractPouchDB","TaskQueue$1","parseAdapter","match","adapter","adapters","PouchDB$5","preferredAdapters","prefix","adapterName","localStorage","use_prefix","prepareForDestruction","onDestroyed","from_constructor","onClosed","__opts","auto_compaction","prefixedName","backend","_adapter","valid","fail","ready","debugPouch","PouchDB","debug","__WEBPACK_IMPORTED_MODULE_6_debug___default","logs","logId","getFieldFromDoc","parsedField","compare$1","parseField","fieldName","fields","current","ch","isCombinationalField","field","combinationFields","getKey","getValue","mergeAndedSelectors","selectors","selector","matcher","$eq","fieldMatchers","operator","mergeGtGte","mergeLtLte","mergeNe","mergeEq","$gte","$gt","$lte","$lt","$ne","massageSelector","input","wasAnded","orOrNor","subSelector","pad","padWith","upToLength","padding","targetLength","padLeft","collate","normalizeKey","ai","collationIndex","bi","stringCollate","arrayCollate","objectCollate","Infinity","isNaN","origKey","toJSON","k","val","indexify","numToIndexableString","toIndexableString","objKey","SEP","parseNumber","num","originalIdx","neg","numAsString","magAsString","MAGNITUDE_DIGITS","magnitude","MIN_MAGNITUDE","parseFloat","stack","metaStack","lastMetaElement","element","lastElementIndex","index","parseIndexableString","parsedNum","parsedStr","arrayElement","objElement","ak","bk","idx","expFormat","toExponential","magForComparison","magString","factor","abs","factorStr","toFixed","createFieldSorter","getFieldValuesAsArray","sorting","aRow","bRow","aFieldValues","bFieldValues","collation","filterInMemoryFields","requestDef","inMemoryFields","row","rowFilter","every","docFieldValue","matchCominationalSelector","matchSelector","userOperator","some","orMatchers","find","userValue","matchers","fieldExists","fieldIsNotUndefined","modField","divisor","mod","arrayContainsValue","arrayContainsAllValues","arraySize","regexMatch","RegExp","typeMatch","matchesSelector","rowsMatched","evalFilter","evalView","validate","filterName","normalize","view","shouldFilter","changesHandler","doc_ids","viewName","ddoc","mapFun","views","MISSING_DOC","doChanges","filterFun","filters","applyChangesFilterPlugin","_changesFilterPlugin","toObject","reduce","parseRevisionInfo","INVALID_REV","makeRevTreeFromRevisions","revisions","revisionIds","parseDoc","newEdits","nRevNum","newRevId","revInfo","uuid","_rev_tree","specialKey","reservedWords","DOC_VALIDATION","dataWords","createBlob","properties","Builder","BlobBuilder","MSBlobBuilder","MozBlobBuilder","WebKitBlobBuilder","builder","append","getBlob","binaryStringToArrayBuffer","bin","buf","charCodeAt","binStringToBluffer","binString","b64ToBluffer","b64","thisAtob","arrayBufferToBinaryString","buffer","binary","bytes","String","fromCharCode","readAsBinaryString","blob","FileReader","FileReaderSync","readAsArrayBuffer","reader","hasBinaryString","onloadend","blobToBinaryString","blobOrBuffer","blobToBase64","base64","thisBtoa","rawToBase64","raw","sliceBlob","end","appendBlob","arrayBuffer","appendString","string","appendBinary","binaryMd5","next","setImmediateShim","loadNextChunk","done","destroy","currentChunk","chunkSize","chunks","inputIsString","MD5_CHUNK_SIZE","ceil","__WEBPACK_IMPORTED_MODULE_7_spark_md5___default","stringMd5","hash","parseBase64","BAD_ARG","preprocessString","blobType","asBinary","content_type","digest","preprocessBlob","md5","preprocessAttachment","preprocessAttachments","docInfos","docv","overallErr","docInfo","processedAttachment","recv","updateDoc","revLimit","prev","cb","writeDoc","previousWinningRev","previouslyDeleted","isRoot","REV_CONFLICT","newRev","rev_map","newRevIsDeleted","winningRev$$1","winningRevIsDeleted","delta","rootIsMissing","processDocs","fetchedDocs","tx","overallCallback","insertDoc","resultsIdx","checkAllDocsDone","docsDone","docsToDo","new_edits","idsToDocs","currentDoc","docWritten","nextDoc","safeJsonParse","JSON","parse","__WEBPACK_IMPORTED_MODULE_8_vuvuzela___default","safeJsonStringify","json","stringify","idbError","evt","IDB_ERROR","encodeMetadata","deletedOrLocal","seq","decodeMetadata","storedObject","decodeDoc","_doc_id_rev","lastIndexOf","readBlobData","body","asBlob","fetchAttachmentsIfNecessary","txn","fetchAttachment","attObj","objectStore","ATTACH_STORE","onsuccess","postProcessAttachments","attNames","compactRevs","count","deleteOrphanedAttachments","possiblyOrphanedDigests","attAndSeqStore","IDBKeyRange","bound","attStore","delete","seqStore","BY_SEQ_STORE","ATTACH_AND_SEQ_STORE","openCursor","only","event","cursor","digestSeq","primaryKey","continue","openTransactionSafely","idb","stores","mode","transaction","idbBulkDocs","dbOpts","startTransaction","DOC_STORE","LOCAL_STORE","META_STORE","txnResult","onabort","ontimeout","oncomplete","docStore","bySeqStore","attachStore","attachAndSeqStore","metaStore","metaDoc","updateDocCountIfReady","verifyAttachments","preconditionErrored","fetchExistingDocs","onAllDocsProcessed","allDocsProcessed","idbProcessDocs","revs_limit","docCount","docCountDelta","numFetched","readMetadata","notify","_meta","verifyAttachment","MISSING_STUB","finish","digests","filename","attErr","isUpdate","writeAttachments","finishDoc","afterPutDoc","revsToDelete","metadataToStore","afterPutMetadata","afterPutDocError","preventDefault","stopPropagation","insertAttachmentMappings","putReq","onerror","collectResults","attachmentSaved","revpos","saveAttachment","attsAdded","attsToAdd","docInfoError","blobSupport","runBatchedCursor","keyRange","batchSize","onBatch","onGetAll","valuesBatch","keysBatch","pseudoCursor","onGetAllKeys","continuePseudoCursor","newKeyRange","lastKey","upper","upperOpen","code","lowerBound","getAll","getAllKeys","onCursor","useGetAll","onSuccess","createKeyRange","inclusiveEnd","upperBound","idbAllDocs","fetchDocAsynchronously","docIdRevIndex","allDocsInner","batchValues","batchValue","batchKeys","onResultsReady","onTxnComplete","startkey","endkey","inclusive_end","keyRangeError","checkBlobSupport","DETECT_BLOB_SUPPORT_STORE","matchedChrome","navigator","userAgent","matchedEdge","countDocs","tryCode","applyNext","running","enqueueTask","action","processMetadataAndWinningDoc","winningDoc","lastSeq","filtered","numResults","returnDocs","onBatchDone","winningDocs","metadatas","fetchWinningDocAndMetadata","onGetMetadata","docIds","docIdsToMetadata","continuous","ExportedSet","since","return_docs","objectStores","IdbPouch","thisCallback","init","createSchema","createObjectStore","keyPath","autoIncrement","createIndex","unique","addDeletedOrLocalIndex","createLocalStoreSchema","migrateLocalStore","localStore","docIdRev","range","seqCursor","addAttachAndSeqStore","migrateAttsAndSeqs","digestMap","migrateMetadata","decodeMetadataCompat","onGetMetadataSeq","metadataSeq","instanceId","_bulkDocs","reqOpts","_get","_getAttachment","attachId","attachment","blobData","_info","updateSeq","doc_count","update_seq","idb_attachment_format","_changes","_close","close","cachedDBs","_getRevisionTree","_doCompaction","_getLocal","_putLocal","oldRev","ret","oStore","oldDoc","_removeLocal","_destroy","openReq","openReqList","indexedDB","deleteDatabase","cached","tryStorageOption","open","ADAPTER_VERSION","onupgradeneeded","migration","migrations","oldVersion","currentTarget","completeSetup","storedMetaDoc","storeMetaDocIfReady","instanceKey","onversionchange","blobSupportPromise","version","decodeUtf8","escape","hexToInt","charCode","parseHexUtf8","parseHexUtf16","parseHexString","encoding","quote","escapeBlob","unescapeBlob","stringifyDoc","unstringifyDoc","qMarks","select","table","joiner","where","orderBy","compactRevs$1","deleteOrphans","seqs","sql","ATTACH_AND_SEQ_STORE$1","executeSql","digestsToCheck","nonOrphanedDigests","ATTACH_STORE$1","BY_SEQ_STORE$1","websqlError","errorNameMatch","errorName","WSQ_ERROR","getSize","websqlBulkDocs","websqlChanges","_name","cnt","deletedInt","insertId","dataWritten","fetchSql","attachmentErr","revsToCompact","DOC_STORE$1","metadataStr","websqlProcessDocs","userDocs","docInfoErrors","openDatabaseWithOpts","websql","description","openDBSafely","openDB$1","cachedResult","cachedDatabases","fetchAttachmentsIfNecessary$1","_","WebSqlPouch$1","dbCreated","runMigration2","DOC_STORE_WINNINGSEQ_INDEX_SQL","BY_SEQ_STORE_DELETED_INDEX_SQL","runMigration3","LOCAL_STORE$1","doNext","runMigration4","updateRows","doc_id_rev","hex","doc_id","BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL","runMigration5","nextPage","SELECT_DOCS","DOC_STORE_AND_BY_SEQ_JOINER","pageSize","digestSeqs","digestSeqPairs","pair","ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL","ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL","runMigration6","runMigration7","checkEncoding","onGetInstanceId","idRequests","onGetVersion","dbVersion","meta","META_STORE$1","attach","attachAndRev","initSeq","ADAPTER_VERSION$1","setupDone","dbid","tasks","nextMigration","fetchVersion","db_version","getMaxSeq","latest$$1","websqlOpts","POUCH_VERSION","openDBResult","readTransaction","theSeq","theDocCount","websql_encoding","sqlArgs","latestRev","totalRows","criteria","selectStmt","reportChange","maxSeq","escaped","putLocal","rowsAffected","removeLocal","store","canOpenTestDB","openDatabase","isValidWebSQL","hasLS","localStorageKey","openedTestDB","openDB","WebSQLPouch","wrappedFetch","wrappedPromise","fetch","response","fetchRequest","options","timer","headers","Headers","fetchOptions","credentials","processData","url","timeout","setTimeout","fetchResponse","statusCode","clearTimeout","text","abort","xhRequest","xhr","timedout","abortReq","cleanUp","timeoutReq","onprogress","upload","onreadystatechange","XMLHttpRequest","exception","withCredentials","Accept","responseType","setRequestHeader","readyState","getResponseHeader","responseText","send","ajax$1","hasXhr","defaultBody","ajaxCore$1","v","missing","res$2","cache","ajax","ua","isSafari","isIE","isEdge","shouldCacheBust","now","pool","promiseFactories","runNext","onError","runNextBatch","thisErr","readAttachmentsAsBlobOrBuffer","encodeDocId","encodeURIComponent","preprocessAttachments$2","hasUrlPrefix","protocol","getHost","substr","user","password","auth","username","genDBUrl","genUrl","pathDel","host","port","paramsToStr","params","HttpPouch","ajax$$1","userOpts","reqAjax","ajaxOpts","defaultHeaders","_ajax","ajaxPromise","adapterFun$$1","setup","skipSetup","skip_setup","setupPromise","dbUrl","encodeAttachmentId","attachmentId","nAuth","token","unescape","Authorization","uuid$$1","compact","ping","compact_running","interval","doBulkGet","doBulkGetShim","MAX_SIMULTANEOUS_REVS","numBatches","batchNum","supportsBulkGet","supportsBulkGetMap","fetchAttachments","filenames","fetchAllAttachments","docOrDocs","revs_info","remove","docOrId","optsOrRev","getAttachment","removeAttachment","putAttachment","Content-Type","_put","allDocs","start_key","end_key","paramStr","batch_size","CHANGES_BATCH_SIZE","heartbeat","DEFAULT_HEARTBEAT","requestTimeout","CHANGES_TIMEOUT_BUFFER","leftToFetch","feed","param_name","lastFetchedSeq","aborted","xhrOpts","fetched","raw_results_length","finished","revsDiff","QueryParseError","captureStackTrace","NotFoundError","BuiltInError","promisedCallback","callbackify","fin","finalPromiseFactory","sequentialize","promiseFactory","that","uniq","theSet","mapToKeysArray","createBuiltInError","sum","jLen","jNum","evalFunctionWithEval","log","TaskQueue$2","createViewSignature","reduceFun","createView","sourceDB","temporary","localDocName","cachedViews","viewSignature","_cachedViews","promiseForView","diffFunction","fullViewName","depDbs","depDbName","registerDependentDatabase","lastSeqDoc","parseViewName","isGenOne","emitError","getBuiltIn","reduceFunString","builtInReduce","_sum","_count","_stats","mapper","origMap","reducer","builtIn","ddocValidator","abstract","viewCleanup","isGenOne$1","fileHasChanged","localDoc","remoteDoc","getDocAttachments","getDocAttachmentsFromTargetOrSource","src","doCheckForLocalAttachments","createBulkGetOpts","diffs","missingRev","getDocs","state","getAllDocs","bulkGetOpts","bulkGetResponse","cancelled","bulkGetInfo","resultDocs","Boolean","hasAttachments","hasConflicts","fetchRevisionOneDocs","getRevisionOneDocs","returnResult","updateCheckpoint","checkpoint","session","returnValue","session_id","replicator","REPLICATOR","CHECKPOINT_VERSION","unshift","CHECKPOINT_HISTORY_SIZE","Checkpointer","compareReplicationLogs","srcDoc","tgtDoc","compareReplicationHistory","sourceHistory","targetHistory","S","sourceRest","T","targetRest","hasSessionId","LOWEST_SEQ","sessionId","props","rest","isForbiddenError","floor","backOff","retry","back_off_function","backOffSet","current_back_off","STARTING_BACK_OFF","sortObjectPropertiesByKey","queryParams","generateReplicationId","filterViewName","queryData","md5sum","replicate","initCheckpointer","checkpointer","repId","checkpointOpts","writeSourceCheckpoint","writeTargetCheckpoint","writeDocs","changedDocs","currentBatch","bulkDocs","completeReplication","errorsById","create","errorsNo","doc_write_failures","docs_written","errors","finishBatch","outResult","writingCheckpoint","writeCheckpoint","getChanges","onCheckpointError","getDiffs","getBatchDocs","got","docs_read","startNextBatch","batches","processPendingBatch","abortReplication","immediate","pendingBatch","changesOpts","live","changesCompleted","replicationCompleted","fatalError","end_time","onChangesComplete","changesPending","onChangesError","abortChanges","batches_limit","_abortChanges","startChanges","getCheckpoint","start_time","_addedListeners","Replication","toPouch","PouchConstructor","replicateWrapper","replicateRet","sync$1","Sync","pullChange","direction","pushChange","pushDenied","pullDenied","pushPaused","pullPaused","pushActive","pullActive","removeAll","isChange","isDenied","isPaused","isActive","removed","addOneListener","listener","canceled","optsPush","optsPull","pull","out","success","replication","sync","other","__WEBPACK_IMPORTED_MODULE_0_uuid__","__WEBPACK_IMPORTED_MODULE_1_lie__","__WEBPACK_IMPORTED_MODULE_1_lie___default","__WEBPACK_IMPORTED_MODULE_2_argsarray__","__WEBPACK_IMPORTED_MODULE_4_inherits__","__WEBPACK_IMPORTED_MODULE_4_inherits___default","__WEBPACK_IMPORTED_MODULE_5_immediate__","__WEBPACK_IMPORTED_MODULE_6_debug__","__WEBPACK_IMPORTED_MODULE_7_spark_md5__","__WEBPACK_IMPORTED_MODULE_8_vuvuzela__","Promise","mangled","Symbol","Map","Set","getOwnPropertyDescriptor","species","setItem","getItem","eventFunction","inprogress","notifyLocalWindows","assign","nextSource","nextKey","MISSING_BULK_DOCS","QUERY_PARSE_ERROR","NOT_AN_OBJECT","hasName","newPromise","post","putDoc","force","oldRevId","oldRevNum","newRevNum","createAttachment","prevrevpos","was_delete","addToMissing","revId","processDoc","missingForId","missingObj","compactDocument","maxHeight","revTree","candidates","promises","onComplete","finishOpenRevs","existing","splittedRev","revNo","currentPath","hashIndex","indexOfRev","_revs_info","TypeError","incompatibleOpt","_type","attachmentError","dependentDb","dependentDbs","depDB","destroyDb","usePrefix","deletedMap","trueName","execute","eventEmitter","Pouch","destructListeners","_destructionListeners","dbList","addToPreferredAdapters","plugin","__defaults","defaults","defaultOpts","PouchAlt","$elemMatch","$allMatch","$exists","$mod","neValue","$in","$nin","$size","$all","$regex","$type","atob","btoa","setImmediate","platform","IDBPouch","WebSqlPouch","HttpPouch$1","persistentQueues","tempViewQueue","CHANGES_BATCH_SIZE$1","sumsqr","_sumsqr","tryMap","tryReduce","rereduce","output","sortByKeyThenValue","y","keyCompare","sliceResults","rowToDocId","postprocessAttachments","addHttpParam","paramName","asJson","coerceInteger","integerCandidate","asNumber","Number","coerceOptions","group_level","checkPositiveInteger","number","checkQueryParseError","startkeyName","endkeyName","group","optionName","httpQuery","keysAsString","customQuery","_query","customViewCleanup","_viewCleanup","defaultsTo","getDocsToPersist","docIdsToChangesAndEmits","getKeyValueDocs","processKeyValueDocs","kvDocsRes","kvDocs","oldKeys","indexableKeysToKeyValues","keyValue","newKeys","kvDoc","metaDocId","defaultMetaDoc","docData","saveKeyValues","listOfDocsToPersist","docsToPersist","getQueue","updateView","updateViewInQueue","mapResults","processNextBatch","currentSeq","createDocIdsToChangesAndEmits","createIndexableKeysToKeyValues","emittedKeyValue","complexKey","reduceView","shouldGroup","groups","lvl","POSITIVE_INFINITY","last","groupKey","reduceTry","queryView","queryViewInQueue","fetchFromView","viewOpts","expectedKeys","parsedKeyAndDocId","onMapResultsReady","shouldReduce","allDocsRes","docIdsToDocs","fetchPromises","keyStart","keyEnd","httpViewCleanup","localViewCleanup","docsToViews","designDocName","viewsToStatus","ddocName","statusIsGood","viewDBName","dbsToDelete","destroyPromises","queryPromised","stale","abstractQuery","mapreduce","updateTarget","updateSource","readOnlySource","comparisons","targetDoc","sourceDoc","1","cleanup","_readyCalled","0","13nb","factory","md5cycle","md5blk","md5blks","md5blk_array","md51","tail","tmp","lo","hi","md51_array","subarray","rhex","hex_chr","toUtf8","utf8Str2ArrayBuffer","returnUInt8Array","arrayBuffer2Utf8Str","concatenateArrayBuffers","first","second","hexToBinaryString","SparkMD5","reset","lsw","clamp","targetArray","sourceArray","begin","contents","_buff","_length","_hash","_finish","getState","setState","hashBinary","content","1XVU","1ipf","ShoppingListRepository","putBulk","putItem","putItemsBulk","findItems","findItemsCountByList","deleteItem","38I5","argsArray","435A","app","discreteValues","pow","randomBlock","safeCounter","counter","timestamp","getTime","fingerprint","slug","date","print","globalCount","mimeTypes","register","applitude","4Bm0","ctor","superCtor","super_","writable","TempCtor","5euN","__WEBPACK_IMPORTED_MODULE_0_lie__","__WEBPACK_IMPORTED_MODULE_0_lie___default","6IAg","h","fmtShort","ms","round","fmtLong","plural","long","8/Wf","9RN+","9oy1","cloudant_url","C9XX","setFieldInDoc","__WEBPACK_IMPORTED_MODULE_0_pouchdb_utils__","__WEBPACK_IMPORTED_MODULE_1_pouchdb_collate__","CR5u","_possibleConstructorReturn","ReferenceError","_inherits","subClass","superClass","setPrototypeOf","__proto__","__WEBPACK_IMPORTED_MODULE_0_preact__","_ref","className","_ref3","_ref4","_ref5","_Component","ShoppingLists","_temp","_this","_ret","_len","_key","editingName","activeListId","oldName","newName","handleEditingStart","listid","listtitle","handleEditingDone","handleEditingSubmit","renameListFunc","updateName","renderEditNameUI","_h","onSubmit","class","margin-top","background-color","ref","inp","nameInput","font-size","margin-bottom","onClick","componentDidUpdate","focus","render","_this2","listItems","_iterator","shoppingLists","_isArray","_i","iterator","_ref2","list","margin","href","openListFunc","title","deleteListFunc","checkAllFunc","defaultChecked","for","checkedCounts","totalCounts","HSMo","_require","ShoppingListFactory","_require2","_require3","ShoppingListRepositoryPouchDB","IFa6","process","normalizeArray","allowAboveRoot","up","xs","splitPathRe","splitPath","resolvedPath","resolvedAbsolute","cwd","isAbsolute","trailingSlash","relative","trim","fromParts","toParts","samePartsLength","outputParts","sep","delimiter","dirname","dir","basename","ext","extname","JkW7","__WEBPACK_IMPORTED_MODULE_1_ibm_shopping_list_model__","__WEBPACK_IMPORTED_MODULE_2_pouchdb__","__WEBPACK_IMPORTED_MODULE_3_pouchdb_find__","__WEBPACK_IMPORTED_MODULE_4__secret__","__WEBPACK_IMPORTED_MODULE_5__material_icons_css__","__WEBPACK_IMPORTED_MODULE_6__materialize_min_css__","__WEBPACK_IMPORTED_MODULE_7__App_css__","__WEBPACK_IMPORTED_MODULE_8__App__","localDB","remoteDB","shoppingListFactory","shoppingListRepository","ensureIndexes","document","KM04","t","r","E","W","children","u","nodeName","attributes","vnode","__d","A","debounceRendering","P","splitText","_componentConstructor","__n","defaultProps","createElementNS","createElement","parentNode","removeChild","cssText","V","innerHTML","__html","removeEventListener","__l","removeAttribute","removeAttributeNS","setAttributeNS","setAttribute","D","afterMount","componentDidMount","H","R","ownerSVGElement","appendChild","_component","nodeValue","createTextNode","replaceChild","__preactattr_","U","firstChild","nextSibling","dangerouslySetInnerHTML","g","childNodes","w","C","N","__k","insertBefore","L","lastChild","previousSibling","I","__b","__x","__r","base","componentWillMount","componentWillReceiveProps","context","__c","__p","syncComponentUpdates","__s","shouldComponentUpdate","componentWillUpdate","getChildContext","M","__u","afterUpdate","__h","beforeUnmount","componentWillUnmount","forceUpdate","$","cloneElement","Component","rerender","NPHD","ShoppingList","activeItemId","itemid","itemtitle","renameItemFunc","items","shoppingListItems","toggleItemCheckFunc","checked","deleteFunc","RIsC","S03M","T/c0","__WEBPACK_IMPORTED_MODULE_2_pouchdb_utils__","__WEBPACK_IMPORTED_MODULE_1_argsarray___default","__WEBPACK_IMPORTED_MODULE_0_pouchdb_collections__","__WEBPACK_IMPORTED_MODULE_1_argsarray__","__WEBPACK_IMPORTED_MODULE_3_inherits__","__WEBPACK_IMPORTED_MODULE_3_inherits___default","UuX/","__WEBPACK_IMPORTED_MODULE_1_immutable__","__WEBPACK_IMPORTED_MODULE_2_ibm_shopping_list_model__","__WEBPACK_IMPORTED_MODULE_3__components_ShoppingList__","__WEBPACK_IMPORTED_MODULE_4__components_ShoppingLists__","App","getShoppingLists","getPouchDocs","checkedCount","totalCount","lists","foundLists","countsList","checkedList","shoppingList","checkedTotalShoppingListItemCount","totalShoppingListItemCount","openShoppingList","getShoppingListItems","refreshShoppingListItems","renameShoppingListItem","newname","deleteShoppingListItem","toggleItemCheck","checkAllListItems","listcheck","newitems","mergeDeep","listOfShoppingListItems","newListOfShoppingListItems","deleteShoppingList","renameShoppingList","createNewShoppingListOrItem","adding","newShoppingList","newShoppingListItem","displayAddingUI","renderNewNameUI","marginTop","placeholder","fullWidth","width","underlineStyle","renderShoppingLists","renderShoppingListItems","renderBackButton","vertical-align","screenname","margin-right","line-height","YrHc","cuid","Record","List","_ShoppingList","place","createdAt","updatedAt","_ShoppingListItem","_guardShoppingList","isRecord","_guardListOfShoppingLists","listOfShoppingLists","_guardShoppingListItem","shoppingListItem","_guardListOfShoppingListItems","newListOfShoppingLists","ZfEw","__WEBPACK_IMPORTED_MODULE_1_spark_md5___default","__WEBPACK_IMPORTED_MODULE_1_spark_md5__","Zuze","createClass","Iterable","isIterable","Seq","KeyedIterable","isKeyed","KeyedSeq","IndexedIterable","isIndexed","IndexedSeq","SetIterable","isAssociative","SetSeq","maybeIterable","IS_ITERABLE_SENTINEL","maybeKeyed","IS_KEYED_SENTINEL","maybeIndexed","IS_INDEXED_SENTINEL","maybeAssociative","isOrdered","maybeOrdered","IS_ORDERED_SENTINEL","MakeRef","SetRef","OwnerID","arrCopy","newArr","ii","ensureSize","iter","__iterate","returnTrue","wrapIndex","uint32Index","NaN","wholeSlice","resolveBegin","resolveIndex","resolveEnd","defaultIndex","Iterator","iteratorValue","iteratorResult","iteratorDone","hasIterator","getIteratorFn","isIterator","maybeIterator","getIterator","iterable","iteratorFn","REAL_ITERATOR_SYMBOL","FAUX_ITERATOR_SYMBOL","isArrayLike","emptySequence","toSeq","seqFromValue","toKeyedSeq","fromEntrySeq","keyedSeqFromValue","entrySeq","toIndexedSeq","indexedSeqFromValue","toSetSeq","ArraySeq","_array","ObjectSeq","_object","_keys","IterableSeq","_iterable","IteratorSeq","_iteratorCache","isSeq","maybeSeq","IS_SEQ_SENTINEL","EMPTY_SEQ","maybeIndexedSeqFromValue","seqIterate","fn","useKeys","_cache","maxIndex","entry","__iterateUncached","seqIterator","__iteratorUncached","fromJS","converter","fromJSWith","","fromJSDefault","parentJSON","isPlainObj","toList","toMap","is","valueA","valueB","valueOf","equals","deepEqual","__hash","notAssociative","entries","flipped","cacheResult","allEqual","bSize","NOT_SET","Repeat","times","_value","EMPTY_REPEAT","Range","step","_start","_end","_step","EMPTY_RANGE","Collection","KeyedCollection","IndexedCollection","SetCollection","smi","i32","STRING_HASH_CACHE_MIN_STRLEN","cachedHashString","hashString","hashCode","hashJSObj","stringHashCache","STRING_HASH_CACHE_SIZE","STRING_HASH_CACHE_MAX_SIZE","usingWeakMap","weakMap","UID_HASH_KEY","canDefineProperty","propertyIsEnumerable","getIENodeHash","objHashUID","isExtensible","nodeType","uniqueID","documentElement","assertNotInfinite","emptyMap","isMap","withMutations","maybeMap","IS_MAP_SENTINEL","ArrayMapNode","ownerID","BitmapIndexedNode","bitmap","nodes","HashArrayMapNode","HashCollisionNode","keyHash","ValueNode","MapIterator","_reverse","_stack","_root","mapIteratorFrame","mapIteratorValue","__prev","makeMap","MapPrototype","__ownerID","__altered","EMPTY_MAP","updateMap","newRoot","newSize","didChangeSize","CHANGE_LENGTH","didAlter","DID_ALTER","updateNode","update","isLeafNode","mergeIntoNode","newNode","idx1","MASK","idx2","SHIFT","createNodes","packNodes","excluding","packedII","packedNodes","bit","expandNodes","including","expandedNodes","SIZE","mergeIntoMapWith","merger","iterables","iters","mergeIntoCollectionWith","deepMerger","deepMergerWith","mergeDeepWith","nextValue","collection","mergeIntoMap","updateInDeepMap","keyPathIter","notSetValue","updater","isNotSet","existingValue","nextExisting","nextUpdated","popCount","setIn","canEdit","newArray","spliceIn","newLen","after","spliceOut","empty","emptyList","isList","makeList","VNode","toArray","setSize","maybeList","IS_LIST_SENTINEL","iterateList","iterateNodeOrLeaf","level","iterateLeaf","iterateNode","tailPos","DONE","_origin","_capacity","getTailOffset","_tail","_level","origin","capacity","ListPrototype","EMPTY_LIST","updateList","setListBounds","newTail","updateVNode","nodeHas","lowerNode","newLowerNode","editableVNode","listNodeFor","rawIndex","owner","oldOrigin","oldCapacity","newOrigin","newCapacity","clear","newLevel","offsetShift","oldTailOffset","newTailOffset","oldTail","removeAfter","removeBefore","beginIndex","mergeIntoListWith","maxSize","OrderedMap","emptyOrderedMap","isOrderedMap","maybeOrderedMap","makeOrderedMap","omap","_map","_list","EMPTY_ORDERED_MAP","updateOrderedMap","newMap","newList","flip","ToKeyedSequence","indexed","_iter","_useKeys","ToIndexedSequence","ToSetSequence","FromEntriesSequence","flipFactory","flipSequence","makeSequence","reversedSequence","includes","cacheResultThrough","this$0","ITERATE_ENTRIES","__iterator","ITERATE_VALUES","ITERATE_KEYS","mapFactory","mappedSequence","reverseFactory","filterFactory","predicate","filterSequence","iterations","countByFactory","grouper","asMutable","asImmutable","groupByFactory","isKeyedIter","coerce","iterableClass","reify","sliceFactory","originalSize","resolvedBegin","resolvedEnd","sliceSize","resolvedSize","sliceSeq","skipped","isSkipping","takeWhileFactory","takeSequence","iterating","skipWhileFactory","skipSequence","skipping","concatFactory","isKeyedIterable","singleton","concatSeq","flattenFactory","flatSequence","flatDeep","currentDepth","stopped","flatMapFactory","interposeFactory","separator","interposedSequence","sortFactory","defaultComparator","maxFactory","maxCompare","comp","zipWithFactory","keyIter","zipper","zipSequence","iterators","isDone","steps","validateEntry","resolveSize","forceIterator","defaultValues","hasInitialized","RecordType","setProps","RecordTypePrototype","_defaultValues","RecordPrototype","makeRecord","likeRecord","record","recordName","names","setProp","emptySet","isSet","maybeSet","IS_SET_SENTINEL","updateSet","__empty","__make","makeSet","SetPrototype","EMPTY_SET","OrderedSet","emptyOrderedSet","isOrderedSet","maybeOrderedSet","makeOrderedSet","OrderedSetPrototype","EMPTY_ORDERED_SET","Stack","emptyStack","isStack","unshiftAll","maybeStack","IS_STACK_SENTINEL","makeStack","head","StackPrototype","_head","EMPTY_STACK","mixin","methods","keyCopier","getOwnPropertySymbols","keyMapper","entryMapper","not","quoteString","defaultZipper","defaultNegComparator","hashIterable","ordered","keyed","murmurHashOfSize","hashMerge","imul","SLICE$0","Keyed","Indexed","ITERATOR_SYMBOL","KEYS","VALUES","ENTRIES","inspect","toSource","of","__toString","searchValue","possibleIndex","offsetValue","WeakMap","keyValues","updateIn","deleteIn","updatedValue","mergeWith","mergeIn","mergeDeepIn","sortBy","mutable","wasAltered","__ensureOwner","iterate","removeIn","exists","MAX_ARRAY_MAP_SIZE","isEditable","newEntries","keyHashFrag","MAX_BITMAP_INDEXED_SIZE","newBitmap","newNodes","newCount","MIN_HASH_ARRAY_MAP_SIZE","keyMatch","subNode","insert","oldSize","originIndex","newChild","removingFirst","oldChild","editable","sizeIndex","valueSeq","indexedIterable","defaultVal","_empty","fromKeys","keySeq","union","intersect","originalSet","subtract","peek","pushAll","toJS","__toJS","toOrderedMap","toOrderedSet","toSet","toStack","__toStringMapper","findEntry","sideEffect","joined","isFirst","initialReduction","reduction","useFirst","reduceRight","reversed","butLast","isEmpty","countBy","entriesSequence","filterNot","found","findKey","findLast","findLastEntry","findLastKey","flatMap","searchKey","getIn","searchKeyPath","nested","groupBy","hasIn","isSubset","isSuperset","keyOf","lastKeyOf","maxBy","minBy","amount","skipLast","skipWhile","skipUntil","take","takeLast","takeWhile","takeUntil","IterablePrototype","chain","contains","mapEntries","mapKeys","KeyedIterablePrototype","findIndex","removeNum","numArgs","spliced","findLastIndex","interpose","interleave","zipped","interleaved","zip","zipWith","cRy3","arrayPrefix","objPrefix","numChar","parsedString","lastCh","numConsecutiveSlashes","d18E","isImmutable","maybeImmutable","isCollection","maybeCollection","maybeRecord","IS_RECORD_SENTINEL","isValueObject","maybeValue","CollectionSeq","defaultConverter","parentValue","converted","this$1","collectionClass","isKeyedCollection","coerceKeyPath","hash$$1","collections","oldVal","newVal","hashCollection","_values","recordSeq","Collection$$1","_collection","KeyedSeq$$1","IndexedSeq$$1","SetSeq$$1","indexedCollection","KeyedCollection$$1","deleteAll","Iterator$$1","IndexedCollection$$1","Map$$1","arguments$1","SetCollection$$1","sets","toRemove","CollectionPrototype","KeyedCollectionPrototype","IndexedCollectionPrototype","Set$$1","indices","_indices","propName","warn","newValues","getDescriptiveName","Immutable","dAjQ","bytesToUuid","bth","byteToHex","f+DB","rng","crypto","msCrypto","getRandomValues","rnds8","rnds","gUuJ","EventEmitter","_events","_maxListeners","isFunction","arg","isNumber","isObject","isUndefined","defaultMaxListeners","setMaxListeners","er","handler","newListener","warned","trace","fired","position","evlistener","emitter","h4f+","eval","hVVj","v1","clockseq","_clockseq","msecs","nsecs","_lastNSecs","dt","_lastMSecs","tl","tmh","_nodeId","_seedBytes","hYHi","jcLW","useColors","firebug","formatArgs","namespace","humanize","color","lastC","save","namespaces","removeItem","load","env","DEBUG","colors","formatters","enable","mY35","__WEBPACK_IMPORTED_MODULE_1_pouchdb_promise__","__WEBPACK_IMPORTED_MODULE_4_events__","assign$1","__WEBPACK_IMPORTED_MODULE_5_inherits__","__WEBPACK_IMPORTED_MODULE_5_inherits___default","__WEBPACK_IMPORTED_MODULE_6_immediate__","__WEBPACK_IMPORTED_MODULE_6_immediate___default","osyQ","_preact","location","serviceWorker","interopDefault","default","firstElementChild","qQO4","qncM","qove","TaskQueue","__WEBPACK_IMPORTED_MODULE_0_pouchdb_promise__","__WEBPACK_IMPORTED_MODULE_5_pouchdb_md5__","createAbstractMapReduce","__WEBPACK_IMPORTED_MODULE_4_pouchdb_collate__","__WEBPACK_IMPORTED_MODULE_3_pouchdb_binary_utils__","__WEBPACK_IMPORTED_MODULE_6_pouchdb_mapreduce_utils__","__WEBPACK_IMPORTED_MODULE_1_pouchdb_collections__","qpbW","rsNZ","massageCreateIndexRequest","explain","getIndexes","deleteIndex","indexDef","getArguments","nextTick","mergeObjects","__WEBPACK_IMPORTED_MODULE_2_pouchdb_selector_core__","oneArrayIsSubArrayOfOther","oneArrayIsStrictSubArrayOfOther","oneSetIsSubArrayOfOther","leftIdx","arrayToObject","maxScore","score","arrayEquals","arr1","arr2","createDeepMultiMapper","toEmit","iLen","createDeepSingleMapper","createShallowSingleMapper","createShallowMultiMapper","checkShallow","createMapper","isShallow","isSingle","mapFunDef","massageSort","massageUseIndex","useIndex","cleanedUseIndex","massageIndexDef","getKeyFromDoc","def","filterInclusiveStart","targetValue","indexFields","docKey","reverseOptions","newOpts","inclusive_start","validateIndex","ascFields","validateSort","defaultUsed","noneIdSorts","sortItem","validateFindRequest","getUserFields","userFields","selectorFields","sortFields","MAX_VALUE","rightIdx","sortOrder","createIndex$1","getMd5","updateDdoc","language","hasInvalidLanguage","viewExists","originalIndexDef","ddocId","abstractMapper","getIndexes$1","indexes","checkFieldInIndex","userOperatorLosesPrecision","sortFieldsByIndex","aIdx","bIdx","getBasicInMemoryFields","needToFilterInMemory","getInMemoryFieldsFromNe","getInMemoryFields","coreInMemoryFields","checkIndexFieldsMatch","sortMatches","selectorMatches","isNonLogicalMatcher","logicalMatchers","checkFieldsLogicallySound","firstField","matcherKey","checkIndexMatches","findMatchingIndexes","findBestMatchingIndex","scoreIndex","userFieldsMap","matchingIndexes","useIndexDdoc","useIndexName","getSingleFieldQueryOptsFor","getSingleFieldCoreQueryPlan","combinedOpts","userOperators","newQueryOpts","queryOpts","getMultiFieldCoreQueryPlan","getMultiFieldQueryOpts","inclusiveStart","COLLATE_LO","COLLATE_HI","indexField","usingGtlt","previousKeys","previousWasEq","previousWasSame","getDefaultQueryPlan","getCoreQueryPlan","planQuery","userFieldsRes","use_index","coreQueryPlan","indexToSignature","doAllDocs","originalOpts","find$1","getIndexesRes","queryPlan","indexToUse","signature","warning","explain$1","dbname","bookmark","deleteIndex$1","deltaFun","__WEBPACK_IMPORTED_MODULE_3_pouchdb_abstract_mapreduce__","subArr","￿","createIndexAsCallback","findAsCallback","explainAsCallback","getIndexesAsCallback","deleteIndexAsCallback","uUPe","draining","oldQueue","scheduleDrain","Mutation","MutationObserver","WebKitMutationObserver","observer","observe","characterData","MessageChannel","scriptEl","channel","port1","onmessage","port2","postMessage","wdwc","_ShoppingListReposito","_shoppingListFactory","_guardRequest","_guardShoppingListRequest","_guardShoppingListItemRequest","_delete","_ensureIndexOfType","_ensureIndexOfTypeAndList","_ensureIndexOfTypeAndChecked","_ensureIndexOfTypeAndListAndChecked","putLists","shoppingListId","_this3","_this4","_this5","deleteItemsBulkByFind","_this6","putItems","shoppingListItemId","_this7","_this8","deleteItemsBulk","_this9","deletedItems","_this10","xdep","arch","execPath","pid","browser","argv","binding","chdir","exit","kill","umask","dlopen","uptime","memoryUsage","uvCounters","features","xz3w","INTERNAL","resolver","PENDING","outcome","safelyResolveThenable","QueueItem","onFulfilled","onRejected","callFulfilled","otherCallFulfilled","callRejected","otherCallRejected","unwrap","handlers","getThen","thenable","tryToUnwrap","tryCatch","resolved","resolveFromAll","outValue","race","REJECTED","FULFILLED","y5CM","selectColor","createDebug","enabled","curr","prevTime","format","formatter","skips","disable"],"mappings":"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","file":"bundle.db381.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"./\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"+bp/\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_uuid__ = __webpack_require__(\"qQO4\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_uuid___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_uuid__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lie__ = __webpack_require__(\"xz3w\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lie___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lie__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_argsarray__ = __webpack_require__(\"38I5\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_argsarray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_argsarray__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_events__ = __webpack_require__(\"gUuJ\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_events___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_events__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_inherits__ = __webpack_require__(\"4Bm0\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_inherits__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_immediate__ = __webpack_require__(\"uUPe\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_immediate___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_immediate__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_debug__ = __webpack_require__(\"jcLW\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_debug___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_debug__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_spark_md5__ = __webpack_require__(\"13nb\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_spark_md5___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_spark_md5__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_vuvuzela__ = __webpack_require__(\"cRy3\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_vuvuzela___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_vuvuzela__);\n\n\n\n\n\n\n\n\n\n\n/* istanbul ignore next */\nvar PouchPromise$1 = typeof Promise === 'function' ? Promise : __WEBPACK_IMPORTED_MODULE_1_lie___default.a;\n\nfunction isBinaryObject(object) {\n  return typeof ArrayBuffer !== 'undefined' && object instanceof ArrayBuffer || typeof Blob !== 'undefined' && object instanceof Blob;\n}\n\nfunction cloneArrayBuffer(buff) {\n  if (typeof buff.slice === 'function') {\n    return buff.slice(0);\n  }\n  // IE10-11 slice() polyfill\n  var target = new ArrayBuffer(buff.byteLength);\n  var targetArray = new Uint8Array(target);\n  var sourceArray = new Uint8Array(buff);\n  targetArray.set(sourceArray);\n  return target;\n}\n\nfunction cloneBinaryObject(object) {\n  if (object instanceof ArrayBuffer) {\n    return cloneArrayBuffer(object);\n  }\n  var size = object.size;\n  var type = object.type;\n  // Blob\n  if (typeof object.slice === 'function') {\n    return object.slice(0, size, type);\n  }\n  // PhantomJS slice() replacement\n  return object.webkitSlice(0, size, type);\n}\n\n// most of this is borrowed from lodash.isPlainObject:\n// https://github.com/fis-components/lodash.isplainobject/\n// blob/29c358140a74f252aeb08c9eb28bef86f2217d4a/index.js\n\nvar funcToString = Function.prototype.toString;\nvar objectCtorString = funcToString.call(Object);\n\nfunction isPlainObject(value) {\n  var proto = Object.getPrototypeOf(value);\n  /* istanbul ignore if */\n  if (proto === null) {\n    // not sure when this happens, but I guess it can\n    return true;\n  }\n  var Ctor = proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;\n}\n\nfunction clone(object) {\n  var newObject;\n  var i;\n  var len;\n\n  if (!object || typeof object !== 'object') {\n    return object;\n  }\n\n  if (Array.isArray(object)) {\n    newObject = [];\n    for (i = 0, len = object.length; i < len; i++) {\n      newObject[i] = clone(object[i]);\n    }\n    return newObject;\n  }\n\n  // special case: to avoid inconsistencies between IndexedDB\n  // and other backends, we automatically stringify Dates\n  if (object instanceof Date) {\n    return object.toISOString();\n  }\n\n  if (isBinaryObject(object)) {\n    return cloneBinaryObject(object);\n  }\n\n  if (!isPlainObject(object)) {\n    return object; // don't clone objects like Workers\n  }\n\n  newObject = {};\n  for (i in object) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(object, i)) {\n      var value = clone(object[i]);\n      if (typeof value !== 'undefined') {\n        newObject[i] = value;\n      }\n    }\n  }\n  return newObject;\n}\n\nfunction once(fun) {\n  var called = false;\n  return __WEBPACK_IMPORTED_MODULE_2_argsarray___default()(function (args) {\n    /* istanbul ignore if */\n    if (called) {\n      // this is a smoke test and should never actually happen\n      throw new Error('once called more than once');\n    } else {\n      called = true;\n      fun.apply(this, args);\n    }\n  });\n}\n\nfunction toPromise(func) {\n  //create the function we will be returning\n  return __WEBPACK_IMPORTED_MODULE_2_argsarray___default()(function (args) {\n    // Clone arguments\n    args = clone(args);\n    var self = this;\n    // if the last argument is a function, assume its a callback\n    var usedCB = typeof args[args.length - 1] === 'function' ? args.pop() : false;\n    var promise = new PouchPromise$1(function (fulfill, reject) {\n      var resp;\n      try {\n        var callback = once(function (err, mesg) {\n          if (err) {\n            reject(err);\n          } else {\n            fulfill(mesg);\n          }\n        });\n        // create a callback for this invocation\n        // apply the function in the orig context\n        args.push(callback);\n        resp = func.apply(self, args);\n        if (resp && typeof resp.then === 'function') {\n          fulfill(resp);\n        }\n      } catch (e) {\n        reject(e);\n      }\n    });\n    // if there is a callback, call it back\n    if (usedCB) {\n      promise.then(function (result) {\n        usedCB(null, result);\n      }, usedCB);\n    }\n    return promise;\n  });\n}\n\nfunction logApiCall(self, name, args) {\n  /* istanbul ignore if */\n  if (self.constructor.listeners('debug').length) {\n    var logArgs = ['api', self.name, name];\n    for (var i = 0; i < args.length - 1; i++) {\n      logArgs.push(args[i]);\n    }\n    self.constructor.emit('debug', logArgs);\n\n    // override the callback itself to log the response\n    var origCallback = args[args.length - 1];\n    args[args.length - 1] = function (err, res) {\n      var responseArgs = ['api', self.name, name];\n      responseArgs = responseArgs.concat(err ? ['error', err] : ['success', res]);\n      self.constructor.emit('debug', responseArgs);\n      origCallback(err, res);\n    };\n  }\n}\n\nfunction adapterFun(name, callback) {\n  return toPromise(__WEBPACK_IMPORTED_MODULE_2_argsarray___default()(function (args) {\n    if (this._closed) {\n      return PouchPromise$1.reject(new Error('database is closed'));\n    }\n    if (this._destroyed) {\n      return PouchPromise$1.reject(new Error('database is destroyed'));\n    }\n    var self = this;\n    logApiCall(self, name, args);\n    if (!this.taskqueue.isReady) {\n      return new PouchPromise$1(function (fulfill, reject) {\n        self.taskqueue.addTask(function (failed) {\n          if (failed) {\n            reject(failed);\n          } else {\n            fulfill(self[name].apply(self, args));\n          }\n        });\n      });\n    }\n    return callback.apply(this, args);\n  }));\n}\n\nfunction mangle(key) {\n  return '$' + key;\n}\nfunction unmangle(key) {\n  return key.substring(1);\n}\nfunction Map$1() {\n  this._store = {};\n}\nMap$1.prototype.get = function (key) {\n  var mangled = mangle(key);\n  return this._store[mangled];\n};\nMap$1.prototype.set = function (key, value) {\n  var mangled = mangle(key);\n  this._store[mangled] = value;\n  return true;\n};\nMap$1.prototype.has = function (key) {\n  var mangled = mangle(key);\n  return mangled in this._store;\n};\nMap$1.prototype.delete = function (key) {\n  var mangled = mangle(key);\n  var res = mangled in this._store;\n  delete this._store[mangled];\n  return res;\n};\nMap$1.prototype.forEach = function (cb) {\n  var keys = Object.keys(this._store);\n  for (var i = 0, len = keys.length; i < len; i++) {\n    var key = keys[i];\n    var value = this._store[key];\n    key = unmangle(key);\n    cb(value, key);\n  }\n};\nObject.defineProperty(Map$1.prototype, 'size', {\n  get: function get() {\n    return Object.keys(this._store).length;\n  }\n});\n\nfunction Set$1(array) {\n  this._store = new Map$1();\n\n  // init with an array\n  if (array && Array.isArray(array)) {\n    for (var i = 0, len = array.length; i < len; i++) {\n      this.add(array[i]);\n    }\n  }\n}\nSet$1.prototype.add = function (key) {\n  return this._store.set(key, true);\n};\nSet$1.prototype.has = function (key) {\n  return this._store.has(key);\n};\nSet$1.prototype.forEach = function (cb) {\n  this._store.forEach(function (value, key) {\n    cb(key);\n  });\n};\nObject.defineProperty(Set$1.prototype, 'size', {\n  get: function get() {\n    return this._store.size;\n  }\n});\n\n/* global Map,Set,Symbol */\n// Based on https://kangax.github.io/compat-table/es6/ we can sniff out\n// incomplete Map/Set implementations which would otherwise cause our tests to fail.\n// Notably they fail in IE11 and iOS 8.4, which this prevents.\nfunction supportsMapAndSet() {\n  if (typeof Symbol === 'undefined' || typeof Map === 'undefined' || typeof Set === 'undefined') {\n    return false;\n  }\n  var prop = Object.getOwnPropertyDescriptor(Map, Symbol.species);\n  return prop && 'get' in prop && Map[Symbol.species] === Map;\n}\n\n// based on https://github.com/montagejs/collections\n/* global Map,Set */\n\nvar ExportedSet;\nvar ExportedMap;\n\n{\n  if (supportsMapAndSet()) {\n    // prefer built-in Map/Set\n    ExportedSet = Set;\n    ExportedMap = Map;\n  } else {\n    // fall back to our polyfill\n    ExportedSet = Set$1;\n    ExportedMap = Map$1;\n  }\n}\n\n// like underscore/lodash _.pick()\nfunction pick(obj, arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var prop = arr[i];\n    if (prop in obj) {\n      res[prop] = obj[prop];\n    }\n  }\n  return res;\n}\n\n// Most browsers throttle concurrent requests at 6, so it's silly\n// to shim _bulk_get by trying to launch potentially hundreds of requests\n// and then letting the majority time out. We can handle this ourselves.\nvar MAX_NUM_CONCURRENT_REQUESTS = 6;\n\nfunction identityFunction(x) {\n  return x;\n}\n\nfunction formatResultForOpenRevsGet(result) {\n  return [{\n    ok: result\n  }];\n}\n\n// shim for P/CouchDB adapters that don't directly implement _bulk_get\nfunction bulkGet(db, opts, callback) {\n  var requests = opts.docs;\n\n  // consolidate into one request per doc if possible\n  var requestsById = new ExportedMap();\n  requests.forEach(function (request) {\n    if (requestsById.has(request.id)) {\n      requestsById.get(request.id).push(request);\n    } else {\n      requestsById.set(request.id, [request]);\n    }\n  });\n\n  var numDocs = requestsById.size;\n  var numDone = 0;\n  var perDocResults = new Array(numDocs);\n\n  function collapseResultsAndFinish() {\n    var results = [];\n    perDocResults.forEach(function (res) {\n      res.docs.forEach(function (info) {\n        results.push({\n          id: res.id,\n          docs: [info]\n        });\n      });\n    });\n    callback(null, { results: results });\n  }\n\n  function checkDone() {\n    if (++numDone === numDocs) {\n      collapseResultsAndFinish();\n    }\n  }\n\n  function gotResult(docIndex, id, docs) {\n    perDocResults[docIndex] = { id: id, docs: docs };\n    checkDone();\n  }\n\n  var allRequests = [];\n  requestsById.forEach(function (value, key) {\n    allRequests.push(key);\n  });\n\n  var i = 0;\n\n  function nextBatch() {\n\n    if (i >= allRequests.length) {\n      return;\n    }\n\n    var upTo = Math.min(i + MAX_NUM_CONCURRENT_REQUESTS, allRequests.length);\n    var batch = allRequests.slice(i, upTo);\n    processBatch(batch, i);\n    i += batch.length;\n  }\n\n  function processBatch(batch, offset) {\n    batch.forEach(function (docId, j) {\n      var docIdx = offset + j;\n      var docRequests = requestsById.get(docId);\n\n      // just use the first request as the \"template\"\n      // TODO: The _bulk_get API allows for more subtle use cases than this,\n      // but for now it is unlikely that there will be a mix of different\n      // \"atts_since\" or \"attachments\" in the same request, since it's just\n      // replicate.js that is using this for the moment.\n      // Also, atts_since is aspirational, since we don't support it yet.\n      var docOpts = pick(docRequests[0], ['atts_since', 'attachments']);\n      docOpts.open_revs = docRequests.map(function (request) {\n        // rev is optional, open_revs disallowed\n        return request.rev;\n      });\n\n      // remove falsey / undefined revisions\n      docOpts.open_revs = docOpts.open_revs.filter(identityFunction);\n\n      var formatResult = identityFunction;\n\n      if (docOpts.open_revs.length === 0) {\n        delete docOpts.open_revs;\n\n        // when fetching only the \"winning\" leaf,\n        // transform the result so it looks like an open_revs\n        // request\n        formatResult = formatResultForOpenRevsGet;\n      }\n\n      // globally-supplied options\n      ['revs', 'attachments', 'binary', 'ajax', 'latest'].forEach(function (param) {\n        if (param in opts) {\n          docOpts[param] = opts[param];\n        }\n      });\n      db.get(docId, docOpts, function (err, res) {\n        var result;\n        /* istanbul ignore if */\n        if (err) {\n          result = [{ error: err }];\n        } else {\n          result = formatResult(res);\n        }\n        gotResult(docIdx, docId, result);\n        nextBatch();\n      });\n    });\n  }\n\n  nextBatch();\n}\n\nfunction isChromeApp() {\n  return typeof chrome !== \"undefined\" && typeof chrome.storage !== \"undefined\" && typeof chrome.storage.local !== \"undefined\";\n}\n\nvar hasLocal;\n\nif (isChromeApp()) {\n  hasLocal = false;\n} else {\n  try {\n    localStorage.setItem('_pouch_check_localstorage', 1);\n    hasLocal = !!localStorage.getItem('_pouch_check_localstorage');\n  } catch (e) {\n    hasLocal = false;\n  }\n}\n\nfunction hasLocalStorage() {\n  return hasLocal;\n}\n\n// Custom nextTick() shim for browsers. In node, this will just be process.nextTick(). We\n// avoid using process.nextTick() directly because the polyfill is very large and we don't\n// need all of it (see: https://github.com/defunctzombie/node-process).\n// \"immediate\" 3.0.8 is used by lie, and it's a smaller version of the latest \"immediate\"\n// package, so it's the one we use.\n// When we use nextTick() in our codebase, we only care about not releasing Zalgo\n// (see: http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony).\n// Microtask vs macrotask doesn't matter to us. So we're free to use the fastest\n// (least latency) option, which is \"immediate\" due to use of microtasks.\n// All of our nextTicks are isolated to this one function so we can easily swap out one\n// implementation for another.\n\n__WEBPACK_IMPORTED_MODULE_4_inherits___default()(Changes, __WEBPACK_IMPORTED_MODULE_3_events__[\"EventEmitter\"]);\n\n/* istanbul ignore next */\nfunction attachBrowserEvents(self) {\n  if (isChromeApp()) {\n    chrome.storage.onChanged.addListener(function (e) {\n      // make sure it's event addressed to us\n      if (e.db_name != null) {\n        //object only has oldValue, newValue members\n        self.emit(e.dbName.newValue);\n      }\n    });\n  } else if (hasLocalStorage()) {\n    if (typeof addEventListener !== 'undefined') {\n      addEventListener(\"storage\", function (e) {\n        self.emit(e.key);\n      });\n    } else {\n      // old IE\n      window.attachEvent(\"storage\", function (e) {\n        self.emit(e.key);\n      });\n    }\n  }\n}\n\nfunction Changes() {\n  __WEBPACK_IMPORTED_MODULE_3_events__[\"EventEmitter\"].call(this);\n  this._listeners = {};\n\n  attachBrowserEvents(this);\n}\nChanges.prototype.addListener = function (dbName, id, db, opts) {\n  /* istanbul ignore if */\n  if (this._listeners[id]) {\n    return;\n  }\n  var self = this;\n  var inprogress = false;\n  function eventFunction() {\n    /* istanbul ignore if */\n    if (!self._listeners[id]) {\n      return;\n    }\n    if (inprogress) {\n      inprogress = 'waiting';\n      return;\n    }\n    inprogress = true;\n    var changesOpts = pick(opts, ['style', 'include_docs', 'attachments', 'conflicts', 'filter', 'doc_ids', 'view', 'since', 'query_params', 'binary']);\n\n    /* istanbul ignore next */\n    function onError() {\n      inprogress = false;\n    }\n\n    db.changes(changesOpts).on('change', function (c) {\n      if (c.seq > opts.since && !opts.cancelled) {\n        opts.since = c.seq;\n        opts.onChange(c);\n      }\n    }).on('complete', function () {\n      if (inprogress === 'waiting') {\n        __WEBPACK_IMPORTED_MODULE_5_immediate___default()(eventFunction);\n      }\n      inprogress = false;\n    }).on('error', onError);\n  }\n  this._listeners[id] = eventFunction;\n  this.on(dbName, eventFunction);\n};\n\nChanges.prototype.removeListener = function (dbName, id) {\n  /* istanbul ignore if */\n  if (!(id in this._listeners)) {\n    return;\n  }\n  __WEBPACK_IMPORTED_MODULE_3_events__[\"EventEmitter\"].prototype.removeListener.call(this, dbName, this._listeners[id]);\n  delete this._listeners[id];\n};\n\n/* istanbul ignore next */\nChanges.prototype.notifyLocalWindows = function (dbName) {\n  //do a useless change on a storage thing\n  //in order to get other windows's listeners to activate\n  if (isChromeApp()) {\n    chrome.storage.local.set({ dbName: dbName });\n  } else if (hasLocalStorage()) {\n    localStorage[dbName] = localStorage[dbName] === \"a\" ? \"b\" : \"a\";\n  }\n};\n\nChanges.prototype.notify = function (dbName) {\n  this.emit(dbName);\n  this.notifyLocalWindows(dbName);\n};\n\nfunction guardedConsole(method) {\n  /* istanbul ignore else */\n  if (console !== 'undefined' && method in console) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    console[method].apply(console, args);\n  }\n}\n\nfunction randomNumber(min, max) {\n  var maxTimeout = 600000; // Hard-coded default of 10 minutes\n  min = parseInt(min, 10) || 0;\n  max = parseInt(max, 10);\n  if (max !== max || max <= min) {\n    max = (min || 1) << 1; //doubling\n  } else {\n    max = max + 1;\n  }\n  // In order to not exceed maxTimeout, pick a random value between half of maxTimeout and maxTimeout\n  if (max > maxTimeout) {\n    min = maxTimeout >> 1; // divide by two\n    max = maxTimeout;\n  }\n  var ratio = Math.random();\n  var range = max - min;\n\n  return ~~(range * ratio + min); // ~~ coerces to an int, but fast.\n}\n\nfunction defaultBackOff(min) {\n  var max = 0;\n  if (!min) {\n    max = 2000;\n  }\n  return randomNumber(min, max);\n}\n\n// designed to give info to browser users, who are disturbed\n// when they see http errors in the console\nfunction explainError(status, str) {\n  guardedConsole('info', 'The above ' + status + ' is totally normal. ' + str);\n}\n\nvar assign;\n{\n  if (typeof Object.assign === 'function') {\n    assign = Object.assign;\n  } else {\n    // lite Object.assign polyfill based on\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n    assign = function assign(target) {\n      var to = Object(target);\n\n      for (var index = 1; index < arguments.length; index++) {\n        var nextSource = arguments[index];\n\n        if (nextSource != null) {\n          // Skip over if undefined or null\n          for (var nextKey in nextSource) {\n            // Avoid bugs when hasOwnProperty is shadowed\n            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n              to[nextKey] = nextSource[nextKey];\n            }\n          }\n        }\n      }\n      return to;\n    };\n  }\n}\n\nvar $inject_Object_assign = assign;\n\n__WEBPACK_IMPORTED_MODULE_4_inherits___default()(PouchError, Error);\n\nfunction PouchError(status, error, reason) {\n  Error.call(this, reason);\n  this.status = status;\n  this.name = error;\n  this.message = reason;\n  this.error = true;\n}\n\nPouchError.prototype.toString = function () {\n  return JSON.stringify({\n    status: this.status,\n    name: this.name,\n    message: this.message,\n    reason: this.reason\n  });\n};\n\nvar UNAUTHORIZED = new PouchError(401, 'unauthorized', \"Name or password is incorrect.\");\nvar MISSING_BULK_DOCS = new PouchError(400, 'bad_request', \"Missing JSON list of 'docs'\");\nvar MISSING_DOC = new PouchError(404, 'not_found', 'missing');\nvar REV_CONFLICT = new PouchError(409, 'conflict', 'Document update conflict');\nvar INVALID_ID = new PouchError(400, 'bad_request', '_id field must contain a string');\nvar MISSING_ID = new PouchError(412, 'missing_id', '_id is required for puts');\nvar RESERVED_ID = new PouchError(400, 'bad_request', 'Only reserved document ids may start with underscore.');\nvar NOT_OPEN = new PouchError(412, 'precondition_failed', 'Database not open');\nvar UNKNOWN_ERROR = new PouchError(500, 'unknown_error', 'Database encountered an unknown error');\nvar BAD_ARG = new PouchError(500, 'badarg', 'Some query argument is invalid');\nvar INVALID_REQUEST = new PouchError(400, 'invalid_request', 'Request was invalid');\nvar QUERY_PARSE_ERROR = new PouchError(400, 'query_parse_error', 'Some query parameter is invalid');\nvar DOC_VALIDATION = new PouchError(500, 'doc_validation', 'Bad special document member');\nvar BAD_REQUEST = new PouchError(400, 'bad_request', 'Something wrong with the request');\nvar NOT_AN_OBJECT = new PouchError(400, 'bad_request', 'Document must be a JSON object');\nvar DB_MISSING = new PouchError(404, 'not_found', 'Database not found');\nvar IDB_ERROR = new PouchError(500, 'indexed_db_went_bad', 'unknown');\nvar WSQ_ERROR = new PouchError(500, 'web_sql_went_bad', 'unknown');\nvar LDB_ERROR = new PouchError(500, 'levelDB_went_went_bad', 'unknown');\nvar FORBIDDEN = new PouchError(403, 'forbidden', 'Forbidden by design doc validate_doc_update function');\nvar INVALID_REV = new PouchError(400, 'bad_request', 'Invalid rev format');\nvar FILE_EXISTS = new PouchError(412, 'file_exists', 'The database could not be created, the file already exists.');\nvar MISSING_STUB = new PouchError(412, 'missing_stub', 'A pre-existing attachment stub wasn\\'t found');\nvar INVALID_URL = new PouchError(413, 'invalid_url', 'Provided URL is invalid');\n\nfunction createError(error, reason) {\n  function CustomPouchError(reason) {\n    // inherit error properties from our parent error manually\n    // so as to allow proper JSON parsing.\n    /* jshint ignore:start */\n    for (var p in error) {\n      if (typeof error[p] !== 'function') {\n        this[p] = error[p];\n      }\n    }\n    /* jshint ignore:end */\n    if (reason !== undefined) {\n      this.reason = reason;\n    }\n  }\n  CustomPouchError.prototype = PouchError.prototype;\n  return new CustomPouchError(reason);\n}\n\nfunction generateErrorFromResponse(err) {\n\n  if (typeof err !== 'object') {\n    var data = err;\n    err = UNKNOWN_ERROR;\n    err.data = data;\n  }\n\n  if ('error' in err && err.error === 'conflict') {\n    err.name = 'conflict';\n    err.status = 409;\n  }\n\n  if (!('name' in err)) {\n    err.name = err.error || 'unknown';\n  }\n\n  if (!('status' in err)) {\n    err.status = 500;\n  }\n\n  if (!('message' in err)) {\n    err.message = err.message || err.reason;\n  }\n\n  return err;\n}\n\nfunction tryFilter(filter, doc, req) {\n  try {\n    return !filter(doc, req);\n  } catch (err) {\n    var msg = 'Filter function threw: ' + err.toString();\n    return createError(BAD_REQUEST, msg);\n  }\n}\n\nfunction filterChange(opts) {\n  var req = {};\n  var hasFilter = opts.filter && typeof opts.filter === 'function';\n  req.query = opts.query_params;\n\n  return function filter(change) {\n    if (!change.doc) {\n      // CSG sends events on the changes feed that don't have documents,\n      // this hack makes a whole lot of existing code robust.\n      change.doc = {};\n    }\n\n    var filterReturn = hasFilter && tryFilter(opts.filter, change.doc, req);\n\n    if (typeof filterReturn === 'object') {\n      return filterReturn;\n    }\n\n    if (filterReturn) {\n      return false;\n    }\n\n    if (!opts.include_docs) {\n      delete change.doc;\n    } else if (!opts.attachments) {\n      for (var att in change.doc._attachments) {\n        /* istanbul ignore else */\n        if (change.doc._attachments.hasOwnProperty(att)) {\n          change.doc._attachments[att].stub = true;\n        }\n      }\n    }\n    return true;\n  };\n}\n\nfunction flatten(arrs) {\n  var res = [];\n  for (var i = 0, len = arrs.length; i < len; i++) {\n    res = res.concat(arrs[i]);\n  }\n  return res;\n}\n\n// shim for Function.prototype.name,\n// for browsers that don't support it like IE\n\n/* istanbul ignore next */\nfunction f() {}\n\nvar hasName = f.name;\nvar res;\n\n// We dont run coverage in IE\n/* istanbul ignore else */\nif (hasName) {\n  res = function res(fun) {\n    return fun.name;\n  };\n} else {\n  res = function res(fun) {\n    return fun.toString().match(/^\\s*function\\s*(\\S*)\\s*\\(/)[1];\n  };\n}\n\n// Determine id an ID is valid\n//   - invalid IDs begin with an underescore that does not begin '_design' or\n//     '_local'\n//   - any other string value is a valid id\n// Returns the specific error object for each case\nfunction invalidIdError(id) {\n  var err;\n  if (!id) {\n    err = createError(MISSING_ID);\n  } else if (typeof id !== 'string') {\n    err = createError(INVALID_ID);\n  } else if (/^_/.test(id) && !/^_(design|local)/.test(id)) {\n    err = createError(RESERVED_ID);\n  }\n  if (err) {\n    throw err;\n  }\n}\n\n// Checks if a PouchDB object is \"remote\" or not. This is\n// designed to opt-in to certain optimizations, such as\n// avoiding checks for \"dependentDbs\" and other things that\n// we know only apply to local databases. In general, \"remote\"\n// should be true for the http adapter, and for third-party\n// adapters with similar expensive boundaries to cross for\n// every API call, such as socket-pouch and worker-pouch.\n// Previously, this was handled via db.type() === 'http'\n// which is now deprecated.\n\nfunction isRemote(db) {\n  if (typeof db._remote === 'boolean') {\n    return db._remote;\n  }\n  /* istanbul ignore next */\n  if (typeof db.type === 'function') {\n    guardedConsole('warn', 'db.type() is deprecated and will be removed in ' + 'a future version of PouchDB');\n    return db.type() === 'http';\n  }\n  /* istanbul ignore next */\n  return false;\n}\n\nfunction listenerCount(ee, type) {\n  return 'listenerCount' in ee ? ee.listenerCount(type) : __WEBPACK_IMPORTED_MODULE_3_events__[\"EventEmitter\"].listenerCount(ee, type);\n}\n\nfunction parseDesignDocFunctionName(s) {\n  if (!s) {\n    return null;\n  }\n  var parts = s.split('/');\n  if (parts.length === 2) {\n    return parts;\n  }\n  if (parts.length === 1) {\n    return [s, s];\n  }\n  return null;\n}\n\nfunction normalizeDesignDocFunctionName(s) {\n  var normalized = parseDesignDocFunctionName(s);\n  return normalized ? normalized.join('/') : null;\n}\n\n// originally parseUri 1.2.2, now patched by us\n// (c) Steven Levithan <stevenlevithan.com>\n// MIT License\nvar keys = [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\", \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"];\nvar qName = \"queryKey\";\nvar qParser = /(?:^|&)([^&=]*)=?([^&]*)/g;\n\n// use the \"loose\" parser\n/* eslint maxlen: 0, no-useless-escape: 0 */\nvar parser = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\nfunction parseUri(str) {\n  var m = parser.exec(str);\n  var uri = {};\n  var i = 14;\n\n  while (i--) {\n    var key = keys[i];\n    var value = m[i] || \"\";\n    var encoded = ['user', 'password'].indexOf(key) !== -1;\n    uri[key] = encoded ? decodeURIComponent(value) : value;\n  }\n\n  uri[qName] = {};\n  uri[keys[12]].replace(qParser, function ($0, $1, $2) {\n    if ($1) {\n      uri[qName][$1] = $2;\n    }\n  });\n\n  return uri;\n}\n\n// Based on https://github.com/alexdavid/scope-eval v0.0.3\n// (source: https://unpkg.com/scope-eval@0.0.3/scope_eval.js)\n// This is basically just a wrapper around new Function()\n\nfunction scopeEval(source, scope) {\n  var keys = [];\n  var values = [];\n  for (var key in scope) {\n    if (scope.hasOwnProperty(key)) {\n      keys.push(key);\n      values.push(scope[key]);\n    }\n  }\n  keys.push(source);\n  return Function.apply(null, keys).apply(null, values);\n}\n\n// this is essentially the \"update sugar\" function from daleharvey/pouchdb#1388\n// the diffFun tells us what delta to apply to the doc.  it either returns\n// the doc, or false if it doesn't need to do an update after all\nfunction upsert(db, docId, diffFun) {\n  return new PouchPromise$1(function (fulfill, reject) {\n    db.get(docId, function (err, doc) {\n      if (err) {\n        /* istanbul ignore next */\n        if (err.status !== 404) {\n          return reject(err);\n        }\n        doc = {};\n      }\n\n      // the user might change the _rev, so save it for posterity\n      var docRev = doc._rev;\n      var newDoc = diffFun(doc);\n\n      if (!newDoc) {\n        // if the diffFun returns falsy, we short-circuit as\n        // an optimization\n        return fulfill({ updated: false, rev: docRev });\n      }\n\n      // users aren't allowed to modify these values,\n      // so reset them here\n      newDoc._id = docId;\n      newDoc._rev = docRev;\n      fulfill(tryAndPut(db, newDoc, diffFun));\n    });\n  });\n}\n\nfunction tryAndPut(db, doc, diffFun) {\n  return db.put(doc).then(function (res) {\n    return {\n      updated: true,\n      rev: res.rev\n    };\n  }, function (err) {\n    /* istanbul ignore next */\n    if (err.status !== 409) {\n      throw err;\n    }\n    return upsert(db, doc._id, diffFun);\n  });\n}\n\nfunction rev() {\n  return __WEBPACK_IMPORTED_MODULE_0_uuid___default.a.v4().replace(/-/g, '').toLowerCase();\n}\n\nvar uuid = __WEBPACK_IMPORTED_MODULE_0_uuid___default.a.v4;\n\n// We fetch all leafs of the revision tree, and sort them based on tree length\n// and whether they were deleted, undeleted documents with the longest revision\n// tree (most edits) win\n// The final sort algorithm is slightly documented in a sidebar here:\n// http://guide.couchdb.org/draft/conflicts.html\nfunction winningRev(metadata) {\n  var winningId;\n  var winningPos;\n  var winningDeleted;\n  var toVisit = metadata.rev_tree.slice();\n  var node;\n  while (node = toVisit.pop()) {\n    var tree = node.ids;\n    var branches = tree[2];\n    var pos = node.pos;\n    if (branches.length) {\n      // non-leaf\n      for (var i = 0, len = branches.length; i < len; i++) {\n        toVisit.push({ pos: pos + 1, ids: branches[i] });\n      }\n      continue;\n    }\n    var deleted = !!tree[1].deleted;\n    var id = tree[0];\n    // sort by deleted, then pos, then id\n    if (!winningId || (winningDeleted !== deleted ? winningDeleted : winningPos !== pos ? winningPos < pos : winningId < id)) {\n      winningId = id;\n      winningPos = pos;\n      winningDeleted = deleted;\n    }\n  }\n\n  return winningPos + '-' + winningId;\n}\n\n// Pretty much all below can be combined into a higher order function to\n// traverse revisions\n// The return value from the callback will be passed as context to all\n// children of that node\nfunction traverseRevTree(revs, callback) {\n  var toVisit = revs.slice();\n\n  var node;\n  while (node = toVisit.pop()) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var branches = tree[2];\n    var newCtx = callback(branches.length === 0, pos, tree[0], node.ctx, tree[1]);\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({ pos: pos + 1, ids: branches[i], ctx: newCtx });\n    }\n  }\n}\n\nfunction sortByPos(a, b) {\n  return a.pos - b.pos;\n}\n\nfunction collectLeaves(revs) {\n  var leaves = [];\n  traverseRevTree(revs, function (isLeaf, pos, id, acc, opts) {\n    if (isLeaf) {\n      leaves.push({ rev: pos + \"-\" + id, pos: pos, opts: opts });\n    }\n  });\n  leaves.sort(sortByPos).reverse();\n  for (var i = 0, len = leaves.length; i < len; i++) {\n    delete leaves[i].pos;\n  }\n  return leaves;\n}\n\n// returns revs of all conflicts that is leaves such that\n// 1. are not deleted and\n// 2. are different than winning revision\nfunction collectConflicts(metadata) {\n  var win = winningRev(metadata);\n  var leaves = collectLeaves(metadata.rev_tree);\n  var conflicts = [];\n  for (var i = 0, len = leaves.length; i < len; i++) {\n    var leaf = leaves[i];\n    if (leaf.rev !== win && !leaf.opts.deleted) {\n      conflicts.push(leaf.rev);\n    }\n  }\n  return conflicts;\n}\n\n// compact a tree by marking its non-leafs as missing,\n// and return a list of revs to delete\nfunction compactTree(metadata) {\n  var revs = [];\n  traverseRevTree(metadata.rev_tree, function (isLeaf, pos, revHash, ctx, opts) {\n    if (opts.status === 'available' && !isLeaf) {\n      revs.push(pos + '-' + revHash);\n      opts.status = 'missing';\n    }\n  });\n  return revs;\n}\n\n// build up a list of all the paths to the leafs in this revision tree\nfunction rootToLeaf(revs) {\n  var paths = [];\n  var toVisit = revs.slice();\n  var node;\n  while (node = toVisit.pop()) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var id = tree[0];\n    var opts = tree[1];\n    var branches = tree[2];\n    var isLeaf = branches.length === 0;\n\n    var history = node.history ? node.history.slice() : [];\n    history.push({ id: id, opts: opts });\n    if (isLeaf) {\n      paths.push({ pos: pos + 1 - history.length, ids: history });\n    }\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({ pos: pos + 1, ids: branches[i], history: history });\n    }\n  }\n  return paths.reverse();\n}\n\n// for a better overview of what this is doing, read:\n// https://github.com/apache/couchdb-couch/blob/master/src/couch_key_tree.erl\n//\n// But for a quick intro, CouchDB uses a revision tree to store a documents\n// history, A -> B -> C, when a document has conflicts, that is a branch in the\n// tree, A -> (B1 | B2 -> C), We store these as a nested array in the format\n//\n// KeyTree = [Path ... ]\n// Path = {pos: position_from_root, ids: Tree}\n// Tree = [Key, Opts, [Tree, ...]], in particular single node: [Key, []]\n\nfunction sortByPos$1(a, b) {\n  return a.pos - b.pos;\n}\n\n// classic binary search\nfunction binarySearch(arr, item, comparator) {\n  var low = 0;\n  var high = arr.length;\n  var mid;\n  while (low < high) {\n    mid = low + high >>> 1;\n    if (comparator(arr[mid], item) < 0) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  return low;\n}\n\n// assuming the arr is sorted, insert the item in the proper place\nfunction insertSorted(arr, item, comparator) {\n  var idx = binarySearch(arr, item, comparator);\n  arr.splice(idx, 0, item);\n}\n\n// Turn a path as a flat array into a tree with a single branch.\n// If any should be stemmed from the beginning of the array, that's passed\n// in as the second argument\nfunction pathToTree(path, numStemmed) {\n  var root;\n  var leaf;\n  for (var i = numStemmed, len = path.length; i < len; i++) {\n    var node = path[i];\n    var currentLeaf = [node.id, node.opts, []];\n    if (leaf) {\n      leaf[2].push(currentLeaf);\n      leaf = currentLeaf;\n    } else {\n      root = leaf = currentLeaf;\n    }\n  }\n  return root;\n}\n\n// compare the IDs of two trees\nfunction compareTree(a, b) {\n  return a[0] < b[0] ? -1 : 1;\n}\n\n// Merge two trees together\n// The roots of tree1 and tree2 must be the same revision\nfunction mergeTree(in_tree1, in_tree2) {\n  var queue = [{ tree1: in_tree1, tree2: in_tree2 }];\n  var conflicts = false;\n  while (queue.length > 0) {\n    var item = queue.pop();\n    var tree1 = item.tree1;\n    var tree2 = item.tree2;\n\n    if (tree1[1].status || tree2[1].status) {\n      tree1[1].status = tree1[1].status === 'available' || tree2[1].status === 'available' ? 'available' : 'missing';\n    }\n\n    for (var i = 0; i < tree2[2].length; i++) {\n      if (!tree1[2][0]) {\n        conflicts = 'new_leaf';\n        tree1[2][0] = tree2[2][i];\n        continue;\n      }\n\n      var merged = false;\n      for (var j = 0; j < tree1[2].length; j++) {\n        if (tree1[2][j][0] === tree2[2][i][0]) {\n          queue.push({ tree1: tree1[2][j], tree2: tree2[2][i] });\n          merged = true;\n        }\n      }\n      if (!merged) {\n        conflicts = 'new_branch';\n        insertSorted(tree1[2], tree2[2][i], compareTree);\n      }\n    }\n  }\n  return { conflicts: conflicts, tree: in_tree1 };\n}\n\nfunction doMerge(tree, path, dontExpand) {\n  var restree = [];\n  var conflicts = false;\n  var merged = false;\n  var res;\n\n  if (!tree.length) {\n    return { tree: [path], conflicts: 'new_leaf' };\n  }\n\n  for (var i = 0, len = tree.length; i < len; i++) {\n    var branch = tree[i];\n    if (branch.pos === path.pos && branch.ids[0] === path.ids[0]) {\n      // Paths start at the same position and have the same root, so they need\n      // merged\n      res = mergeTree(branch.ids, path.ids);\n      restree.push({ pos: branch.pos, ids: res.tree });\n      conflicts = conflicts || res.conflicts;\n      merged = true;\n    } else if (dontExpand !== true) {\n      // The paths start at a different position, take the earliest path and\n      // traverse up until it as at the same point from root as the path we\n      // want to merge.  If the keys match we return the longer path with the\n      // other merged After stemming we dont want to expand the trees\n\n      var t1 = branch.pos < path.pos ? branch : path;\n      var t2 = branch.pos < path.pos ? path : branch;\n      var diff = t2.pos - t1.pos;\n\n      var candidateParents = [];\n\n      var trees = [];\n      trees.push({ ids: t1.ids, diff: diff, parent: null, parentIdx: null });\n      while (trees.length > 0) {\n        var item = trees.pop();\n        if (item.diff === 0) {\n          if (item.ids[0] === t2.ids[0]) {\n            candidateParents.push(item);\n          }\n          continue;\n        }\n        var elements = item.ids[2];\n        for (var j = 0, elementsLen = elements.length; j < elementsLen; j++) {\n          trees.push({\n            ids: elements[j],\n            diff: item.diff - 1,\n            parent: item.ids,\n            parentIdx: j\n          });\n        }\n      }\n\n      var el = candidateParents[0];\n\n      if (!el) {\n        restree.push(branch);\n      } else {\n        res = mergeTree(el.ids, t2.ids);\n        el.parent[2][el.parentIdx] = res.tree;\n        restree.push({ pos: t1.pos, ids: t1.ids });\n        conflicts = conflicts || res.conflicts;\n        merged = true;\n      }\n    } else {\n      restree.push(branch);\n    }\n  }\n\n  // We didnt find\n  if (!merged) {\n    restree.push(path);\n  }\n\n  restree.sort(sortByPos$1);\n\n  return {\n    tree: restree,\n    conflicts: conflicts || 'internal_node'\n  };\n}\n\n// To ensure we dont grow the revision tree infinitely, we stem old revisions\nfunction stem(tree, depth) {\n  // First we break out the tree into a complete list of root to leaf paths\n  var paths = rootToLeaf(tree);\n  var stemmedRevs;\n\n  var result;\n  for (var i = 0, len = paths.length; i < len; i++) {\n    // Then for each path, we cut off the start of the path based on the\n    // `depth` to stem to, and generate a new set of flat trees\n    var path = paths[i];\n    var stemmed = path.ids;\n    var node;\n    if (stemmed.length > depth) {\n      // only do the stemming work if we actually need to stem\n      if (!stemmedRevs) {\n        stemmedRevs = {}; // avoid allocating this object unnecessarily\n      }\n      var numStemmed = stemmed.length - depth;\n      node = {\n        pos: path.pos + numStemmed,\n        ids: pathToTree(stemmed, numStemmed)\n      };\n\n      for (var s = 0; s < numStemmed; s++) {\n        var rev = path.pos + s + '-' + stemmed[s].id;\n        stemmedRevs[rev] = true;\n      }\n    } else {\n      // no need to actually stem\n      node = {\n        pos: path.pos,\n        ids: pathToTree(stemmed, 0)\n      };\n    }\n\n    // Then we remerge all those flat trees together, ensuring that we dont\n    // connect trees that would go beyond the depth limit\n    if (result) {\n      result = doMerge(result, node, true).tree;\n    } else {\n      result = [node];\n    }\n  }\n\n  // this is memory-heavy per Chrome profiler, avoid unless we actually stemmed\n  if (stemmedRevs) {\n    traverseRevTree(result, function (isLeaf, pos, revHash) {\n      // some revisions may have been removed in a branch but not in another\n      delete stemmedRevs[pos + '-' + revHash];\n    });\n  }\n\n  return {\n    tree: result,\n    revs: stemmedRevs ? Object.keys(stemmedRevs) : []\n  };\n}\n\nfunction merge(tree, path, depth) {\n  var newTree = doMerge(tree, path);\n  var stemmed = stem(newTree.tree, depth);\n  return {\n    tree: stemmed.tree,\n    stemmedRevs: stemmed.revs,\n    conflicts: newTree.conflicts\n  };\n}\n\n// return true if a rev exists in the rev tree, false otherwise\nfunction revExists(revs, rev) {\n  var toVisit = revs.slice();\n  var splitRev = rev.split('-');\n  var targetPos = parseInt(splitRev[0], 10);\n  var targetId = splitRev[1];\n\n  var node;\n  while (node = toVisit.pop()) {\n    if (node.pos === targetPos && node.ids[0] === targetId) {\n      return true;\n    }\n    var branches = node.ids[2];\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({ pos: node.pos + 1, ids: branches[i] });\n    }\n  }\n  return false;\n}\n\nfunction getTrees(node) {\n  return node.ids;\n}\n\n// check if a specific revision of a doc has been deleted\n//  - metadata: the metadata object from the doc store\n//  - rev: (optional) the revision to check. defaults to winning revision\nfunction isDeleted(metadata, rev) {\n  if (!rev) {\n    rev = winningRev(metadata);\n  }\n  var id = rev.substring(rev.indexOf('-') + 1);\n  var toVisit = metadata.rev_tree.map(getTrees);\n\n  var tree;\n  while (tree = toVisit.pop()) {\n    if (tree[0] === id) {\n      return !!tree[1].deleted;\n    }\n    toVisit = toVisit.concat(tree[2]);\n  }\n}\n\nfunction isLocalId(id) {\n  return (/^_local/.test(id)\n  );\n}\n\n// returns the current leaf node for a given revision\nfunction latest(rev, metadata) {\n  var toVisit = metadata.rev_tree.slice();\n  var node;\n  while (node = toVisit.pop()) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var id = tree[0];\n    var opts = tree[1];\n    var branches = tree[2];\n    var isLeaf = branches.length === 0;\n\n    var history = node.history ? node.history.slice() : [];\n    history.push({ id: id, pos: pos, opts: opts });\n\n    if (isLeaf) {\n      for (var i = 0, len = history.length; i < len; i++) {\n        var historyNode = history[i];\n        var historyRev = historyNode.pos + '-' + historyNode.id;\n\n        if (historyRev === rev) {\n          // return the rev of this leaf\n          return pos + '-' + id;\n        }\n      }\n    }\n\n    for (var j = 0, l = branches.length; j < l; j++) {\n      toVisit.push({ pos: pos + 1, ids: branches[j], history: history });\n    }\n  }\n\n  /* istanbul ignore next */\n  throw new Error('Unable to resolve latest revision for id ' + metadata.id + ', rev ' + rev);\n}\n\n__WEBPACK_IMPORTED_MODULE_4_inherits___default()(Changes$2, __WEBPACK_IMPORTED_MODULE_3_events__[\"EventEmitter\"]);\n\nfunction tryCatchInChangeListener(self, change) {\n  // isolate try/catches to avoid V8 deoptimizations\n  try {\n    self.emit('change', change);\n  } catch (e) {\n    guardedConsole('error', 'Error in .on(\"change\", function):', e);\n  }\n}\n\nfunction Changes$2(db, opts, callback) {\n  __WEBPACK_IMPORTED_MODULE_3_events__[\"EventEmitter\"].call(this);\n  var self = this;\n  this.db = db;\n  opts = opts ? clone(opts) : {};\n  var complete = opts.complete = once(function (err, resp) {\n    if (err) {\n      if (listenerCount(self, 'error') > 0) {\n        self.emit('error', err);\n      }\n    } else {\n      self.emit('complete', resp);\n    }\n    self.removeAllListeners();\n    db.removeListener('destroyed', onDestroy);\n  });\n  if (callback) {\n    self.on('complete', function (resp) {\n      callback(null, resp);\n    });\n    self.on('error', callback);\n  }\n  function onDestroy() {\n    self.cancel();\n  }\n  db.once('destroyed', onDestroy);\n\n  opts.onChange = function (change) {\n    /* istanbul ignore if */\n    if (self.isCancelled) {\n      return;\n    }\n    tryCatchInChangeListener(self, change);\n  };\n\n  var promise = new PouchPromise$1(function (fulfill, reject) {\n    opts.complete = function (err, res) {\n      if (err) {\n        reject(err);\n      } else {\n        fulfill(res);\n      }\n    };\n  });\n  self.once('cancel', function () {\n    db.removeListener('destroyed', onDestroy);\n    opts.complete(null, { status: 'cancelled' });\n  });\n  this.then = promise.then.bind(promise);\n  this['catch'] = promise['catch'].bind(promise);\n  this.then(function (result) {\n    complete(null, result);\n  }, complete);\n\n  if (!db.taskqueue.isReady) {\n    db.taskqueue.addTask(function (failed) {\n      if (failed) {\n        opts.complete(failed);\n      } else if (self.isCancelled) {\n        self.emit('cancel');\n      } else {\n        self.validateChanges(opts);\n      }\n    });\n  } else {\n    self.validateChanges(opts);\n  }\n}\nChanges$2.prototype.cancel = function () {\n  this.isCancelled = true;\n  if (this.db.taskqueue.isReady) {\n    this.emit('cancel');\n  }\n};\nfunction processChange(doc, metadata, opts) {\n  var changeList = [{ rev: doc._rev }];\n  if (opts.style === 'all_docs') {\n    changeList = collectLeaves(metadata.rev_tree).map(function (x) {\n      return { rev: x.rev };\n    });\n  }\n  var change = {\n    id: metadata.id,\n    changes: changeList,\n    doc: doc\n  };\n\n  if (isDeleted(metadata, doc._rev)) {\n    change.deleted = true;\n  }\n  if (opts.conflicts) {\n    change.doc._conflicts = collectConflicts(metadata);\n    if (!change.doc._conflicts.length) {\n      delete change.doc._conflicts;\n    }\n  }\n  return change;\n}\n\nChanges$2.prototype.validateChanges = function (opts) {\n  var callback = opts.complete;\n  var self = this;\n\n  /* istanbul ignore else */\n  if (PouchDB$5._changesFilterPlugin) {\n    PouchDB$5._changesFilterPlugin.validate(opts, function (err) {\n      if (err) {\n        return callback(err);\n      }\n      self.doChanges(opts);\n    });\n  } else {\n    self.doChanges(opts);\n  }\n};\n\nChanges$2.prototype.doChanges = function (opts) {\n  var self = this;\n  var callback = opts.complete;\n\n  opts = clone(opts);\n  if ('live' in opts && !('continuous' in opts)) {\n    opts.continuous = opts.live;\n  }\n  opts.processChange = processChange;\n\n  if (opts.since === 'latest') {\n    opts.since = 'now';\n  }\n  if (!opts.since) {\n    opts.since = 0;\n  }\n  if (opts.since === 'now') {\n    this.db.info().then(function (info) {\n      /* istanbul ignore if */\n      if (self.isCancelled) {\n        callback(null, { status: 'cancelled' });\n        return;\n      }\n      opts.since = info.update_seq;\n      self.doChanges(opts);\n    }, callback);\n    return;\n  }\n\n  /* istanbul ignore else */\n  if (PouchDB$5._changesFilterPlugin) {\n    PouchDB$5._changesFilterPlugin.normalize(opts);\n    if (PouchDB$5._changesFilterPlugin.shouldFilter(this, opts)) {\n      return PouchDB$5._changesFilterPlugin.filter(this, opts);\n    }\n  } else {\n    ['doc_ids', 'filter', 'selector', 'view'].forEach(function (key) {\n      if (key in opts) {\n        guardedConsole('warn', 'The \"' + key + '\" option was passed in to changes/replicate, ' + 'but pouchdb-changes-filter plugin is not installed, so it ' + 'was ignored. Please install the plugin to enable filtering.');\n      }\n    });\n  }\n\n  if (!('descending' in opts)) {\n    opts.descending = false;\n  }\n\n  // 0 and 1 should return 1 document\n  opts.limit = opts.limit === 0 ? 1 : opts.limit;\n  opts.complete = callback;\n  var newPromise = this.db._changes(opts);\n  /* istanbul ignore else */\n  if (newPromise && typeof newPromise.cancel === 'function') {\n    var cancel = self.cancel;\n    self.cancel = __WEBPACK_IMPORTED_MODULE_2_argsarray___default()(function (args) {\n      newPromise.cancel();\n      cancel.apply(this, args);\n    });\n  }\n};\n\n/*\n * A generic pouch adapter\n */\n\nfunction compare(left, right) {\n  return left < right ? -1 : left > right ? 1 : 0;\n}\n\n// Wrapper for functions that call the bulkdocs api with a single doc,\n// if the first result is an error, return an error\nfunction yankError(callback, docId) {\n  return function (err, results) {\n    if (err || results[0] && results[0].error) {\n      err = err || results[0];\n      err.docId = docId;\n      callback(err);\n    } else {\n      callback(null, results.length ? results[0] : results);\n    }\n  };\n}\n\n// clean docs given to us by the user\nfunction cleanDocs(docs) {\n  for (var i = 0; i < docs.length; i++) {\n    var doc = docs[i];\n    if (doc._deleted) {\n      delete doc._attachments; // ignore atts for deleted docs\n    } else if (doc._attachments) {\n      // filter out extraneous keys from _attachments\n      var atts = Object.keys(doc._attachments);\n      for (var j = 0; j < atts.length; j++) {\n        var att = atts[j];\n        doc._attachments[att] = pick(doc._attachments[att], ['data', 'digest', 'content_type', 'length', 'revpos', 'stub']);\n      }\n    }\n  }\n}\n\n// compare two docs, first by _id then by _rev\nfunction compareByIdThenRev(a, b) {\n  var idCompare = compare(a._id, b._id);\n  if (idCompare !== 0) {\n    return idCompare;\n  }\n  var aStart = a._revisions ? a._revisions.start : 0;\n  var bStart = b._revisions ? b._revisions.start : 0;\n  return compare(aStart, bStart);\n}\n\n// for every node in a revision tree computes its distance from the closest\n// leaf\nfunction computeHeight(revs) {\n  var height = {};\n  var edges = [];\n  traverseRevTree(revs, function (isLeaf, pos, id, prnt) {\n    var rev$$1 = pos + \"-\" + id;\n    if (isLeaf) {\n      height[rev$$1] = 0;\n    }\n    if (prnt !== undefined) {\n      edges.push({ from: prnt, to: rev$$1 });\n    }\n    return rev$$1;\n  });\n\n  edges.reverse();\n  edges.forEach(function (edge) {\n    if (height[edge.from] === undefined) {\n      height[edge.from] = 1 + height[edge.to];\n    } else {\n      height[edge.from] = Math.min(height[edge.from], 1 + height[edge.to]);\n    }\n  });\n  return height;\n}\n\nfunction allDocsKeysQuery(api, opts, callback) {\n  var keys = 'limit' in opts ? opts.keys.slice(opts.skip, opts.limit + opts.skip) : opts.skip > 0 ? opts.keys.slice(opts.skip) : opts.keys;\n  if (opts.descending) {\n    keys.reverse();\n  }\n  if (!keys.length) {\n    return api._allDocs({ limit: 0 }, callback);\n  }\n  var finalResults = {\n    offset: opts.skip\n  };\n  return PouchPromise$1.all(keys.map(function (key) {\n    var subOpts = $inject_Object_assign({ key: key, deleted: 'ok' }, opts);\n    ['limit', 'skip', 'keys'].forEach(function (optKey) {\n      delete subOpts[optKey];\n    });\n    return new PouchPromise$1(function (resolve, reject) {\n      api._allDocs(subOpts, function (err, res) {\n        /* istanbul ignore if */\n        if (err) {\n          return reject(err);\n        }\n        finalResults.total_rows = res.total_rows;\n        resolve(res.rows[0] || { key: key, error: 'not_found' });\n      });\n    });\n  })).then(function (results) {\n    finalResults.rows = results;\n    return finalResults;\n  });\n}\n\n// all compaction is done in a queue, to avoid attaching\n// too many listeners at once\nfunction doNextCompaction(self) {\n  var task = self._compactionQueue[0];\n  var opts = task.opts;\n  var callback = task.callback;\n  self.get('_local/compaction').catch(function () {\n    return false;\n  }).then(function (doc) {\n    if (doc && doc.last_seq) {\n      opts.last_seq = doc.last_seq;\n    }\n    self._compact(opts, function (err, res) {\n      /* istanbul ignore if */\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, res);\n      }\n      __WEBPACK_IMPORTED_MODULE_5_immediate___default()(function () {\n        self._compactionQueue.shift();\n        if (self._compactionQueue.length) {\n          doNextCompaction(self);\n        }\n      });\n    });\n  });\n}\n\nfunction attachmentNameError(name) {\n  if (name.charAt(0) === '_') {\n    return name + ' is not a valid attachment name, attachment ' + 'names cannot start with \\'_\\'';\n  }\n  return false;\n}\n\n__WEBPACK_IMPORTED_MODULE_4_inherits___default()(AbstractPouchDB, __WEBPACK_IMPORTED_MODULE_3_events__[\"EventEmitter\"]);\n\nfunction AbstractPouchDB() {\n  __WEBPACK_IMPORTED_MODULE_3_events__[\"EventEmitter\"].call(this);\n}\n\nAbstractPouchDB.prototype.post = adapterFun('post', function (doc, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof doc !== 'object' || Array.isArray(doc)) {\n    return callback(createError(NOT_AN_OBJECT));\n  }\n  this.bulkDocs({ docs: [doc] }, opts, yankError(callback, doc._id));\n});\n\nAbstractPouchDB.prototype.put = adapterFun('put', function (doc, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n  if (typeof doc !== 'object' || Array.isArray(doc)) {\n    return cb(createError(NOT_AN_OBJECT));\n  }\n  invalidIdError(doc._id);\n  if (isLocalId(doc._id) && typeof this._putLocal === 'function') {\n    if (doc._deleted) {\n      return this._removeLocal(doc, cb);\n    } else {\n      return this._putLocal(doc, cb);\n    }\n  }\n  var self = this;\n  if (opts.force && doc._rev) {\n    transformForceOptionToNewEditsOption();\n    putDoc(function (err) {\n      var result = err ? null : { ok: true, id: doc._id, rev: doc._rev };\n      cb(err, result);\n    });\n  } else {\n    putDoc(cb);\n  }\n\n  function transformForceOptionToNewEditsOption() {\n    var parts = doc._rev.split('-');\n    var oldRevId = parts[1];\n    var oldRevNum = parseInt(parts[0], 10);\n\n    var newRevNum = oldRevNum + 1;\n    var newRevId = rev();\n\n    doc._revisions = {\n      start: newRevNum,\n      ids: [newRevId, oldRevId]\n    };\n    doc._rev = newRevNum + '-' + newRevId;\n    opts.new_edits = false;\n  }\n  function putDoc(next) {\n    if (typeof self._put === 'function' && opts.new_edits !== false) {\n      self._put(doc, opts, next);\n    } else {\n      self.bulkDocs({ docs: [doc] }, opts, yankError(next, doc._id));\n    }\n  }\n});\n\nAbstractPouchDB.prototype.putAttachment = adapterFun('putAttachment', function (docId, attachmentId, rev$$1, blob, type) {\n  var api = this;\n  if (typeof type === 'function') {\n    type = blob;\n    blob = rev$$1;\n    rev$$1 = null;\n  }\n  // Lets fix in https://github.com/pouchdb/pouchdb/issues/3267\n  /* istanbul ignore if */\n  if (typeof type === 'undefined') {\n    type = blob;\n    blob = rev$$1;\n    rev$$1 = null;\n  }\n  if (!type) {\n    guardedConsole('warn', 'Attachment', attachmentId, 'on document', docId, 'is missing content_type');\n  }\n\n  function createAttachment(doc) {\n    var prevrevpos = '_rev' in doc ? parseInt(doc._rev, 10) : 0;\n    doc._attachments = doc._attachments || {};\n    doc._attachments[attachmentId] = {\n      content_type: type,\n      data: blob,\n      revpos: ++prevrevpos\n    };\n    return api.put(doc);\n  }\n\n  return api.get(docId).then(function (doc) {\n    if (doc._rev !== rev$$1) {\n      throw createError(REV_CONFLICT);\n    }\n\n    return createAttachment(doc);\n  }, function (err) {\n    // create new doc\n    /* istanbul ignore else */\n    if (err.reason === MISSING_DOC.message) {\n      return createAttachment({ _id: docId });\n    } else {\n      throw err;\n    }\n  });\n});\n\nAbstractPouchDB.prototype.removeAttachment = adapterFun('removeAttachment', function (docId, attachmentId, rev$$1, callback) {\n  var self = this;\n  self.get(docId, function (err, obj) {\n    /* istanbul ignore if */\n    if (err) {\n      callback(err);\n      return;\n    }\n    if (obj._rev !== rev$$1) {\n      callback(createError(REV_CONFLICT));\n      return;\n    }\n    /* istanbul ignore if */\n    if (!obj._attachments) {\n      return callback();\n    }\n    delete obj._attachments[attachmentId];\n    if (Object.keys(obj._attachments).length === 0) {\n      delete obj._attachments;\n    }\n    self.put(obj, callback);\n  });\n});\n\nAbstractPouchDB.prototype.remove = adapterFun('remove', function (docOrId, optsOrRev, opts, callback) {\n  var doc;\n  if (typeof optsOrRev === 'string') {\n    // id, rev, opts, callback style\n    doc = {\n      _id: docOrId,\n      _rev: optsOrRev\n    };\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n  } else {\n    // doc, opts, callback style\n    doc = docOrId;\n    if (typeof optsOrRev === 'function') {\n      callback = optsOrRev;\n      opts = {};\n    } else {\n      callback = opts;\n      opts = optsOrRev;\n    }\n  }\n  opts = opts || {};\n  opts.was_delete = true;\n  var newDoc = { _id: doc._id, _rev: doc._rev || opts.rev };\n  newDoc._deleted = true;\n  if (isLocalId(newDoc._id) && typeof this._removeLocal === 'function') {\n    return this._removeLocal(doc, callback);\n  }\n  this.bulkDocs({ docs: [newDoc] }, opts, yankError(callback, newDoc._id));\n});\n\nAbstractPouchDB.prototype.revsDiff = adapterFun('revsDiff', function (req, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  var ids = Object.keys(req);\n\n  if (!ids.length) {\n    return callback(null, {});\n  }\n\n  var count = 0;\n  var missing = new ExportedMap();\n\n  function addToMissing(id, revId) {\n    if (!missing.has(id)) {\n      missing.set(id, { missing: [] });\n    }\n    missing.get(id).missing.push(revId);\n  }\n\n  function processDoc(id, rev_tree) {\n    // Is this fast enough? Maybe we should switch to a set simulated by a map\n    var missingForId = req[id].slice(0);\n    traverseRevTree(rev_tree, function (isLeaf, pos, revHash, ctx, opts) {\n      var rev$$1 = pos + '-' + revHash;\n      var idx = missingForId.indexOf(rev$$1);\n      if (idx === -1) {\n        return;\n      }\n\n      missingForId.splice(idx, 1);\n      /* istanbul ignore if */\n      if (opts.status !== 'available') {\n        addToMissing(id, rev$$1);\n      }\n    });\n\n    // Traversing the tree is synchronous, so now `missingForId` contains\n    // revisions that were not found in the tree\n    missingForId.forEach(function (rev$$1) {\n      addToMissing(id, rev$$1);\n    });\n  }\n\n  ids.map(function (id) {\n    this._getRevisionTree(id, function (err, rev_tree) {\n      if (err && err.status === 404 && err.message === 'missing') {\n        missing.set(id, { missing: req[id] });\n      } else if (err) {\n        /* istanbul ignore next */\n        return callback(err);\n      } else {\n        processDoc(id, rev_tree);\n      }\n\n      if (++count === ids.length) {\n        // convert LazyMap to object\n        var missingObj = {};\n        missing.forEach(function (value, key) {\n          missingObj[key] = value;\n        });\n        return callback(null, missingObj);\n      }\n    });\n  }, this);\n});\n\n// _bulk_get API for faster replication, as described in\n// https://github.com/apache/couchdb-chttpd/pull/33\n// At the \"abstract\" level, it will just run multiple get()s in\n// parallel, because this isn't much of a performance cost\n// for local databases (except the cost of multiple transactions, which is\n// small). The http adapter overrides this in order\n// to do a more efficient single HTTP request.\nAbstractPouchDB.prototype.bulkGet = adapterFun('bulkGet', function (opts, callback) {\n  bulkGet(this, opts, callback);\n});\n\n// compact one document and fire callback\n// by compacting we mean removing all revisions which\n// are further from the leaf in revision tree than max_height\nAbstractPouchDB.prototype.compactDocument = adapterFun('compactDocument', function (docId, maxHeight, callback) {\n  var self = this;\n  this._getRevisionTree(docId, function (err, revTree) {\n    /* istanbul ignore if */\n    if (err) {\n      return callback(err);\n    }\n    var height = computeHeight(revTree);\n    var candidates = [];\n    var revs = [];\n    Object.keys(height).forEach(function (rev$$1) {\n      if (height[rev$$1] > maxHeight) {\n        candidates.push(rev$$1);\n      }\n    });\n\n    traverseRevTree(revTree, function (isLeaf, pos, revHash, ctx, opts) {\n      var rev$$1 = pos + '-' + revHash;\n      if (opts.status === 'available' && candidates.indexOf(rev$$1) !== -1) {\n        revs.push(rev$$1);\n      }\n    });\n    self._doCompaction(docId, revs, callback);\n  });\n});\n\n// compact the whole database using single document\n// compaction\nAbstractPouchDB.prototype.compact = adapterFun('compact', function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  var self = this;\n  opts = opts || {};\n\n  self._compactionQueue = self._compactionQueue || [];\n  self._compactionQueue.push({ opts: opts, callback: callback });\n  if (self._compactionQueue.length === 1) {\n    doNextCompaction(self);\n  }\n});\nAbstractPouchDB.prototype._compact = function (opts, callback) {\n  var self = this;\n  var changesOpts = {\n    return_docs: false,\n    last_seq: opts.last_seq || 0\n  };\n  var promises = [];\n\n  function onChange(row) {\n    promises.push(self.compactDocument(row.id, 0));\n  }\n  function onComplete(resp) {\n    var lastSeq = resp.last_seq;\n    PouchPromise$1.all(promises).then(function () {\n      return upsert(self, '_local/compaction', function deltaFunc(doc) {\n        if (!doc.last_seq || doc.last_seq < lastSeq) {\n          doc.last_seq = lastSeq;\n          return doc;\n        }\n        return false; // somebody else got here first, don't update\n      });\n    }).then(function () {\n      callback(null, { ok: true });\n    }).catch(callback);\n  }\n  self.changes(changesOpts).on('change', onChange).on('complete', onComplete).on('error', callback);\n};\n\n/* Begin api wrappers. Specific functionality to storage belongs in the\n   _[method] */\nAbstractPouchDB.prototype.get = adapterFun('get', function (id, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n  if (typeof id !== 'string') {\n    return cb(createError(INVALID_ID));\n  }\n  if (isLocalId(id) && typeof this._getLocal === 'function') {\n    return this._getLocal(id, cb);\n  }\n  var leaves = [],\n      self = this;\n\n  function finishOpenRevs() {\n    var result = [];\n    var count = leaves.length;\n    /* istanbul ignore if */\n    if (!count) {\n      return cb(null, result);\n    }\n\n    // order with open_revs is unspecified\n    leaves.forEach(function (leaf) {\n      self.get(id, {\n        rev: leaf,\n        revs: opts.revs,\n        latest: opts.latest,\n        attachments: opts.attachments\n      }, function (err, doc) {\n        if (!err) {\n          // using latest=true can produce duplicates\n          var existing;\n          for (var i = 0, l = result.length; i < l; i++) {\n            if (result[i].ok && result[i].ok._rev === doc._rev) {\n              existing = true;\n              break;\n            }\n          }\n          if (!existing) {\n            result.push({ ok: doc });\n          }\n        } else {\n          result.push({ missing: leaf });\n        }\n        count--;\n        if (!count) {\n          cb(null, result);\n        }\n      });\n    });\n  }\n\n  if (opts.open_revs) {\n    if (opts.open_revs === \"all\") {\n      this._getRevisionTree(id, function (err, rev_tree) {\n        if (err) {\n          return cb(err);\n        }\n        leaves = collectLeaves(rev_tree).map(function (leaf) {\n          return leaf.rev;\n        });\n        finishOpenRevs();\n      });\n    } else {\n      if (Array.isArray(opts.open_revs)) {\n        leaves = opts.open_revs;\n        for (var i = 0; i < leaves.length; i++) {\n          var l = leaves[i];\n          // looks like it's the only thing couchdb checks\n          if (!(typeof l === \"string\" && /^\\d+-/.test(l))) {\n            return cb(createError(INVALID_REV));\n          }\n        }\n        finishOpenRevs();\n      } else {\n        return cb(createError(UNKNOWN_ERROR, 'function_clause'));\n      }\n    }\n    return; // open_revs does not like other options\n  }\n\n  return this._get(id, opts, function (err, result) {\n    if (err) {\n      err.docId = id;\n      return cb(err);\n    }\n\n    var doc = result.doc;\n    var metadata = result.metadata;\n    var ctx = result.ctx;\n\n    if (opts.conflicts) {\n      var conflicts = collectConflicts(metadata);\n      if (conflicts.length) {\n        doc._conflicts = conflicts;\n      }\n    }\n\n    if (isDeleted(metadata, doc._rev)) {\n      doc._deleted = true;\n    }\n\n    if (opts.revs || opts.revs_info) {\n      var splittedRev = doc._rev.split('-');\n      var revNo = parseInt(splittedRev[0], 10);\n      var revHash = splittedRev[1];\n\n      var paths = rootToLeaf(metadata.rev_tree);\n      var path = null;\n\n      for (var i = 0; i < paths.length; i++) {\n        var currentPath = paths[i];\n        var hashIndex = currentPath.ids.map(function (x) {\n          return x.id;\n        }).indexOf(revHash);\n        var hashFoundAtRevPos = hashIndex === revNo - 1;\n\n        if (hashFoundAtRevPos || !path && hashIndex !== -1) {\n          path = currentPath;\n        }\n      }\n\n      var indexOfRev = path.ids.map(function (x) {\n        return x.id;\n      }).indexOf(doc._rev.split('-')[1]) + 1;\n      var howMany = path.ids.length - indexOfRev;\n      path.ids.splice(indexOfRev, howMany);\n      path.ids.reverse();\n\n      if (opts.revs) {\n        doc._revisions = {\n          start: path.pos + path.ids.length - 1,\n          ids: path.ids.map(function (rev$$1) {\n            return rev$$1.id;\n          })\n        };\n      }\n      if (opts.revs_info) {\n        var pos = path.pos + path.ids.length;\n        doc._revs_info = path.ids.map(function (rev$$1) {\n          pos--;\n          return {\n            rev: pos + '-' + rev$$1.id,\n            status: rev$$1.opts.status\n          };\n        });\n      }\n    }\n\n    if (opts.attachments && doc._attachments) {\n      var attachments = doc._attachments;\n      var count = Object.keys(attachments).length;\n      if (count === 0) {\n        return cb(null, doc);\n      }\n      Object.keys(attachments).forEach(function (key) {\n        this._getAttachment(doc._id, key, attachments[key], {\n          // Previously the revision handling was done in adapter.js\n          // getAttachment, however since idb-next doesnt we need to\n          // pass the rev through\n          rev: doc._rev,\n          binary: opts.binary,\n          ctx: ctx\n        }, function (err, data) {\n          var att = doc._attachments[key];\n          att.data = data;\n          delete att.stub;\n          delete att.length;\n          if (! --count) {\n            cb(null, doc);\n          }\n        });\n      }, self);\n    } else {\n      if (doc._attachments) {\n        for (var key in doc._attachments) {\n          /* istanbul ignore else */\n          if (doc._attachments.hasOwnProperty(key)) {\n            doc._attachments[key].stub = true;\n          }\n        }\n      }\n      cb(null, doc);\n    }\n  });\n});\n\n// TODO: I dont like this, it forces an extra read for every\n// attachment read and enforces a confusing api between\n// adapter.js and the adapter implementation\nAbstractPouchDB.prototype.getAttachment = adapterFun('getAttachment', function (docId, attachmentId, opts, callback) {\n  var self = this;\n  if (opts instanceof Function) {\n    callback = opts;\n    opts = {};\n  }\n  this._get(docId, opts, function (err, res) {\n    if (err) {\n      return callback(err);\n    }\n    if (res.doc._attachments && res.doc._attachments[attachmentId]) {\n      opts.ctx = res.ctx;\n      opts.binary = true;\n      self._getAttachment(docId, attachmentId, res.doc._attachments[attachmentId], opts, callback);\n    } else {\n      return callback(createError(MISSING_DOC));\n    }\n  });\n});\n\nAbstractPouchDB.prototype.allDocs = adapterFun('allDocs', function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  opts.skip = typeof opts.skip !== 'undefined' ? opts.skip : 0;\n  if (opts.start_key) {\n    opts.startkey = opts.start_key;\n  }\n  if (opts.end_key) {\n    opts.endkey = opts.end_key;\n  }\n  if ('keys' in opts) {\n    if (!Array.isArray(opts.keys)) {\n      return callback(new TypeError('options.keys must be an array'));\n    }\n    var incompatibleOpt = ['startkey', 'endkey', 'key'].filter(function (incompatibleOpt) {\n      return incompatibleOpt in opts;\n    })[0];\n    if (incompatibleOpt) {\n      callback(createError(QUERY_PARSE_ERROR, 'Query parameter `' + incompatibleOpt + '` is not compatible with multi-get'));\n      return;\n    }\n    if (!isRemote(this)) {\n      return allDocsKeysQuery(this, opts, callback);\n    }\n  }\n\n  return this._allDocs(opts, callback);\n});\n\nAbstractPouchDB.prototype.changes = function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return new Changes$2(this, opts, callback);\n};\n\nAbstractPouchDB.prototype.close = adapterFun('close', function (callback) {\n  this._closed = true;\n  this.emit('closed');\n  return this._close(callback);\n});\n\nAbstractPouchDB.prototype.info = adapterFun('info', function (callback) {\n  var self = this;\n  this._info(function (err, info) {\n    if (err) {\n      return callback(err);\n    }\n    // assume we know better than the adapter, unless it informs us\n    info.db_name = info.db_name || self.name;\n    info.auto_compaction = !!(self.auto_compaction && !isRemote(self));\n    info.adapter = self.adapter;\n    callback(null, info);\n  });\n});\n\nAbstractPouchDB.prototype.id = adapterFun('id', function (callback) {\n  return this._id(callback);\n});\n\n/* istanbul ignore next */\nAbstractPouchDB.prototype.type = function () {\n  return typeof this._type === 'function' ? this._type() : this.adapter;\n};\n\nAbstractPouchDB.prototype.bulkDocs = adapterFun('bulkDocs', function (req, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  opts = opts || {};\n\n  if (Array.isArray(req)) {\n    req = {\n      docs: req\n    };\n  }\n\n  if (!req || !req.docs || !Array.isArray(req.docs)) {\n    return callback(createError(MISSING_BULK_DOCS));\n  }\n\n  for (var i = 0; i < req.docs.length; ++i) {\n    if (typeof req.docs[i] !== 'object' || Array.isArray(req.docs[i])) {\n      return callback(createError(NOT_AN_OBJECT));\n    }\n  }\n\n  var attachmentError;\n  req.docs.forEach(function (doc) {\n    if (doc._attachments) {\n      Object.keys(doc._attachments).forEach(function (name) {\n        attachmentError = attachmentError || attachmentNameError(name);\n        if (!doc._attachments[name].content_type) {\n          guardedConsole('warn', 'Attachment', name, 'on document', doc._id, 'is missing content_type');\n        }\n      });\n    }\n  });\n\n  if (attachmentError) {\n    return callback(createError(BAD_REQUEST, attachmentError));\n  }\n\n  if (!('new_edits' in opts)) {\n    if ('new_edits' in req) {\n      opts.new_edits = req.new_edits;\n    } else {\n      opts.new_edits = true;\n    }\n  }\n\n  var adapter = this;\n  if (!opts.new_edits && !isRemote(adapter)) {\n    // ensure revisions of the same doc are sorted, so that\n    // the local adapter processes them correctly (#2935)\n    req.docs.sort(compareByIdThenRev);\n  }\n\n  cleanDocs(req.docs);\n\n  // in the case of conflicts, we want to return the _ids to the user\n  // however, the underlying adapter may destroy the docs array, so\n  // create a copy here\n  var ids = req.docs.map(function (doc) {\n    return doc._id;\n  });\n\n  return this._bulkDocs(req, opts, function (err, res) {\n    if (err) {\n      return callback(err);\n    }\n    if (!opts.new_edits) {\n      // this is what couch does when new_edits is false\n      res = res.filter(function (x) {\n        return x.error;\n      });\n    }\n    // add ids for error/conflict responses (not required for CouchDB)\n    if (!isRemote(adapter)) {\n      for (var i = 0, l = res.length; i < l; i++) {\n        res[i].id = res[i].id || ids[i];\n      }\n    }\n\n    callback(null, res);\n  });\n});\n\nAbstractPouchDB.prototype.registerDependentDatabase = adapterFun('registerDependentDatabase', function (dependentDb, callback) {\n  var depDB = new this.constructor(dependentDb, this.__opts);\n\n  function diffFun(doc) {\n    doc.dependentDbs = doc.dependentDbs || {};\n    if (doc.dependentDbs[dependentDb]) {\n      return false; // no update required\n    }\n    doc.dependentDbs[dependentDb] = true;\n    return doc;\n  }\n  upsert(this, '_local/_pouch_dependentDbs', diffFun).then(function () {\n    callback(null, { db: depDB });\n  }).catch(callback);\n});\n\nAbstractPouchDB.prototype.destroy = adapterFun('destroy', function (opts, callback) {\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  var self = this;\n  var usePrefix = 'use_prefix' in self ? self.use_prefix : true;\n\n  function destroyDb() {\n    // call destroy method of the particular adaptor\n    self._destroy(opts, function (err, resp) {\n      if (err) {\n        return callback(err);\n      }\n      self._destroyed = true;\n      self.emit('destroyed');\n      callback(null, resp || { 'ok': true });\n    });\n  }\n\n  if (isRemote(self)) {\n    // no need to check for dependent DBs if it's a remote DB\n    return destroyDb();\n  }\n\n  self.get('_local/_pouch_dependentDbs', function (err, localDoc) {\n    if (err) {\n      /* istanbul ignore if */\n      if (err.status !== 404) {\n        return callback(err);\n      } else {\n        // no dependencies\n        return destroyDb();\n      }\n    }\n    var dependentDbs = localDoc.dependentDbs;\n    var PouchDB = self.constructor;\n    var deletedMap = Object.keys(dependentDbs).map(function (name) {\n      // use_prefix is only false in the browser\n      /* istanbul ignore next */\n      var trueName = usePrefix ? name.replace(new RegExp('^' + PouchDB.prefix), '') : name;\n      return new PouchDB(trueName, self.__opts).destroy();\n    });\n    PouchPromise$1.all(deletedMap).then(destroyDb, callback);\n  });\n});\n\nfunction TaskQueue$1() {\n  this.isReady = false;\n  this.failed = false;\n  this.queue = [];\n}\n\nTaskQueue$1.prototype.execute = function () {\n  var fun;\n  if (this.failed) {\n    while (fun = this.queue.shift()) {\n      fun(this.failed);\n    }\n  } else {\n    while (fun = this.queue.shift()) {\n      fun();\n    }\n  }\n};\n\nTaskQueue$1.prototype.fail = function (err) {\n  this.failed = err;\n  this.execute();\n};\n\nTaskQueue$1.prototype.ready = function (db) {\n  this.isReady = true;\n  this.db = db;\n  this.execute();\n};\n\nTaskQueue$1.prototype.addTask = function (fun) {\n  this.queue.push(fun);\n  if (this.failed) {\n    this.execute();\n  }\n};\n\nfunction parseAdapter(name, opts) {\n  var match = name.match(/([a-z-]*):\\/\\/(.*)/);\n  if (match) {\n    // the http adapter expects the fully qualified name\n    return {\n      name: /https?/.test(match[1]) ? match[1] + '://' + match[2] : match[2],\n      adapter: match[1]\n    };\n  }\n\n  var adapters = PouchDB$5.adapters;\n  var preferredAdapters = PouchDB$5.preferredAdapters;\n  var prefix = PouchDB$5.prefix;\n  var adapterName = opts.adapter;\n\n  if (!adapterName) {\n    // automatically determine adapter\n    for (var i = 0; i < preferredAdapters.length; ++i) {\n      adapterName = preferredAdapters[i];\n      // check for browsers that have been upgraded from websql-only to websql+idb\n      /* istanbul ignore if */\n      if (adapterName === 'idb' && 'websql' in adapters && hasLocalStorage() && localStorage['_pouch__websqldb_' + prefix + name]) {\n        // log it, because this can be confusing during development\n        guardedConsole('log', 'PouchDB is downgrading \"' + name + '\" to WebSQL to' + ' avoid data loss, because it was already opened with WebSQL.');\n        continue; // keep using websql to avoid user data loss\n      }\n      break;\n    }\n  }\n\n  var adapter = adapters[adapterName];\n\n  // if adapter is invalid, then an error will be thrown later\n  var usePrefix = adapter && 'use_prefix' in adapter ? adapter.use_prefix : true;\n\n  return {\n    name: usePrefix ? prefix + name : name,\n    adapter: adapterName\n  };\n}\n\n// OK, so here's the deal. Consider this code:\n//     var db1 = new PouchDB('foo');\n//     var db2 = new PouchDB('foo');\n//     db1.destroy();\n// ^ these two both need to emit 'destroyed' events,\n// as well as the PouchDB constructor itself.\n// So we have one db object (whichever one got destroy() called on it)\n// responsible for emitting the initial event, which then gets emitted\n// by the constructor, which then broadcasts it to any other dbs\n// that may have been created with the same name.\nfunction prepareForDestruction(self) {\n\n  function onDestroyed(from_constructor) {\n    self.removeListener('closed', onClosed);\n    if (!from_constructor) {\n      self.constructor.emit('destroyed', self.name);\n    }\n  }\n\n  function onClosed() {\n    self.removeListener('destroyed', onDestroyed);\n    self.constructor.emit('unref', self);\n  }\n\n  self.once('destroyed', onDestroyed);\n  self.once('closed', onClosed);\n  self.constructor.emit('ref', self);\n}\n\n__WEBPACK_IMPORTED_MODULE_4_inherits___default()(PouchDB$5, AbstractPouchDB);\nfunction PouchDB$5(name, opts) {\n  // In Node our test suite only tests this for PouchAlt unfortunately\n  /* istanbul ignore if */\n  if (!(this instanceof PouchDB$5)) {\n    return new PouchDB$5(name, opts);\n  }\n\n  var self = this;\n  opts = opts || {};\n\n  if (name && typeof name === 'object') {\n    opts = name;\n    name = opts.name;\n    delete opts.name;\n  }\n\n  this.__opts = opts = clone(opts);\n\n  self.auto_compaction = opts.auto_compaction;\n  self.prefix = PouchDB$5.prefix;\n\n  if (typeof name !== 'string') {\n    throw new Error('Missing/invalid DB name');\n  }\n\n  var prefixedName = (opts.prefix || '') + name;\n  var backend = parseAdapter(prefixedName, opts);\n\n  opts.name = backend.name;\n  opts.adapter = opts.adapter || backend.adapter;\n\n  self.name = name;\n  self._adapter = opts.adapter;\n  PouchDB$5.emit('debug', ['adapter', 'Picked adapter: ', opts.adapter]);\n\n  if (!PouchDB$5.adapters[opts.adapter] || !PouchDB$5.adapters[opts.adapter].valid()) {\n    throw new Error('Invalid Adapter: ' + opts.adapter);\n  }\n\n  AbstractPouchDB.call(self);\n  self.taskqueue = new TaskQueue$1();\n\n  self.adapter = opts.adapter;\n\n  PouchDB$5.adapters[opts.adapter].call(self, opts, function (err) {\n    if (err) {\n      return self.taskqueue.fail(err);\n    }\n    prepareForDestruction(self);\n\n    self.emit('created', self);\n    PouchDB$5.emit('created', self.name);\n    self.taskqueue.ready(self);\n  });\n}\n\nPouchDB$5.adapters = {};\nPouchDB$5.preferredAdapters = [];\n\nPouchDB$5.prefix = '_pouch_';\n\nvar eventEmitter = new __WEBPACK_IMPORTED_MODULE_3_events__[\"EventEmitter\"]();\n\nfunction setUpEventEmitter(Pouch) {\n  Object.keys(__WEBPACK_IMPORTED_MODULE_3_events__[\"EventEmitter\"].prototype).forEach(function (key) {\n    if (typeof __WEBPACK_IMPORTED_MODULE_3_events__[\"EventEmitter\"].prototype[key] === 'function') {\n      Pouch[key] = eventEmitter[key].bind(eventEmitter);\n    }\n  });\n\n  // these are created in constructor.js, and allow us to notify each DB with\n  // the same name that it was destroyed, via the constructor object\n  var destructListeners = Pouch._destructionListeners = new ExportedMap();\n\n  Pouch.on('ref', function onConstructorRef(db) {\n    if (!destructListeners.has(db.name)) {\n      destructListeners.set(db.name, []);\n    }\n    destructListeners.get(db.name).push(db);\n  });\n\n  Pouch.on('unref', function onConstructorUnref(db) {\n    if (!destructListeners.has(db.name)) {\n      return;\n    }\n    var dbList = destructListeners.get(db.name);\n    var pos = dbList.indexOf(db);\n    if (pos < 0) {\n      /* istanbul ignore next */\n      return;\n    }\n    dbList.splice(pos, 1);\n    if (dbList.length > 1) {\n      /* istanbul ignore next */\n      destructListeners.set(db.name, dbList);\n    } else {\n      destructListeners.delete(db.name);\n    }\n  });\n\n  Pouch.on('destroyed', function onConstructorDestroyed(name) {\n    if (!destructListeners.has(name)) {\n      return;\n    }\n    var dbList = destructListeners.get(name);\n    destructListeners.delete(name);\n    dbList.forEach(function (db) {\n      db.emit('destroyed', true);\n    });\n  });\n}\n\nsetUpEventEmitter(PouchDB$5);\n\nPouchDB$5.adapter = function (id, obj, addToPreferredAdapters) {\n  /* istanbul ignore else */\n  if (obj.valid()) {\n    PouchDB$5.adapters[id] = obj;\n    if (addToPreferredAdapters) {\n      PouchDB$5.preferredAdapters.push(id);\n    }\n  }\n};\n\nPouchDB$5.plugin = function (obj) {\n  if (typeof obj === 'function') {\n    // function style for plugins\n    obj(PouchDB$5);\n  } else if (typeof obj !== 'object' || Object.keys(obj).length === 0) {\n    throw new Error('Invalid plugin: got \"' + obj + '\", expected an object or a function');\n  } else {\n    Object.keys(obj).forEach(function (id) {\n      // object style for plugins\n      PouchDB$5.prototype[id] = obj[id];\n    });\n  }\n  if (this.__defaults) {\n    PouchDB$5.__defaults = $inject_Object_assign({}, this.__defaults);\n  }\n  return PouchDB$5;\n};\n\nPouchDB$5.defaults = function (defaultOpts) {\n  function PouchAlt(name, opts) {\n    if (!(this instanceof PouchAlt)) {\n      return new PouchAlt(name, opts);\n    }\n\n    opts = opts || {};\n\n    if (name && typeof name === 'object') {\n      opts = name;\n      name = opts.name;\n      delete opts.name;\n    }\n\n    opts = $inject_Object_assign({}, PouchAlt.__defaults, opts);\n    PouchDB$5.call(this, name, opts);\n  }\n\n  __WEBPACK_IMPORTED_MODULE_4_inherits___default()(PouchAlt, PouchDB$5);\n\n  PouchAlt.preferredAdapters = PouchDB$5.preferredAdapters.slice();\n  Object.keys(PouchDB$5).forEach(function (key) {\n    if (!(key in PouchAlt)) {\n      PouchAlt[key] = PouchDB$5[key];\n    }\n  });\n\n  // make default options transitive\n  // https://github.com/pouchdb/pouchdb/issues/5922\n  PouchAlt.__defaults = $inject_Object_assign({}, this.__defaults, defaultOpts);\n\n  return PouchAlt;\n};\n\n// managed automatically by set-version.js\nvar version = \"6.3.4\";\n\nfunction debugPouch(PouchDB) {\n  PouchDB.debug = __WEBPACK_IMPORTED_MODULE_6_debug___default.a;\n  var logs = {};\n  /* istanbul ignore next */\n  PouchDB.on('debug', function (args) {\n    // first argument is log identifier\n    var logId = args[0];\n    // rest should be passed verbatim to debug module\n    var logArgs = args.slice(1);\n    if (!logs[logId]) {\n      logs[logId] = __WEBPACK_IMPORTED_MODULE_6_debug___default()('pouchdb:' + logId);\n    }\n    logs[logId].apply(null, logArgs);\n  });\n}\n\n// this would just be \"return doc[field]\", but fields\n// can be \"deep\" due to dot notation\nfunction getFieldFromDoc(doc, parsedField) {\n  var value = doc;\n  for (var i = 0, len = parsedField.length; i < len; i++) {\n    var key = parsedField[i];\n    value = value[key];\n    if (!value) {\n      break;\n    }\n  }\n  return value;\n}\n\nfunction compare$1(left, right) {\n  return left < right ? -1 : left > right ? 1 : 0;\n}\n\n// Converts a string in dot notation to an array of its components, with backslash escaping\nfunction parseField(fieldName) {\n  // fields may be deep (e.g. \"foo.bar.baz\"), so parse\n  var fields = [];\n  var current = '';\n  for (var i = 0, len = fieldName.length; i < len; i++) {\n    var ch = fieldName[i];\n    if (ch === '.') {\n      if (i > 0 && fieldName[i - 1] === '\\\\') {\n        // escaped delimiter\n        current = current.substring(0, current.length - 1) + '.';\n      } else {\n        // not escaped, so delimiter\n        fields.push(current);\n        current = '';\n      }\n    } else {\n      // normal character\n      current += ch;\n    }\n  }\n  fields.push(current);\n  return fields;\n}\n\nvar combinationFields = ['$or', '$nor', '$not'];\nfunction isCombinationalField(field) {\n  return combinationFields.indexOf(field) > -1;\n}\n\nfunction getKey(obj) {\n  return Object.keys(obj)[0];\n}\n\nfunction getValue(obj) {\n  return obj[getKey(obj)];\n}\n\n// flatten an array of selectors joined by an $and operator\nfunction mergeAndedSelectors(selectors) {\n\n  // sort to ensure that e.g. if the user specified\n  // $and: [{$gt: 'a'}, {$gt: 'b'}], then it's collapsed into\n  // just {$gt: 'b'}\n  var res = {};\n\n  selectors.forEach(function (selector) {\n    Object.keys(selector).forEach(function (field) {\n      var matcher = selector[field];\n      if (typeof matcher !== 'object') {\n        matcher = { $eq: matcher };\n      }\n\n      if (isCombinationalField(field)) {\n        if (matcher instanceof Array) {\n          res[field] = matcher.map(function (m) {\n            return mergeAndedSelectors([m]);\n          });\n        } else {\n          res[field] = mergeAndedSelectors([matcher]);\n        }\n      } else {\n        var fieldMatchers = res[field] = res[field] || {};\n        Object.keys(matcher).forEach(function (operator) {\n          var value = matcher[operator];\n\n          if (operator === '$gt' || operator === '$gte') {\n            return mergeGtGte(operator, value, fieldMatchers);\n          } else if (operator === '$lt' || operator === '$lte') {\n            return mergeLtLte(operator, value, fieldMatchers);\n          } else if (operator === '$ne') {\n            return mergeNe(value, fieldMatchers);\n          } else if (operator === '$eq') {\n            return mergeEq(value, fieldMatchers);\n          }\n          fieldMatchers[operator] = value;\n        });\n      }\n    });\n  });\n\n  return res;\n}\n\n// collapse logically equivalent gt/gte values\nfunction mergeGtGte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$gte !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gte) {\n        // more specificity\n        fieldMatchers.$gte = value;\n      }\n    } else {\n      // operator === '$gt'\n      if (value >= fieldMatchers.$gte) {\n        // more specificity\n        delete fieldMatchers.$gte;\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$gt !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gt) {\n        // more specificity\n        delete fieldMatchers.$gt;\n        fieldMatchers.$gte = value;\n      }\n    } else {\n      // operator === '$gt'\n      if (value > fieldMatchers.$gt) {\n        // more specificity\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// collapse logically equivalent lt/lte values\nfunction mergeLtLte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$lte !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lte) {\n        // more specificity\n        fieldMatchers.$lte = value;\n      }\n    } else {\n      // operator === '$gt'\n      if (value <= fieldMatchers.$lte) {\n        // more specificity\n        delete fieldMatchers.$lte;\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$lt !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lt) {\n        // more specificity\n        delete fieldMatchers.$lt;\n        fieldMatchers.$lte = value;\n      }\n    } else {\n      // operator === '$gt'\n      if (value < fieldMatchers.$lt) {\n        // more specificity\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// combine $ne values into one array\nfunction mergeNe(value, fieldMatchers) {\n  if ('$ne' in fieldMatchers) {\n    // there are many things this could \"not\" be\n    fieldMatchers.$ne.push(value);\n  } else {\n    // doesn't exist yet\n    fieldMatchers.$ne = [value];\n  }\n}\n\n// add $eq into the mix\nfunction mergeEq(value, fieldMatchers) {\n  // these all have less specificity than the $eq\n  // TODO: check for user errors here\n  delete fieldMatchers.$gt;\n  delete fieldMatchers.$gte;\n  delete fieldMatchers.$lt;\n  delete fieldMatchers.$lte;\n  delete fieldMatchers.$ne;\n  fieldMatchers.$eq = value;\n}\n\n//\n// normalize the selector\n//\nfunction massageSelector(input) {\n  var result = clone(input);\n  var wasAnded = false;\n  if ('$and' in result) {\n    result = mergeAndedSelectors(result['$and']);\n    wasAnded = true;\n  }\n\n  ['$or', '$nor'].forEach(function (orOrNor) {\n    if (orOrNor in result) {\n      // message each individual selector\n      // e.g. {foo: 'bar'} becomes {foo: {$eq: 'bar'}}\n      result[orOrNor].forEach(function (subSelector) {\n        var fields = Object.keys(subSelector);\n        for (var i = 0; i < fields.length; i++) {\n          var field = fields[i];\n          var matcher = subSelector[field];\n          if (typeof matcher !== 'object' || matcher === null) {\n            subSelector[field] = { $eq: matcher };\n          }\n        }\n      });\n    }\n  });\n\n  if ('$not' in result) {\n    //This feels a little like forcing, but it will work for now,\n    //I would like to come back to this and make the merging of selectors a little more generic\n    result['$not'] = mergeAndedSelectors([result['$not']]);\n  }\n\n  var fields = Object.keys(result);\n\n  for (var i = 0; i < fields.length; i++) {\n    var field = fields[i];\n    var matcher = result[field];\n\n    if (typeof matcher !== 'object' || matcher === null) {\n      matcher = { $eq: matcher };\n    } else if ('$ne' in matcher && !wasAnded) {\n      // I put these in an array, since there may be more than one\n      // but in the \"mergeAnded\" operation, I already take care of that\n      matcher.$ne = [matcher.$ne];\n    }\n    result[field] = matcher;\n  }\n\n  return result;\n}\n\nfunction pad(str, padWith, upToLength) {\n  var padding = '';\n  var targetLength = upToLength - str.length;\n  /* istanbul ignore next */\n  while (padding.length < targetLength) {\n    padding += padWith;\n  }\n  return padding;\n}\n\nfunction padLeft(str, padWith, upToLength) {\n  var padding = pad(str, padWith, upToLength);\n  return padding + str;\n}\n\nvar MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE\nvar MAGNITUDE_DIGITS = 3; // ditto\nvar SEP = ''; // set to '_' for easier debugging \n\nfunction collate(a, b) {\n\n  if (a === b) {\n    return 0;\n  }\n\n  a = normalizeKey(a);\n  b = normalizeKey(b);\n\n  var ai = collationIndex(a);\n  var bi = collationIndex(b);\n  if (ai - bi !== 0) {\n    return ai - bi;\n  }\n  switch (typeof a) {\n    case 'number':\n      return a - b;\n    case 'boolean':\n      return a < b ? -1 : 1;\n    case 'string':\n      return stringCollate(a, b);\n  }\n  return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);\n}\n\n// couch considers null/NaN/Infinity/-Infinity === undefined,\n// for the purposes of mapreduce indexes. also, dates get stringified.\nfunction normalizeKey(key) {\n  switch (typeof key) {\n    case 'undefined':\n      return null;\n    case 'number':\n      if (key === Infinity || key === -Infinity || isNaN(key)) {\n        return null;\n      }\n      return key;\n    case 'object':\n      var origKey = key;\n      if (Array.isArray(key)) {\n        var len = key.length;\n        key = new Array(len);\n        for (var i = 0; i < len; i++) {\n          key[i] = normalizeKey(origKey[i]);\n        }\n        /* istanbul ignore next */\n      } else if (key instanceof Date) {\n        return key.toJSON();\n      } else if (key !== null) {\n        // generic object\n        key = {};\n        for (var k in origKey) {\n          if (origKey.hasOwnProperty(k)) {\n            var val = origKey[k];\n            if (typeof val !== 'undefined') {\n              key[k] = normalizeKey(val);\n            }\n          }\n        }\n      }\n  }\n  return key;\n}\n\nfunction indexify(key) {\n  if (key !== null) {\n    switch (typeof key) {\n      case 'boolean':\n        return key ? 1 : 0;\n      case 'number':\n        return numToIndexableString(key);\n      case 'string':\n        // We've to be sure that key does not contain \\u0000\n        // Do order-preserving replacements:\n        // 0 -> 1, 1\n        // 1 -> 1, 2\n        // 2 -> 2, 2\n        return key.replace(/\\u0002/g, '\\x02\\x02').replace(/\\u0001/g, '\\x01\\x02').replace(/\\u0000/g, '\\x01\\x01');\n      case 'object':\n        var isArray = Array.isArray(key);\n        var arr = isArray ? key : Object.keys(key);\n        var i = -1;\n        var len = arr.length;\n        var result = '';\n        if (isArray) {\n          while (++i < len) {\n            result += toIndexableString(arr[i]);\n          }\n        } else {\n          while (++i < len) {\n            var objKey = arr[i];\n            result += toIndexableString(objKey) + toIndexableString(key[objKey]);\n          }\n        }\n        return result;\n    }\n  }\n  return '';\n}\n\n// convert the given key to a string that would be appropriate\n// for lexical sorting, e.g. within a database, where the\n// sorting is the same given by the collate() function.\nfunction toIndexableString(key) {\n  var zero = '\\0';\n  key = normalizeKey(key);\n  return collationIndex(key) + SEP + indexify(key) + zero;\n}\n\nfunction parseNumber(str, i) {\n  var originalIdx = i;\n  var num;\n  var zero = str[i] === '1';\n  if (zero) {\n    num = 0;\n    i++;\n  } else {\n    var neg = str[i] === '0';\n    i++;\n    var numAsString = '';\n    var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);\n    var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;\n    /* istanbul ignore next */\n    if (neg) {\n      magnitude = -magnitude;\n    }\n    i += MAGNITUDE_DIGITS;\n    while (true) {\n      var ch = str[i];\n      if (ch === '\\0') {\n        break;\n      } else {\n        numAsString += ch;\n      }\n      i++;\n    }\n    numAsString = numAsString.split('.');\n    if (numAsString.length === 1) {\n      num = parseInt(numAsString, 10);\n    } else {\n      /* istanbul ignore next */\n      num = parseFloat(numAsString[0] + '.' + numAsString[1]);\n    }\n    /* istanbul ignore next */\n    if (neg) {\n      num = num - 10;\n    }\n    /* istanbul ignore next */\n    if (magnitude !== 0) {\n      // parseFloat is more reliable than pow due to rounding errors\n      // e.g. Number.MAX_VALUE would return Infinity if we did\n      // num * Math.pow(10, magnitude);\n      num = parseFloat(num + 'e' + magnitude);\n    }\n  }\n  return { num: num, length: i - originalIdx };\n}\n\n// move up the stack while parsing\n// this function moved outside of parseIndexableString for performance\nfunction pop(stack, metaStack) {\n  var obj = stack.pop();\n\n  if (metaStack.length) {\n    var lastMetaElement = metaStack[metaStack.length - 1];\n    if (obj === lastMetaElement.element) {\n      // popping a meta-element, e.g. an object whose value is another object\n      metaStack.pop();\n      lastMetaElement = metaStack[metaStack.length - 1];\n    }\n    var element = lastMetaElement.element;\n    var lastElementIndex = lastMetaElement.index;\n    if (Array.isArray(element)) {\n      element.push(obj);\n    } else if (lastElementIndex === stack.length - 2) {\n      // obj with key+value\n      var key = stack.pop();\n      element[key] = obj;\n    } else {\n      stack.push(obj); // obj with key only\n    }\n  }\n}\n\nfunction parseIndexableString(str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n\n  /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n  while (true) {\n    var collationIndex = str[i++];\n    if (collationIndex === '\\0') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case '1':\n        stack.push(null);\n        break;\n      case '2':\n        stack.push(str[i] === '1');\n        i++;\n        break;\n      case '3':\n        var parsedNum = parseNumber(str, i);\n        stack.push(parsedNum.num);\n        i += parsedNum.length;\n        break;\n      case '4':\n        var parsedStr = '';\n        /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n        while (true) {\n          var ch = str[i];\n          if (ch === '\\0') {\n            break;\n          }\n          parsedStr += ch;\n          i++;\n        }\n        // perform the reverse of the order-preserving replacement\n        // algorithm (see above)\n        parsedStr = parsedStr.replace(/\\u0001\\u0001/g, '\\0').replace(/\\u0001\\u0002/g, '\\x01').replace(/\\u0002\\u0002/g, '\\x02');\n        stack.push(parsedStr);\n        break;\n      case '5':\n        var arrayElement = { element: [], index: stack.length };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '6':\n        var objElement = { element: {}, index: stack.length };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      /* istanbul ignore next */\n      default:\n        throw new Error('bad collationIndex or unexpectedly reached end of input: ' + collationIndex);\n    }\n  }\n}\n\nfunction arrayCollate(a, b) {\n  var len = Math.min(a.length, b.length);\n  for (var i = 0; i < len; i++) {\n    var sort = collate(a[i], b[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n  }\n  return a.length === b.length ? 0 : a.length > b.length ? 1 : -1;\n}\nfunction stringCollate(a, b) {\n  // See: https://github.com/daleharvey/pouchdb/issues/40\n  // This is incompatible with the CouchDB implementation, but its the\n  // best we can do for now\n  return a === b ? 0 : a > b ? 1 : -1;\n}\nfunction objectCollate(a, b) {\n  var ak = Object.keys(a),\n      bk = Object.keys(b);\n  var len = Math.min(ak.length, bk.length);\n  for (var i = 0; i < len; i++) {\n    // First sort the keys\n    var sort = collate(ak[i], bk[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n    // if the keys are equal sort the values\n    sort = collate(a[ak[i]], b[bk[i]]);\n    if (sort !== 0) {\n      return sort;\n    }\n  }\n  return ak.length === bk.length ? 0 : ak.length > bk.length ? 1 : -1;\n}\n// The collation is defined by erlangs ordered terms\n// the atoms null, true, false come first, then numbers, strings,\n// arrays, then objects\n// null/undefined/NaN/Infinity/-Infinity are all considered null\nfunction collationIndex(x) {\n  var id = ['boolean', 'number', 'string', 'object'];\n  var idx = id.indexOf(typeof x);\n  //false if -1 otherwise true, but fast!!!!1\n  if (~idx) {\n    if (x === null) {\n      return 1;\n    }\n    if (Array.isArray(x)) {\n      return 5;\n    }\n    return idx < 3 ? idx + 2 : idx + 3;\n  }\n  /* istanbul ignore next */\n  if (Array.isArray(x)) {\n    return 5;\n  }\n}\n\n// conversion:\n// x yyy zz...zz\n// x = 0 for negative, 1 for 0, 2 for positive\n// y = exponent (for negative numbers negated) moved so that it's >= 0\n// z = mantisse\nfunction numToIndexableString(num) {\n\n  if (num === 0) {\n    return '1';\n  }\n\n  // convert number to exponential format for easier and\n  // more succinct string sorting\n  var expFormat = num.toExponential().split(/e\\+?/);\n  var magnitude = parseInt(expFormat[1], 10);\n\n  var neg = num < 0;\n\n  var result = neg ? '0' : '2';\n\n  // first sort by magnitude\n  // it's easier if all magnitudes are positive\n  var magForComparison = (neg ? -magnitude : magnitude) - MIN_MAGNITUDE;\n  var magString = padLeft(magForComparison.toString(), '0', MAGNITUDE_DIGITS);\n\n  result += SEP + magString;\n\n  // then sort by the factor\n  var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)\n  /* istanbul ignore next */\n  if (neg) {\n    // for negative reverse ordering\n    factor = 10 - factor;\n  }\n\n  var factorStr = factor.toFixed(20);\n\n  // strip zeros from the end\n  factorStr = factorStr.replace(/\\.?0+$/, '');\n\n  result += SEP + factorStr;\n\n  return result;\n}\n\n// create a comparator based on the sort object\nfunction createFieldSorter(sort) {\n\n  function getFieldValuesAsArray(doc) {\n    return sort.map(function (sorting) {\n      var fieldName = getKey(sorting);\n      var parsedField = parseField(fieldName);\n      var docFieldValue = getFieldFromDoc(doc, parsedField);\n      return docFieldValue;\n    });\n  }\n\n  return function (aRow, bRow) {\n    var aFieldValues = getFieldValuesAsArray(aRow.doc);\n    var bFieldValues = getFieldValuesAsArray(bRow.doc);\n    var collation = collate(aFieldValues, bFieldValues);\n    if (collation !== 0) {\n      return collation;\n    }\n    // this is what mango seems to do\n    return compare$1(aRow.doc._id, bRow.doc._id);\n  };\n}\n\nfunction filterInMemoryFields(rows, requestDef, inMemoryFields) {\n  rows = rows.filter(function (row) {\n    return rowFilter(row.doc, requestDef.selector, inMemoryFields);\n  });\n\n  if (requestDef.sort) {\n    // in-memory sort\n    var fieldSorter = createFieldSorter(requestDef.sort);\n    rows = rows.sort(fieldSorter);\n    if (typeof requestDef.sort[0] !== 'string' && getValue(requestDef.sort[0]) === 'desc') {\n      rows = rows.reverse();\n    }\n  }\n\n  if ('limit' in requestDef || 'skip' in requestDef) {\n    // have to do the limit in-memory\n    var skip = requestDef.skip || 0;\n    var limit = ('limit' in requestDef ? requestDef.limit : rows.length) + skip;\n    rows = rows.slice(skip, limit);\n  }\n  return rows;\n}\n\nfunction rowFilter(doc, selector, inMemoryFields) {\n  return inMemoryFields.every(function (field) {\n    var matcher = selector[field];\n    var parsedField = parseField(field);\n    var docFieldValue = getFieldFromDoc(doc, parsedField);\n    if (isCombinationalField(field)) {\n      return matchCominationalSelector(field, matcher, doc);\n    }\n\n    return matchSelector(matcher, doc, parsedField, docFieldValue);\n  });\n}\n\nfunction matchSelector(matcher, doc, parsedField, docFieldValue) {\n  if (!matcher) {\n    // no filtering necessary; this field is just needed for sorting\n    return true;\n  }\n\n  return Object.keys(matcher).every(function (userOperator) {\n    var userValue = matcher[userOperator];\n    return match(userOperator, doc, userValue, parsedField, docFieldValue);\n  });\n}\n\nfunction matchCominationalSelector(field, matcher, doc) {\n\n  if (field === '$or') {\n    return matcher.some(function (orMatchers) {\n      return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n    });\n  }\n\n  if (field === '$not') {\n    return !rowFilter(doc, matcher, Object.keys(matcher));\n  }\n\n  //`$nor`\n  return !matcher.find(function (orMatchers) {\n    return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n  });\n}\n\nfunction match(userOperator, doc, userValue, parsedField, docFieldValue) {\n  if (!matchers[userOperator]) {\n    throw new Error('unknown operator \"' + userOperator + '\" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, ' + '$nin, $size, $mod, $regex, $elemMatch, $type, $allMatch or $all');\n  }\n  return matchers[userOperator](doc, userValue, parsedField, docFieldValue);\n}\n\nfunction fieldExists(docFieldValue) {\n  return typeof docFieldValue !== 'undefined' && docFieldValue !== null;\n}\n\nfunction fieldIsNotUndefined(docFieldValue) {\n  return typeof docFieldValue !== 'undefined';\n}\n\nfunction modField(docFieldValue, userValue) {\n  var divisor = userValue[0];\n  var mod = userValue[1];\n  if (divisor === 0) {\n    throw new Error('Bad divisor, cannot divide by zero');\n  }\n\n  if (parseInt(divisor, 10) !== divisor) {\n    throw new Error('Divisor is not an integer');\n  }\n\n  if (parseInt(mod, 10) !== mod) {\n    throw new Error('Modulus is not an integer');\n  }\n\n  if (parseInt(docFieldValue, 10) !== docFieldValue) {\n    return false;\n  }\n\n  return docFieldValue % divisor === mod;\n}\n\nfunction arrayContainsValue(docFieldValue, userValue) {\n  return userValue.some(function (val) {\n    if (docFieldValue instanceof Array) {\n      return docFieldValue.indexOf(val) > -1;\n    }\n\n    return docFieldValue === val;\n  });\n}\n\nfunction arrayContainsAllValues(docFieldValue, userValue) {\n  return userValue.every(function (val) {\n    return docFieldValue.indexOf(val) > -1;\n  });\n}\n\nfunction arraySize(docFieldValue, userValue) {\n  return docFieldValue.length === userValue;\n}\n\nfunction regexMatch(docFieldValue, userValue) {\n  var re = new RegExp(userValue);\n\n  return re.test(docFieldValue);\n}\n\nfunction typeMatch(docFieldValue, userValue) {\n\n  switch (userValue) {\n    case 'null':\n      return docFieldValue === null;\n    case 'boolean':\n      return typeof docFieldValue === 'boolean';\n    case 'number':\n      return typeof docFieldValue === 'number';\n    case 'string':\n      return typeof docFieldValue === 'string';\n    case 'array':\n      return docFieldValue instanceof Array;\n    case 'object':\n      return {}.toString.call(docFieldValue) === '[object Object]';\n  }\n\n  throw new Error(userValue + ' not supported as a type.' + 'Please use one of object, string, array, number, boolean or null.');\n}\n\nvar matchers = {\n\n  '$elemMatch': function $elemMatch(doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object') {\n      return docFieldValue.some(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.some(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n\n  '$allMatch': function $allMatch(doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n\n    /* istanbul ignore next */\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object') {\n      return docFieldValue.every(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.every(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n\n  '$eq': function $eq(doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) === 0;\n  },\n\n  '$gte': function $gte(doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) >= 0;\n  },\n\n  '$gt': function $gt(doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) > 0;\n  },\n\n  '$lte': function $lte(doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) <= 0;\n  },\n\n  '$lt': function $lt(doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) < 0;\n  },\n\n  '$exists': function $exists(doc, userValue, parsedField, docFieldValue) {\n    //a field that is null is still considered to exist\n    if (userValue) {\n      return fieldIsNotUndefined(docFieldValue);\n    }\n\n    return !fieldIsNotUndefined(docFieldValue);\n  },\n\n  '$mod': function $mod(doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && modField(docFieldValue, userValue);\n  },\n\n  '$ne': function $ne(doc, userValue, parsedField, docFieldValue) {\n    return userValue.every(function (neValue) {\n      return collate(docFieldValue, neValue) !== 0;\n    });\n  },\n  '$in': function $in(doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$nin': function $nin(doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && !arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$size': function $size(doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arraySize(docFieldValue, userValue);\n  },\n\n  '$all': function $all(doc, userValue, parsedField, docFieldValue) {\n    return Array.isArray(docFieldValue) && arrayContainsAllValues(docFieldValue, userValue);\n  },\n\n  '$regex': function $regex(doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && regexMatch(docFieldValue, userValue);\n  },\n\n  '$type': function $type(doc, userValue, parsedField, docFieldValue) {\n    return typeMatch(docFieldValue, userValue);\n  }\n};\n\n// return true if the given doc matches the supplied selector\nfunction matchesSelector(doc, selector) {\n  /* istanbul ignore if */\n  if (typeof selector !== 'object') {\n    // match the CouchDB error message\n    throw new Error('Selector error: expected a JSON object');\n  }\n\n  selector = massageSelector(selector);\n  var row = {\n    'doc': doc\n  };\n\n  var rowsMatched = filterInMemoryFields([row], { 'selector': selector }, Object.keys(selector));\n  return rowsMatched && rowsMatched.length === 1;\n}\n\nfunction evalFilter(input) {\n  return scopeEval('\"use strict\";\\nreturn ' + input + ';', {});\n}\n\nfunction evalView(input) {\n  var code = ['return function(doc) {', '  \"use strict\";', '  var emitted = false;', '  var emit = function (a, b) {', '    emitted = true;', '  };', '  var view = ' + input + ';', '  view(doc);', '  if (emitted) {', '    return true;', '  }', '};'].join('\\n');\n\n  return scopeEval(code, {});\n}\n\nfunction validate(opts, callback) {\n  if (opts.selector) {\n    if (opts.filter && opts.filter !== '_selector') {\n      var filterName = typeof opts.filter === 'string' ? opts.filter : 'function';\n      return callback(new Error('selector invalid for filter \"' + filterName + '\"'));\n    }\n  }\n  callback();\n}\n\nfunction normalize(opts) {\n  if (opts.view && !opts.filter) {\n    opts.filter = '_view';\n  }\n\n  if (opts.selector && !opts.filter) {\n    opts.filter = '_selector';\n  }\n\n  if (opts.filter && typeof opts.filter === 'string') {\n    if (opts.filter === '_view') {\n      opts.view = normalizeDesignDocFunctionName(opts.view);\n    } else {\n      opts.filter = normalizeDesignDocFunctionName(opts.filter);\n    }\n  }\n}\n\nfunction shouldFilter(changesHandler, opts) {\n  return opts.filter && typeof opts.filter === 'string' && !opts.doc_ids && !isRemote(changesHandler.db);\n}\n\nfunction filter(changesHandler, opts) {\n  var callback = opts.complete;\n  if (opts.filter === '_view') {\n    if (!opts.view || typeof opts.view !== 'string') {\n      var err = createError(BAD_REQUEST, '`view` filter parameter not found or invalid.');\n      return callback(err);\n    }\n    // fetch a view from a design doc, make it behave like a filter\n    var viewName = parseDesignDocFunctionName(opts.view);\n    changesHandler.db.get('_design/' + viewName[0], function (err, ddoc) {\n      /* istanbul ignore if */\n      if (changesHandler.isCancelled) {\n        return callback(null, { status: 'cancelled' });\n      }\n      /* istanbul ignore next */\n      if (err) {\n        return callback(generateErrorFromResponse(err));\n      }\n      var mapFun = ddoc && ddoc.views && ddoc.views[viewName[1]] && ddoc.views[viewName[1]].map;\n      if (!mapFun) {\n        return callback(createError(MISSING_DOC, ddoc.views ? 'missing json key: ' + viewName[1] : 'missing json key: views'));\n      }\n      opts.filter = evalView(mapFun);\n      changesHandler.doChanges(opts);\n    });\n  } else if (opts.selector) {\n    opts.filter = function (doc) {\n      return matchesSelector(doc, opts.selector);\n    };\n    changesHandler.doChanges(opts);\n  } else {\n    // fetch a filter from a design doc\n    var filterName = parseDesignDocFunctionName(opts.filter);\n    changesHandler.db.get('_design/' + filterName[0], function (err, ddoc) {\n      /* istanbul ignore if */\n      if (changesHandler.isCancelled) {\n        return callback(null, { status: 'cancelled' });\n      }\n      /* istanbul ignore next */\n      if (err) {\n        return callback(generateErrorFromResponse(err));\n      }\n      var filterFun = ddoc && ddoc.filters && ddoc.filters[filterName[1]];\n      if (!filterFun) {\n        return callback(createError(MISSING_DOC, ddoc && ddoc.filters ? 'missing json key: ' + filterName[1] : 'missing json key: filters'));\n      }\n      opts.filter = evalFilter(filterFun);\n      changesHandler.doChanges(opts);\n    });\n  }\n}\n\nfunction applyChangesFilterPlugin(PouchDB) {\n  PouchDB._changesFilterPlugin = {\n    validate: validate,\n    normalize: normalize,\n    shouldFilter: shouldFilter,\n    filter: filter\n  };\n}\n\n// TODO: remove from pouchdb-core (breaking)\nPouchDB$5.plugin(debugPouch);\n\n// TODO: remove from pouchdb-core (breaking)\nPouchDB$5.plugin(applyChangesFilterPlugin);\n\nPouchDB$5.version = version;\n\nfunction toObject(array) {\n  return array.reduce(function (obj, item) {\n    obj[item] = true;\n    return obj;\n  }, {});\n}\n// List of top level reserved words for doc\nvar reservedWords = toObject(['_id', '_rev', '_attachments', '_deleted', '_revisions', '_revs_info', '_conflicts', '_deleted_conflicts', '_local_seq', '_rev_tree',\n//replication documents\n'_replication_id', '_replication_state', '_replication_state_time', '_replication_state_reason', '_replication_stats',\n// Specific to Couchbase Sync Gateway\n'_removed']);\n\n// List of reserved words that should end up the document\nvar dataWords = toObject(['_attachments',\n//replication documents\n'_replication_id', '_replication_state', '_replication_state_time', '_replication_state_reason', '_replication_stats']);\n\nfunction parseRevisionInfo(rev$$1) {\n  if (!/^\\d+-./.test(rev$$1)) {\n    return createError(INVALID_REV);\n  }\n  var idx = rev$$1.indexOf('-');\n  var left = rev$$1.substring(0, idx);\n  var right = rev$$1.substring(idx + 1);\n  return {\n    prefix: parseInt(left, 10),\n    id: right\n  };\n}\n\nfunction makeRevTreeFromRevisions(revisions, opts) {\n  var pos = revisions.start - revisions.ids.length + 1;\n\n  var revisionIds = revisions.ids;\n  var ids = [revisionIds[0], opts, []];\n\n  for (var i = 1, len = revisionIds.length; i < len; i++) {\n    ids = [revisionIds[i], { status: 'missing' }, [ids]];\n  }\n\n  return [{\n    pos: pos,\n    ids: ids\n  }];\n}\n\n// Preprocess documents, parse their revisions, assign an id and a\n// revision for new writes that are missing them, etc\nfunction parseDoc(doc, newEdits) {\n\n  var nRevNum;\n  var newRevId;\n  var revInfo;\n  var opts = { status: 'available' };\n  if (doc._deleted) {\n    opts.deleted = true;\n  }\n\n  if (newEdits) {\n    if (!doc._id) {\n      doc._id = uuid();\n    }\n    newRevId = rev();\n    if (doc._rev) {\n      revInfo = parseRevisionInfo(doc._rev);\n      if (revInfo.error) {\n        return revInfo;\n      }\n      doc._rev_tree = [{\n        pos: revInfo.prefix,\n        ids: [revInfo.id, { status: 'missing' }, [[newRevId, opts, []]]]\n      }];\n      nRevNum = revInfo.prefix + 1;\n    } else {\n      doc._rev_tree = [{\n        pos: 1,\n        ids: [newRevId, opts, []]\n      }];\n      nRevNum = 1;\n    }\n  } else {\n    if (doc._revisions) {\n      doc._rev_tree = makeRevTreeFromRevisions(doc._revisions, opts);\n      nRevNum = doc._revisions.start;\n      newRevId = doc._revisions.ids[0];\n    }\n    if (!doc._rev_tree) {\n      revInfo = parseRevisionInfo(doc._rev);\n      if (revInfo.error) {\n        return revInfo;\n      }\n      nRevNum = revInfo.prefix;\n      newRevId = revInfo.id;\n      doc._rev_tree = [{\n        pos: nRevNum,\n        ids: [newRevId, opts, []]\n      }];\n    }\n  }\n\n  invalidIdError(doc._id);\n\n  doc._rev = nRevNum + '-' + newRevId;\n\n  var result = { metadata: {}, data: {} };\n  for (var key in doc) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(doc, key)) {\n      var specialKey = key[0] === '_';\n      if (specialKey && !reservedWords[key]) {\n        var error = createError(DOC_VALIDATION, key);\n        error.message = DOC_VALIDATION.message + ': ' + key;\n        throw error;\n      } else if (specialKey && !dataWords[key]) {\n        result.metadata[key.slice(1)] = doc[key];\n      } else {\n        result.data[key] = doc[key];\n      }\n    }\n  }\n  return result;\n}\n\nvar thisAtob = function thisAtob(str) {\n  return atob(str);\n};\n\nvar thisBtoa = function thisBtoa(str) {\n  return btoa(str);\n};\n\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor (e.g.\n// old QtWebKit versions, Android < 4.4).\nfunction createBlob(parts, properties) {\n  /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n  parts = parts || [];\n  properties = properties || {};\n  try {\n    return new Blob(parts, properties);\n  } catch (e) {\n    if (e.name !== \"TypeError\") {\n      throw e;\n    }\n    var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;\n    var builder = new Builder();\n    for (var i = 0; i < parts.length; i += 1) {\n      builder.append(parts[i]);\n    }\n    return builder.getBlob(properties.type);\n  }\n}\n\n// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n// encode-decode-image-with-base64-breaks-image (2013-04-21)\nfunction binaryStringToArrayBuffer(bin) {\n  var length = bin.length;\n  var buf = new ArrayBuffer(length);\n  var arr = new Uint8Array(buf);\n  for (var i = 0; i < length; i++) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return buf;\n}\n\nfunction binStringToBluffer(binString, type) {\n  return createBlob([binaryStringToArrayBuffer(binString)], { type: type });\n}\n\nfunction b64ToBluffer(b64, type) {\n  return binStringToBluffer(thisAtob(b64), type);\n}\n\n//Can't find original post, but this is close\n//http://stackoverflow.com/questions/6965107/ (continues on next line)\n//converting-between-strings-and-arraybuffers\nfunction arrayBufferToBinaryString(buffer) {\n  var binary = '';\n  var bytes = new Uint8Array(buffer);\n  var length = bytes.byteLength;\n  for (var i = 0; i < length; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return binary;\n}\n\n// shim for browsers that don't support it\nfunction readAsBinaryString(blob, callback) {\n  if (typeof FileReader === 'undefined') {\n    // fix for Firefox in a web worker\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n    return callback(arrayBufferToBinaryString(new FileReaderSync().readAsArrayBuffer(blob)));\n  }\n\n  var reader = new FileReader();\n  var hasBinaryString = typeof reader.readAsBinaryString === 'function';\n  reader.onloadend = function (e) {\n    var result = e.target.result || '';\n    if (hasBinaryString) {\n      return callback(result);\n    }\n    callback(arrayBufferToBinaryString(result));\n  };\n  if (hasBinaryString) {\n    reader.readAsBinaryString(blob);\n  } else {\n    reader.readAsArrayBuffer(blob);\n  }\n}\n\nfunction blobToBinaryString(blobOrBuffer, callback) {\n  readAsBinaryString(blobOrBuffer, function (bin) {\n    callback(bin);\n  });\n}\n\nfunction blobToBase64(blobOrBuffer, callback) {\n  blobToBinaryString(blobOrBuffer, function (base64) {\n    callback(thisBtoa(base64));\n  });\n}\n\n// simplified API. universal browser support is assumed\nfunction readAsArrayBuffer(blob, callback) {\n  if (typeof FileReader === 'undefined') {\n    // fix for Firefox in a web worker:\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n    return callback(new FileReaderSync().readAsArrayBuffer(blob));\n  }\n\n  var reader = new FileReader();\n  reader.onloadend = function (e) {\n    var result = e.target.result || new ArrayBuffer(0);\n    callback(result);\n  };\n  reader.readAsArrayBuffer(blob);\n}\n\n// this is not used in the browser\n\nvar setImmediateShim = global.setImmediate || global.setTimeout;\nvar MD5_CHUNK_SIZE = 32768;\n\nfunction rawToBase64(raw) {\n  return thisBtoa(raw);\n}\n\nfunction sliceBlob(blob, start, end) {\n  if (blob.webkitSlice) {\n    return blob.webkitSlice(start, end);\n  }\n  return blob.slice(start, end);\n}\n\nfunction appendBlob(buffer, blob, start, end, callback) {\n  if (start > 0 || end < blob.size) {\n    // only slice blob if we really need to\n    blob = sliceBlob(blob, start, end);\n  }\n  readAsArrayBuffer(blob, function (arrayBuffer) {\n    buffer.append(arrayBuffer);\n    callback();\n  });\n}\n\nfunction appendString(buffer, string, start, end, callback) {\n  if (start > 0 || end < string.length) {\n    // only create a substring if we really need to\n    string = string.substring(start, end);\n  }\n  buffer.appendBinary(string);\n  callback();\n}\n\nfunction binaryMd5(data, callback) {\n  var inputIsString = typeof data === 'string';\n  var len = inputIsString ? data.length : data.size;\n  var chunkSize = Math.min(MD5_CHUNK_SIZE, len);\n  var chunks = Math.ceil(len / chunkSize);\n  var currentChunk = 0;\n  var buffer = inputIsString ? new __WEBPACK_IMPORTED_MODULE_7_spark_md5___default.a() : new __WEBPACK_IMPORTED_MODULE_7_spark_md5___default.a.ArrayBuffer();\n\n  var append = inputIsString ? appendString : appendBlob;\n\n  function next() {\n    setImmediateShim(loadNextChunk);\n  }\n\n  function done() {\n    var raw = buffer.end(true);\n    var base64 = rawToBase64(raw);\n    callback(base64);\n    buffer.destroy();\n  }\n\n  function loadNextChunk() {\n    var start = currentChunk * chunkSize;\n    var end = start + chunkSize;\n    currentChunk++;\n    if (currentChunk < chunks) {\n      append(buffer, data, start, end, next);\n    } else {\n      append(buffer, data, start, end, done);\n    }\n  }\n  loadNextChunk();\n}\n\nfunction stringMd5(string) {\n  return __WEBPACK_IMPORTED_MODULE_7_spark_md5___default.a.hash(string);\n}\n\nfunction parseBase64(data) {\n  try {\n    return thisAtob(data);\n  } catch (e) {\n    var err = createError(BAD_ARG, 'Attachment is not a valid base64 string');\n    return { error: err };\n  }\n}\n\nfunction preprocessString(att, blobType, callback) {\n  var asBinary = parseBase64(att.data);\n  if (asBinary.error) {\n    return callback(asBinary.error);\n  }\n\n  att.length = asBinary.length;\n  if (blobType === 'blob') {\n    att.data = binStringToBluffer(asBinary, att.content_type);\n  } else if (blobType === 'base64') {\n    att.data = thisBtoa(asBinary);\n  } else {\n    // binary\n    att.data = asBinary;\n  }\n  binaryMd5(asBinary, function (result) {\n    att.digest = 'md5-' + result;\n    callback();\n  });\n}\n\nfunction preprocessBlob(att, blobType, callback) {\n  binaryMd5(att.data, function (md5) {\n    att.digest = 'md5-' + md5;\n    // size is for blobs (browser), length is for buffers (node)\n    att.length = att.data.size || att.data.length || 0;\n    if (blobType === 'binary') {\n      blobToBinaryString(att.data, function (binString) {\n        att.data = binString;\n        callback();\n      });\n    } else if (blobType === 'base64') {\n      blobToBase64(att.data, function (b64) {\n        att.data = b64;\n        callback();\n      });\n    } else {\n      callback();\n    }\n  });\n}\n\nfunction preprocessAttachment(att, blobType, callback) {\n  if (att.stub) {\n    return callback();\n  }\n  if (typeof att.data === 'string') {\n    // input is a base64 string\n    preprocessString(att, blobType, callback);\n  } else {\n    // input is a blob\n    preprocessBlob(att, blobType, callback);\n  }\n}\n\nfunction preprocessAttachments(docInfos, blobType, callback) {\n\n  if (!docInfos.length) {\n    return callback();\n  }\n\n  var docv = 0;\n  var overallErr;\n\n  docInfos.forEach(function (docInfo) {\n    var attachments = docInfo.data && docInfo.data._attachments ? Object.keys(docInfo.data._attachments) : [];\n    var recv = 0;\n\n    if (!attachments.length) {\n      return done();\n    }\n\n    function processedAttachment(err) {\n      overallErr = err;\n      recv++;\n      if (recv === attachments.length) {\n        done();\n      }\n    }\n\n    for (var key in docInfo.data._attachments) {\n      if (docInfo.data._attachments.hasOwnProperty(key)) {\n        preprocessAttachment(docInfo.data._attachments[key], blobType, processedAttachment);\n      }\n    }\n  });\n\n  function done() {\n    docv++;\n    if (docInfos.length === docv) {\n      if (overallErr) {\n        callback(overallErr);\n      } else {\n        callback();\n      }\n    }\n  }\n}\n\nfunction updateDoc(revLimit, prev, docInfo, results, i, cb, writeDoc, newEdits) {\n\n  if (revExists(prev.rev_tree, docInfo.metadata.rev)) {\n    results[i] = docInfo;\n    return cb();\n  }\n\n  // sometimes this is pre-calculated. historically not always\n  var previousWinningRev = prev.winningRev || winningRev(prev);\n  var previouslyDeleted = 'deleted' in prev ? prev.deleted : isDeleted(prev, previousWinningRev);\n  var deleted = 'deleted' in docInfo.metadata ? docInfo.metadata.deleted : isDeleted(docInfo.metadata);\n  var isRoot = /^1-/.test(docInfo.metadata.rev);\n\n  if (previouslyDeleted && !deleted && newEdits && isRoot) {\n    var newDoc = docInfo.data;\n    newDoc._rev = previousWinningRev;\n    newDoc._id = docInfo.metadata.id;\n    docInfo = parseDoc(newDoc, newEdits);\n  }\n\n  var merged = merge(prev.rev_tree, docInfo.metadata.rev_tree[0], revLimit);\n\n  var inConflict = newEdits && (previouslyDeleted && deleted && merged.conflicts !== 'new_leaf' || !previouslyDeleted && merged.conflicts !== 'new_leaf' || previouslyDeleted && !deleted && merged.conflicts === 'new_branch');\n\n  if (inConflict) {\n    var err = createError(REV_CONFLICT);\n    results[i] = err;\n    return cb();\n  }\n\n  var newRev = docInfo.metadata.rev;\n  docInfo.metadata.rev_tree = merged.tree;\n  docInfo.stemmedRevs = merged.stemmedRevs || [];\n  /* istanbul ignore else */\n  if (prev.rev_map) {\n    docInfo.metadata.rev_map = prev.rev_map; // used only by leveldb\n  }\n\n  // recalculate\n  var winningRev$$1 = winningRev(docInfo.metadata);\n  var winningRevIsDeleted = isDeleted(docInfo.metadata, winningRev$$1);\n\n  // calculate the total number of documents that were added/removed,\n  // from the perspective of total_rows/doc_count\n  var delta = previouslyDeleted === winningRevIsDeleted ? 0 : previouslyDeleted < winningRevIsDeleted ? -1 : 1;\n\n  var newRevIsDeleted;\n  if (newRev === winningRev$$1) {\n    // if the new rev is the same as the winning rev, we can reuse that value\n    newRevIsDeleted = winningRevIsDeleted;\n  } else {\n    // if they're not the same, then we need to recalculate\n    newRevIsDeleted = isDeleted(docInfo.metadata, newRev);\n  }\n\n  writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted, true, delta, i, cb);\n}\n\nfunction rootIsMissing(docInfo) {\n  return docInfo.metadata.rev_tree[0].ids[1].status === 'missing';\n}\n\nfunction processDocs(revLimit, docInfos, api, fetchedDocs, tx, results, writeDoc, opts, overallCallback) {\n\n  // Default to 1000 locally\n  revLimit = revLimit || 1000;\n\n  function insertDoc(docInfo, resultsIdx, callback) {\n    // Cant insert new deleted documents\n    var winningRev$$1 = winningRev(docInfo.metadata);\n    var deleted = isDeleted(docInfo.metadata, winningRev$$1);\n    if ('was_delete' in opts && deleted) {\n      results[resultsIdx] = createError(MISSING_DOC, 'deleted');\n      return callback();\n    }\n\n    // 4712 - detect whether a new document was inserted with a _rev\n    var inConflict = newEdits && rootIsMissing(docInfo);\n\n    if (inConflict) {\n      var err = createError(REV_CONFLICT);\n      results[resultsIdx] = err;\n      return callback();\n    }\n\n    var delta = deleted ? 0 : 1;\n\n    writeDoc(docInfo, winningRev$$1, deleted, deleted, false, delta, resultsIdx, callback);\n  }\n\n  var newEdits = opts.new_edits;\n  var idsToDocs = new ExportedMap();\n\n  var docsDone = 0;\n  var docsToDo = docInfos.length;\n\n  function checkAllDocsDone() {\n    if (++docsDone === docsToDo && overallCallback) {\n      overallCallback();\n    }\n  }\n\n  docInfos.forEach(function (currentDoc, resultsIdx) {\n\n    if (currentDoc._id && isLocalId(currentDoc._id)) {\n      var fun = currentDoc._deleted ? '_removeLocal' : '_putLocal';\n      api[fun](currentDoc, { ctx: tx }, function (err, res) {\n        results[resultsIdx] = err || res;\n        checkAllDocsDone();\n      });\n      return;\n    }\n\n    var id = currentDoc.metadata.id;\n    if (idsToDocs.has(id)) {\n      docsToDo--; // duplicate\n      idsToDocs.get(id).push([currentDoc, resultsIdx]);\n    } else {\n      idsToDocs.set(id, [[currentDoc, resultsIdx]]);\n    }\n  });\n\n  // in the case of new_edits, the user can provide multiple docs\n  // with the same id. these need to be processed sequentially\n  idsToDocs.forEach(function (docs, id) {\n    var numDone = 0;\n\n    function docWritten() {\n      if (++numDone < docs.length) {\n        nextDoc();\n      } else {\n        checkAllDocsDone();\n      }\n    }\n    function nextDoc() {\n      var value = docs[numDone];\n      var currentDoc = value[0];\n      var resultsIdx = value[1];\n\n      if (fetchedDocs.has(id)) {\n        updateDoc(revLimit, fetchedDocs.get(id), currentDoc, results, resultsIdx, docWritten, writeDoc, newEdits);\n      } else {\n        // Ensure stemming applies to new writes as well\n        var merged = merge([], currentDoc.metadata.rev_tree[0], revLimit);\n        currentDoc.metadata.rev_tree = merged.tree;\n        currentDoc.stemmedRevs = merged.stemmedRevs || [];\n        insertDoc(currentDoc, resultsIdx, docWritten);\n      }\n    }\n    nextDoc();\n  });\n}\n\n// IndexedDB requires a versioned database structure, so we use the\n// version here to manage migrations.\nvar ADAPTER_VERSION = 5;\n\n// The object stores created for each database\n// DOC_STORE stores the document meta data, its revision history and state\n// Keyed by document id\nvar DOC_STORE = 'document-store';\n// BY_SEQ_STORE stores a particular version of a document, keyed by its\n// sequence id\nvar BY_SEQ_STORE = 'by-sequence';\n// Where we store attachments\nvar ATTACH_STORE = 'attach-store';\n// Where we store many-to-many relations\n// between attachment digests and seqs\nvar ATTACH_AND_SEQ_STORE = 'attach-seq-store';\n\n// Where we store database-wide meta data in a single record\n// keyed by id: META_STORE\nvar META_STORE = 'meta-store';\n// Where we store local documents\nvar LOCAL_STORE = 'local-store';\n// Where we detect blob support\nvar DETECT_BLOB_SUPPORT_STORE = 'detect-blob-support';\n\nfunction safeJsonParse(str) {\n  // This try/catch guards against stack overflow errors.\n  // JSON.parse() is faster than vuvuzela.parse() but vuvuzela\n  // cannot overflow.\n  try {\n    return JSON.parse(str);\n  } catch (e) {\n    /* istanbul ignore next */\n    return __WEBPACK_IMPORTED_MODULE_8_vuvuzela___default.a.parse(str);\n  }\n}\n\nfunction safeJsonStringify(json) {\n  try {\n    return JSON.stringify(json);\n  } catch (e) {\n    /* istanbul ignore next */\n    return __WEBPACK_IMPORTED_MODULE_8_vuvuzela___default.a.stringify(json);\n  }\n}\n\nfunction idbError(callback) {\n  return function (evt) {\n    var message = 'unknown_error';\n    if (evt.target && evt.target.error) {\n      message = evt.target.error.name || evt.target.error.message;\n    }\n    callback(createError(IDB_ERROR, message, evt.type));\n  };\n}\n\n// Unfortunately, the metadata has to be stringified\n// when it is put into the database, because otherwise\n// IndexedDB can throw errors for deeply-nested objects.\n// Originally we just used JSON.parse/JSON.stringify; now\n// we use this custom vuvuzela library that avoids recursion.\n// If we could do it all over again, we'd probably use a\n// format for the revision trees other than JSON.\nfunction encodeMetadata(metadata, winningRev, deleted) {\n  return {\n    data: safeJsonStringify(metadata),\n    winningRev: winningRev,\n    deletedOrLocal: deleted ? '1' : '0',\n    seq: metadata.seq, // highest seq for this doc\n    id: metadata.id\n  };\n}\n\nfunction decodeMetadata(storedObject) {\n  if (!storedObject) {\n    return null;\n  }\n  var metadata = safeJsonParse(storedObject.data);\n  metadata.winningRev = storedObject.winningRev;\n  metadata.deleted = storedObject.deletedOrLocal === '1';\n  metadata.seq = storedObject.seq;\n  return metadata;\n}\n\n// read the doc back out from the database. we don't store the\n// _id or _rev because we already have _doc_id_rev.\nfunction decodeDoc(doc) {\n  if (!doc) {\n    return doc;\n  }\n  var idx = doc._doc_id_rev.lastIndexOf(':');\n  doc._id = doc._doc_id_rev.substring(0, idx - 1);\n  doc._rev = doc._doc_id_rev.substring(idx + 1);\n  delete doc._doc_id_rev;\n  return doc;\n}\n\n// Read a blob from the database, encoding as necessary\n// and translating from base64 if the IDB doesn't support\n// native Blobs\nfunction readBlobData(body, type, asBlob, callback) {\n  if (asBlob) {\n    if (!body) {\n      callback(createBlob([''], { type: type }));\n    } else if (typeof body !== 'string') {\n      // we have blob support\n      callback(body);\n    } else {\n      // no blob support\n      callback(b64ToBluffer(body, type));\n    }\n  } else {\n    // as base64 string\n    if (!body) {\n      callback('');\n    } else if (typeof body !== 'string') {\n      // we have blob support\n      readAsBinaryString(body, function (binary) {\n        callback(thisBtoa(binary));\n      });\n    } else {\n      // no blob support\n      callback(body);\n    }\n  }\n}\n\nfunction fetchAttachmentsIfNecessary(doc, opts, txn, cb) {\n  var attachments = Object.keys(doc._attachments || {});\n  if (!attachments.length) {\n    return cb && cb();\n  }\n  var numDone = 0;\n\n  function checkDone() {\n    if (++numDone === attachments.length && cb) {\n      cb();\n    }\n  }\n\n  function fetchAttachment(doc, att) {\n    var attObj = doc._attachments[att];\n    var digest = attObj.digest;\n    var req = txn.objectStore(ATTACH_STORE).get(digest);\n    req.onsuccess = function (e) {\n      attObj.body = e.target.result.body;\n      checkDone();\n    };\n  }\n\n  attachments.forEach(function (att) {\n    if (opts.attachments && opts.include_docs) {\n      fetchAttachment(doc, att);\n    } else {\n      doc._attachments[att].stub = true;\n      checkDone();\n    }\n  });\n}\n\n// IDB-specific postprocessing necessary because\n// we don't know whether we stored a true Blob or\n// a base64-encoded string, and if it's a Blob it\n// needs to be read outside of the transaction context\nfunction postProcessAttachments(results, asBlob) {\n  return PouchPromise$1.all(results.map(function (row) {\n    if (row.doc && row.doc._attachments) {\n      var attNames = Object.keys(row.doc._attachments);\n      return PouchPromise$1.all(attNames.map(function (att) {\n        var attObj = row.doc._attachments[att];\n        if (!('body' in attObj)) {\n          // already processed\n          return;\n        }\n        var body = attObj.body;\n        var type = attObj.content_type;\n        return new PouchPromise$1(function (resolve) {\n          readBlobData(body, type, asBlob, function (data) {\n            row.doc._attachments[att] = $inject_Object_assign(pick(attObj, ['digest', 'content_type']), { data: data });\n            resolve();\n          });\n        });\n      }));\n    }\n  }));\n}\n\nfunction compactRevs(revs, docId, txn) {\n\n  var possiblyOrphanedDigests = [];\n  var seqStore = txn.objectStore(BY_SEQ_STORE);\n  var attStore = txn.objectStore(ATTACH_STORE);\n  var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n  var count = revs.length;\n\n  function checkDone() {\n    count--;\n    if (!count) {\n      // done processing all revs\n      deleteOrphanedAttachments();\n    }\n  }\n\n  function deleteOrphanedAttachments() {\n    if (!possiblyOrphanedDigests.length) {\n      return;\n    }\n    possiblyOrphanedDigests.forEach(function (digest) {\n      var countReq = attAndSeqStore.index('digestSeq').count(IDBKeyRange.bound(digest + '::', digest + '::\\uFFFF', false, false));\n      countReq.onsuccess = function (e) {\n        var count = e.target.result;\n        if (!count) {\n          // orphaned\n          attStore.delete(digest);\n        }\n      };\n    });\n  }\n\n  revs.forEach(function (rev$$1) {\n    var index = seqStore.index('_doc_id_rev');\n    var key = docId + \"::\" + rev$$1;\n    index.getKey(key).onsuccess = function (e) {\n      var seq = e.target.result;\n      if (typeof seq !== 'number') {\n        return checkDone();\n      }\n      seqStore.delete(seq);\n\n      var cursor = attAndSeqStore.index('seq').openCursor(IDBKeyRange.only(seq));\n\n      cursor.onsuccess = function (event) {\n        var cursor = event.target.result;\n        if (cursor) {\n          var digest = cursor.value.digestSeq.split('::')[0];\n          possiblyOrphanedDigests.push(digest);\n          attAndSeqStore.delete(cursor.primaryKey);\n          cursor.continue();\n        } else {\n          // done\n          checkDone();\n        }\n      };\n    };\n  });\n}\n\nfunction openTransactionSafely(idb, stores, mode) {\n  try {\n    return {\n      txn: idb.transaction(stores, mode)\n    };\n  } catch (err) {\n    return {\n      error: err\n    };\n  }\n}\n\nvar changesHandler = new Changes();\n\nfunction idbBulkDocs(dbOpts, req, opts, api, idb, callback) {\n  var docInfos = req.docs;\n  var txn;\n  var docStore;\n  var bySeqStore;\n  var attachStore;\n  var attachAndSeqStore;\n  var metaStore;\n  var docInfoError;\n  var metaDoc;\n\n  for (var i = 0, len = docInfos.length; i < len; i++) {\n    var doc = docInfos[i];\n    if (doc._id && isLocalId(doc._id)) {\n      continue;\n    }\n    doc = docInfos[i] = parseDoc(doc, opts.new_edits);\n    if (doc.error && !docInfoError) {\n      docInfoError = doc;\n    }\n  }\n\n  if (docInfoError) {\n    return callback(docInfoError);\n  }\n\n  var allDocsProcessed = false;\n  var docCountDelta = 0;\n  var results = new Array(docInfos.length);\n  var fetchedDocs = new ExportedMap();\n  var preconditionErrored = false;\n  var blobType = api._meta.blobSupport ? 'blob' : 'base64';\n\n  preprocessAttachments(docInfos, blobType, function (err) {\n    if (err) {\n      return callback(err);\n    }\n    startTransaction();\n  });\n\n  function startTransaction() {\n\n    var stores = [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE, LOCAL_STORE, ATTACH_AND_SEQ_STORE, META_STORE];\n    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    txn = txnResult.txn;\n    txn.onabort = idbError(callback);\n    txn.ontimeout = idbError(callback);\n    txn.oncomplete = complete;\n    docStore = txn.objectStore(DOC_STORE);\n    bySeqStore = txn.objectStore(BY_SEQ_STORE);\n    attachStore = txn.objectStore(ATTACH_STORE);\n    attachAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n    metaStore = txn.objectStore(META_STORE);\n\n    metaStore.get(META_STORE).onsuccess = function (e) {\n      metaDoc = e.target.result;\n      updateDocCountIfReady();\n    };\n\n    verifyAttachments(function (err) {\n      if (err) {\n        preconditionErrored = true;\n        return callback(err);\n      }\n      fetchExistingDocs();\n    });\n  }\n\n  function onAllDocsProcessed() {\n    allDocsProcessed = true;\n    updateDocCountIfReady();\n  }\n\n  function idbProcessDocs() {\n    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs, txn, results, writeDoc, opts, onAllDocsProcessed);\n  }\n\n  function updateDocCountIfReady() {\n    if (!metaDoc || !allDocsProcessed) {\n      return;\n    }\n    // caching the docCount saves a lot of time in allDocs() and\n    // info(), which is why we go to all the trouble of doing this\n    metaDoc.docCount += docCountDelta;\n    metaStore.put(metaDoc);\n  }\n\n  function fetchExistingDocs() {\n\n    if (!docInfos.length) {\n      return;\n    }\n\n    var numFetched = 0;\n\n    function checkDone() {\n      if (++numFetched === docInfos.length) {\n        idbProcessDocs();\n      }\n    }\n\n    function readMetadata(event) {\n      var metadata = decodeMetadata(event.target.result);\n\n      if (metadata) {\n        fetchedDocs.set(metadata.id, metadata);\n      }\n      checkDone();\n    }\n\n    for (var i = 0, len = docInfos.length; i < len; i++) {\n      var docInfo = docInfos[i];\n      if (docInfo._id && isLocalId(docInfo._id)) {\n        checkDone(); // skip local docs\n        continue;\n      }\n      var req = docStore.get(docInfo.metadata.id);\n      req.onsuccess = readMetadata;\n    }\n  }\n\n  function complete() {\n    if (preconditionErrored) {\n      return;\n    }\n\n    changesHandler.notify(api._meta.name);\n    callback(null, results);\n  }\n\n  function verifyAttachment(digest, callback) {\n\n    var req = attachStore.get(digest);\n    req.onsuccess = function (e) {\n      if (!e.target.result) {\n        var err = createError(MISSING_STUB, 'unknown stub attachment with digest ' + digest);\n        err.status = 412;\n        callback(err);\n      } else {\n        callback();\n      }\n    };\n  }\n\n  function verifyAttachments(finish) {\n\n    var digests = [];\n    docInfos.forEach(function (docInfo) {\n      if (docInfo.data && docInfo.data._attachments) {\n        Object.keys(docInfo.data._attachments).forEach(function (filename) {\n          var att = docInfo.data._attachments[filename];\n          if (att.stub) {\n            digests.push(att.digest);\n          }\n        });\n      }\n    });\n    if (!digests.length) {\n      return finish();\n    }\n    var numDone = 0;\n    var err;\n\n    function checkDone() {\n      if (++numDone === digests.length) {\n        finish(err);\n      }\n    }\n    digests.forEach(function (digest) {\n      verifyAttachment(digest, function (attErr) {\n        if (attErr && !err) {\n          err = attErr;\n        }\n        checkDone();\n      });\n    });\n  }\n\n  function writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted, isUpdate, delta, resultsIdx, callback) {\n\n    docInfo.metadata.winningRev = winningRev$$1;\n    docInfo.metadata.deleted = winningRevIsDeleted;\n\n    var doc = docInfo.data;\n    doc._id = docInfo.metadata.id;\n    doc._rev = docInfo.metadata.rev;\n\n    if (newRevIsDeleted) {\n      doc._deleted = true;\n    }\n\n    var hasAttachments = doc._attachments && Object.keys(doc._attachments).length;\n    if (hasAttachments) {\n      return writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted, isUpdate, resultsIdx, callback);\n    }\n\n    docCountDelta += delta;\n    updateDocCountIfReady();\n\n    finishDoc(docInfo, winningRev$$1, winningRevIsDeleted, isUpdate, resultsIdx, callback);\n  }\n\n  function finishDoc(docInfo, winningRev$$1, winningRevIsDeleted, isUpdate, resultsIdx, callback) {\n\n    var doc = docInfo.data;\n    var metadata = docInfo.metadata;\n\n    doc._doc_id_rev = metadata.id + '::' + metadata.rev;\n    delete doc._id;\n    delete doc._rev;\n\n    function afterPutDoc(e) {\n      var revsToDelete = docInfo.stemmedRevs || [];\n\n      if (isUpdate && api.auto_compaction) {\n        revsToDelete = revsToDelete.concat(compactTree(docInfo.metadata));\n      }\n\n      if (revsToDelete && revsToDelete.length) {\n        compactRevs(revsToDelete, docInfo.metadata.id, txn);\n      }\n\n      metadata.seq = e.target.result;\n      // Current _rev is calculated from _rev_tree on read\n      // delete metadata.rev;\n      var metadataToStore = encodeMetadata(metadata, winningRev$$1, winningRevIsDeleted);\n      var metaDataReq = docStore.put(metadataToStore);\n      metaDataReq.onsuccess = afterPutMetadata;\n    }\n\n    function afterPutDocError(e) {\n      // ConstraintError, need to update, not put (see #1638 for details)\n      e.preventDefault(); // avoid transaction abort\n      e.stopPropagation(); // avoid transaction onerror\n      var index = bySeqStore.index('_doc_id_rev');\n      var getKeyReq = index.getKey(doc._doc_id_rev);\n      getKeyReq.onsuccess = function (e) {\n        var putReq = bySeqStore.put(doc, e.target.result);\n        putReq.onsuccess = afterPutDoc;\n      };\n    }\n\n    function afterPutMetadata() {\n      results[resultsIdx] = {\n        ok: true,\n        id: metadata.id,\n        rev: metadata.rev\n      };\n      fetchedDocs.set(docInfo.metadata.id, docInfo.metadata);\n      insertAttachmentMappings(docInfo, metadata.seq, callback);\n    }\n\n    var putReq = bySeqStore.put(doc);\n\n    putReq.onsuccess = afterPutDoc;\n    putReq.onerror = afterPutDocError;\n  }\n\n  function writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted, isUpdate, resultsIdx, callback) {\n\n    var doc = docInfo.data;\n\n    var numDone = 0;\n    var attachments = Object.keys(doc._attachments);\n\n    function collectResults() {\n      if (numDone === attachments.length) {\n        finishDoc(docInfo, winningRev$$1, winningRevIsDeleted, isUpdate, resultsIdx, callback);\n      }\n    }\n\n    function attachmentSaved() {\n      numDone++;\n      collectResults();\n    }\n\n    attachments.forEach(function (key) {\n      var att = docInfo.data._attachments[key];\n      if (!att.stub) {\n        var data = att.data;\n        delete att.data;\n        att.revpos = parseInt(winningRev$$1, 10);\n        var digest = att.digest;\n        saveAttachment(digest, data, attachmentSaved);\n      } else {\n        numDone++;\n        collectResults();\n      }\n    });\n  }\n\n  // map seqs to attachment digests, which\n  // we will need later during compaction\n  function insertAttachmentMappings(docInfo, seq, callback) {\n\n    var attsAdded = 0;\n    var attsToAdd = Object.keys(docInfo.data._attachments || {});\n\n    if (!attsToAdd.length) {\n      return callback();\n    }\n\n    function checkDone() {\n      if (++attsAdded === attsToAdd.length) {\n        callback();\n      }\n    }\n\n    function add(att) {\n      var digest = docInfo.data._attachments[att].digest;\n      var req = attachAndSeqStore.put({\n        seq: seq,\n        digestSeq: digest + '::' + seq\n      });\n\n      req.onsuccess = checkDone;\n      req.onerror = function (e) {\n        // this callback is for a constaint error, which we ignore\n        // because this docid/rev has already been associated with\n        // the digest (e.g. when new_edits == false)\n        e.preventDefault(); // avoid transaction abort\n        e.stopPropagation(); // avoid transaction onerror\n        checkDone();\n      };\n    }\n    for (var i = 0; i < attsToAdd.length; i++) {\n      add(attsToAdd[i]); // do in parallel\n    }\n  }\n\n  function saveAttachment(digest, data, callback) {\n\n    var getKeyReq = attachStore.count(digest);\n    getKeyReq.onsuccess = function (e) {\n      var count = e.target.result;\n      if (count) {\n        return callback(); // already exists\n      }\n      var newAtt = {\n        digest: digest,\n        body: data\n      };\n      var putReq = attachStore.put(newAtt);\n      putReq.onsuccess = callback;\n    };\n  }\n}\n\n// Abstraction over IDBCursor and getAll()/getAllKeys() that allows us to batch our operations\n// while falling back to a normal IDBCursor operation on browsers that don't support getAll() or\n// getAllKeys(). This allows for a much faster implementation than just straight-up cursors, because\n// we're not processing each document one-at-a-time.\nfunction runBatchedCursor(objectStore, keyRange, descending, batchSize, onBatch) {\n\n  // Bail out of getAll()/getAllKeys() in the following cases:\n  // 1) either method is unsupported - we need both\n  // 2) batchSize is 1 (might as well use IDBCursor), or batchSize is -1 (i.e. batchSize unlimited,\n  //    not really clear the user wants a batched approach where the entire DB is read into memory,\n  //    perhaps they are filtering on a per-doc basis)\n  // 3) descending – no real way to do this via getAll()/getAllKeys()\n\n  var useGetAll = typeof objectStore.getAll === 'function' && typeof objectStore.getAllKeys === 'function' && batchSize > 1 && !descending;\n\n  var keysBatch;\n  var valuesBatch;\n  var pseudoCursor;\n\n  function onGetAll(e) {\n    valuesBatch = e.target.result;\n    if (keysBatch) {\n      onBatch(keysBatch, valuesBatch, pseudoCursor);\n    }\n  }\n\n  function onGetAllKeys(e) {\n    keysBatch = e.target.result;\n    if (valuesBatch) {\n      onBatch(keysBatch, valuesBatch, pseudoCursor);\n    }\n  }\n\n  function continuePseudoCursor() {\n    if (!keysBatch.length) {\n      // no more results\n      return onBatch();\n    }\n    // fetch next batch, exclusive start\n    var lastKey = keysBatch[keysBatch.length - 1];\n    var newKeyRange;\n    if (keyRange && keyRange.upper) {\n      try {\n        newKeyRange = IDBKeyRange.bound(lastKey, keyRange.upper, true, keyRange.upperOpen);\n      } catch (e) {\n        if (e.name === \"DataError\" && e.code === 0) {\n          return onBatch(); // we're done, startkey and endkey are equal\n        }\n      }\n    } else {\n      newKeyRange = IDBKeyRange.lowerBound(lastKey, true);\n    }\n    keyRange = newKeyRange;\n    keysBatch = null;\n    valuesBatch = null;\n    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;\n    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;\n  }\n\n  function onCursor(e) {\n    var cursor = e.target.result;\n    if (!cursor) {\n      // done\n      return onBatch();\n    }\n    // regular IDBCursor acts like a batch where batch size is always 1\n    onBatch([cursor.key], [cursor.value], cursor);\n  }\n\n  if (useGetAll) {\n    pseudoCursor = { \"continue\": continuePseudoCursor };\n    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;\n    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;\n  } else if (descending) {\n    objectStore.openCursor(keyRange, 'prev').onsuccess = onCursor;\n  } else {\n    objectStore.openCursor(keyRange).onsuccess = onCursor;\n  }\n}\n\n// simple shim for objectStore.getAll(), falling back to IDBCursor\nfunction getAll(objectStore, keyRange, onSuccess) {\n  if (typeof objectStore.getAll === 'function') {\n    // use native getAll\n    objectStore.getAll(keyRange).onsuccess = onSuccess;\n    return;\n  }\n  // fall back to cursors\n  var values = [];\n\n  function onCursor(e) {\n    var cursor = e.target.result;\n    if (cursor) {\n      values.push(cursor.value);\n      cursor.continue();\n    } else {\n      onSuccess({\n        target: {\n          result: values\n        }\n      });\n    }\n  }\n\n  objectStore.openCursor(keyRange).onsuccess = onCursor;\n}\n\nfunction createKeyRange(start, end, inclusiveEnd, key, descending) {\n  try {\n    if (start && end) {\n      if (descending) {\n        return IDBKeyRange.bound(end, start, !inclusiveEnd, false);\n      } else {\n        return IDBKeyRange.bound(start, end, false, !inclusiveEnd);\n      }\n    } else if (start) {\n      if (descending) {\n        return IDBKeyRange.upperBound(start);\n      } else {\n        return IDBKeyRange.lowerBound(start);\n      }\n    } else if (end) {\n      if (descending) {\n        return IDBKeyRange.lowerBound(end, !inclusiveEnd);\n      } else {\n        return IDBKeyRange.upperBound(end, !inclusiveEnd);\n      }\n    } else if (key) {\n      return IDBKeyRange.only(key);\n    }\n  } catch (e) {\n    return { error: e };\n  }\n  return null;\n}\n\nfunction idbAllDocs(opts, idb, callback) {\n  var start = 'startkey' in opts ? opts.startkey : false;\n  var end = 'endkey' in opts ? opts.endkey : false;\n  var key = 'key' in opts ? opts.key : false;\n  var skip = opts.skip || 0;\n  var limit = typeof opts.limit === 'number' ? opts.limit : -1;\n  var inclusiveEnd = opts.inclusive_end !== false;\n\n  var keyRange = createKeyRange(start, end, inclusiveEnd, key, opts.descending);\n  var keyRangeError = keyRange && keyRange.error;\n  if (keyRangeError && !(keyRangeError.name === \"DataError\" && keyRangeError.code === 0)) {\n    // DataError with error code 0 indicates start is less than end, so\n    // can just do an empty query. Else need to throw\n    return callback(createError(IDB_ERROR, keyRangeError.name, keyRangeError.message));\n  }\n\n  var stores = [DOC_STORE, BY_SEQ_STORE, META_STORE];\n\n  if (opts.attachments) {\n    stores.push(ATTACH_STORE);\n  }\n  var txnResult = openTransactionSafely(idb, stores, 'readonly');\n  if (txnResult.error) {\n    return callback(txnResult.error);\n  }\n  var txn = txnResult.txn;\n  txn.oncomplete = onTxnComplete;\n  txn.onabort = idbError(callback);\n  var docStore = txn.objectStore(DOC_STORE);\n  var seqStore = txn.objectStore(BY_SEQ_STORE);\n  var metaStore = txn.objectStore(META_STORE);\n  var docIdRevIndex = seqStore.index('_doc_id_rev');\n  var results = [];\n  var docCount;\n\n  metaStore.get(META_STORE).onsuccess = function (e) {\n    docCount = e.target.result.docCount;\n  };\n\n  // if the user specifies include_docs=true, then we don't\n  // want to block the main cursor while we're fetching the doc\n  function fetchDocAsynchronously(metadata, row, winningRev$$1) {\n    var key = metadata.id + \"::\" + winningRev$$1;\n    docIdRevIndex.get(key).onsuccess = function onGetDoc(e) {\n      row.doc = decodeDoc(e.target.result);\n      if (opts.conflicts) {\n        var conflicts = collectConflicts(metadata);\n        if (conflicts.length) {\n          row.doc._conflicts = conflicts;\n        }\n      }\n      fetchAttachmentsIfNecessary(row.doc, opts, txn);\n    };\n  }\n\n  function allDocsInner(winningRev$$1, metadata) {\n    var row = {\n      id: metadata.id,\n      key: metadata.id,\n      value: {\n        rev: winningRev$$1\n      }\n    };\n    var deleted = metadata.deleted;\n    if (opts.deleted === 'ok') {\n      results.push(row);\n      // deleted docs are okay with \"keys\" requests\n      if (deleted) {\n        row.value.deleted = true;\n        row.doc = null;\n      } else if (opts.include_docs) {\n        fetchDocAsynchronously(metadata, row, winningRev$$1);\n      }\n    } else if (!deleted && skip-- <= 0) {\n      results.push(row);\n      if (opts.include_docs) {\n        fetchDocAsynchronously(metadata, row, winningRev$$1);\n      }\n    }\n  }\n\n  function processBatch(batchValues) {\n    for (var i = 0, len = batchValues.length; i < len; i++) {\n      if (results.length === limit) {\n        break;\n      }\n      var batchValue = batchValues[i];\n      var metadata = decodeMetadata(batchValue);\n      var winningRev$$1 = metadata.winningRev;\n      allDocsInner(winningRev$$1, metadata);\n    }\n  }\n\n  function onBatch(batchKeys, batchValues, cursor) {\n    if (!cursor) {\n      return;\n    }\n    processBatch(batchValues);\n    if (results.length < limit) {\n      cursor.continue();\n    }\n  }\n\n  function onGetAll(e) {\n    var values = e.target.result;\n    if (opts.descending) {\n      values = values.reverse();\n    }\n    processBatch(values);\n  }\n\n  function onResultsReady() {\n    callback(null, {\n      total_rows: docCount,\n      offset: opts.skip,\n      rows: results\n    });\n  }\n\n  function onTxnComplete() {\n    if (opts.attachments) {\n      postProcessAttachments(results, opts.binary).then(onResultsReady);\n    } else {\n      onResultsReady();\n    }\n  }\n\n  // don't bother doing any requests if start > end or limit === 0\n  if (keyRangeError || limit === 0) {\n    return;\n  }\n  if (limit === -1) {\n    // just fetch everything\n    return getAll(docStore, keyRange, onGetAll);\n  }\n  // else do a cursor\n  // choose a batch size based on the skip, since we'll need to skip that many\n  runBatchedCursor(docStore, keyRange, opts.descending, limit + skip, onBatch);\n}\n\n//\n// Blobs are not supported in all versions of IndexedDB, notably\n// Chrome <37 and Android <5. In those versions, storing a blob will throw.\n//\n// Various other blob bugs exist in Chrome v37-42 (inclusive).\n// Detecting them is expensive and confusing to users, and Chrome 37-42\n// is at very low usage worldwide, so we do a hacky userAgent check instead.\n//\n// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n//\nfunction checkBlobSupport(txn) {\n  return new PouchPromise$1(function (resolve) {\n    var blob = createBlob(['']);\n    var req = txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');\n\n    req.onsuccess = function () {\n      var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n      var matchedEdge = navigator.userAgent.match(/Edge\\//);\n      // MS Edge pretends to be Chrome 42:\n      // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n      resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);\n    };\n\n    txn.onabort = function (e) {\n      // If the transaction aborts now its due to not being able to\n      // write to the database, likely due to the disk being full\n      e.preventDefault();\n      e.stopPropagation();\n      resolve(false);\n    };\n  }).catch(function () {\n    return false; // error, so assume unsupported\n  });\n}\n\nfunction countDocs(txn, cb) {\n  var index = txn.objectStore(DOC_STORE).index('deletedOrLocal');\n  index.count(IDBKeyRange.only('0')).onsuccess = function (e) {\n    cb(e.target.result);\n  };\n}\n\n// This task queue ensures that IDB open calls are done in their own tick\n// and sequentially - i.e. we wait for the async IDB open to *fully* complete\n// before calling the next one. This works around IE/Edge race conditions in IDB.\n\nvar running = false;\nvar queue = [];\n\nfunction tryCode(fun, err, res, PouchDB) {\n  try {\n    fun(err, res);\n  } catch (err) {\n    // Shouldn't happen, but in some odd cases\n    // IndexedDB implementations might throw a sync\n    // error, in which case this will at least log it.\n    PouchDB.emit('error', err);\n  }\n}\n\nfunction applyNext() {\n  if (running || !queue.length) {\n    return;\n  }\n  running = true;\n  queue.shift()();\n}\n\nfunction enqueueTask(action, callback, PouchDB) {\n  queue.push(function runAction() {\n    action(function runCallback(err, res) {\n      tryCode(callback, err, res, PouchDB);\n      running = false;\n      __WEBPACK_IMPORTED_MODULE_5_immediate___default()(function runNext() {\n        applyNext(PouchDB);\n      });\n    });\n  });\n  applyNext();\n}\n\nfunction changes(opts, api, dbName, idb) {\n  opts = clone(opts);\n\n  if (opts.continuous) {\n    var id = dbName + ':' + uuid();\n    changesHandler.addListener(dbName, id, api, opts);\n    changesHandler.notify(dbName);\n    return {\n      cancel: function cancel() {\n        changesHandler.removeListener(dbName, id);\n      }\n    };\n  }\n\n  var docIds = opts.doc_ids && new ExportedSet(opts.doc_ids);\n\n  opts.since = opts.since || 0;\n  var lastSeq = opts.since;\n\n  var limit = 'limit' in opts ? opts.limit : -1;\n  if (limit === 0) {\n    limit = 1; // per CouchDB _changes spec\n  }\n  var returnDocs;\n  if ('return_docs' in opts) {\n    returnDocs = opts.return_docs;\n  } else if ('returnDocs' in opts) {\n    // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n    returnDocs = opts.returnDocs;\n  } else {\n    returnDocs = true;\n  }\n\n  var results = [];\n  var numResults = 0;\n  var filter = filterChange(opts);\n  var docIdsToMetadata = new ExportedMap();\n\n  var txn;\n  var bySeqStore;\n  var docStore;\n  var docIdRevIndex;\n\n  function onBatch(batchKeys, batchValues, cursor) {\n    if (!cursor || !batchKeys.length) {\n      // done\n      return;\n    }\n\n    var winningDocs = new Array(batchKeys.length);\n    var metadatas = new Array(batchKeys.length);\n\n    function processMetadataAndWinningDoc(metadata, winningDoc) {\n      var change = opts.processChange(winningDoc, metadata, opts);\n      lastSeq = change.seq = metadata.seq;\n\n      var filtered = filter(change);\n      if (typeof filtered === 'object') {\n        // anything but true/false indicates error\n        return opts.complete(filtered);\n      }\n\n      if (filtered) {\n        numResults++;\n        if (returnDocs) {\n          results.push(change);\n        }\n        // process the attachment immediately\n        // for the benefit of live listeners\n        if (opts.attachments && opts.include_docs) {\n          fetchAttachmentsIfNecessary(winningDoc, opts, txn, function () {\n            postProcessAttachments([change], opts.binary).then(function () {\n              opts.onChange(change);\n            });\n          });\n        } else {\n          opts.onChange(change);\n        }\n      }\n    }\n\n    function onBatchDone() {\n      for (var i = 0, len = winningDocs.length; i < len; i++) {\n        if (numResults === limit) {\n          break;\n        }\n        var winningDoc = winningDocs[i];\n        if (!winningDoc) {\n          continue;\n        }\n        var metadata = metadatas[i];\n        processMetadataAndWinningDoc(metadata, winningDoc);\n      }\n\n      if (numResults !== limit) {\n        cursor.continue();\n      }\n    }\n\n    // Fetch all metadatas/winningdocs from this batch in parallel, then process\n    // them all only once all data has been collected. This is done in parallel\n    // because it's faster than doing it one-at-a-time.\n    var numDone = 0;\n    batchValues.forEach(function (value, i) {\n      var doc = decodeDoc(value);\n      var seq = batchKeys[i];\n      fetchWinningDocAndMetadata(doc, seq, function (metadata, winningDoc) {\n        metadatas[i] = metadata;\n        winningDocs[i] = winningDoc;\n        if (++numDone === batchKeys.length) {\n          onBatchDone();\n        }\n      });\n    });\n  }\n\n  function onGetMetadata(doc, seq, metadata, cb) {\n    if (metadata.seq !== seq) {\n      // some other seq is later\n      return cb();\n    }\n\n    if (metadata.winningRev === doc._rev) {\n      // this is the winning doc\n      return cb(metadata, doc);\n    }\n\n    // fetch winning doc in separate request\n    var docIdRev = doc._id + '::' + metadata.winningRev;\n    var req = docIdRevIndex.get(docIdRev);\n    req.onsuccess = function (e) {\n      cb(metadata, decodeDoc(e.target.result));\n    };\n  }\n\n  function fetchWinningDocAndMetadata(doc, seq, cb) {\n    if (docIds && !docIds.has(doc._id)) {\n      return cb();\n    }\n\n    var metadata = docIdsToMetadata.get(doc._id);\n    if (metadata) {\n      // cached\n      return onGetMetadata(doc, seq, metadata, cb);\n    }\n    // metadata not cached, have to go fetch it\n    docStore.get(doc._id).onsuccess = function (e) {\n      metadata = decodeMetadata(e.target.result);\n      docIdsToMetadata.set(doc._id, metadata);\n      onGetMetadata(doc, seq, metadata, cb);\n    };\n  }\n\n  function finish() {\n    opts.complete(null, {\n      results: results,\n      last_seq: lastSeq\n    });\n  }\n\n  function onTxnComplete() {\n    if (!opts.continuous && opts.attachments) {\n      // cannot guarantee that postProcessing was already done,\n      // so do it again\n      postProcessAttachments(results).then(finish);\n    } else {\n      finish();\n    }\n  }\n\n  var objectStores = [DOC_STORE, BY_SEQ_STORE];\n  if (opts.attachments) {\n    objectStores.push(ATTACH_STORE);\n  }\n  var txnResult = openTransactionSafely(idb, objectStores, 'readonly');\n  if (txnResult.error) {\n    return opts.complete(txnResult.error);\n  }\n  txn = txnResult.txn;\n  txn.onabort = idbError(opts.complete);\n  txn.oncomplete = onTxnComplete;\n\n  bySeqStore = txn.objectStore(BY_SEQ_STORE);\n  docStore = txn.objectStore(DOC_STORE);\n  docIdRevIndex = bySeqStore.index('_doc_id_rev');\n\n  var keyRange = opts.since && !opts.descending ? IDBKeyRange.lowerBound(opts.since, true) : null;\n\n  runBatchedCursor(bySeqStore, keyRange, opts.descending, limit, onBatch);\n}\n\nvar cachedDBs = new ExportedMap();\nvar blobSupportPromise;\nvar openReqList = new ExportedMap();\n\nfunction IdbPouch(opts, callback) {\n  var api = this;\n\n  enqueueTask(function (thisCallback) {\n    init(api, opts, thisCallback);\n  }, callback, api.constructor);\n}\n\nfunction init(api, opts, callback) {\n\n  var dbName = opts.name;\n\n  var idb = null;\n  api._meta = null;\n\n  // called when creating a fresh new database\n  function createSchema(db) {\n    var docStore = db.createObjectStore(DOC_STORE, { keyPath: 'id' });\n    db.createObjectStore(BY_SEQ_STORE, { autoIncrement: true }).createIndex('_doc_id_rev', '_doc_id_rev', { unique: true });\n    db.createObjectStore(ATTACH_STORE, { keyPath: 'digest' });\n    db.createObjectStore(META_STORE, { keyPath: 'id', autoIncrement: false });\n    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n\n    // added in v2\n    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', { unique: false });\n\n    // added in v3\n    db.createObjectStore(LOCAL_STORE, { keyPath: '_id' });\n\n    // added in v4\n    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE, { autoIncrement: true });\n    attAndSeqStore.createIndex('seq', 'seq');\n    attAndSeqStore.createIndex('digestSeq', 'digestSeq', { unique: true });\n  }\n\n  // migration to version 2\n  // unfortunately \"deletedOrLocal\" is a misnomer now that we no longer\n  // store local docs in the main doc-store, but whaddyagonnado\n  function addDeletedOrLocalIndex(txn, callback) {\n    var docStore = txn.objectStore(DOC_STORE);\n    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', { unique: false });\n\n    docStore.openCursor().onsuccess = function (event) {\n      var cursor = event.target.result;\n      if (cursor) {\n        var metadata = cursor.value;\n        var deleted = isDeleted(metadata);\n        metadata.deletedOrLocal = deleted ? \"1\" : \"0\";\n        docStore.put(metadata);\n        cursor.continue();\n      } else {\n        callback();\n      }\n    };\n  }\n\n  // migration to version 3 (part 1)\n  function createLocalStoreSchema(db) {\n    db.createObjectStore(LOCAL_STORE, { keyPath: '_id' }).createIndex('_doc_id_rev', '_doc_id_rev', { unique: true });\n  }\n\n  // migration to version 3 (part 2)\n  function migrateLocalStore(txn, cb) {\n    var localStore = txn.objectStore(LOCAL_STORE);\n    var docStore = txn.objectStore(DOC_STORE);\n    var seqStore = txn.objectStore(BY_SEQ_STORE);\n\n    var cursor = docStore.openCursor();\n    cursor.onsuccess = function (event) {\n      var cursor = event.target.result;\n      if (cursor) {\n        var metadata = cursor.value;\n        var docId = metadata.id;\n        var local = isLocalId(docId);\n        var rev$$1 = winningRev(metadata);\n        if (local) {\n          var docIdRev = docId + \"::\" + rev$$1;\n          // remove all seq entries\n          // associated with this docId\n          var start = docId + \"::\";\n          var end = docId + \"::~\";\n          var index = seqStore.index('_doc_id_rev');\n          var range = IDBKeyRange.bound(start, end, false, false);\n          var seqCursor = index.openCursor(range);\n          seqCursor.onsuccess = function (e) {\n            seqCursor = e.target.result;\n            if (!seqCursor) {\n              // done\n              docStore.delete(cursor.primaryKey);\n              cursor.continue();\n            } else {\n              var data = seqCursor.value;\n              if (data._doc_id_rev === docIdRev) {\n                localStore.put(data);\n              }\n              seqStore.delete(seqCursor.primaryKey);\n              seqCursor.continue();\n            }\n          };\n        } else {\n          cursor.continue();\n        }\n      } else if (cb) {\n        cb();\n      }\n    };\n  }\n\n  // migration to version 4 (part 1)\n  function addAttachAndSeqStore(db) {\n    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE, { autoIncrement: true });\n    attAndSeqStore.createIndex('seq', 'seq');\n    attAndSeqStore.createIndex('digestSeq', 'digestSeq', { unique: true });\n  }\n\n  // migration to version 4 (part 2)\n  function migrateAttsAndSeqs(txn, callback) {\n    var seqStore = txn.objectStore(BY_SEQ_STORE);\n    var attStore = txn.objectStore(ATTACH_STORE);\n    var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n\n    // need to actually populate the table. this is the expensive part,\n    // so as an optimization, check first that this database even\n    // contains attachments\n    var req = attStore.count();\n    req.onsuccess = function (e) {\n      var count = e.target.result;\n      if (!count) {\n        return callback(); // done\n      }\n\n      seqStore.openCursor().onsuccess = function (e) {\n        var cursor = e.target.result;\n        if (!cursor) {\n          return callback(); // done\n        }\n        var doc = cursor.value;\n        var seq = cursor.primaryKey;\n        var atts = Object.keys(doc._attachments || {});\n        var digestMap = {};\n        for (var j = 0; j < atts.length; j++) {\n          var att = doc._attachments[atts[j]];\n          digestMap[att.digest] = true; // uniq digests, just in case\n        }\n        var digests = Object.keys(digestMap);\n        for (j = 0; j < digests.length; j++) {\n          var digest = digests[j];\n          attAndSeqStore.put({\n            seq: seq,\n            digestSeq: digest + '::' + seq\n          });\n        }\n        cursor.continue();\n      };\n    };\n  }\n\n  // migration to version 5\n  // Instead of relying on on-the-fly migration of metadata,\n  // this brings the doc-store to its modern form:\n  // - metadata.winningrev\n  // - metadata.seq\n  // - stringify the metadata when storing it\n  function migrateMetadata(txn) {\n\n    function decodeMetadataCompat(storedObject) {\n      if (!storedObject.data) {\n        // old format, when we didn't store it stringified\n        storedObject.deleted = storedObject.deletedOrLocal === '1';\n        return storedObject;\n      }\n      return decodeMetadata(storedObject);\n    }\n\n    // ensure that every metadata has a winningRev and seq,\n    // which was previously created on-the-fly but better to migrate\n    var bySeqStore = txn.objectStore(BY_SEQ_STORE);\n    var docStore = txn.objectStore(DOC_STORE);\n    var cursor = docStore.openCursor();\n    cursor.onsuccess = function (e) {\n      var cursor = e.target.result;\n      if (!cursor) {\n        return; // done\n      }\n      var metadata = decodeMetadataCompat(cursor.value);\n\n      metadata.winningRev = metadata.winningRev || winningRev(metadata);\n\n      function fetchMetadataSeq() {\n        // metadata.seq was added post-3.2.0, so if it's missing,\n        // we need to fetch it manually\n        var start = metadata.id + '::';\n        var end = metadata.id + '::\\uFFFF';\n        var req = bySeqStore.index('_doc_id_rev').openCursor(IDBKeyRange.bound(start, end));\n\n        var metadataSeq = 0;\n        req.onsuccess = function (e) {\n          var cursor = e.target.result;\n          if (!cursor) {\n            metadata.seq = metadataSeq;\n            return onGetMetadataSeq();\n          }\n          var seq = cursor.primaryKey;\n          if (seq > metadataSeq) {\n            metadataSeq = seq;\n          }\n          cursor.continue();\n        };\n      }\n\n      function onGetMetadataSeq() {\n        var metadataToStore = encodeMetadata(metadata, metadata.winningRev, metadata.deleted);\n\n        var req = docStore.put(metadataToStore);\n        req.onsuccess = function () {\n          cursor.continue();\n        };\n      }\n\n      if (metadata.seq) {\n        return onGetMetadataSeq();\n      }\n\n      fetchMetadataSeq();\n    };\n  }\n\n  api._remote = false;\n  api.type = function () {\n    return 'idb';\n  };\n\n  api._id = toPromise(function (callback) {\n    callback(null, api._meta.instanceId);\n  });\n\n  api._bulkDocs = function idb_bulkDocs(req, reqOpts, callback) {\n    idbBulkDocs(opts, req, reqOpts, api, idb, callback);\n  };\n\n  // First we look up the metadata in the ids database, then we fetch the\n  // current revision(s) from the by sequence store\n  api._get = function idb_get(id, opts, callback) {\n    var doc;\n    var metadata;\n    var err;\n    var txn = opts.ctx;\n    if (!txn) {\n      var txnResult = openTransactionSafely(idb, [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      txn = txnResult.txn;\n    }\n\n    function finish() {\n      callback(err, { doc: doc, metadata: metadata, ctx: txn });\n    }\n\n    txn.objectStore(DOC_STORE).get(id).onsuccess = function (e) {\n      metadata = decodeMetadata(e.target.result);\n      // we can determine the result here if:\n      // 1. there is no such document\n      // 2. the document is deleted and we don't ask about specific rev\n      // When we ask with opts.rev we expect the answer to be either\n      // doc (possibly with _deleted=true) or missing error\n      if (!metadata) {\n        err = createError(MISSING_DOC, 'missing');\n        return finish();\n      }\n\n      var rev$$1;\n      if (!opts.rev) {\n        rev$$1 = metadata.winningRev;\n        var deleted = isDeleted(metadata);\n        if (deleted) {\n          err = createError(MISSING_DOC, \"deleted\");\n          return finish();\n        }\n      } else {\n        rev$$1 = opts.latest ? latest(opts.rev, metadata) : opts.rev;\n      }\n\n      var objectStore = txn.objectStore(BY_SEQ_STORE);\n      var key = metadata.id + '::' + rev$$1;\n\n      objectStore.index('_doc_id_rev').get(key).onsuccess = function (e) {\n        doc = e.target.result;\n        if (doc) {\n          doc = decodeDoc(doc);\n        }\n        if (!doc) {\n          err = createError(MISSING_DOC, 'missing');\n          return finish();\n        }\n        finish();\n      };\n    };\n  };\n\n  api._getAttachment = function (docId, attachId, attachment, opts, callback) {\n    var txn;\n    if (opts.ctx) {\n      txn = opts.ctx;\n    } else {\n      var txnResult = openTransactionSafely(idb, [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      txn = txnResult.txn;\n    }\n    var digest = attachment.digest;\n    var type = attachment.content_type;\n\n    txn.objectStore(ATTACH_STORE).get(digest).onsuccess = function (e) {\n      var body = e.target.result.body;\n      readBlobData(body, type, opts.binary, function (blobData) {\n        callback(null, blobData);\n      });\n    };\n  };\n\n  api._info = function idb_info(callback) {\n    var updateSeq;\n    var docCount;\n\n    var txnResult = openTransactionSafely(idb, [META_STORE, BY_SEQ_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {\n      docCount = e.target.result.docCount;\n    };\n    txn.objectStore(BY_SEQ_STORE).openCursor(null, 'prev').onsuccess = function (e) {\n      var cursor = e.target.result;\n      updateSeq = cursor ? cursor.key : 0;\n    };\n\n    txn.oncomplete = function () {\n      callback(null, {\n        doc_count: docCount,\n        update_seq: updateSeq,\n        // for debugging\n        idb_attachment_format: api._meta.blobSupport ? 'binary' : 'base64'\n      });\n    };\n  };\n\n  api._allDocs = function idb_allDocs(opts, callback) {\n    idbAllDocs(opts, idb, callback);\n  };\n\n  api._changes = function idbChanges(opts) {\n    return changes(opts, api, dbName, idb);\n  };\n\n  api._close = function (callback) {\n    // https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#close\n    // \"Returns immediately and closes the connection in a separate thread...\"\n    idb.close();\n    cachedDBs.delete(dbName);\n    callback();\n  };\n\n  api._getRevisionTree = function (docId, callback) {\n    var txnResult = openTransactionSafely(idb, [DOC_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n    var req = txn.objectStore(DOC_STORE).get(docId);\n    req.onsuccess = function (event) {\n      var doc = decodeMetadata(event.target.result);\n      if (!doc) {\n        callback(createError(MISSING_DOC));\n      } else {\n        callback(null, doc.rev_tree);\n      }\n    };\n  };\n\n  // This function removes revisions of document docId\n  // which are listed in revs and sets this document\n  // revision to to rev_tree\n  api._doCompaction = function (docId, revs, callback) {\n    var stores = [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE, ATTACH_AND_SEQ_STORE];\n    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n\n    var docStore = txn.objectStore(DOC_STORE);\n\n    docStore.get(docId).onsuccess = function (event) {\n      var metadata = decodeMetadata(event.target.result);\n      traverseRevTree(metadata.rev_tree, function (isLeaf, pos, revHash, ctx, opts) {\n        var rev$$1 = pos + '-' + revHash;\n        if (revs.indexOf(rev$$1) !== -1) {\n          opts.status = 'missing';\n        }\n      });\n      compactRevs(revs, docId, txn);\n      var winningRev$$1 = metadata.winningRev;\n      var deleted = metadata.deleted;\n      txn.objectStore(DOC_STORE).put(encodeMetadata(metadata, winningRev$$1, deleted));\n    };\n    txn.onabort = idbError(callback);\n    txn.oncomplete = function () {\n      callback();\n    };\n  };\n\n  api._getLocal = function (id, callback) {\n    var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var tx = txnResult.txn;\n    var req = tx.objectStore(LOCAL_STORE).get(id);\n\n    req.onerror = idbError(callback);\n    req.onsuccess = function (e) {\n      var doc = e.target.result;\n      if (!doc) {\n        callback(createError(MISSING_DOC));\n      } else {\n        delete doc['_doc_id_rev']; // for backwards compat\n        callback(null, doc);\n      }\n    };\n  };\n\n  api._putLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    delete doc._revisions; // ignore this, trust the rev\n    var oldRev = doc._rev;\n    var id = doc._id;\n    if (!oldRev) {\n      doc._rev = '0-1';\n    } else {\n      doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);\n    }\n\n    var tx = opts.ctx;\n    var ret;\n    if (!tx) {\n      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      tx = txnResult.txn;\n      tx.onerror = idbError(callback);\n      tx.oncomplete = function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      };\n    }\n\n    var oStore = tx.objectStore(LOCAL_STORE);\n    var req;\n    if (oldRev) {\n      req = oStore.get(id);\n      req.onsuccess = function (e) {\n        var oldDoc = e.target.result;\n        if (!oldDoc || oldDoc._rev !== oldRev) {\n          callback(createError(REV_CONFLICT));\n        } else {\n          // update\n          var req = oStore.put(doc);\n          req.onsuccess = function () {\n            ret = { ok: true, id: doc._id, rev: doc._rev };\n            if (opts.ctx) {\n              // return immediately\n              callback(null, ret);\n            }\n          };\n        }\n      };\n    } else {\n      // new doc\n      req = oStore.add(doc);\n      req.onerror = function (e) {\n        // constraint error, already exists\n        callback(createError(REV_CONFLICT));\n        e.preventDefault(); // avoid transaction abort\n        e.stopPropagation(); // avoid transaction onerror\n      };\n      req.onsuccess = function () {\n        ret = { ok: true, id: doc._id, rev: doc._rev };\n        if (opts.ctx) {\n          // return immediately\n          callback(null, ret);\n        }\n      };\n    }\n  };\n\n  api._removeLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var tx = opts.ctx;\n    if (!tx) {\n      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      tx = txnResult.txn;\n      tx.oncomplete = function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      };\n    }\n    var ret;\n    var id = doc._id;\n    var oStore = tx.objectStore(LOCAL_STORE);\n    var req = oStore.get(id);\n\n    req.onerror = idbError(callback);\n    req.onsuccess = function (e) {\n      var oldDoc = e.target.result;\n      if (!oldDoc || oldDoc._rev !== doc._rev) {\n        callback(createError(MISSING_DOC));\n      } else {\n        oStore.delete(id);\n        ret = { ok: true, id: id, rev: '0-0' };\n        if (opts.ctx) {\n          // return immediately\n          callback(null, ret);\n        }\n      }\n    };\n  };\n\n  api._destroy = function (opts, callback) {\n    changesHandler.removeAllListeners(dbName);\n\n    //Close open request for \"dbName\" database to fix ie delay.\n    var openReq = openReqList.get(dbName);\n    if (openReq && openReq.result) {\n      openReq.result.close();\n      cachedDBs.delete(dbName);\n    }\n    var req = indexedDB.deleteDatabase(dbName);\n\n    req.onsuccess = function () {\n      //Remove open request from the list.\n      openReqList.delete(dbName);\n      if (hasLocalStorage() && dbName in localStorage) {\n        delete localStorage[dbName];\n      }\n      callback(null, { 'ok': true });\n    };\n\n    req.onerror = idbError(callback);\n  };\n\n  var cached = cachedDBs.get(dbName);\n\n  if (cached) {\n    idb = cached.idb;\n    api._meta = cached.global;\n    return __WEBPACK_IMPORTED_MODULE_5_immediate___default()(function () {\n      callback(null, api);\n    });\n  }\n\n  var req;\n  if (opts.storage) {\n    req = tryStorageOption(dbName, opts.storage);\n  } else {\n    req = indexedDB.open(dbName, ADAPTER_VERSION);\n  }\n\n  openReqList.set(dbName, req);\n\n  req.onupgradeneeded = function (e) {\n    var db = e.target.result;\n    if (e.oldVersion < 1) {\n      return createSchema(db); // new db, initial schema\n    }\n    // do migrations\n\n    var txn = e.currentTarget.transaction;\n    // these migrations have to be done in this function, before\n    // control is returned to the event loop, because IndexedDB\n\n    if (e.oldVersion < 3) {\n      createLocalStoreSchema(db); // v2 -> v3\n    }\n    if (e.oldVersion < 4) {\n      addAttachAndSeqStore(db); // v3 -> v4\n    }\n\n    var migrations = [addDeletedOrLocalIndex, // v1 -> v2\n    migrateLocalStore, // v2 -> v3\n    migrateAttsAndSeqs, // v3 -> v4\n    migrateMetadata // v4 -> v5\n    ];\n\n    var i = e.oldVersion;\n\n    function next() {\n      var migration = migrations[i - 1];\n      i++;\n      if (migration) {\n        migration(txn, next);\n      }\n    }\n\n    next();\n  };\n\n  req.onsuccess = function (e) {\n\n    idb = e.target.result;\n\n    idb.onversionchange = function () {\n      idb.close();\n      cachedDBs.delete(dbName);\n    };\n\n    idb.onabort = function (e) {\n      guardedConsole('error', 'Database has a global failure', e.target.error);\n      idb.close();\n      cachedDBs.delete(dbName);\n    };\n\n    // Do a few setup operations (in parallel as much as possible):\n    // 1. Fetch meta doc\n    // 2. Check blob support\n    // 3. Calculate docCount\n    // 4. Generate an instanceId if necessary\n    // 5. Store docCount and instanceId on meta doc\n\n    var txn = idb.transaction([META_STORE, DETECT_BLOB_SUPPORT_STORE, DOC_STORE], 'readwrite');\n\n    var storedMetaDoc = false;\n    var metaDoc;\n    var docCount;\n    var blobSupport;\n    var instanceId;\n\n    function completeSetup() {\n      if (typeof blobSupport === 'undefined' || !storedMetaDoc) {\n        return;\n      }\n      api._meta = {\n        name: dbName,\n        instanceId: instanceId,\n        blobSupport: blobSupport\n      };\n\n      cachedDBs.set(dbName, {\n        idb: idb,\n        global: api._meta\n      });\n      callback(null, api);\n    }\n\n    function storeMetaDocIfReady() {\n      if (typeof docCount === 'undefined' || typeof metaDoc === 'undefined') {\n        return;\n      }\n      var instanceKey = dbName + '_id';\n      if (instanceKey in metaDoc) {\n        instanceId = metaDoc[instanceKey];\n      } else {\n        metaDoc[instanceKey] = instanceId = uuid();\n      }\n      metaDoc.docCount = docCount;\n      txn.objectStore(META_STORE).put(metaDoc);\n    }\n\n    //\n    // fetch or generate the instanceId\n    //\n    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {\n      metaDoc = e.target.result || { id: META_STORE };\n      storeMetaDocIfReady();\n    };\n\n    //\n    // countDocs\n    //\n    countDocs(txn, function (count) {\n      docCount = count;\n      storeMetaDocIfReady();\n    });\n\n    //\n    // check blob support\n    //\n    if (!blobSupportPromise) {\n      // make sure blob support is only checked once\n      blobSupportPromise = checkBlobSupport(txn);\n    }\n\n    blobSupportPromise.then(function (val) {\n      blobSupport = val;\n      completeSetup();\n    });\n\n    // only when the metadata put transaction has completed,\n    // consider the setup done\n    txn.oncomplete = function () {\n      storedMetaDoc = true;\n      completeSetup();\n    };\n  };\n\n  req.onerror = function () {\n    var msg = 'Failed to open indexedDB, are you in private browsing mode?';\n    guardedConsole('error', msg);\n    callback(createError(IDB_ERROR, msg));\n  };\n}\n\nIdbPouch.valid = function () {\n  // Issue #2533, we finally gave up on doing bug\n  // detection instead of browser sniffing. Safari brought us\n  // to our knees.\n  var isSafari = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);\n\n  // some outdated implementations of IDB that appear on Samsung\n  // and HTC Android devices <4.4 are missing IDBKeyRange\n  return !isSafari && typeof indexedDB !== 'undefined' && typeof IDBKeyRange !== 'undefined';\n};\n\nfunction tryStorageOption(dbName, storage) {\n  try {\n    // option only available in Firefox 26+\n    return indexedDB.open(dbName, {\n      version: ADAPTER_VERSION,\n      storage: storage\n    });\n  } catch (err) {\n    return indexedDB.open(dbName, ADAPTER_VERSION);\n  }\n}\n\nvar IDBPouch = function IDBPouch(PouchDB) {\n  PouchDB.adapter('idb', IdbPouch, true);\n};\n\n//\n// Parsing hex strings. Yeah.\n//\n// So basically we need this because of a bug in WebSQL:\n// https://code.google.com/p/chromium/issues/detail?id=422690\n// https://bugs.webkit.org/show_bug.cgi?id=137637\n//\n// UTF-8 and UTF-16 are provided as separate functions\n// for meager performance improvements\n//\n\nfunction decodeUtf8(str) {\n  return decodeURIComponent(escape(str));\n}\n\nfunction hexToInt(charCode) {\n  // '0'-'9' is 48-57\n  // 'A'-'F' is 65-70\n  // SQLite will only give us uppercase hex\n  return charCode < 65 ? charCode - 48 : charCode - 55;\n}\n\n// Example:\n// pragma encoding=utf8;\n// select hex('A');\n// returns '41'\nfunction parseHexUtf8(str, start, end) {\n  var result = '';\n  while (start < end) {\n    result += String.fromCharCode(hexToInt(str.charCodeAt(start++)) << 4 | hexToInt(str.charCodeAt(start++)));\n  }\n  return result;\n}\n\n// Example:\n// pragma encoding=utf16;\n// select hex('A');\n// returns '4100'\n// notice that the 00 comes after the 41 (i.e. it's swizzled)\nfunction parseHexUtf16(str, start, end) {\n  var result = '';\n  while (start < end) {\n    // UTF-16, so swizzle the bytes\n    result += String.fromCharCode(hexToInt(str.charCodeAt(start + 2)) << 12 | hexToInt(str.charCodeAt(start + 3)) << 8 | hexToInt(str.charCodeAt(start)) << 4 | hexToInt(str.charCodeAt(start + 1)));\n    start += 4;\n  }\n  return result;\n}\n\nfunction parseHexString(str, encoding) {\n  if (encoding === 'UTF-8') {\n    return decodeUtf8(parseHexUtf8(str, 0, str.length));\n  } else {\n    return parseHexUtf16(str, 0, str.length);\n  }\n}\n\nfunction quote(str) {\n  return \"'\" + str + \"'\";\n}\n\nvar ADAPTER_VERSION$1 = 7; // used to manage migrations\n\n// The object stores created for each database\n// DOC_STORE stores the document meta data, its revision history and state\nvar DOC_STORE$1 = quote('document-store');\n// BY_SEQ_STORE stores a particular version of a document, keyed by its\n// sequence id\nvar BY_SEQ_STORE$1 = quote('by-sequence');\n// Where we store attachments\nvar ATTACH_STORE$1 = quote('attach-store');\nvar LOCAL_STORE$1 = quote('local-store');\nvar META_STORE$1 = quote('metadata-store');\n// where we store many-to-many relations between attachment\n// digests and seqs\nvar ATTACH_AND_SEQ_STORE$1 = quote('attach-seq-store');\n\n// escapeBlob and unescapeBlob are workarounds for a websql bug:\n// https://code.google.com/p/chromium/issues/detail?id=422690\n// https://bugs.webkit.org/show_bug.cgi?id=137637\n// The goal is to never actually insert the \\u0000 character\n// in the database.\nfunction escapeBlob(str) {\n  return str.replace(/\\u0002/g, '\\x02\\x02').replace(/\\u0001/g, '\\x01\\x02').replace(/\\u0000/g, '\\x01\\x01');\n}\n\nfunction unescapeBlob(str) {\n  return str.replace(/\\u0001\\u0001/g, '\\0').replace(/\\u0001\\u0002/g, '\\x01').replace(/\\u0002\\u0002/g, '\\x02');\n}\n\nfunction stringifyDoc(doc) {\n  // don't bother storing the id/rev. it uses lots of space,\n  // in persistent map/reduce especially\n  delete doc._id;\n  delete doc._rev;\n  return JSON.stringify(doc);\n}\n\nfunction unstringifyDoc(doc, id, rev$$1) {\n  doc = JSON.parse(doc);\n  doc._id = id;\n  doc._rev = rev$$1;\n  return doc;\n}\n\n// question mark groups IN queries, e.g. 3 -> '(?,?,?)'\nfunction qMarks(num) {\n  var s = '(';\n  while (num--) {\n    s += '?';\n    if (num) {\n      s += ',';\n    }\n  }\n  return s + ')';\n}\n\nfunction select(selector, table, joiner, where, orderBy) {\n  return 'SELECT ' + selector + ' FROM ' + (typeof table === 'string' ? table : table.join(' JOIN ')) + (joiner ? ' ON ' + joiner : '') + (where ? ' WHERE ' + (typeof where === 'string' ? where : where.join(' AND ')) : '') + (orderBy ? ' ORDER BY ' + orderBy : '');\n}\n\nfunction compactRevs$1(revs, docId, tx) {\n\n  if (!revs.length) {\n    return;\n  }\n\n  var numDone = 0;\n  var seqs = [];\n\n  function checkDone() {\n    if (++numDone === revs.length) {\n      // done\n      deleteOrphans();\n    }\n  }\n\n  function deleteOrphans() {\n    // find orphaned attachment digests\n\n    if (!seqs.length) {\n      return;\n    }\n\n    var sql = 'SELECT DISTINCT digest AS digest FROM ' + ATTACH_AND_SEQ_STORE$1 + ' WHERE seq IN ' + qMarks(seqs.length);\n\n    tx.executeSql(sql, seqs, function (tx, res) {\n\n      var digestsToCheck = [];\n      for (var i = 0; i < res.rows.length; i++) {\n        digestsToCheck.push(res.rows.item(i).digest);\n      }\n      if (!digestsToCheck.length) {\n        return;\n      }\n\n      var sql = 'DELETE FROM ' + ATTACH_AND_SEQ_STORE$1 + ' WHERE seq IN (' + seqs.map(function () {\n        return '?';\n      }).join(',') + ')';\n      tx.executeSql(sql, seqs, function (tx) {\n\n        var sql = 'SELECT digest FROM ' + ATTACH_AND_SEQ_STORE$1 + ' WHERE digest IN (' + digestsToCheck.map(function () {\n          return '?';\n        }).join(',') + ')';\n        tx.executeSql(sql, digestsToCheck, function (tx, res) {\n          var nonOrphanedDigests = new ExportedSet();\n          for (var i = 0; i < res.rows.length; i++) {\n            nonOrphanedDigests.add(res.rows.item(i).digest);\n          }\n          digestsToCheck.forEach(function (digest) {\n            if (nonOrphanedDigests.has(digest)) {\n              return;\n            }\n            tx.executeSql('DELETE FROM ' + ATTACH_AND_SEQ_STORE$1 + ' WHERE digest=?', [digest]);\n            tx.executeSql('DELETE FROM ' + ATTACH_STORE$1 + ' WHERE digest=?', [digest]);\n          });\n        });\n      });\n    });\n  }\n\n  // update by-seq and attach stores in parallel\n  revs.forEach(function (rev$$1) {\n    var sql = 'SELECT seq FROM ' + BY_SEQ_STORE$1 + ' WHERE doc_id=? AND rev=?';\n\n    tx.executeSql(sql, [docId, rev$$1], function (tx, res) {\n      if (!res.rows.length) {\n        // already deleted\n        return checkDone();\n      }\n      var seq = res.rows.item(0).seq;\n      seqs.push(seq);\n\n      tx.executeSql('DELETE FROM ' + BY_SEQ_STORE$1 + ' WHERE seq=?', [seq], checkDone);\n    });\n  });\n}\n\nfunction websqlError(callback) {\n  return function (event) {\n    guardedConsole('error', 'WebSQL threw an error', event);\n    // event may actually be a SQLError object, so report is as such\n    var errorNameMatch = event && event.constructor.toString().match(/function ([^(]+)/);\n    var errorName = errorNameMatch && errorNameMatch[1] || event.type;\n    var errorReason = event.target || event.message;\n    callback(createError(WSQ_ERROR, errorReason, errorName));\n  };\n}\n\nfunction getSize(opts) {\n  if ('size' in opts) {\n    // triggers immediate popup in iOS, fixes #2347\n    // e.g. 5000001 asks for 5 MB, 10000001 asks for 10 MB,\n    return opts.size * 1000000;\n  }\n  // In iOS, doesn't matter as long as it's <= 5000000.\n  // Except that if you request too much, our tests fail\n  // because of the native \"do you accept?\" popup.\n  // In Android <=4.3, this value is actually used as an\n  // honest-to-god ceiling for data, so we need to\n  // set it to a decently high number.\n  var isAndroid = typeof navigator !== 'undefined' && /Android/.test(navigator.userAgent);\n  return isAndroid ? 5000000 : 1; // in PhantomJS, if you use 0 it will crash\n}\n\nfunction websqlBulkDocs(dbOpts, req, opts, api, db, websqlChanges, callback) {\n  var newEdits = opts.new_edits;\n  var userDocs = req.docs;\n\n  // Parse the docs, give them a sequence number for the result\n  var docInfos = userDocs.map(function (doc) {\n    if (doc._id && isLocalId(doc._id)) {\n      return doc;\n    }\n    var newDoc = parseDoc(doc, newEdits);\n    return newDoc;\n  });\n\n  var docInfoErrors = docInfos.filter(function (docInfo) {\n    return docInfo.error;\n  });\n  if (docInfoErrors.length) {\n    return callback(docInfoErrors[0]);\n  }\n\n  var tx;\n  var results = new Array(docInfos.length);\n  var fetchedDocs = new ExportedMap();\n\n  var preconditionErrored;\n  function complete() {\n    if (preconditionErrored) {\n      return callback(preconditionErrored);\n    }\n    websqlChanges.notify(api._name);\n    callback(null, results);\n  }\n\n  function verifyAttachment(digest, callback) {\n    var sql = 'SELECT count(*) as cnt FROM ' + ATTACH_STORE$1 + ' WHERE digest=?';\n    tx.executeSql(sql, [digest], function (tx, result) {\n      if (result.rows.item(0).cnt === 0) {\n        var err = createError(MISSING_STUB, 'unknown stub attachment with digest ' + digest);\n        callback(err);\n      } else {\n        callback();\n      }\n    });\n  }\n\n  function verifyAttachments(finish) {\n    var digests = [];\n    docInfos.forEach(function (docInfo) {\n      if (docInfo.data && docInfo.data._attachments) {\n        Object.keys(docInfo.data._attachments).forEach(function (filename) {\n          var att = docInfo.data._attachments[filename];\n          if (att.stub) {\n            digests.push(att.digest);\n          }\n        });\n      }\n    });\n    if (!digests.length) {\n      return finish();\n    }\n    var numDone = 0;\n    var err;\n\n    function checkDone() {\n      if (++numDone === digests.length) {\n        finish(err);\n      }\n    }\n    digests.forEach(function (digest) {\n      verifyAttachment(digest, function (attErr) {\n        if (attErr && !err) {\n          err = attErr;\n        }\n        checkDone();\n      });\n    });\n  }\n\n  function writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted, isUpdate, delta, resultsIdx, callback) {\n\n    function finish() {\n      var data = docInfo.data;\n      var deletedInt = newRevIsDeleted ? 1 : 0;\n\n      var id = data._id;\n      var rev = data._rev;\n      var json = stringifyDoc(data);\n      var sql = 'INSERT INTO ' + BY_SEQ_STORE$1 + ' (doc_id, rev, json, deleted) VALUES (?, ?, ?, ?);';\n      var sqlArgs = [id, rev, json, deletedInt];\n\n      // map seqs to attachment digests, which\n      // we will need later during compaction\n      function insertAttachmentMappings(seq, callback) {\n        var attsAdded = 0;\n        var attsToAdd = Object.keys(data._attachments || {});\n\n        if (!attsToAdd.length) {\n          return callback();\n        }\n        function checkDone() {\n          if (++attsAdded === attsToAdd.length) {\n            callback();\n          }\n          return false; // ack handling a constraint error\n        }\n        function add(att) {\n          var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE$1 + ' (digest, seq) VALUES (?,?)';\n          var sqlArgs = [data._attachments[att].digest, seq];\n          tx.executeSql(sql, sqlArgs, checkDone, checkDone);\n          // second callback is for a constaint error, which we ignore\n          // because this docid/rev has already been associated with\n          // the digest (e.g. when new_edits == false)\n        }\n        for (var i = 0; i < attsToAdd.length; i++) {\n          add(attsToAdd[i]); // do in parallel\n        }\n      }\n\n      tx.executeSql(sql, sqlArgs, function (tx, result) {\n        var seq = result.insertId;\n        insertAttachmentMappings(seq, function () {\n          dataWritten(tx, seq);\n        });\n      }, function () {\n        // constraint error, recover by updating instead (see #1638)\n        var fetchSql = select('seq', BY_SEQ_STORE$1, null, 'doc_id=? AND rev=?');\n        tx.executeSql(fetchSql, [id, rev], function (tx, res) {\n          var seq = res.rows.item(0).seq;\n          var sql = 'UPDATE ' + BY_SEQ_STORE$1 + ' SET json=?, deleted=? WHERE doc_id=? AND rev=?;';\n          var sqlArgs = [json, deletedInt, id, rev];\n          tx.executeSql(sql, sqlArgs, function (tx) {\n            insertAttachmentMappings(seq, function () {\n              dataWritten(tx, seq);\n            });\n          });\n        });\n        return false; // ack that we've handled the error\n      });\n    }\n\n    function collectResults(attachmentErr) {\n      if (!err) {\n        if (attachmentErr) {\n          err = attachmentErr;\n          callback(err);\n        } else if (recv === attachments.length) {\n          finish();\n        }\n      }\n    }\n\n    var err = null;\n    var recv = 0;\n\n    docInfo.data._id = docInfo.metadata.id;\n    docInfo.data._rev = docInfo.metadata.rev;\n    var attachments = Object.keys(docInfo.data._attachments || {});\n\n    if (newRevIsDeleted) {\n      docInfo.data._deleted = true;\n    }\n\n    function attachmentSaved(err) {\n      recv++;\n      collectResults(err);\n    }\n\n    attachments.forEach(function (key) {\n      var att = docInfo.data._attachments[key];\n      if (!att.stub) {\n        var data = att.data;\n        delete att.data;\n        att.revpos = parseInt(winningRev$$1, 10);\n        var digest = att.digest;\n        saveAttachment(digest, data, attachmentSaved);\n      } else {\n        recv++;\n        collectResults();\n      }\n    });\n\n    if (!attachments.length) {\n      finish();\n    }\n\n    function dataWritten(tx, seq) {\n      var id = docInfo.metadata.id;\n\n      var revsToCompact = docInfo.stemmedRevs || [];\n      if (isUpdate && api.auto_compaction) {\n        revsToCompact = compactTree(docInfo.metadata).concat(revsToCompact);\n      }\n      if (revsToCompact.length) {\n        compactRevs$1(revsToCompact, id, tx);\n      }\n\n      docInfo.metadata.seq = seq;\n      var rev = docInfo.metadata.rev;\n      delete docInfo.metadata.rev;\n\n      var sql = isUpdate ? 'UPDATE ' + DOC_STORE$1 + ' SET json=?, max_seq=?, winningseq=' + '(SELECT seq FROM ' + BY_SEQ_STORE$1 + ' WHERE doc_id=' + DOC_STORE$1 + '.id AND rev=?) WHERE id=?' : 'INSERT INTO ' + DOC_STORE$1 + ' (id, winningseq, max_seq, json) VALUES (?,?,?,?);';\n      var metadataStr = safeJsonStringify(docInfo.metadata);\n      var params = isUpdate ? [metadataStr, seq, winningRev$$1, id] : [id, seq, seq, metadataStr];\n      tx.executeSql(sql, params, function () {\n        results[resultsIdx] = {\n          ok: true,\n          id: docInfo.metadata.id,\n          rev: rev\n        };\n        fetchedDocs.set(id, docInfo.metadata);\n        callback();\n      });\n    }\n  }\n\n  function websqlProcessDocs() {\n    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs, tx, results, writeDoc, opts);\n  }\n\n  function fetchExistingDocs(callback) {\n    if (!docInfos.length) {\n      return callback();\n    }\n\n    var numFetched = 0;\n\n    function checkDone() {\n      if (++numFetched === docInfos.length) {\n        callback();\n      }\n    }\n\n    docInfos.forEach(function (docInfo) {\n      if (docInfo._id && isLocalId(docInfo._id)) {\n        return checkDone(); // skip local docs\n      }\n      var id = docInfo.metadata.id;\n      tx.executeSql('SELECT json FROM ' + DOC_STORE$1 + ' WHERE id = ?', [id], function (tx, result) {\n        if (result.rows.length) {\n          var metadata = safeJsonParse(result.rows.item(0).json);\n          fetchedDocs.set(id, metadata);\n        }\n        checkDone();\n      });\n    });\n  }\n\n  function saveAttachment(digest, data, callback) {\n    var sql = 'SELECT digest FROM ' + ATTACH_STORE$1 + ' WHERE digest=?';\n    tx.executeSql(sql, [digest], function (tx, result) {\n      if (result.rows.length) {\n        // attachment already exists\n        return callback();\n      }\n      // we could just insert before selecting and catch the error,\n      // but my hunch is that it's cheaper not to serialize the blob\n      // from JS to C if we don't have to (TODO: confirm this)\n      sql = 'INSERT INTO ' + ATTACH_STORE$1 + ' (digest, body, escaped) VALUES (?,?,1)';\n      tx.executeSql(sql, [digest, escapeBlob(data)], function () {\n        callback();\n      }, function () {\n        // ignore constaint errors, means it already exists\n        callback();\n        return false; // ack we handled the error\n      });\n    });\n  }\n\n  preprocessAttachments(docInfos, 'binary', function (err) {\n    if (err) {\n      return callback(err);\n    }\n    db.transaction(function (txn) {\n      tx = txn;\n      verifyAttachments(function (err) {\n        if (err) {\n          preconditionErrored = err;\n        } else {\n          fetchExistingDocs(websqlProcessDocs);\n        }\n      });\n    }, websqlError(callback), complete);\n  });\n}\n\nvar cachedDatabases = new ExportedMap();\n\n// openDatabase passed in through opts (e.g. for node-websql)\nfunction openDatabaseWithOpts(opts) {\n  return opts.websql(opts.name, opts.version, opts.description, opts.size);\n}\n\nfunction openDBSafely(opts) {\n  try {\n    return {\n      db: openDatabaseWithOpts(opts)\n    };\n  } catch (err) {\n    return {\n      error: err\n    };\n  }\n}\n\nfunction openDB$1(opts) {\n  var cachedResult = cachedDatabases.get(opts.name);\n  if (!cachedResult) {\n    cachedResult = openDBSafely(opts);\n    cachedDatabases.set(opts.name, cachedResult);\n  }\n  return cachedResult;\n}\n\nvar websqlChanges = new Changes();\n\nfunction fetchAttachmentsIfNecessary$1(doc, opts, api, txn, cb) {\n  var attachments = Object.keys(doc._attachments || {});\n  if (!attachments.length) {\n    return cb && cb();\n  }\n  var numDone = 0;\n\n  function checkDone() {\n    if (++numDone === attachments.length && cb) {\n      cb();\n    }\n  }\n\n  function fetchAttachment(doc, att) {\n    var attObj = doc._attachments[att];\n    var attOpts = { binary: opts.binary, ctx: txn };\n    api._getAttachment(doc._id, att, attObj, attOpts, function (_, data) {\n      doc._attachments[att] = $inject_Object_assign(pick(attObj, ['digest', 'content_type']), { data: data });\n      checkDone();\n    });\n  }\n\n  attachments.forEach(function (att) {\n    if (opts.attachments && opts.include_docs) {\n      fetchAttachment(doc, att);\n    } else {\n      doc._attachments[att].stub = true;\n      checkDone();\n    }\n  });\n}\n\nvar POUCH_VERSION = 1;\n\n// these indexes cover the ground for most allDocs queries\nvar BY_SEQ_STORE_DELETED_INDEX_SQL = 'CREATE INDEX IF NOT EXISTS \\'by-seq-deleted-idx\\' ON ' + BY_SEQ_STORE$1 + ' (seq, deleted)';\nvar BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL = 'CREATE UNIQUE INDEX IF NOT EXISTS \\'by-seq-doc-id-rev\\' ON ' + BY_SEQ_STORE$1 + ' (doc_id, rev)';\nvar DOC_STORE_WINNINGSEQ_INDEX_SQL = 'CREATE INDEX IF NOT EXISTS \\'doc-winningseq-idx\\' ON ' + DOC_STORE$1 + ' (winningseq)';\nvar ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL = 'CREATE INDEX IF NOT EXISTS \\'attach-seq-seq-idx\\' ON ' + ATTACH_AND_SEQ_STORE$1 + ' (seq)';\nvar ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL = 'CREATE UNIQUE INDEX IF NOT EXISTS \\'attach-seq-digest-idx\\' ON ' + ATTACH_AND_SEQ_STORE$1 + ' (digest, seq)';\n\nvar DOC_STORE_AND_BY_SEQ_JOINER = BY_SEQ_STORE$1 + '.seq = ' + DOC_STORE$1 + '.winningseq';\n\nvar SELECT_DOCS = BY_SEQ_STORE$1 + '.seq AS seq, ' + BY_SEQ_STORE$1 + '.deleted AS deleted, ' + BY_SEQ_STORE$1 + '.json AS data, ' + BY_SEQ_STORE$1 + '.rev AS rev, ' + DOC_STORE$1 + '.json AS metadata';\n\nfunction WebSqlPouch$1(opts, callback) {\n  var api = this;\n  var instanceId = null;\n  var size = getSize(opts);\n  var idRequests = [];\n  var encoding;\n\n  api._name = opts.name;\n\n  // extend the options here, because sqlite plugin has a ton of options\n  // and they are constantly changing, so it's more prudent to allow anything\n  var websqlOpts = $inject_Object_assign({}, opts, {\n    version: POUCH_VERSION,\n    description: opts.name,\n    size: size\n  });\n  var openDBResult = openDB$1(websqlOpts);\n  if (openDBResult.error) {\n    return websqlError(callback)(openDBResult.error);\n  }\n  var db = openDBResult.db;\n  if (typeof db.readTransaction !== 'function') {\n    // doesn't exist in sqlite plugin\n    db.readTransaction = db.transaction;\n  }\n\n  function dbCreated() {\n    // note the db name in case the browser upgrades to idb\n    if (hasLocalStorage()) {\n      window.localStorage['_pouch__websqldb_' + api._name] = true;\n    }\n    callback(null, api);\n  }\n\n  // In this migration, we added the 'deleted' and 'local' columns to the\n  // by-seq and doc store tables.\n  // To preserve existing user data, we re-process all the existing JSON\n  // and add these values.\n  // Called migration2 because it corresponds to adapter version (db_version) #2\n  function runMigration2(tx, callback) {\n    // index used for the join in the allDocs query\n    tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);\n\n    tx.executeSql('ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN deleted TINYINT(1) DEFAULT 0', [], function () {\n      tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);\n      tx.executeSql('ALTER TABLE ' + DOC_STORE$1 + ' ADD COLUMN local TINYINT(1) DEFAULT 0', [], function () {\n        tx.executeSql('CREATE INDEX IF NOT EXISTS \\'doc-store-local-idx\\' ON ' + DOC_STORE$1 + ' (local, id)');\n\n        var sql = 'SELECT ' + DOC_STORE$1 + '.winningseq AS seq, ' + DOC_STORE$1 + '.json AS metadata FROM ' + BY_SEQ_STORE$1 + ' JOIN ' + DOC_STORE$1 + ' ON ' + BY_SEQ_STORE$1 + '.seq = ' + DOC_STORE$1 + '.winningseq';\n\n        tx.executeSql(sql, [], function (tx, result) {\n\n          var deleted = [];\n          var local = [];\n\n          for (var i = 0; i < result.rows.length; i++) {\n            var item = result.rows.item(i);\n            var seq = item.seq;\n            var metadata = JSON.parse(item.metadata);\n            if (isDeleted(metadata)) {\n              deleted.push(seq);\n            }\n            if (isLocalId(metadata.id)) {\n              local.push(metadata.id);\n            }\n          }\n          tx.executeSql('UPDATE ' + DOC_STORE$1 + 'SET local = 1 WHERE id IN ' + qMarks(local.length), local, function () {\n            tx.executeSql('UPDATE ' + BY_SEQ_STORE$1 + ' SET deleted = 1 WHERE seq IN ' + qMarks(deleted.length), deleted, callback);\n          });\n        });\n      });\n    });\n  }\n\n  // in this migration, we make all the local docs unversioned\n  function runMigration3(tx, callback) {\n    var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE$1 + ' (id UNIQUE, rev, json)';\n    tx.executeSql(local, [], function () {\n      var sql = 'SELECT ' + DOC_STORE$1 + '.id AS id, ' + BY_SEQ_STORE$1 + '.json AS data ' + 'FROM ' + BY_SEQ_STORE$1 + ' JOIN ' + DOC_STORE$1 + ' ON ' + BY_SEQ_STORE$1 + '.seq = ' + DOC_STORE$1 + '.winningseq WHERE local = 1';\n      tx.executeSql(sql, [], function (tx, res) {\n        var rows = [];\n        for (var i = 0; i < res.rows.length; i++) {\n          rows.push(res.rows.item(i));\n        }\n        function doNext() {\n          if (!rows.length) {\n            return callback(tx);\n          }\n          var row = rows.shift();\n          var rev$$1 = JSON.parse(row.data)._rev;\n          tx.executeSql('INSERT INTO ' + LOCAL_STORE$1 + ' (id, rev, json) VALUES (?,?,?)', [row.id, rev$$1, row.data], function (tx) {\n            tx.executeSql('DELETE FROM ' + DOC_STORE$1 + ' WHERE id=?', [row.id], function (tx) {\n              tx.executeSql('DELETE FROM ' + BY_SEQ_STORE$1 + ' WHERE seq=?', [row.seq], function () {\n                doNext();\n              });\n            });\n          });\n        }\n        doNext();\n      });\n    });\n  }\n\n  // in this migration, we remove doc_id_rev and just use rev\n  function runMigration4(tx, callback) {\n\n    function updateRows(rows) {\n      function doNext() {\n        if (!rows.length) {\n          return callback(tx);\n        }\n        var row = rows.shift();\n        var doc_id_rev = parseHexString(row.hex, encoding);\n        var idx = doc_id_rev.lastIndexOf('::');\n        var doc_id = doc_id_rev.substring(0, idx);\n        var rev$$1 = doc_id_rev.substring(idx + 2);\n        var sql = 'UPDATE ' + BY_SEQ_STORE$1 + ' SET doc_id=?, rev=? WHERE doc_id_rev=?';\n        tx.executeSql(sql, [doc_id, rev$$1, doc_id_rev], function () {\n          doNext();\n        });\n      }\n      doNext();\n    }\n\n    var sql = 'ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN doc_id';\n    tx.executeSql(sql, [], function (tx) {\n      var sql = 'ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN rev';\n      tx.executeSql(sql, [], function (tx) {\n        tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL, [], function (tx) {\n          var sql = 'SELECT hex(doc_id_rev) as hex FROM ' + BY_SEQ_STORE$1;\n          tx.executeSql(sql, [], function (tx, res) {\n            var rows = [];\n            for (var i = 0; i < res.rows.length; i++) {\n              rows.push(res.rows.item(i));\n            }\n            updateRows(rows);\n          });\n        });\n      });\n    });\n  }\n\n  // in this migration, we add the attach_and_seq table\n  // for issue #2818\n  function runMigration5(tx, callback) {\n\n    function migrateAttsAndSeqs(tx) {\n      // need to actually populate the table. this is the expensive part,\n      // so as an optimization, check first that this database even\n      // contains attachments\n      var sql = 'SELECT COUNT(*) AS cnt FROM ' + ATTACH_STORE$1;\n      tx.executeSql(sql, [], function (tx, res) {\n        var count = res.rows.item(0).cnt;\n        if (!count) {\n          return callback(tx);\n        }\n\n        var offset = 0;\n        var pageSize = 10;\n        function nextPage() {\n          var sql = select(SELECT_DOCS + ', ' + DOC_STORE$1 + '.id AS id', [DOC_STORE$1, BY_SEQ_STORE$1], DOC_STORE_AND_BY_SEQ_JOINER, null, DOC_STORE$1 + '.id ');\n          sql += ' LIMIT ' + pageSize + ' OFFSET ' + offset;\n          offset += pageSize;\n          tx.executeSql(sql, [], function (tx, res) {\n            if (!res.rows.length) {\n              return callback(tx);\n            }\n            var digestSeqs = {};\n            function addDigestSeq(digest, seq) {\n              // uniq digest/seq pairs, just in case there are dups\n              var seqs = digestSeqs[digest] = digestSeqs[digest] || [];\n              if (seqs.indexOf(seq) === -1) {\n                seqs.push(seq);\n              }\n            }\n            for (var i = 0; i < res.rows.length; i++) {\n              var row = res.rows.item(i);\n              var doc = unstringifyDoc(row.data, row.id, row.rev);\n              var atts = Object.keys(doc._attachments || {});\n              for (var j = 0; j < atts.length; j++) {\n                var att = doc._attachments[atts[j]];\n                addDigestSeq(att.digest, row.seq);\n              }\n            }\n            var digestSeqPairs = [];\n            Object.keys(digestSeqs).forEach(function (digest) {\n              var seqs = digestSeqs[digest];\n              seqs.forEach(function (seq) {\n                digestSeqPairs.push([digest, seq]);\n              });\n            });\n            if (!digestSeqPairs.length) {\n              return nextPage();\n            }\n            var numDone = 0;\n            digestSeqPairs.forEach(function (pair) {\n              var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE$1 + ' (digest, seq) VALUES (?,?)';\n              tx.executeSql(sql, pair, function () {\n                if (++numDone === digestSeqPairs.length) {\n                  nextPage();\n                }\n              });\n            });\n          });\n        }\n        nextPage();\n      });\n    }\n\n    var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' + ATTACH_AND_SEQ_STORE$1 + ' (digest, seq INTEGER)';\n    tx.executeSql(attachAndRev, [], function (tx) {\n      tx.executeSql(ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL, [], function (tx) {\n        tx.executeSql(ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL, [], migrateAttsAndSeqs);\n      });\n    });\n  }\n\n  // in this migration, we use escapeBlob() and unescapeBlob()\n  // instead of reading out the binary as HEX, which is slow\n  function runMigration6(tx, callback) {\n    var sql = 'ALTER TABLE ' + ATTACH_STORE$1 + ' ADD COLUMN escaped TINYINT(1) DEFAULT 0';\n    tx.executeSql(sql, [], callback);\n  }\n\n  // issue #3136, in this migration we need a \"latest seq\" as well\n  // as the \"winning seq\" in the doc store\n  function runMigration7(tx, callback) {\n    var sql = 'ALTER TABLE ' + DOC_STORE$1 + ' ADD COLUMN max_seq INTEGER';\n    tx.executeSql(sql, [], function (tx) {\n      var sql = 'UPDATE ' + DOC_STORE$1 + ' SET max_seq=(SELECT MAX(seq) FROM ' + BY_SEQ_STORE$1 + ' WHERE doc_id=id)';\n      tx.executeSql(sql, [], function (tx) {\n        // add unique index after filling, else we'll get a constraint\n        // error when we do the ALTER TABLE\n        var sql = 'CREATE UNIQUE INDEX IF NOT EXISTS \\'doc-max-seq-idx\\' ON ' + DOC_STORE$1 + ' (max_seq)';\n        tx.executeSql(sql, [], callback);\n      });\n    });\n  }\n\n  function checkEncoding(tx, cb) {\n    // UTF-8 on chrome/android, UTF-16 on safari < 7.1\n    tx.executeSql('SELECT HEX(\"a\") AS hex', [], function (tx, res) {\n      var hex = res.rows.item(0).hex;\n      encoding = hex.length === 2 ? 'UTF-8' : 'UTF-16';\n      cb();\n    });\n  }\n\n  function onGetInstanceId() {\n    while (idRequests.length > 0) {\n      var idCallback = idRequests.pop();\n      idCallback(null, instanceId);\n    }\n  }\n\n  function onGetVersion(tx, dbVersion) {\n    if (dbVersion === 0) {\n      // initial schema\n\n      var meta = 'CREATE TABLE IF NOT EXISTS ' + META_STORE$1 + ' (dbid, db_version INTEGER)';\n      var attach = 'CREATE TABLE IF NOT EXISTS ' + ATTACH_STORE$1 + ' (digest UNIQUE, escaped TINYINT(1), body BLOB)';\n      var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' + ATTACH_AND_SEQ_STORE$1 + ' (digest, seq INTEGER)';\n      // TODO: migrate winningseq to INTEGER\n      var doc = 'CREATE TABLE IF NOT EXISTS ' + DOC_STORE$1 + ' (id unique, json, winningseq, max_seq INTEGER UNIQUE)';\n      var seq = 'CREATE TABLE IF NOT EXISTS ' + BY_SEQ_STORE$1 + ' (seq INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, ' + 'json, deleted TINYINT(1), doc_id, rev)';\n      var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE$1 + ' (id UNIQUE, rev, json)';\n\n      // creates\n      tx.executeSql(attach);\n      tx.executeSql(local);\n      tx.executeSql(attachAndRev, [], function () {\n        tx.executeSql(ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL);\n        tx.executeSql(ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL);\n      });\n      tx.executeSql(doc, [], function () {\n        tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);\n        tx.executeSql(seq, [], function () {\n          tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);\n          tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL);\n          tx.executeSql(meta, [], function () {\n            // mark the db version, and new dbid\n            var initSeq = 'INSERT INTO ' + META_STORE$1 + ' (db_version, dbid) VALUES (?,?)';\n            instanceId = uuid();\n            var initSeqArgs = [ADAPTER_VERSION$1, instanceId];\n            tx.executeSql(initSeq, initSeqArgs, function () {\n              onGetInstanceId();\n            });\n          });\n        });\n      });\n    } else {\n      // version > 0\n\n      var setupDone = function setupDone() {\n        var migrated = dbVersion < ADAPTER_VERSION$1;\n        if (migrated) {\n          // update the db version within this transaction\n          tx.executeSql('UPDATE ' + META_STORE$1 + ' SET db_version = ' + ADAPTER_VERSION$1);\n        }\n        // notify db.id() callers\n        var sql = 'SELECT dbid FROM ' + META_STORE$1;\n        tx.executeSql(sql, [], function (tx, result) {\n          instanceId = result.rows.item(0).dbid;\n          onGetInstanceId();\n        });\n      };\n\n      // would love to use promises here, but then websql\n      // ends the transaction early\n      var tasks = [runMigration2, runMigration3, runMigration4, runMigration5, runMigration6, runMigration7, setupDone];\n\n      // run each migration sequentially\n      var i = dbVersion;\n      var nextMigration = function nextMigration(tx) {\n        tasks[i - 1](tx, nextMigration);\n        i++;\n      };\n      nextMigration(tx);\n    }\n  }\n\n  function setup() {\n    db.transaction(function (tx) {\n      // first check the encoding\n      checkEncoding(tx, function () {\n        // then get the version\n        fetchVersion(tx);\n      });\n    }, websqlError(callback), dbCreated);\n  }\n\n  function fetchVersion(tx) {\n    var sql = 'SELECT sql FROM sqlite_master WHERE tbl_name = ' + META_STORE$1;\n    tx.executeSql(sql, [], function (tx, result) {\n      if (!result.rows.length) {\n        // database hasn't even been created yet (version 0)\n        onGetVersion(tx, 0);\n      } else if (!/db_version/.test(result.rows.item(0).sql)) {\n        // table was created, but without the new db_version column,\n        // so add it.\n        tx.executeSql('ALTER TABLE ' + META_STORE$1 + ' ADD COLUMN db_version INTEGER', [], function () {\n          // before version 2, this column didn't even exist\n          onGetVersion(tx, 1);\n        });\n      } else {\n        // column exists, we can safely get it\n        tx.executeSql('SELECT db_version FROM ' + META_STORE$1, [], function (tx, result) {\n          var dbVersion = result.rows.item(0).db_version;\n          onGetVersion(tx, dbVersion);\n        });\n      }\n    });\n  }\n\n  setup();\n\n  function getMaxSeq(tx, callback) {\n    var sql = 'SELECT MAX(seq) AS seq FROM ' + BY_SEQ_STORE$1;\n    tx.executeSql(sql, [], function (tx, res) {\n      var updateSeq = res.rows.item(0).seq || 0;\n      callback(updateSeq);\n    });\n  }\n\n  function countDocs(tx, callback) {\n    // count the total rows\n    var sql = select('COUNT(' + DOC_STORE$1 + '.id) AS \\'num\\'', [DOC_STORE$1, BY_SEQ_STORE$1], DOC_STORE_AND_BY_SEQ_JOINER, BY_SEQ_STORE$1 + '.deleted=0');\n\n    tx.executeSql(sql, [], function (tx, result) {\n      callback(result.rows.item(0).num);\n    });\n  }\n\n  api._remote = false;\n  api.type = function () {\n    return 'websql';\n  };\n\n  api._id = toPromise(function (callback) {\n    callback(null, instanceId);\n  });\n\n  api._info = function (callback) {\n    var seq;\n    var docCount;\n    db.readTransaction(function (tx) {\n      getMaxSeq(tx, function (theSeq) {\n        seq = theSeq;\n      });\n      countDocs(tx, function (theDocCount) {\n        docCount = theDocCount;\n      });\n    }, websqlError(callback), function () {\n      callback(null, {\n        doc_count: docCount,\n        update_seq: seq,\n        websql_encoding: encoding\n      });\n    });\n  };\n\n  api._bulkDocs = function (req, reqOpts, callback) {\n    websqlBulkDocs(opts, req, reqOpts, api, db, websqlChanges, callback);\n  };\n\n  function latest$$1(tx, id, rev$$1, callback, finish) {\n    var sql = select(SELECT_DOCS, [DOC_STORE$1, BY_SEQ_STORE$1], DOC_STORE_AND_BY_SEQ_JOINER, DOC_STORE$1 + '.id=?');\n    var sqlArgs = [id];\n\n    tx.executeSql(sql, sqlArgs, function (a, results) {\n      if (!results.rows.length) {\n        var err = createError(MISSING_DOC, 'missing');\n        return finish(err);\n      }\n      var item = results.rows.item(0);\n      var metadata = safeJsonParse(item.metadata);\n      callback(latest(rev$$1, metadata));\n    });\n  }\n\n  api._get = function (id, opts, callback) {\n    var doc;\n    var metadata;\n    var tx = opts.ctx;\n    if (!tx) {\n      return db.readTransaction(function (txn) {\n        api._get(id, $inject_Object_assign({ ctx: txn }, opts), callback);\n      });\n    }\n\n    function finish(err) {\n      callback(err, { doc: doc, metadata: metadata, ctx: tx });\n    }\n\n    var sql;\n    var sqlArgs;\n\n    if (!opts.rev) {\n      sql = select(SELECT_DOCS, [DOC_STORE$1, BY_SEQ_STORE$1], DOC_STORE_AND_BY_SEQ_JOINER, DOC_STORE$1 + '.id=?');\n      sqlArgs = [id];\n    } else if (opts.latest) {\n      latest$$1(tx, id, opts.rev, function (latestRev) {\n        opts.latest = false;\n        opts.rev = latestRev;\n        api._get(id, opts, callback);\n      }, finish);\n      return;\n    } else {\n      sql = select(SELECT_DOCS, [DOC_STORE$1, BY_SEQ_STORE$1], DOC_STORE$1 + '.id=' + BY_SEQ_STORE$1 + '.doc_id', [BY_SEQ_STORE$1 + '.doc_id=?', BY_SEQ_STORE$1 + '.rev=?']);\n      sqlArgs = [id, opts.rev];\n    }\n\n    tx.executeSql(sql, sqlArgs, function (a, results) {\n      if (!results.rows.length) {\n        var missingErr = createError(MISSING_DOC, 'missing');\n        return finish(missingErr);\n      }\n      var item = results.rows.item(0);\n      metadata = safeJsonParse(item.metadata);\n      if (item.deleted && !opts.rev) {\n        var deletedErr = createError(MISSING_DOC, 'deleted');\n        return finish(deletedErr);\n      }\n      doc = unstringifyDoc(item.data, metadata.id, item.rev);\n      finish();\n    });\n  };\n\n  api._allDocs = function (opts, callback) {\n    var results = [];\n    var totalRows;\n\n    var start = 'startkey' in opts ? opts.startkey : false;\n    var end = 'endkey' in opts ? opts.endkey : false;\n    var key = 'key' in opts ? opts.key : false;\n    var descending = 'descending' in opts ? opts.descending : false;\n    var limit = 'limit' in opts ? opts.limit : -1;\n    var offset = 'skip' in opts ? opts.skip : 0;\n    var inclusiveEnd = opts.inclusive_end !== false;\n\n    var sqlArgs = [];\n    var criteria = [];\n\n    if (key !== false) {\n      criteria.push(DOC_STORE$1 + '.id = ?');\n      sqlArgs.push(key);\n    } else if (start !== false || end !== false) {\n      if (start !== false) {\n        criteria.push(DOC_STORE$1 + '.id ' + (descending ? '<=' : '>=') + ' ?');\n        sqlArgs.push(start);\n      }\n      if (end !== false) {\n        var comparator = descending ? '>' : '<';\n        if (inclusiveEnd) {\n          comparator += '=';\n        }\n        criteria.push(DOC_STORE$1 + '.id ' + comparator + ' ?');\n        sqlArgs.push(end);\n      }\n      if (key !== false) {\n        criteria.push(DOC_STORE$1 + '.id = ?');\n        sqlArgs.push(key);\n      }\n    }\n\n    if (opts.deleted !== 'ok') {\n      // report deleted if keys are specified\n      criteria.push(BY_SEQ_STORE$1 + '.deleted = 0');\n    }\n\n    db.readTransaction(function (tx) {\n      // count the docs in parallel to other operations\n      countDocs(tx, function (docCount) {\n        totalRows = docCount;\n      });\n\n      if (limit === 0) {\n        return;\n      }\n\n      // do a single query to fetch the documents\n      var sql = select(SELECT_DOCS, [DOC_STORE$1, BY_SEQ_STORE$1], DOC_STORE_AND_BY_SEQ_JOINER, criteria, DOC_STORE$1 + '.id ' + (descending ? 'DESC' : 'ASC'));\n      sql += ' LIMIT ' + limit + ' OFFSET ' + offset;\n\n      tx.executeSql(sql, sqlArgs, function (tx, result) {\n        for (var i = 0, l = result.rows.length; i < l; i++) {\n          var item = result.rows.item(i);\n          var metadata = safeJsonParse(item.metadata);\n          var id = metadata.id;\n          var data = unstringifyDoc(item.data, id, item.rev);\n          var winningRev$$1 = data._rev;\n          var doc = {\n            id: id,\n            key: id,\n            value: { rev: winningRev$$1 }\n          };\n          if (opts.include_docs) {\n            doc.doc = data;\n            doc.doc._rev = winningRev$$1;\n            if (opts.conflicts) {\n              var conflicts = collectConflicts(metadata);\n              if (conflicts.length) {\n                doc.doc._conflicts = conflicts;\n              }\n            }\n            fetchAttachmentsIfNecessary$1(doc.doc, opts, api, tx);\n          }\n          if (item.deleted) {\n            if (opts.deleted === 'ok') {\n              doc.value.deleted = true;\n              doc.doc = null;\n            } else {\n              continue;\n            }\n          }\n          results.push(doc);\n        }\n      });\n    }, websqlError(callback), function () {\n      callback(null, {\n        total_rows: totalRows,\n        offset: opts.skip,\n        rows: results\n      });\n    });\n  };\n\n  api._changes = function (opts) {\n    opts = clone(opts);\n\n    if (opts.continuous) {\n      var id = api._name + ':' + uuid();\n      websqlChanges.addListener(api._name, id, api, opts);\n      websqlChanges.notify(api._name);\n      return {\n        cancel: function cancel() {\n          websqlChanges.removeListener(api._name, id);\n        }\n      };\n    }\n\n    var descending = opts.descending;\n\n    // Ignore the `since` parameter when `descending` is true\n    opts.since = opts.since && !descending ? opts.since : 0;\n\n    var limit = 'limit' in opts ? opts.limit : -1;\n    if (limit === 0) {\n      limit = 1; // per CouchDB _changes spec\n    }\n\n    var returnDocs;\n    if ('return_docs' in opts) {\n      returnDocs = opts.return_docs;\n    } else if ('returnDocs' in opts) {\n      // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n      returnDocs = opts.returnDocs;\n    } else {\n      returnDocs = true;\n    }\n    var results = [];\n    var numResults = 0;\n\n    function fetchChanges() {\n\n      var selectStmt = DOC_STORE$1 + '.json AS metadata, ' + DOC_STORE$1 + '.max_seq AS maxSeq, ' + BY_SEQ_STORE$1 + '.json AS winningDoc, ' + BY_SEQ_STORE$1 + '.rev AS winningRev ';\n\n      var from = DOC_STORE$1 + ' JOIN ' + BY_SEQ_STORE$1;\n\n      var joiner = DOC_STORE$1 + '.id=' + BY_SEQ_STORE$1 + '.doc_id' + ' AND ' + DOC_STORE$1 + '.winningseq=' + BY_SEQ_STORE$1 + '.seq';\n\n      var criteria = ['maxSeq > ?'];\n      var sqlArgs = [opts.since];\n\n      if (opts.doc_ids) {\n        criteria.push(DOC_STORE$1 + '.id IN ' + qMarks(opts.doc_ids.length));\n        sqlArgs = sqlArgs.concat(opts.doc_ids);\n      }\n\n      var orderBy = 'maxSeq ' + (descending ? 'DESC' : 'ASC');\n\n      var sql = select(selectStmt, from, joiner, criteria, orderBy);\n\n      var filter = filterChange(opts);\n      if (!opts.view && !opts.filter) {\n        // we can just limit in the query\n        sql += ' LIMIT ' + limit;\n      }\n\n      var lastSeq = opts.since || 0;\n      db.readTransaction(function (tx) {\n        tx.executeSql(sql, sqlArgs, function (tx, result) {\n          function reportChange(change) {\n            return function () {\n              opts.onChange(change);\n            };\n          }\n          for (var i = 0, l = result.rows.length; i < l; i++) {\n            var item = result.rows.item(i);\n            var metadata = safeJsonParse(item.metadata);\n            lastSeq = item.maxSeq;\n\n            var doc = unstringifyDoc(item.winningDoc, metadata.id, item.winningRev);\n            var change = opts.processChange(doc, metadata, opts);\n            change.seq = item.maxSeq;\n\n            var filtered = filter(change);\n            if (typeof filtered === 'object') {\n              return opts.complete(filtered);\n            }\n\n            if (filtered) {\n              numResults++;\n              if (returnDocs) {\n                results.push(change);\n              }\n              // process the attachment immediately\n              // for the benefit of live listeners\n              if (opts.attachments && opts.include_docs) {\n                fetchAttachmentsIfNecessary$1(doc, opts, api, tx, reportChange(change));\n              } else {\n                reportChange(change)();\n              }\n            }\n            if (numResults === limit) {\n              break;\n            }\n          }\n        });\n      }, websqlError(opts.complete), function () {\n        if (!opts.continuous) {\n          opts.complete(null, {\n            results: results,\n            last_seq: lastSeq\n          });\n        }\n      });\n    }\n\n    fetchChanges();\n  };\n\n  api._close = function (callback) {\n    //WebSQL databases do not need to be closed\n    callback();\n  };\n\n  api._getAttachment = function (docId, attachId, attachment, opts, callback) {\n    var res;\n    var tx = opts.ctx;\n    var digest = attachment.digest;\n    var type = attachment.content_type;\n    var sql = 'SELECT escaped, ' + 'CASE WHEN escaped = 1 THEN body ELSE HEX(body) END AS body FROM ' + ATTACH_STORE$1 + ' WHERE digest=?';\n    tx.executeSql(sql, [digest], function (tx, result) {\n      // websql has a bug where \\u0000 causes early truncation in strings\n      // and blobs. to work around this, we used to use the hex() function,\n      // but that's not performant. after migration 6, we remove \\u0000\n      // and add it back in afterwards\n      var item = result.rows.item(0);\n      var data = item.escaped ? unescapeBlob(item.body) : parseHexString(item.body, encoding);\n      if (opts.binary) {\n        res = binStringToBluffer(data, type);\n      } else {\n        res = thisBtoa(data);\n      }\n      callback(null, res);\n    });\n  };\n\n  api._getRevisionTree = function (docId, callback) {\n    db.readTransaction(function (tx) {\n      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE$1 + ' WHERE id = ?';\n      tx.executeSql(sql, [docId], function (tx, result) {\n        if (!result.rows.length) {\n          callback(createError(MISSING_DOC));\n        } else {\n          var data = safeJsonParse(result.rows.item(0).metadata);\n          callback(null, data.rev_tree);\n        }\n      });\n    });\n  };\n\n  api._doCompaction = function (docId, revs, callback) {\n    if (!revs.length) {\n      return callback();\n    }\n    db.transaction(function (tx) {\n\n      // update doc store\n      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE$1 + ' WHERE id = ?';\n      tx.executeSql(sql, [docId], function (tx, result) {\n        var metadata = safeJsonParse(result.rows.item(0).metadata);\n        traverseRevTree(metadata.rev_tree, function (isLeaf, pos, revHash, ctx, opts) {\n          var rev$$1 = pos + '-' + revHash;\n          if (revs.indexOf(rev$$1) !== -1) {\n            opts.status = 'missing';\n          }\n        });\n\n        var sql = 'UPDATE ' + DOC_STORE$1 + ' SET json = ? WHERE id = ?';\n        tx.executeSql(sql, [safeJsonStringify(metadata), docId]);\n      });\n\n      compactRevs$1(revs, docId, tx);\n    }, websqlError(callback), function () {\n      callback();\n    });\n  };\n\n  api._getLocal = function (id, callback) {\n    db.readTransaction(function (tx) {\n      var sql = 'SELECT json, rev FROM ' + LOCAL_STORE$1 + ' WHERE id=?';\n      tx.executeSql(sql, [id], function (tx, res) {\n        if (res.rows.length) {\n          var item = res.rows.item(0);\n          var doc = unstringifyDoc(item.json, id, item.rev);\n          callback(null, doc);\n        } else {\n          callback(createError(MISSING_DOC));\n        }\n      });\n    });\n  };\n\n  api._putLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    delete doc._revisions; // ignore this, trust the rev\n    var oldRev = doc._rev;\n    var id = doc._id;\n    var newRev;\n    if (!oldRev) {\n      newRev = doc._rev = '0-1';\n    } else {\n      newRev = doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);\n    }\n    var json = stringifyDoc(doc);\n\n    var ret;\n    function putLocal(tx) {\n      var sql;\n      var values;\n      if (oldRev) {\n        sql = 'UPDATE ' + LOCAL_STORE$1 + ' SET rev=?, json=? ' + 'WHERE id=? AND rev=?';\n        values = [newRev, json, id, oldRev];\n      } else {\n        sql = 'INSERT INTO ' + LOCAL_STORE$1 + ' (id, rev, json) VALUES (?,?,?)';\n        values = [id, newRev, json];\n      }\n      tx.executeSql(sql, values, function (tx, res) {\n        if (res.rowsAffected) {\n          ret = { ok: true, id: id, rev: newRev };\n          if (opts.ctx) {\n            // return immediately\n            callback(null, ret);\n          }\n        } else {\n          callback(createError(REV_CONFLICT));\n        }\n      }, function () {\n        callback(createError(REV_CONFLICT));\n        return false; // ack that we handled the error\n      });\n    }\n\n    if (opts.ctx) {\n      putLocal(opts.ctx);\n    } else {\n      db.transaction(putLocal, websqlError(callback), function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      });\n    }\n  };\n\n  api._removeLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var ret;\n\n    function removeLocal(tx) {\n      var sql = 'DELETE FROM ' + LOCAL_STORE$1 + ' WHERE id=? AND rev=?';\n      var params = [doc._id, doc._rev];\n      tx.executeSql(sql, params, function (tx, res) {\n        if (!res.rowsAffected) {\n          return callback(createError(MISSING_DOC));\n        }\n        ret = { ok: true, id: doc._id, rev: '0-0' };\n        if (opts.ctx) {\n          // return immediately\n          callback(null, ret);\n        }\n      });\n    }\n\n    if (opts.ctx) {\n      removeLocal(opts.ctx);\n    } else {\n      db.transaction(removeLocal, websqlError(callback), function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      });\n    }\n  };\n\n  api._destroy = function (opts, callback) {\n    websqlChanges.removeAllListeners(api._name);\n    db.transaction(function (tx) {\n      var stores = [DOC_STORE$1, BY_SEQ_STORE$1, ATTACH_STORE$1, META_STORE$1, LOCAL_STORE$1, ATTACH_AND_SEQ_STORE$1];\n      stores.forEach(function (store) {\n        tx.executeSql('DROP TABLE IF EXISTS ' + store, []);\n      });\n    }, websqlError(callback), function () {\n      if (hasLocalStorage()) {\n        delete window.localStorage['_pouch__websqldb_' + api._name];\n        delete window.localStorage[api._name];\n      }\n      callback(null, { 'ok': true });\n    });\n  };\n}\n\nfunction canOpenTestDB() {\n  try {\n    openDatabase('_pouch_validate_websql', 1, '', 1);\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\n// WKWebView had a bug where WebSQL would throw a DOM Exception 18\n// (see https://bugs.webkit.org/show_bug.cgi?id=137760 and\n// https://github.com/pouchdb/pouchdb/issues/5079)\n// This has been fixed in latest WebKit, so we try to detect it here.\nfunction isValidWebSQL() {\n  // WKWebView UA:\n  //   Mozilla/5.0 (iPhone; CPU iPhone OS 9_2 like Mac OS X)\n  //   AppleWebKit/601.1.46 (KHTML, like Gecko) Mobile/13C75\n  // Chrome for iOS UA:\n  //   Mozilla/5.0 (iPhone; U; CPU iPhone OS 5_1_1 like Mac OS X; en)\n  //   AppleWebKit/534.46.0 (KHTML, like Gecko) CriOS/19.0.1084.60\n  //   Mobile/9B206 Safari/7534.48.3\n  // Firefox for iOS UA:\n  //   Mozilla/5.0 (iPhone; CPU iPhone OS 8_3 like Mac OS X) AppleWebKit/600.1.4\n  //   (KHTML, like Gecko) FxiOS/1.0 Mobile/12F69 Safari/600.1.4\n\n  // indexedDB is null on some UIWebViews and undefined in others\n  // see: https://bugs.webkit.org/show_bug.cgi?id=137034\n  if (typeof indexedDB === 'undefined' || indexedDB === null || !/iP(hone|od|ad)/.test(navigator.userAgent)) {\n    // definitely not WKWebView, avoid creating an unnecessary database\n    return true;\n  }\n  // Cache the result in LocalStorage. Reason we do this is because if we\n  // call openDatabase() too many times, Safari craps out in SauceLabs and\n  // starts throwing DOM Exception 14s.\n  var hasLS = hasLocalStorage();\n  // Include user agent in the hash, so that if Safari is upgraded, we don't\n  // continually think it's broken.\n  var localStorageKey = '_pouch__websqldb_valid_' + navigator.userAgent;\n  if (hasLS && localStorage[localStorageKey]) {\n    return localStorage[localStorageKey] === '1';\n  }\n  var openedTestDB = canOpenTestDB();\n  if (hasLS) {\n    localStorage[localStorageKey] = openedTestDB ? '1' : '0';\n  }\n  return openedTestDB;\n}\n\nfunction valid() {\n  if (typeof openDatabase !== 'function') {\n    return false;\n  }\n  return isValidWebSQL();\n}\n\nfunction openDB(name, version, description, size) {\n  // Traditional WebSQL API\n  return openDatabase(name, version, description, size);\n}\n\nfunction WebSQLPouch(opts, callback) {\n  var _opts = $inject_Object_assign({\n    websql: openDB\n  }, opts);\n\n  WebSqlPouch$1.call(this, _opts, callback);\n}\n\nWebSQLPouch.valid = valid;\n\nWebSQLPouch.use_prefix = true;\n\nvar WebSqlPouch = function WebSqlPouch(PouchDB) {\n  PouchDB.adapter('websql', WebSQLPouch, true);\n};\n\n/* global fetch */\n/* global Headers */\nfunction wrappedFetch() {\n  var wrappedPromise = {};\n\n  var promise = new PouchPromise$1(function (resolve, reject) {\n    wrappedPromise.resolve = resolve;\n    wrappedPromise.reject = reject;\n  });\n\n  var args = new Array(arguments.length);\n\n  for (var i = 0; i < args.length; i++) {\n    args[i] = arguments[i];\n  }\n\n  wrappedPromise.promise = promise;\n\n  PouchPromise$1.resolve().then(function () {\n    return fetch.apply(null, args);\n  }).then(function (response) {\n    wrappedPromise.resolve(response);\n  }).catch(function (error) {\n    wrappedPromise.reject(error);\n  });\n\n  return wrappedPromise;\n}\n\nfunction fetchRequest(options, callback) {\n  var wrappedPromise, timer, response;\n\n  var headers = new Headers();\n\n  var fetchOptions = {\n    method: options.method,\n    credentials: 'include',\n    headers: headers\n  };\n\n  if (options.json) {\n    headers.set('Accept', 'application/json');\n    headers.set('Content-Type', options.headers['Content-Type'] || 'application/json');\n  }\n\n  if (options.body && options.processData && typeof options.body !== 'string') {\n    fetchOptions.body = JSON.stringify(options.body);\n  } else if ('body' in options) {\n    fetchOptions.body = options.body;\n  } else {\n    fetchOptions.body = null;\n  }\n\n  Object.keys(options.headers).forEach(function (key) {\n    if (options.headers.hasOwnProperty(key)) {\n      headers.set(key, options.headers[key]);\n    }\n  });\n\n  wrappedPromise = wrappedFetch(options.url, fetchOptions);\n\n  if (options.timeout > 0) {\n    timer = setTimeout(function () {\n      wrappedPromise.reject(new Error('Load timeout for resource: ' + options.url));\n    }, options.timeout);\n  }\n\n  wrappedPromise.promise.then(function (fetchResponse) {\n    response = {\n      statusCode: fetchResponse.status\n    };\n\n    if (options.timeout > 0) {\n      clearTimeout(timer);\n    }\n\n    if (response.statusCode >= 200 && response.statusCode < 300) {\n      return options.binary ? fetchResponse.blob() : fetchResponse.text();\n    }\n\n    return fetchResponse.json();\n  }).then(function (result) {\n    if (response.statusCode >= 200 && response.statusCode < 300) {\n      callback(null, response, result);\n    } else {\n      result.status = response.statusCode;\n      callback(result);\n    }\n  }).catch(function (error) {\n    if (!error) {\n      // this happens when the listener is canceled\n      error = new Error('canceled');\n    }\n    callback(error);\n  });\n\n  return { abort: wrappedPromise.reject };\n}\n\nfunction xhRequest(options, callback) {\n\n  var xhr, timer;\n  var timedout = false;\n\n  var abortReq = function abortReq() {\n    xhr.abort();\n    cleanUp();\n  };\n\n  var timeoutReq = function timeoutReq() {\n    timedout = true;\n    xhr.abort();\n    cleanUp();\n  };\n\n  var ret = { abort: abortReq };\n\n  var cleanUp = function cleanUp() {\n    clearTimeout(timer);\n    ret.abort = function () {};\n    if (xhr) {\n      xhr.onprogress = undefined;\n      if (xhr.upload) {\n        xhr.upload.onprogress = undefined;\n      }\n      xhr.onreadystatechange = undefined;\n      xhr = undefined;\n    }\n  };\n\n  if (options.xhr) {\n    xhr = new options.xhr();\n  } else {\n    xhr = new XMLHttpRequest();\n  }\n\n  try {\n    xhr.open(options.method, options.url);\n  } catch (exception) {\n    return callback(new Error(exception.name || 'Url is invalid'));\n  }\n\n  xhr.withCredentials = 'withCredentials' in options ? options.withCredentials : true;\n\n  if (options.method === 'GET') {\n    delete options.headers['Content-Type'];\n  } else if (options.json) {\n    options.headers.Accept = 'application/json';\n    options.headers['Content-Type'] = options.headers['Content-Type'] || 'application/json';\n    if (options.body && options.processData && typeof options.body !== \"string\") {\n      options.body = JSON.stringify(options.body);\n    }\n  }\n\n  if (options.binary) {\n    xhr.responseType = 'arraybuffer';\n  }\n\n  if (!('body' in options)) {\n    options.body = null;\n  }\n\n  for (var key in options.headers) {\n    if (options.headers.hasOwnProperty(key)) {\n      xhr.setRequestHeader(key, options.headers[key]);\n    }\n  }\n\n  if (options.timeout > 0) {\n    timer = setTimeout(timeoutReq, options.timeout);\n    xhr.onprogress = function () {\n      clearTimeout(timer);\n      if (xhr.readyState !== 4) {\n        timer = setTimeout(timeoutReq, options.timeout);\n      }\n    };\n    if (typeof xhr.upload !== 'undefined') {\n      // does not exist in ie9\n      xhr.upload.onprogress = xhr.onprogress;\n    }\n  }\n\n  xhr.onreadystatechange = function () {\n    if (xhr.readyState !== 4) {\n      return;\n    }\n\n    var response = {\n      statusCode: xhr.status\n    };\n\n    if (xhr.status >= 200 && xhr.status < 300) {\n      var data;\n      if (options.binary) {\n        data = createBlob([xhr.response || ''], {\n          type: xhr.getResponseHeader('Content-Type')\n        });\n      } else {\n        data = xhr.responseText;\n      }\n      callback(null, response, data);\n    } else {\n      var err = {};\n      if (timedout) {\n        err = new Error('ETIMEDOUT');\n        err.code = 'ETIMEDOUT';\n      } else if (typeof xhr.response === 'string') {\n        try {\n          err = JSON.parse(xhr.response);\n        } catch (e) {}\n      }\n      err.status = xhr.status;\n      callback(err);\n    }\n    cleanUp();\n  };\n\n  if (options.body && options.body instanceof Blob) {\n    readAsArrayBuffer(options.body, function (arrayBuffer) {\n      xhr.send(arrayBuffer);\n    });\n  } else {\n    xhr.send(options.body);\n  }\n\n  return ret;\n}\n\nfunction testXhr() {\n  try {\n    new XMLHttpRequest();\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\nvar hasXhr = testXhr();\n\nfunction ajax$1(options, callback) {\n  if (!false && (hasXhr || options.xhr)) {\n    return xhRequest(options, callback);\n  } else {\n    return fetchRequest(options, callback);\n  }\n}\n\n// the blob already has a type; do nothing\nvar res$2 = function res$2() {};\n\nfunction defaultBody() {\n  return '';\n}\n\nfunction ajaxCore$1(options, callback) {\n\n  options = clone(options);\n\n  var defaultOptions = {\n    method: \"GET\",\n    headers: {},\n    json: true,\n    processData: true,\n    timeout: 10000,\n    cache: false\n  };\n\n  options = $inject_Object_assign(defaultOptions, options);\n\n  function onSuccess(obj, resp, cb) {\n    if (!options.binary && options.json && typeof obj === 'string') {\n      /* istanbul ignore next */\n      try {\n        obj = JSON.parse(obj);\n      } catch (e) {\n        // Probably a malformed JSON from server\n        return cb(e);\n      }\n    }\n    if (Array.isArray(obj)) {\n      obj = obj.map(function (v) {\n        if (v.error || v.missing) {\n          return generateErrorFromResponse(v);\n        } else {\n          return v;\n        }\n      });\n    }\n    if (options.binary) {\n      res$2(obj, resp);\n    }\n    cb(null, obj, resp);\n  }\n\n  if (options.json) {\n    if (!options.binary) {\n      options.headers.Accept = 'application/json';\n    }\n    options.headers['Content-Type'] = options.headers['Content-Type'] || 'application/json';\n  }\n\n  if (options.binary) {\n    options.encoding = null;\n    options.json = false;\n  }\n\n  if (!options.processData) {\n    options.json = false;\n  }\n\n  return ajax$1(options, function (err, response, body) {\n\n    if (err) {\n      return callback(generateErrorFromResponse(err));\n    }\n\n    var error;\n    var content_type = response.headers && response.headers['content-type'];\n    var data = body || defaultBody();\n\n    // CouchDB doesn't always return the right content-type for JSON data, so\n    // we check for ^{ and }$ (ignoring leading/trailing whitespace)\n    if (!options.binary && (options.json || !options.processData) && typeof data !== 'object' && (/json/.test(content_type) || /^[\\s]*\\{/.test(data) && /\\}[\\s]*$/.test(data))) {\n      try {\n        data = JSON.parse(data.toString());\n      } catch (e) {}\n    }\n\n    if (response.statusCode >= 200 && response.statusCode < 300) {\n      onSuccess(data, response, callback);\n    } else {\n      error = generateErrorFromResponse(data);\n      error.status = response.statusCode;\n      callback(error);\n    }\n  });\n}\n\nfunction ajax(opts, callback) {\n\n  // cache-buster, specifically designed to work around IE's aggressive caching\n  // see http://www.dashbay.com/2011/05/internet-explorer-caches-ajax/\n  // Also Safari caches POSTs, so we need to cache-bust those too.\n  var ua = navigator && navigator.userAgent ? navigator.userAgent.toLowerCase() : '';\n\n  var isSafari = ua.indexOf('safari') !== -1 && ua.indexOf('chrome') === -1;\n  var isIE = ua.indexOf('msie') !== -1;\n  var isEdge = ua.indexOf('edge') !== -1;\n\n  // it appears the new version of safari also caches GETs,\n  // see https://github.com/pouchdb/pouchdb/issues/5010\n  var shouldCacheBust = isSafari || (isIE || isEdge) && opts.method === 'GET';\n\n  var cache = 'cache' in opts ? opts.cache : true;\n\n  var isBlobUrl = /^blob:/.test(opts.url); // don't append nonces for blob URLs\n\n  if (!isBlobUrl && (shouldCacheBust || !cache)) {\n    var hasArgs = opts.url.indexOf('?') !== -1;\n    opts.url += (hasArgs ? '&' : '?') + '_nonce=' + Date.now();\n  }\n\n  return ajaxCore$1(opts, callback);\n}\n\n// dead simple promise pool, inspired by https://github.com/timdp/es6-promise-pool\n// but much smaller in code size. limits the number of concurrent promises that are executed\n\n\nfunction pool(promiseFactories, limit) {\n  return new PouchPromise$1(function (resolve, reject) {\n    var running = 0;\n    var current = 0;\n    var done = 0;\n    var len = promiseFactories.length;\n    var err;\n\n    function runNext() {\n      running++;\n      promiseFactories[current++]().then(onSuccess, onError);\n    }\n\n    function doNext() {\n      if (++done === len) {\n        /* istanbul ignore if */\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      } else {\n        runNextBatch();\n      }\n    }\n\n    function onSuccess() {\n      running--;\n      doNext();\n    }\n\n    /* istanbul ignore next */\n    function onError(thisErr) {\n      running--;\n      err = err || thisErr;\n      doNext();\n    }\n\n    function runNextBatch() {\n      while (running < limit && current < len) {\n        runNext();\n      }\n    }\n\n    runNextBatch();\n  });\n}\n\nvar CHANGES_BATCH_SIZE = 25;\nvar MAX_SIMULTANEOUS_REVS = 50;\nvar CHANGES_TIMEOUT_BUFFER = 5000;\nvar DEFAULT_HEARTBEAT = 10000;\n\nvar supportsBulkGetMap = {};\n\nfunction readAttachmentsAsBlobOrBuffer(row) {\n  var atts = row.doc && row.doc._attachments;\n  if (!atts) {\n    return;\n  }\n  Object.keys(atts).forEach(function (filename) {\n    var att = atts[filename];\n    att.data = b64ToBluffer(att.data, att.content_type);\n  });\n}\n\nfunction encodeDocId(id) {\n  if (/^_design/.test(id)) {\n    return '_design/' + encodeURIComponent(id.slice(8));\n  }\n  if (/^_local/.test(id)) {\n    return '_local/' + encodeURIComponent(id.slice(7));\n  }\n  return encodeURIComponent(id);\n}\n\nfunction preprocessAttachments$2(doc) {\n  if (!doc._attachments || !Object.keys(doc._attachments)) {\n    return PouchPromise$1.resolve();\n  }\n\n  return PouchPromise$1.all(Object.keys(doc._attachments).map(function (key) {\n    var attachment = doc._attachments[key];\n    if (attachment.data && typeof attachment.data !== 'string') {\n      return new PouchPromise$1(function (resolve) {\n        blobToBase64(attachment.data, resolve);\n      }).then(function (b64) {\n        attachment.data = b64;\n      });\n    }\n  }));\n}\n\nfunction hasUrlPrefix(opts) {\n  if (!opts.prefix) {\n    return false;\n  }\n\n  var protocol = parseUri(opts.prefix).protocol;\n\n  return protocol === 'http' || protocol === 'https';\n}\n\n// Get all the information you possibly can about the URI given by name and\n// return it as a suitable object.\nfunction getHost(name, opts) {\n\n  // encode db name if opts.prefix is a url (#5574)\n  if (hasUrlPrefix(opts)) {\n    var dbName = opts.name.substr(opts.prefix.length);\n    name = opts.prefix + encodeURIComponent(dbName);\n  }\n\n  // Prase the URI into all its little bits\n  var uri = parseUri(name);\n\n  // Store the user and password as a separate auth object\n  if (uri.user || uri.password) {\n    uri.auth = { username: uri.user, password: uri.password };\n  }\n\n  // Split the path part of the URI into parts using '/' as the delimiter\n  // after removing any leading '/' and any trailing '/'\n  var parts = uri.path.replace(/(^\\/|\\/$)/g, '').split('/');\n\n  // Store the first part as the database name and remove it from the parts\n  // array\n  uri.db = parts.pop();\n  // Prevent double encoding of URI component\n  if (uri.db.indexOf('%') === -1) {\n    uri.db = encodeURIComponent(uri.db);\n  }\n\n  // Restore the path by joining all the remaining parts (all the parts\n  // except for the database name) with '/'s\n  uri.path = parts.join('/');\n\n  return uri;\n}\n\n// Generate a URL with the host data given by opts and the given path\nfunction genDBUrl(opts, path) {\n  return genUrl(opts, opts.db + '/' + path);\n}\n\n// Generate a URL with the host data given by opts and the given path\nfunction genUrl(opts, path) {\n  // If the host already has a path, then we need to have a path delimiter\n  // Otherwise, the path delimiter is the empty string\n  var pathDel = !opts.path ? '' : '/';\n\n  // If the host already has a path, then we need to have a path delimiter\n  // Otherwise, the path delimiter is the empty string\n  return opts.protocol + '://' + opts.host + (opts.port ? ':' + opts.port : '') + '/' + opts.path + pathDel + path;\n}\n\nfunction paramsToStr(params) {\n  return '?' + Object.keys(params).map(function (k) {\n    return k + '=' + encodeURIComponent(params[k]);\n  }).join('&');\n}\n\n// Implements the PouchDB API for dealing with CouchDB instances over HTTP\nfunction HttpPouch(opts, callback) {\n\n  // The functions that will be publicly available for HttpPouch\n  var api = this;\n\n  var host = getHost(opts.name, opts);\n  var dbUrl = genDBUrl(host, '');\n\n  opts = clone(opts);\n  var ajaxOpts = opts.ajax || {};\n\n  if (opts.auth || host.auth) {\n    var nAuth = opts.auth || host.auth;\n    var str = nAuth.username + ':' + nAuth.password;\n    var token = thisBtoa(unescape(encodeURIComponent(str)));\n    ajaxOpts.headers = ajaxOpts.headers || {};\n    ajaxOpts.headers.Authorization = 'Basic ' + token;\n  }\n\n  // Not strictly necessary, but we do this because numerous tests\n  // rely on swapping ajax in and out.\n  api._ajax = ajax;\n\n  function ajax$$1(userOpts, options, callback) {\n    var reqAjax = userOpts.ajax || {};\n    var reqOpts = $inject_Object_assign(clone(ajaxOpts), reqAjax, options);\n    var defaultHeaders = clone(ajaxOpts.headers || {});\n    reqOpts.headers = $inject_Object_assign(defaultHeaders, reqAjax.headers, options.headers || {});\n    /* istanbul ignore if */\n    if (api.constructor.listeners('debug').length) {\n      api.constructor.emit('debug', ['http', reqOpts.method, reqOpts.url]);\n    }\n    return api._ajax(reqOpts, callback);\n  }\n\n  function ajaxPromise(userOpts, opts) {\n    return new PouchPromise$1(function (resolve, reject) {\n      ajax$$1(userOpts, opts, function (err, res) {\n        /* istanbul ignore if */\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  function adapterFun$$1(name, fun) {\n    return adapterFun(name, __WEBPACK_IMPORTED_MODULE_2_argsarray___default()(function (args) {\n      setup().then(function () {\n        return fun.apply(this, args);\n      }).catch(function (e) {\n        var callback = args.pop();\n        callback(e);\n      });\n    }));\n  }\n\n  var setupPromise;\n\n  function setup() {\n    // TODO: Remove `skipSetup` in favor of `skip_setup` in a future release\n    if (opts.skipSetup || opts.skip_setup) {\n      return PouchPromise$1.resolve();\n    }\n\n    // If there is a setup in process or previous successful setup\n    // done then we will use that\n    // If previous setups have been rejected we will try again\n    if (setupPromise) {\n      return setupPromise;\n    }\n\n    var checkExists = { method: 'GET', url: dbUrl };\n    setupPromise = ajaxPromise({}, checkExists).catch(function (err) {\n      if (err && err.status && err.status === 404) {\n        // Doesnt exist, create it\n        explainError(404, 'PouchDB is just detecting if the remote exists.');\n        return ajaxPromise({}, { method: 'PUT', url: dbUrl });\n      } else {\n        return PouchPromise$1.reject(err);\n      }\n    }).catch(function (err) {\n      // If we try to create a database that already exists, skipped in\n      // istanbul since its catching a race condition.\n      /* istanbul ignore if */\n      if (err && err.status && err.status === 412) {\n        return true;\n      }\n      return PouchPromise$1.reject(err);\n    });\n\n    setupPromise.catch(function () {\n      setupPromise = null;\n    });\n\n    return setupPromise;\n  }\n\n  __WEBPACK_IMPORTED_MODULE_5_immediate___default()(function () {\n    callback(null, api);\n  });\n\n  api._remote = true;\n  /* istanbul ignore next */\n  api.type = function () {\n    return 'http';\n  };\n\n  api.id = adapterFun$$1('id', function (callback) {\n    ajax$$1({}, { method: 'GET', url: genUrl(host, '') }, function (err, result) {\n      var uuid$$1 = result && result.uuid ? result.uuid + host.db : genDBUrl(host, '');\n      callback(null, uuid$$1);\n    });\n  });\n\n  api.request = adapterFun$$1('request', function (options, callback) {\n    options.url = genDBUrl(host, options.url);\n    ajax$$1({}, options, callback);\n  });\n\n  // Sends a POST request to the host calling the couchdb _compact function\n  //    version: The version of CouchDB it is running\n  api.compact = adapterFun$$1('compact', function (opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n    ajax$$1(opts, {\n      url: genDBUrl(host, '_compact'),\n      method: 'POST'\n    }, function () {\n      function ping() {\n        api.info(function (err, res) {\n          // CouchDB may send a \"compact_running:true\" if it's\n          // already compacting. PouchDB Server doesn't.\n          /* istanbul ignore else */\n          if (res && !res.compact_running) {\n            callback(null, { ok: true });\n          } else {\n            setTimeout(ping, opts.interval || 200);\n          }\n        });\n      }\n      // Ping the http if it's finished compaction\n      ping();\n    });\n  });\n\n  api.bulkGet = adapterFun('bulkGet', function (opts, callback) {\n    var self = this;\n\n    function doBulkGet(cb) {\n      var params = {};\n      if (opts.revs) {\n        params.revs = true;\n      }\n      if (opts.attachments) {\n        /* istanbul ignore next */\n        params.attachments = true;\n      }\n      if (opts.latest) {\n        params.latest = true;\n      }\n      ajax$$1(opts, {\n        url: genDBUrl(host, '_bulk_get' + paramsToStr(params)),\n        method: 'POST',\n        body: { docs: opts.docs }\n      }, cb);\n    }\n\n    /* istanbul ignore next */\n    function doBulkGetShim() {\n      // avoid \"url too long error\" by splitting up into multiple requests\n      var batchSize = MAX_SIMULTANEOUS_REVS;\n      var numBatches = Math.ceil(opts.docs.length / batchSize);\n      var numDone = 0;\n      var results = new Array(numBatches);\n\n      function onResult(batchNum) {\n        return function (err, res) {\n          // err is impossible because shim returns a list of errs in that case\n          results[batchNum] = res.results;\n          if (++numDone === numBatches) {\n            callback(null, { results: flatten(results) });\n          }\n        };\n      }\n\n      for (var i = 0; i < numBatches; i++) {\n        var subOpts = pick(opts, ['revs', 'attachments', 'latest']);\n        subOpts.ajax = ajaxOpts;\n        subOpts.docs = opts.docs.slice(i * batchSize, Math.min(opts.docs.length, (i + 1) * batchSize));\n        bulkGet(self, subOpts, onResult(i));\n      }\n    }\n\n    // mark the whole database as either supporting or not supporting _bulk_get\n    var dbUrl = genUrl(host, '');\n    var supportsBulkGet = supportsBulkGetMap[dbUrl];\n\n    /* istanbul ignore next */\n    if (typeof supportsBulkGet !== 'boolean') {\n      // check if this database supports _bulk_get\n      doBulkGet(function (err, res) {\n        if (err) {\n          supportsBulkGetMap[dbUrl] = false;\n          explainError(err.status, 'PouchDB is just detecting if the remote ' + 'supports the _bulk_get API.');\n          doBulkGetShim();\n        } else {\n          supportsBulkGetMap[dbUrl] = true;\n          callback(null, res);\n        }\n      });\n    } else if (supportsBulkGet) {\n      doBulkGet(callback);\n    } else {\n      doBulkGetShim();\n    }\n  });\n\n  // Calls GET on the host, which gets back a JSON string containing\n  //    couchdb: A welcome string\n  //    version: The version of CouchDB it is running\n  api._info = function (callback) {\n    setup().then(function () {\n      ajax$$1({}, {\n        method: 'GET',\n        url: genDBUrl(host, '')\n      }, function (err, res) {\n        /* istanbul ignore next */\n        if (err) {\n          return callback(err);\n        }\n        res.host = genDBUrl(host, '');\n        callback(null, res);\n      });\n    }).catch(callback);\n  };\n\n  // Get the document with the given id from the database given by host.\n  // The id could be solely the _id in the database, or it may be a\n  // _design/ID or _local/ID path\n  api.get = adapterFun$$1('get', function (id, opts, callback) {\n    // If no options were given, set the callback to the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n\n    // List of parameters to add to the GET request\n    var params = {};\n\n    if (opts.revs) {\n      params.revs = true;\n    }\n\n    if (opts.revs_info) {\n      params.revs_info = true;\n    }\n\n    if (opts.latest) {\n      params.latest = true;\n    }\n\n    if (opts.open_revs) {\n      if (opts.open_revs !== \"all\") {\n        opts.open_revs = JSON.stringify(opts.open_revs);\n      }\n      params.open_revs = opts.open_revs;\n    }\n\n    if (opts.rev) {\n      params.rev = opts.rev;\n    }\n\n    if (opts.conflicts) {\n      params.conflicts = opts.conflicts;\n    }\n\n    id = encodeDocId(id);\n\n    // Set the options for the ajax call\n    var options = {\n      method: 'GET',\n      url: genDBUrl(host, id + paramsToStr(params))\n    };\n\n    function fetchAttachments(doc) {\n      var atts = doc._attachments;\n      var filenames = atts && Object.keys(atts);\n      if (!atts || !filenames.length) {\n        return;\n      }\n      // we fetch these manually in separate XHRs, because\n      // Sync Gateway would normally send it back as multipart/mixed,\n      // which we cannot parse. Also, this is more efficient than\n      // receiving attachments as base64-encoded strings.\n      function fetch(filename) {\n        var att = atts[filename];\n        var path = encodeDocId(doc._id) + '/' + encodeAttachmentId(filename) + '?rev=' + doc._rev;\n        return ajaxPromise(opts, {\n          method: 'GET',\n          url: genDBUrl(host, path),\n          binary: true\n        }).then(function (blob) {\n          if (opts.binary) {\n            return blob;\n          }\n          return new PouchPromise$1(function (resolve) {\n            blobToBase64(blob, resolve);\n          });\n        }).then(function (data) {\n          delete att.stub;\n          delete att.length;\n          att.data = data;\n        });\n      }\n\n      var promiseFactories = filenames.map(function (filename) {\n        return function () {\n          return fetch(filename);\n        };\n      });\n\n      // This limits the number of parallel xhr requests to 5 any time\n      // to avoid issues with maximum browser request limits\n      return pool(promiseFactories, 5);\n    }\n\n    function fetchAllAttachments(docOrDocs) {\n      if (Array.isArray(docOrDocs)) {\n        return PouchPromise$1.all(docOrDocs.map(function (doc) {\n          if (doc.ok) {\n            return fetchAttachments(doc.ok);\n          }\n        }));\n      }\n      return fetchAttachments(docOrDocs);\n    }\n\n    ajaxPromise(opts, options).then(function (res) {\n      return PouchPromise$1.resolve().then(function () {\n        if (opts.attachments) {\n          return fetchAllAttachments(res);\n        }\n      }).then(function () {\n        callback(null, res);\n      });\n    }).catch(function (e) {\n      e.docId = id;\n      callback(e);\n    });\n  });\n\n  // Delete the document given by doc from the database given by host.\n  api.remove = adapterFun$$1('remove', function (docOrId, optsOrRev, opts, callback) {\n    var doc;\n    if (typeof optsOrRev === 'string') {\n      // id, rev, opts, callback style\n      doc = {\n        _id: docOrId,\n        _rev: optsOrRev\n      };\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {};\n      }\n    } else {\n      // doc, opts, callback style\n      doc = docOrId;\n      if (typeof optsOrRev === 'function') {\n        callback = optsOrRev;\n        opts = {};\n      } else {\n        callback = opts;\n        opts = optsOrRev;\n      }\n    }\n\n    var rev$$1 = doc._rev || opts.rev;\n\n    // Delete the document\n    ajax$$1(opts, {\n      method: 'DELETE',\n      url: genDBUrl(host, encodeDocId(doc._id)) + '?rev=' + rev$$1\n    }, callback);\n  });\n\n  function encodeAttachmentId(attachmentId) {\n    return attachmentId.split(\"/\").map(encodeURIComponent).join(\"/\");\n  }\n\n  // Get the attachment\n  api.getAttachment = adapterFun$$1('getAttachment', function (docId, attachmentId, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var params = opts.rev ? '?rev=' + opts.rev : '';\n    var url = genDBUrl(host, encodeDocId(docId)) + '/' + encodeAttachmentId(attachmentId) + params;\n    ajax$$1(opts, {\n      method: 'GET',\n      url: url,\n      binary: true\n    }, callback);\n  });\n\n  // Remove the attachment given by the id and rev\n  api.removeAttachment = adapterFun$$1('removeAttachment', function (docId, attachmentId, rev$$1, callback) {\n\n    var url = genDBUrl(host, encodeDocId(docId) + '/' + encodeAttachmentId(attachmentId)) + '?rev=' + rev$$1;\n\n    ajax$$1({}, {\n      method: 'DELETE',\n      url: url\n    }, callback);\n  });\n\n  // Add the attachment given by blob and its contentType property\n  // to the document with the given id, the revision given by rev, and\n  // add it to the database given by host.\n  api.putAttachment = adapterFun$$1('putAttachment', function (docId, attachmentId, rev$$1, blob, type, callback) {\n    if (typeof type === 'function') {\n      callback = type;\n      type = blob;\n      blob = rev$$1;\n      rev$$1 = null;\n    }\n    var id = encodeDocId(docId) + '/' + encodeAttachmentId(attachmentId);\n    var url = genDBUrl(host, id);\n    if (rev$$1) {\n      url += '?rev=' + rev$$1;\n    }\n\n    if (typeof blob === 'string') {\n      // input is assumed to be a base64 string\n      var binary;\n      try {\n        binary = thisAtob(blob);\n      } catch (err) {\n        return callback(createError(BAD_ARG, 'Attachment is not a valid base64 string'));\n      }\n      blob = binary ? binStringToBluffer(binary, type) : '';\n    }\n\n    var opts = {\n      headers: { 'Content-Type': type },\n      method: 'PUT',\n      url: url,\n      processData: false,\n      body: blob,\n      timeout: ajaxOpts.timeout || 60000\n    };\n    // Add the attachment\n    ajax$$1({}, opts, callback);\n  });\n\n  // Update/create multiple documents given by req in the database\n  // given by host.\n  api._bulkDocs = function (req, opts, callback) {\n    // If new_edits=false then it prevents the database from creating\n    // new revision numbers for the documents. Instead it just uses\n    // the old ones. This is used in database replication.\n    req.new_edits = opts.new_edits;\n\n    setup().then(function () {\n      return PouchPromise$1.all(req.docs.map(preprocessAttachments$2));\n    }).then(function () {\n      // Update/create the documents\n      ajax$$1(opts, {\n        method: 'POST',\n        url: genDBUrl(host, '_bulk_docs'),\n        timeout: opts.timeout,\n        body: req\n      }, function (err, results) {\n        if (err) {\n          return callback(err);\n        }\n        results.forEach(function (result) {\n          result.ok = true; // smooths out cloudant not adding this\n        });\n        callback(null, results);\n      });\n    }).catch(callback);\n  };\n\n  // Update/create document\n  api._put = function (doc, opts, callback) {\n    setup().then(function () {\n      return preprocessAttachments$2(doc);\n    }).then(function () {\n      // Update/create the document\n      ajax$$1(opts, {\n        method: 'PUT',\n        url: genDBUrl(host, encodeDocId(doc._id)),\n        body: doc\n      }, function (err, result) {\n        if (err) {\n          err.docId = doc && doc._id;\n          return callback(err);\n        }\n        callback(null, result);\n      });\n    }).catch(callback);\n  };\n\n  // Get a listing of the documents in the database given\n  // by host and ordered by increasing id.\n  api.allDocs = adapterFun$$1('allDocs', function (opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n\n    // List of parameters to add to the GET request\n    var params = {};\n    var body;\n    var method = 'GET';\n\n    if (opts.conflicts) {\n      params.conflicts = true;\n    }\n\n    if (opts.descending) {\n      params.descending = true;\n    }\n\n    if (opts.include_docs) {\n      params.include_docs = true;\n    }\n\n    // added in CouchDB 1.6.0\n    if (opts.attachments) {\n      params.attachments = true;\n    }\n\n    if (opts.key) {\n      params.key = JSON.stringify(opts.key);\n    }\n\n    if (opts.start_key) {\n      opts.startkey = opts.start_key;\n    }\n\n    if (opts.startkey) {\n      params.startkey = JSON.stringify(opts.startkey);\n    }\n\n    if (opts.end_key) {\n      opts.endkey = opts.end_key;\n    }\n\n    if (opts.endkey) {\n      params.endkey = JSON.stringify(opts.endkey);\n    }\n\n    if (typeof opts.inclusive_end !== 'undefined') {\n      params.inclusive_end = !!opts.inclusive_end;\n    }\n\n    if (typeof opts.limit !== 'undefined') {\n      params.limit = opts.limit;\n    }\n\n    if (typeof opts.skip !== 'undefined') {\n      params.skip = opts.skip;\n    }\n\n    var paramStr = paramsToStr(params);\n\n    if (typeof opts.keys !== 'undefined') {\n      method = 'POST';\n      body = { keys: opts.keys };\n    }\n\n    // Get the document listing\n    ajaxPromise(opts, {\n      method: method,\n      url: genDBUrl(host, '_all_docs' + paramStr),\n      body: body\n    }).then(function (res) {\n      if (opts.include_docs && opts.attachments && opts.binary) {\n        res.rows.forEach(readAttachmentsAsBlobOrBuffer);\n      }\n      callback(null, res);\n    }).catch(callback);\n  });\n\n  // Get a list of changes made to documents in the database given by host.\n  // TODO According to the README, there should be two other methods here,\n  // api.changes.addListener and api.changes.removeListener.\n  api._changes = function (opts) {\n\n    // We internally page the results of a changes request, this means\n    // if there is a large set of changes to be returned we can start\n    // processing them quicker instead of waiting on the entire\n    // set of changes to return and attempting to process them at once\n    var batchSize = 'batch_size' in opts ? opts.batch_size : CHANGES_BATCH_SIZE;\n\n    opts = clone(opts);\n\n    if (opts.continuous && !('heartbeat' in opts)) {\n      opts.heartbeat = DEFAULT_HEARTBEAT;\n    }\n\n    var requestTimeout = 'timeout' in opts ? opts.timeout : 'timeout' in ajaxOpts ? ajaxOpts.timeout : 30 * 1000;\n\n    // ensure CHANGES_TIMEOUT_BUFFER applies\n    if ('timeout' in opts && opts.timeout && requestTimeout - opts.timeout < CHANGES_TIMEOUT_BUFFER) {\n      requestTimeout = opts.timeout + CHANGES_TIMEOUT_BUFFER;\n    }\n\n    if ('heartbeat' in opts && opts.heartbeat && requestTimeout - opts.heartbeat < CHANGES_TIMEOUT_BUFFER) {\n      requestTimeout = opts.heartbeat + CHANGES_TIMEOUT_BUFFER;\n    }\n\n    var params = {};\n    if ('timeout' in opts && opts.timeout) {\n      params.timeout = opts.timeout;\n    }\n\n    var limit = typeof opts.limit !== 'undefined' ? opts.limit : false;\n    var returnDocs;\n    if ('return_docs' in opts) {\n      returnDocs = opts.return_docs;\n    } else if ('returnDocs' in opts) {\n      // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n      returnDocs = opts.returnDocs;\n    } else {\n      returnDocs = true;\n    }\n    //\n    var leftToFetch = limit;\n\n    if (opts.style) {\n      params.style = opts.style;\n    }\n\n    if (opts.include_docs || opts.filter && typeof opts.filter === 'function') {\n      params.include_docs = true;\n    }\n\n    if (opts.attachments) {\n      params.attachments = true;\n    }\n\n    if (opts.continuous) {\n      params.feed = 'longpoll';\n    }\n\n    if (opts.conflicts) {\n      params.conflicts = true;\n    }\n\n    if (opts.descending) {\n      params.descending = true;\n    }\n\n    if ('heartbeat' in opts) {\n      // If the heartbeat value is false, it disables the default heartbeat\n      if (opts.heartbeat) {\n        params.heartbeat = opts.heartbeat;\n      }\n    }\n\n    if (opts.filter && typeof opts.filter === 'string') {\n      params.filter = opts.filter;\n    }\n\n    if (opts.view && typeof opts.view === 'string') {\n      params.filter = '_view';\n      params.view = opts.view;\n    }\n\n    // If opts.query_params exists, pass it through to the changes request.\n    // These parameters may be used by the filter on the source database.\n    if (opts.query_params && typeof opts.query_params === 'object') {\n      for (var param_name in opts.query_params) {\n        /* istanbul ignore else */\n        if (opts.query_params.hasOwnProperty(param_name)) {\n          params[param_name] = opts.query_params[param_name];\n        }\n      }\n    }\n\n    var method = 'GET';\n    var body;\n\n    if (opts.doc_ids) {\n      // set this automagically for the user; it's annoying that couchdb\n      // requires both a \"filter\" and a \"doc_ids\" param.\n      params.filter = '_doc_ids';\n      method = 'POST';\n      body = { doc_ids: opts.doc_ids };\n    }\n    /* istanbul ignore next */\n    else if (opts.selector) {\n        // set this automagically for the user, similar to above\n        params.filter = '_selector';\n        method = 'POST';\n        body = { selector: opts.selector };\n      }\n\n    var xhr;\n    var lastFetchedSeq;\n\n    // Get all the changes starting wtih the one immediately after the\n    // sequence number given by since.\n    var fetch = function fetch(since, callback) {\n      if (opts.aborted) {\n        return;\n      }\n      params.since = since;\n      // \"since\" can be any kind of json object in Coudant/CouchDB 2.x\n      /* istanbul ignore next */\n      if (typeof params.since === \"object\") {\n        params.since = JSON.stringify(params.since);\n      }\n\n      if (opts.descending) {\n        if (limit) {\n          params.limit = leftToFetch;\n        }\n      } else {\n        params.limit = !limit || leftToFetch > batchSize ? batchSize : leftToFetch;\n      }\n\n      // Set the options for the ajax call\n      var xhrOpts = {\n        method: method,\n        url: genDBUrl(host, '_changes' + paramsToStr(params)),\n        timeout: requestTimeout,\n        body: body\n      };\n      lastFetchedSeq = since;\n\n      /* istanbul ignore if */\n      if (opts.aborted) {\n        return;\n      }\n\n      // Get the changes\n      setup().then(function () {\n        xhr = ajax$$1(opts, xhrOpts, callback);\n      }).catch(callback);\n    };\n\n    // If opts.since exists, get all the changes from the sequence\n    // number given by opts.since. Otherwise, get all the changes\n    // from the sequence number 0.\n    var results = { results: [] };\n\n    var fetched = function fetched(err, res) {\n      if (opts.aborted) {\n        return;\n      }\n      var raw_results_length = 0;\n      // If the result of the ajax call (res) contains changes (res.results)\n      if (res && res.results) {\n        raw_results_length = res.results.length;\n        results.last_seq = res.last_seq;\n        // For each change\n        var req = {};\n        req.query = opts.query_params;\n        res.results = res.results.filter(function (c) {\n          leftToFetch--;\n          var ret = filterChange(opts)(c);\n          if (ret) {\n            if (opts.include_docs && opts.attachments && opts.binary) {\n              readAttachmentsAsBlobOrBuffer(c);\n            }\n            if (returnDocs) {\n              results.results.push(c);\n            }\n            opts.onChange(c);\n          }\n          return ret;\n        });\n      } else if (err) {\n        // In case of an error, stop listening for changes and call\n        // opts.complete\n        opts.aborted = true;\n        opts.complete(err);\n        return;\n      }\n\n      // The changes feed may have timed out with no results\n      // if so reuse last update sequence\n      if (res && res.last_seq) {\n        lastFetchedSeq = res.last_seq;\n      }\n\n      var finished = limit && leftToFetch <= 0 || res && raw_results_length < batchSize || opts.descending;\n\n      if (opts.continuous && !(limit && leftToFetch <= 0) || !finished) {\n        // Queue a call to fetch again with the newest sequence number\n        __WEBPACK_IMPORTED_MODULE_5_immediate___default()(function () {\n          fetch(lastFetchedSeq, fetched);\n        });\n      } else {\n        // We're done, call the callback\n        opts.complete(null, results);\n      }\n    };\n\n    fetch(opts.since || 0, fetched);\n\n    // Return a method to cancel this method from processing any more\n    return {\n      cancel: function cancel() {\n        opts.aborted = true;\n        if (xhr) {\n          xhr.abort();\n        }\n      }\n    };\n  };\n\n  // Given a set of document/revision IDs (given by req), tets the subset of\n  // those that do NOT correspond to revisions stored in the database.\n  // See http://wiki.apache.org/couchdb/HttpPostRevsDiff\n  api.revsDiff = adapterFun$$1('revsDiff', function (req, opts, callback) {\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    // Get the missing document/revision IDs\n    ajax$$1(opts, {\n      method: 'POST',\n      url: genDBUrl(host, '_revs_diff'),\n      body: req\n    }, callback);\n  });\n\n  api._close = function (callback) {\n    callback();\n  };\n\n  api._destroy = function (options, callback) {\n    ajax$$1(options, {\n      url: genDBUrl(host, ''),\n      method: 'DELETE'\n    }, function (err, resp) {\n      if (err && err.status && err.status !== 404) {\n        return callback(err);\n      }\n      callback(null, resp);\n    });\n  };\n}\n\n// HttpPouch is a valid adapter.\nHttpPouch.valid = function () {\n  return true;\n};\n\nvar HttpPouch$1 = function HttpPouch$1(PouchDB) {\n  PouchDB.adapter('http', HttpPouch, false);\n  PouchDB.adapter('https', HttpPouch, false);\n};\n\nfunction QueryParseError(message) {\n  this.status = 400;\n  this.name = 'query_parse_error';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, QueryParseError);\n  } catch (e) {}\n}\n\n__WEBPACK_IMPORTED_MODULE_4_inherits___default()(QueryParseError, Error);\n\nfunction NotFoundError(message) {\n  this.status = 404;\n  this.name = 'not_found';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, NotFoundError);\n  } catch (e) {}\n}\n\n__WEBPACK_IMPORTED_MODULE_4_inherits___default()(NotFoundError, Error);\n\nfunction BuiltInError(message) {\n  this.status = 500;\n  this.name = 'invalid_value';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, BuiltInError);\n  } catch (e) {}\n}\n\n__WEBPACK_IMPORTED_MODULE_4_inherits___default()(BuiltInError, Error);\n\nfunction promisedCallback(promise, callback) {\n  if (callback) {\n    promise.then(function (res) {\n      __WEBPACK_IMPORTED_MODULE_5_immediate___default()(function () {\n        callback(null, res);\n      });\n    }, function (reason) {\n      __WEBPACK_IMPORTED_MODULE_5_immediate___default()(function () {\n        callback(reason);\n      });\n    });\n  }\n  return promise;\n}\n\nfunction callbackify(fun) {\n  return __WEBPACK_IMPORTED_MODULE_2_argsarray___default()(function (args) {\n    var cb = args.pop();\n    var promise = fun.apply(this, args);\n    if (typeof cb === 'function') {\n      promisedCallback(promise, cb);\n    }\n    return promise;\n  });\n}\n\n// Promise finally util similar to Q.finally\nfunction fin(promise, finalPromiseFactory) {\n  return promise.then(function (res) {\n    return finalPromiseFactory().then(function () {\n      return res;\n    });\n  }, function (reason) {\n    return finalPromiseFactory().then(function () {\n      throw reason;\n    });\n  });\n}\n\nfunction sequentialize(queue, promiseFactory) {\n  return function () {\n    var args = arguments;\n    var that = this;\n    return queue.add(function () {\n      return promiseFactory.apply(that, args);\n    });\n  };\n}\n\n// uniq an array of strings, order not guaranteed\n// similar to underscore/lodash _.uniq\nfunction uniq(arr) {\n  var theSet = new ExportedSet(arr);\n  var result = new Array(theSet.size);\n  var index = -1;\n  theSet.forEach(function (value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nfunction mapToKeysArray(map) {\n  var result = new Array(map.size);\n  var index = -1;\n  map.forEach(function (value, key) {\n    result[++index] = key;\n  });\n  return result;\n}\n\nfunction createBuiltInError(name) {\n  var message = 'builtin ' + name + ' function requires map values to be numbers' + ' or number arrays';\n  return new BuiltInError(message);\n}\n\nfunction sum(values) {\n  var result = 0;\n  for (var i = 0, len = values.length; i < len; i++) {\n    var num = values[i];\n    if (typeof num !== 'number') {\n      if (Array.isArray(num)) {\n        // lists of numbers are also allowed, sum them separately\n        result = typeof result === 'number' ? [result] : result;\n        for (var j = 0, jLen = num.length; j < jLen; j++) {\n          var jNum = num[j];\n          if (typeof jNum !== 'number') {\n            throw createBuiltInError('_sum');\n          } else if (typeof result[j] === 'undefined') {\n            result.push(jNum);\n          } else {\n            result[j] += jNum;\n          }\n        }\n      } else {\n        // not array/number\n        throw createBuiltInError('_sum');\n      }\n    } else if (typeof result === 'number') {\n      result += num;\n    } else {\n      // add number to array\n      result[0] += num;\n    }\n  }\n  return result;\n}\n\nvar log = guardedConsole.bind(null, 'log');\nvar isArray = Array.isArray;\nvar toJSON = JSON.parse;\n\nfunction evalFunctionWithEval(func, emit) {\n  return scopeEval(\"return (\" + func.replace(/;\\s*$/, \"\") + \");\", {\n    emit: emit,\n    sum: sum,\n    log: log,\n    isArray: isArray,\n    toJSON: toJSON\n  });\n}\n\n/*\n * Simple task queue to sequentialize actions. Assumes\n * callbacks will eventually fire (once).\n */\n\nfunction TaskQueue$2() {\n  this.promise = new PouchPromise$1(function (fulfill) {\n    fulfill();\n  });\n}\nTaskQueue$2.prototype.add = function (promiseFactory) {\n  this.promise = this.promise.catch(function () {\n    // just recover\n  }).then(function () {\n    return promiseFactory();\n  });\n  return this.promise;\n};\nTaskQueue$2.prototype.finish = function () {\n  return this.promise;\n};\n\nfunction stringify(input) {\n  if (!input) {\n    return 'undefined'; // backwards compat for empty reduce\n  }\n  // for backwards compat with mapreduce, functions/strings are stringified\n  // as-is. everything else is JSON-stringified.\n  switch (typeof input) {\n    case 'function':\n      // e.g. a mapreduce map\n      return input.toString();\n    case 'string':\n      // e.g. a mapreduce built-in _reduce function\n      return input.toString();\n    default:\n      // e.g. a JSON object in the case of mango queries\n      return JSON.stringify(input);\n  }\n}\n\n/* create a string signature for a view so we can cache it and uniq it */\nfunction createViewSignature(mapFun, reduceFun) {\n  // the \"undefined\" part is for backwards compatibility\n  return stringify(mapFun) + stringify(reduceFun) + 'undefined';\n}\n\nfunction createView(sourceDB, viewName, mapFun, reduceFun, temporary, localDocName) {\n  var viewSignature = createViewSignature(mapFun, reduceFun);\n\n  var cachedViews;\n  if (!temporary) {\n    // cache this to ensure we don't try to update the same view twice\n    cachedViews = sourceDB._cachedViews = sourceDB._cachedViews || {};\n    if (cachedViews[viewSignature]) {\n      return cachedViews[viewSignature];\n    }\n  }\n\n  var promiseForView = sourceDB.info().then(function (info) {\n\n    var depDbName = info.db_name + '-mrview-' + (temporary ? 'temp' : stringMd5(viewSignature));\n\n    // save the view name in the source db so it can be cleaned up if necessary\n    // (e.g. when the _design doc is deleted, remove all associated view data)\n    function diffFunction(doc) {\n      doc.views = doc.views || {};\n      var fullViewName = viewName;\n      if (fullViewName.indexOf('/') === -1) {\n        fullViewName = viewName + '/' + viewName;\n      }\n      var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};\n      /* istanbul ignore if */\n      if (depDbs[depDbName]) {\n        return; // no update necessary\n      }\n      depDbs[depDbName] = true;\n      return doc;\n    }\n    return upsert(sourceDB, '_local/' + localDocName, diffFunction).then(function () {\n      return sourceDB.registerDependentDatabase(depDbName).then(function (res) {\n        var db = res.db;\n        db.auto_compaction = true;\n        var view = {\n          name: depDbName,\n          db: db,\n          sourceDB: sourceDB,\n          adapter: sourceDB.adapter,\n          mapFun: mapFun,\n          reduceFun: reduceFun\n        };\n        return view.db.get('_local/lastSeq').catch(function (err) {\n          /* istanbul ignore if */\n          if (err.status !== 404) {\n            throw err;\n          }\n        }).then(function (lastSeqDoc) {\n          view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;\n          if (cachedViews) {\n            view.db.once('destroyed', function () {\n              delete cachedViews[viewSignature];\n            });\n          }\n          return view;\n        });\n      });\n    });\n  });\n\n  if (cachedViews) {\n    cachedViews[viewSignature] = promiseForView;\n  }\n  return promiseForView;\n}\n\nvar persistentQueues = {};\nvar tempViewQueue = new TaskQueue$2();\nvar CHANGES_BATCH_SIZE$1 = 50;\n\nfunction parseViewName(name) {\n  // can be either 'ddocname/viewname' or just 'viewname'\n  // (where the ddoc name is the same)\n  return name.indexOf('/') === -1 ? [name, name] : name.split('/');\n}\n\nfunction isGenOne(changes) {\n  // only return true if the current change is 1-\n  // and there are no other leafs\n  return changes.length === 1 && /^1-/.test(changes[0].rev);\n}\n\nfunction emitError(db, e) {\n  try {\n    db.emit('error', e);\n  } catch (err) {\n    guardedConsole('error', 'The user\\'s map/reduce function threw an uncaught error.\\n' + 'You can debug this error by doing:\\n' + 'myDatabase.on(\\'error\\', function (err) { debugger; });\\n' + 'Please double-check your map/reduce function.');\n    guardedConsole('error', e);\n  }\n}\n\n/**\n * Returns an \"abstract\" mapreduce object of the form:\n *\n *   {\n *     query: queryFun,\n *     viewCleanup: viewCleanupFun\n *   }\n *\n * Arguments are:\n *\n * localDoc: string\n *   This is for the local doc that gets saved in order to track the\n *   \"dependent\" DBs and clean them up for viewCleanup. It should be\n *   unique, so that indexer plugins don't collide with each other.\n * mapper: function (mapFunDef, emit)\n *   Returns a map function based on the mapFunDef, which in the case of\n *   normal map/reduce is just the de-stringified function, but may be\n *   something else, such as an object in the case of pouchdb-find.\n * reducer: function (reduceFunDef)\n *   Ditto, but for reducing. Modules don't have to support reducing\n *   (e.g. pouchdb-find).\n * ddocValidator: function (ddoc, viewName)\n *   Throws an error if the ddoc or viewName is not valid.\n *   This could be a way to communicate to the user that the configuration for the\n *   indexer is invalid.\n */\nfunction createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator) {\n\n  function tryMap(db, fun, doc) {\n    // emit an event if there was an error thrown by a map function.\n    // putting try/catches in a single function also avoids deoptimizations.\n    try {\n      fun(doc);\n    } catch (e) {\n      emitError(db, e);\n    }\n  }\n\n  function tryReduce(db, fun, keys, values, rereduce) {\n    // same as above, but returning the result or an error. there are two separate\n    // functions to avoid extra memory allocations since the tryCode() case is used\n    // for custom map functions (common) vs this function, which is only used for\n    // custom reduce functions (rare)\n    try {\n      return { output: fun(keys, values, rereduce) };\n    } catch (e) {\n      emitError(db, e);\n      return { error: e };\n    }\n  }\n\n  function sortByKeyThenValue(x, y) {\n    var keyCompare = collate(x.key, y.key);\n    return keyCompare !== 0 ? keyCompare : collate(x.value, y.value);\n  }\n\n  function sliceResults(results, limit, skip) {\n    skip = skip || 0;\n    if (typeof limit === 'number') {\n      return results.slice(skip, limit + skip);\n    } else if (skip > 0) {\n      return results.slice(skip);\n    }\n    return results;\n  }\n\n  function rowToDocId(row) {\n    var val = row.value;\n    // Users can explicitly specify a joined doc _id, or it\n    // defaults to the doc _id that emitted the key/value.\n    var docId = val && typeof val === 'object' && val._id || row.id;\n    return docId;\n  }\n\n  function readAttachmentsAsBlobOrBuffer(res) {\n    res.rows.forEach(function (row) {\n      var atts = row.doc && row.doc._attachments;\n      if (!atts) {\n        return;\n      }\n      Object.keys(atts).forEach(function (filename) {\n        var att = atts[filename];\n        atts[filename].data = b64ToBluffer(att.data, att.content_type);\n      });\n    });\n  }\n\n  function postprocessAttachments(opts) {\n    return function (res) {\n      if (opts.include_docs && opts.attachments && opts.binary) {\n        readAttachmentsAsBlobOrBuffer(res);\n      }\n      return res;\n    };\n  }\n\n  function addHttpParam(paramName, opts, params, asJson) {\n    // add an http param from opts to params, optionally json-encoded\n    var val = opts[paramName];\n    if (typeof val !== 'undefined') {\n      if (asJson) {\n        val = encodeURIComponent(JSON.stringify(val));\n      }\n      params.push(paramName + '=' + val);\n    }\n  }\n\n  function coerceInteger(integerCandidate) {\n    if (typeof integerCandidate !== 'undefined') {\n      var asNumber = Number(integerCandidate);\n      // prevents e.g. '1foo' or '1.1' being coerced to 1\n      if (!isNaN(asNumber) && asNumber === parseInt(integerCandidate, 10)) {\n        return asNumber;\n      } else {\n        return integerCandidate;\n      }\n    }\n  }\n\n  function coerceOptions(opts) {\n    opts.group_level = coerceInteger(opts.group_level);\n    opts.limit = coerceInteger(opts.limit);\n    opts.skip = coerceInteger(opts.skip);\n    return opts;\n  }\n\n  function checkPositiveInteger(number) {\n    if (number) {\n      if (typeof number !== 'number') {\n        return new QueryParseError('Invalid value for integer: \"' + number + '\"');\n      }\n      if (number < 0) {\n        return new QueryParseError('Invalid value for positive integer: ' + '\"' + number + '\"');\n      }\n    }\n  }\n\n  function checkQueryParseError(options, fun) {\n    var startkeyName = options.descending ? 'endkey' : 'startkey';\n    var endkeyName = options.descending ? 'startkey' : 'endkey';\n\n    if (typeof options[startkeyName] !== 'undefined' && typeof options[endkeyName] !== 'undefined' && collate(options[startkeyName], options[endkeyName]) > 0) {\n      throw new QueryParseError('No rows can match your key range, ' + 'reverse your start_key and end_key or set {descending : true}');\n    } else if (fun.reduce && options.reduce !== false) {\n      if (options.include_docs) {\n        throw new QueryParseError('{include_docs:true} is invalid for reduce');\n      } else if (options.keys && options.keys.length > 1 && !options.group && !options.group_level) {\n        throw new QueryParseError('Multi-key fetches for reduce views must use ' + '{group: true}');\n      }\n    }\n    ['group_level', 'limit', 'skip'].forEach(function (optionName) {\n      var error = checkPositiveInteger(options[optionName]);\n      if (error) {\n        throw error;\n      }\n    });\n  }\n\n  function httpQuery(db, fun, opts) {\n    // List of parameters to add to the PUT request\n    var params = [];\n    var body;\n    var method = 'GET';\n\n    // If opts.reduce exists and is defined, then add it to the list\n    // of parameters.\n    // If reduce=false then the results are that of only the map function\n    // not the final result of map and reduce.\n    addHttpParam('reduce', opts, params);\n    addHttpParam('include_docs', opts, params);\n    addHttpParam('attachments', opts, params);\n    addHttpParam('limit', opts, params);\n    addHttpParam('descending', opts, params);\n    addHttpParam('group', opts, params);\n    addHttpParam('group_level', opts, params);\n    addHttpParam('skip', opts, params);\n    addHttpParam('stale', opts, params);\n    addHttpParam('conflicts', opts, params);\n    addHttpParam('startkey', opts, params, true);\n    addHttpParam('start_key', opts, params, true);\n    addHttpParam('endkey', opts, params, true);\n    addHttpParam('end_key', opts, params, true);\n    addHttpParam('inclusive_end', opts, params);\n    addHttpParam('key', opts, params, true);\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    params = params === '' ? '' : '?' + params;\n\n    // If keys are supplied, issue a POST to circumvent GET query string limits\n    // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\n    if (typeof opts.keys !== 'undefined') {\n      var MAX_URL_LENGTH = 2000;\n      // according to http://stackoverflow.com/a/417184/680742,\n      // the de facto URL length limit is 2000 characters\n\n      var keysAsString = 'keys=' + encodeURIComponent(JSON.stringify(opts.keys));\n      if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {\n        // If the keys are short enough, do a GET. we do this to work around\n        // Safari not understanding 304s on POSTs (see pouchdb/pouchdb#1239)\n        params += (params[0] === '?' ? '&' : '?') + keysAsString;\n      } else {\n        method = 'POST';\n        if (typeof fun === 'string') {\n          body = { keys: opts.keys };\n        } else {\n          // fun is {map : mapfun}, so append to this\n          fun.keys = opts.keys;\n        }\n      }\n    }\n\n    // We are referencing a query defined in the design doc\n    if (typeof fun === 'string') {\n      var parts = parseViewName(fun);\n      return db.request({\n        method: method,\n        url: '_design/' + parts[0] + '/_view/' + parts[1] + params,\n        body: body\n      }).then(\n      /* istanbul ignore next */\n      function (result) {\n        // fail the entire request if the result contains an error\n        result.rows.forEach(function (row) {\n          if (row.value && row.value.error && row.value.error === \"builtin_reduce_error\") {\n            throw new Error(row.reason);\n          }\n        });\n\n        return result;\n      }).then(postprocessAttachments(opts));\n    }\n\n    // We are using a temporary view, terrible for performance, good for testing\n    body = body || {};\n    Object.keys(fun).forEach(function (key) {\n      if (Array.isArray(fun[key])) {\n        body[key] = fun[key];\n      } else {\n        body[key] = fun[key].toString();\n      }\n    });\n    return db.request({\n      method: 'POST',\n      url: '_temp_view' + params,\n      body: body\n    }).then(postprocessAttachments(opts));\n  }\n\n  // custom adapters can define their own api._query\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customQuery(db, fun, opts) {\n    return new PouchPromise$1(function (resolve, reject) {\n      db._query(fun, opts, function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  // custom adapters can define their own api._viewCleanup\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customViewCleanup(db) {\n    return new PouchPromise$1(function (resolve, reject) {\n      db._viewCleanup(function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  function defaultsTo(value) {\n    return function (reason) {\n      /* istanbul ignore else */\n      if (reason.status === 404) {\n        return value;\n      } else {\n        throw reason;\n      }\n    };\n  }\n\n  // returns a promise for a list of docs to update, based on the input docId.\n  // the order doesn't matter, because post-3.2.0, bulkDocs\n  // is an atomic operation in all three adapters.\n  function getDocsToPersist(docId, view, docIdsToChangesAndEmits) {\n    var metaDocId = '_local/doc_' + docId;\n    var defaultMetaDoc = { _id: metaDocId, keys: [] };\n    var docData = docIdsToChangesAndEmits.get(docId);\n    var indexableKeysToKeyValues = docData[0];\n    var changes = docData[1];\n\n    function getMetaDoc() {\n      if (isGenOne(changes)) {\n        // generation 1, so we can safely assume initial state\n        // for performance reasons (avoids unnecessary GETs)\n        return PouchPromise$1.resolve(defaultMetaDoc);\n      }\n      return view.db.get(metaDocId).catch(defaultsTo(defaultMetaDoc));\n    }\n\n    function getKeyValueDocs(metaDoc) {\n      if (!metaDoc.keys.length) {\n        // no keys, no need for a lookup\n        return PouchPromise$1.resolve({ rows: [] });\n      }\n      return view.db.allDocs({\n        keys: metaDoc.keys,\n        include_docs: true\n      });\n    }\n\n    function processKeyValueDocs(metaDoc, kvDocsRes) {\n      var kvDocs = [];\n      var oldKeys = new ExportedSet();\n\n      for (var i = 0, len = kvDocsRes.rows.length; i < len; i++) {\n        var row = kvDocsRes.rows[i];\n        var doc = row.doc;\n        if (!doc) {\n          // deleted\n          continue;\n        }\n        kvDocs.push(doc);\n        oldKeys.add(doc._id);\n        doc._deleted = !indexableKeysToKeyValues.has(doc._id);\n        if (!doc._deleted) {\n          var keyValue = indexableKeysToKeyValues.get(doc._id);\n          if ('value' in keyValue) {\n            doc.value = keyValue.value;\n          }\n        }\n      }\n      var newKeys = mapToKeysArray(indexableKeysToKeyValues);\n      newKeys.forEach(function (key) {\n        if (!oldKeys.has(key)) {\n          // new doc\n          var kvDoc = {\n            _id: key\n          };\n          var keyValue = indexableKeysToKeyValues.get(key);\n          if ('value' in keyValue) {\n            kvDoc.value = keyValue.value;\n          }\n          kvDocs.push(kvDoc);\n        }\n      });\n      metaDoc.keys = uniq(newKeys.concat(metaDoc.keys));\n      kvDocs.push(metaDoc);\n\n      return kvDocs;\n    }\n\n    return getMetaDoc().then(function (metaDoc) {\n      return getKeyValueDocs(metaDoc).then(function (kvDocsRes) {\n        return processKeyValueDocs(metaDoc, kvDocsRes);\n      });\n    });\n  }\n\n  // updates all emitted key/value docs and metaDocs in the mrview database\n  // for the given batch of documents from the source database\n  function saveKeyValues(view, docIdsToChangesAndEmits, seq) {\n    var seqDocId = '_local/lastSeq';\n    return view.db.get(seqDocId).catch(defaultsTo({ _id: seqDocId, seq: 0 })).then(function (lastSeqDoc) {\n      var docIds = mapToKeysArray(docIdsToChangesAndEmits);\n      return PouchPromise$1.all(docIds.map(function (docId) {\n        return getDocsToPersist(docId, view, docIdsToChangesAndEmits);\n      })).then(function (listOfDocsToPersist) {\n        var docsToPersist = flatten(listOfDocsToPersist);\n        lastSeqDoc.seq = seq;\n        docsToPersist.push(lastSeqDoc);\n        // write all docs in a single operation, update the seq once\n        return view.db.bulkDocs({ docs: docsToPersist });\n      });\n    });\n  }\n\n  function getQueue(view) {\n    var viewName = typeof view === 'string' ? view : view.name;\n    var queue = persistentQueues[viewName];\n    if (!queue) {\n      queue = persistentQueues[viewName] = new TaskQueue$2();\n    }\n    return queue;\n  }\n\n  function updateView(view) {\n    return sequentialize(getQueue(view), function () {\n      return updateViewInQueue(view);\n    })();\n  }\n\n  function updateViewInQueue(view) {\n    // bind the emit function once\n    var mapResults;\n    var doc;\n\n    function emit(key, value) {\n      var output = { id: doc._id, key: normalizeKey(key) };\n      // Don't explicitly store the value unless it's defined and non-null.\n      // This saves on storage space, because often people don't use it.\n      if (typeof value !== 'undefined' && value !== null) {\n        output.value = normalizeKey(value);\n      }\n      mapResults.push(output);\n    }\n\n    var mapFun = mapper(view.mapFun, emit);\n\n    var currentSeq = view.seq || 0;\n\n    function processChange(docIdsToChangesAndEmits, seq) {\n      return function () {\n        return saveKeyValues(view, docIdsToChangesAndEmits, seq);\n      };\n    }\n\n    var queue = new TaskQueue$2();\n\n    function processNextBatch() {\n      return view.sourceDB.changes({\n        conflicts: true,\n        include_docs: true,\n        style: 'all_docs',\n        since: currentSeq,\n        limit: CHANGES_BATCH_SIZE$1\n      }).then(processBatch);\n    }\n\n    function processBatch(response) {\n      var results = response.results;\n      if (!results.length) {\n        return;\n      }\n      var docIdsToChangesAndEmits = createDocIdsToChangesAndEmits(results);\n      queue.add(processChange(docIdsToChangesAndEmits, currentSeq));\n      if (results.length < CHANGES_BATCH_SIZE$1) {\n        return;\n      }\n      return processNextBatch();\n    }\n\n    function createDocIdsToChangesAndEmits(results) {\n      var docIdsToChangesAndEmits = new ExportedMap();\n      for (var i = 0, len = results.length; i < len; i++) {\n        var change = results[i];\n        if (change.doc._id[0] !== '_') {\n          mapResults = [];\n          doc = change.doc;\n\n          if (!doc._deleted) {\n            tryMap(view.sourceDB, mapFun, doc);\n          }\n          mapResults.sort(sortByKeyThenValue);\n\n          var indexableKeysToKeyValues = createIndexableKeysToKeyValues(mapResults);\n          docIdsToChangesAndEmits.set(change.doc._id, [indexableKeysToKeyValues, change.changes]);\n        }\n        currentSeq = change.seq;\n      }\n      return docIdsToChangesAndEmits;\n    }\n\n    function createIndexableKeysToKeyValues(mapResults) {\n      var indexableKeysToKeyValues = new ExportedMap();\n      var lastKey;\n      for (var i = 0, len = mapResults.length; i < len; i++) {\n        var emittedKeyValue = mapResults[i];\n        var complexKey = [emittedKeyValue.key, emittedKeyValue.id];\n        if (i > 0 && collate(emittedKeyValue.key, lastKey) === 0) {\n          complexKey.push(i); // dup key+id, so make it unique\n        }\n        indexableKeysToKeyValues.set(toIndexableString(complexKey), emittedKeyValue);\n        lastKey = emittedKeyValue.key;\n      }\n      return indexableKeysToKeyValues;\n    }\n\n    return processNextBatch().then(function () {\n      return queue.finish();\n    }).then(function () {\n      view.seq = currentSeq;\n    });\n  }\n\n  function reduceView(view, results, options) {\n    if (options.group_level === 0) {\n      delete options.group_level;\n    }\n\n    var shouldGroup = options.group || options.group_level;\n\n    var reduceFun = reducer(view.reduceFun);\n\n    var groups = [];\n    var lvl = isNaN(options.group_level) ? Number.POSITIVE_INFINITY : options.group_level;\n    results.forEach(function (e) {\n      var last = groups[groups.length - 1];\n      var groupKey = shouldGroup ? e.key : null;\n\n      // only set group_level for array keys\n      if (shouldGroup && Array.isArray(groupKey)) {\n        groupKey = groupKey.slice(0, lvl);\n      }\n\n      if (last && collate(last.groupKey, groupKey) === 0) {\n        last.keys.push([e.key, e.id]);\n        last.values.push(e.value);\n        return;\n      }\n      groups.push({\n        keys: [[e.key, e.id]],\n        values: [e.value],\n        groupKey: groupKey\n      });\n    });\n    results = [];\n    for (var i = 0, len = groups.length; i < len; i++) {\n      var e = groups[i];\n      var reduceTry = tryReduce(view.sourceDB, reduceFun, e.keys, e.values, false);\n      if (reduceTry.error && reduceTry.error instanceof BuiltInError) {\n        // CouchDB returns an error if a built-in errors out\n        throw reduceTry.error;\n      }\n      results.push({\n        // CouchDB just sets the value to null if a non-built-in errors out\n        value: reduceTry.error ? null : reduceTry.output,\n        key: e.groupKey\n      });\n    }\n    // no total_rows/offset when reducing\n    return { rows: sliceResults(results, options.limit, options.skip) };\n  }\n\n  function queryView(view, opts) {\n    return sequentialize(getQueue(view), function () {\n      return queryViewInQueue(view, opts);\n    })();\n  }\n\n  function queryViewInQueue(view, opts) {\n    var totalRows;\n    var shouldReduce = view.reduceFun && opts.reduce !== false;\n    var skip = opts.skip || 0;\n    if (typeof opts.keys !== 'undefined' && !opts.keys.length) {\n      // equivalent query\n      opts.limit = 0;\n      delete opts.keys;\n    }\n\n    function fetchFromView(viewOpts) {\n      viewOpts.include_docs = true;\n      return view.db.allDocs(viewOpts).then(function (res) {\n        totalRows = res.total_rows;\n        return res.rows.map(function (result) {\n\n          // implicit migration - in older versions of PouchDB,\n          // we explicitly stored the doc as {id: ..., key: ..., value: ...}\n          // this is tested in a migration test\n          /* istanbul ignore next */\n          if ('value' in result.doc && typeof result.doc.value === 'object' && result.doc.value !== null) {\n            var keys = Object.keys(result.doc.value).sort();\n            // this detection method is not perfect, but it's unlikely the user\n            // emitted a value which was an object with these 3 exact keys\n            var expectedKeys = ['id', 'key', 'value'];\n            if (!(keys < expectedKeys || keys > expectedKeys)) {\n              return result.doc.value;\n            }\n          }\n\n          var parsedKeyAndDocId = parseIndexableString(result.doc._id);\n          return {\n            key: parsedKeyAndDocId[0],\n            id: parsedKeyAndDocId[1],\n            value: 'value' in result.doc ? result.doc.value : null\n          };\n        });\n      });\n    }\n\n    function onMapResultsReady(rows) {\n      var finalResults;\n      if (shouldReduce) {\n        finalResults = reduceView(view, rows, opts);\n      } else {\n        finalResults = {\n          total_rows: totalRows,\n          offset: skip,\n          rows: rows\n        };\n      }\n      if (opts.include_docs) {\n        var docIds = uniq(rows.map(rowToDocId));\n\n        return view.sourceDB.allDocs({\n          keys: docIds,\n          include_docs: true,\n          conflicts: opts.conflicts,\n          attachments: opts.attachments,\n          binary: opts.binary\n        }).then(function (allDocsRes) {\n          var docIdsToDocs = new ExportedMap();\n          allDocsRes.rows.forEach(function (row) {\n            docIdsToDocs.set(row.id, row.doc);\n          });\n          rows.forEach(function (row) {\n            var docId = rowToDocId(row);\n            var doc = docIdsToDocs.get(docId);\n            if (doc) {\n              row.doc = doc;\n            }\n          });\n          return finalResults;\n        });\n      } else {\n        return finalResults;\n      }\n    }\n\n    if (typeof opts.keys !== 'undefined') {\n      var keys = opts.keys;\n      var fetchPromises = keys.map(function (key) {\n        var viewOpts = {\n          startkey: toIndexableString([key]),\n          endkey: toIndexableString([key, {}])\n        };\n        return fetchFromView(viewOpts);\n      });\n      return PouchPromise$1.all(fetchPromises).then(flatten).then(onMapResultsReady);\n    } else {\n      // normal query, no 'keys'\n      var viewOpts = {\n        descending: opts.descending\n      };\n      var startkey;\n      var endkey;\n      if ('start_key' in opts) {\n        startkey = opts.start_key;\n      }\n      if ('startkey' in opts) {\n        startkey = opts.startkey;\n      }\n      if ('end_key' in opts) {\n        endkey = opts.end_key;\n      }\n      if ('endkey' in opts) {\n        endkey = opts.endkey;\n      }\n      if (typeof startkey !== 'undefined') {\n        viewOpts.startkey = opts.descending ? toIndexableString([startkey, {}]) : toIndexableString([startkey]);\n      }\n      if (typeof endkey !== 'undefined') {\n        var inclusiveEnd = opts.inclusive_end !== false;\n        if (opts.descending) {\n          inclusiveEnd = !inclusiveEnd;\n        }\n\n        viewOpts.endkey = toIndexableString(inclusiveEnd ? [endkey, {}] : [endkey]);\n      }\n      if (typeof opts.key !== 'undefined') {\n        var keyStart = toIndexableString([opts.key]);\n        var keyEnd = toIndexableString([opts.key, {}]);\n        if (viewOpts.descending) {\n          viewOpts.endkey = keyStart;\n          viewOpts.startkey = keyEnd;\n        } else {\n          viewOpts.startkey = keyStart;\n          viewOpts.endkey = keyEnd;\n        }\n      }\n      if (!shouldReduce) {\n        if (typeof opts.limit === 'number') {\n          viewOpts.limit = opts.limit;\n        }\n        viewOpts.skip = skip;\n      }\n      return fetchFromView(viewOpts).then(onMapResultsReady);\n    }\n  }\n\n  function httpViewCleanup(db) {\n    return db.request({\n      method: 'POST',\n      url: '_view_cleanup'\n    });\n  }\n\n  function localViewCleanup(db) {\n    return db.get('_local/' + localDocName).then(function (metaDoc) {\n      var docsToViews = new ExportedMap();\n      Object.keys(metaDoc.views).forEach(function (fullViewName) {\n        var parts = parseViewName(fullViewName);\n        var designDocName = '_design/' + parts[0];\n        var viewName = parts[1];\n        var views = docsToViews.get(designDocName);\n        if (!views) {\n          views = new ExportedSet();\n          docsToViews.set(designDocName, views);\n        }\n        views.add(viewName);\n      });\n      var opts = {\n        keys: mapToKeysArray(docsToViews),\n        include_docs: true\n      };\n      return db.allDocs(opts).then(function (res) {\n        var viewsToStatus = {};\n        res.rows.forEach(function (row) {\n          var ddocName = row.key.substring(8); // cuts off '_design/'\n          docsToViews.get(row.key).forEach(function (viewName) {\n            var fullViewName = ddocName + '/' + viewName;\n            /* istanbul ignore if */\n            if (!metaDoc.views[fullViewName]) {\n              // new format, without slashes, to support PouchDB 2.2.0\n              // migration test in pouchdb's browser.migration.js verifies this\n              fullViewName = viewName;\n            }\n            var viewDBNames = Object.keys(metaDoc.views[fullViewName]);\n            // design doc deleted, or view function nonexistent\n            var statusIsGood = row.doc && row.doc.views && row.doc.views[viewName];\n            viewDBNames.forEach(function (viewDBName) {\n              viewsToStatus[viewDBName] = viewsToStatus[viewDBName] || statusIsGood;\n            });\n          });\n        });\n        var dbsToDelete = Object.keys(viewsToStatus).filter(function (viewDBName) {\n          return !viewsToStatus[viewDBName];\n        });\n        var destroyPromises = dbsToDelete.map(function (viewDBName) {\n          return sequentialize(getQueue(viewDBName), function () {\n            return new db.constructor(viewDBName, db.__opts).destroy();\n          })();\n        });\n        return PouchPromise$1.all(destroyPromises).then(function () {\n          return { ok: true };\n        });\n      });\n    }, defaultsTo({ ok: true }));\n  }\n\n  function queryPromised(db, fun, opts) {\n    /* istanbul ignore next */\n    if (typeof db._query === 'function') {\n      return customQuery(db, fun, opts);\n    }\n    if (isRemote(db)) {\n      return httpQuery(db, fun, opts);\n    }\n\n    if (typeof fun !== 'string') {\n      // temp_view\n      checkQueryParseError(opts, fun);\n\n      tempViewQueue.add(function () {\n        var createViewPromise = createView(\n        /* sourceDB */db,\n        /* viewName */'temp_view/temp_view',\n        /* mapFun */fun.map,\n        /* reduceFun */fun.reduce,\n        /* temporary */true,\n        /* localDocName */localDocName);\n        return createViewPromise.then(function (view) {\n          return fin(updateView(view).then(function () {\n            return queryView(view, opts);\n          }), function () {\n            return view.db.destroy();\n          });\n        });\n      });\n      return tempViewQueue.finish();\n    } else {\n      // persistent view\n      var fullViewName = fun;\n      var parts = parseViewName(fullViewName);\n      var designDocName = parts[0];\n      var viewName = parts[1];\n      return db.get('_design/' + designDocName).then(function (doc) {\n        var fun = doc.views && doc.views[viewName];\n\n        if (!fun) {\n          // basic validator; it's assumed that every subclass would want this\n          throw new NotFoundError('ddoc ' + doc._id + ' has no view named ' + viewName);\n        }\n\n        ddocValidator(doc, viewName);\n        checkQueryParseError(opts, fun);\n\n        var createViewPromise = createView(\n        /* sourceDB */db,\n        /* viewName */fullViewName,\n        /* mapFun */fun.map,\n        /* reduceFun */fun.reduce,\n        /* temporary */false,\n        /* localDocName */localDocName);\n        return createViewPromise.then(function (view) {\n          if (opts.stale === 'ok' || opts.stale === 'update_after') {\n            if (opts.stale === 'update_after') {\n              __WEBPACK_IMPORTED_MODULE_5_immediate___default()(function () {\n                updateView(view);\n              });\n            }\n            return queryView(view, opts);\n          } else {\n            // stale not ok\n            return updateView(view).then(function () {\n              return queryView(view, opts);\n            });\n          }\n        });\n      });\n    }\n  }\n\n  function abstractQuery(fun, opts, callback) {\n    var db = this;\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = opts ? coerceOptions(opts) : {};\n\n    if (typeof fun === 'function') {\n      fun = { map: fun };\n    }\n\n    var promise = PouchPromise$1.resolve().then(function () {\n      return queryPromised(db, fun, opts);\n    });\n    promisedCallback(promise, callback);\n    return promise;\n  }\n\n  var abstractViewCleanup = callbackify(function () {\n    var db = this;\n    /* istanbul ignore next */\n    if (typeof db._viewCleanup === 'function') {\n      return customViewCleanup(db);\n    }\n    if (isRemote(db)) {\n      return httpViewCleanup(db);\n    }\n    return localViewCleanup(db);\n  });\n\n  return {\n    query: abstractQuery,\n    viewCleanup: abstractViewCleanup\n  };\n}\n\nvar builtInReduce = {\n  _sum: function _sum(keys, values) {\n    return sum(values);\n  },\n\n  _count: function _count(keys, values) {\n    return values.length;\n  },\n\n  _stats: function _stats(keys, values) {\n    // no need to implement rereduce=true, because Pouch\n    // will never call it\n    function sumsqr(values) {\n      var _sumsqr = 0;\n      for (var i = 0, len = values.length; i < len; i++) {\n        var num = values[i];\n        _sumsqr += num * num;\n      }\n      return _sumsqr;\n    }\n    return {\n      sum: sum(values),\n      min: Math.min.apply(null, values),\n      max: Math.max.apply(null, values),\n      count: values.length,\n      sumsqr: sumsqr(values)\n    };\n  }\n};\n\nfunction getBuiltIn(reduceFunString) {\n  if (/^_sum/.test(reduceFunString)) {\n    return builtInReduce._sum;\n  } else if (/^_count/.test(reduceFunString)) {\n    return builtInReduce._count;\n  } else if (/^_stats/.test(reduceFunString)) {\n    return builtInReduce._stats;\n  } else if (/^_/.test(reduceFunString)) {\n    throw new Error(reduceFunString + ' is not a supported reduce function.');\n  }\n}\n\nfunction mapper(mapFun, emit) {\n  // for temp_views one can use emit(doc, emit), see #38\n  if (typeof mapFun === \"function\" && mapFun.length === 2) {\n    var origMap = mapFun;\n    return function (doc) {\n      return origMap(doc, emit);\n    };\n  } else {\n    return evalFunctionWithEval(mapFun.toString(), emit);\n  }\n}\n\nfunction reducer(reduceFun) {\n  var reduceFunString = reduceFun.toString();\n  var builtIn = getBuiltIn(reduceFunString);\n  if (builtIn) {\n    return builtIn;\n  } else {\n    return evalFunctionWithEval(reduceFunString);\n  }\n}\n\nfunction ddocValidator(ddoc, viewName) {\n  var fun = ddoc.views && ddoc.views[viewName];\n  if (typeof fun.map !== 'string') {\n    throw new NotFoundError('ddoc ' + ddoc._id + ' has no string view named ' + viewName + ', instead found object of type: ' + typeof fun.map);\n  }\n}\n\nvar localDocName = 'mrviews';\nvar abstract = createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator);\n\nfunction query(fun, opts, callback) {\n  return abstract.query.call(this, fun, opts, callback);\n}\n\nfunction viewCleanup(callback) {\n  return abstract.viewCleanup.call(this, callback);\n}\n\nvar mapreduce = {\n  query: query,\n  viewCleanup: viewCleanup\n};\n\nfunction isGenOne$1(rev$$1) {\n  return (/^1-/.test(rev$$1)\n  );\n}\n\nfunction fileHasChanged(localDoc, remoteDoc, filename) {\n  return !localDoc._attachments || !localDoc._attachments[filename] || localDoc._attachments[filename].digest !== remoteDoc._attachments[filename].digest;\n}\n\nfunction getDocAttachments(db, doc) {\n  var filenames = Object.keys(doc._attachments);\n  return PouchPromise$1.all(filenames.map(function (filename) {\n    return db.getAttachment(doc._id, filename, { rev: doc._rev });\n  }));\n}\n\nfunction getDocAttachmentsFromTargetOrSource(target, src, doc) {\n  var doCheckForLocalAttachments = isRemote(src) && !isRemote(target);\n  var filenames = Object.keys(doc._attachments);\n\n  if (!doCheckForLocalAttachments) {\n    return getDocAttachments(src, doc);\n  }\n\n  return target.get(doc._id).then(function (localDoc) {\n    return PouchPromise$1.all(filenames.map(function (filename) {\n      if (fileHasChanged(localDoc, doc, filename)) {\n        return src.getAttachment(doc._id, filename);\n      }\n\n      return target.getAttachment(localDoc._id, filename);\n    }));\n  }).catch(function (error) {\n    /* istanbul ignore if */\n    if (error.status !== 404) {\n      throw error;\n    }\n\n    return getDocAttachments(src, doc);\n  });\n}\n\nfunction createBulkGetOpts(diffs) {\n  var requests = [];\n  Object.keys(diffs).forEach(function (id) {\n    var missingRevs = diffs[id].missing;\n    missingRevs.forEach(function (missingRev) {\n      requests.push({\n        id: id,\n        rev: missingRev\n      });\n    });\n  });\n\n  return {\n    docs: requests,\n    revs: true,\n    latest: true\n  };\n}\n\n//\n// Fetch all the documents from the src as described in the \"diffs\",\n// which is a mapping of docs IDs to revisions. If the state ever\n// changes to \"cancelled\", then the returned promise will be rejected.\n// Else it will be resolved with a list of fetched documents.\n//\nfunction getDocs(src, target, diffs, state) {\n  diffs = clone(diffs); // we do not need to modify this\n\n  var resultDocs = [],\n      ok = true;\n\n  function getAllDocs() {\n\n    var bulkGetOpts = createBulkGetOpts(diffs);\n\n    if (!bulkGetOpts.docs.length) {\n      // optimization: skip empty requests\n      return;\n    }\n\n    return src.bulkGet(bulkGetOpts).then(function (bulkGetResponse) {\n      /* istanbul ignore if */\n      if (state.cancelled) {\n        throw new Error('cancelled');\n      }\n      return PouchPromise$1.all(bulkGetResponse.results.map(function (bulkGetInfo) {\n        return PouchPromise$1.all(bulkGetInfo.docs.map(function (doc) {\n          var remoteDoc = doc.ok;\n\n          if (doc.error) {\n            // when AUTO_COMPACTION is set, docs can be returned which look\n            // like this: {\"missing\":\"1-7c3ac256b693c462af8442f992b83696\"}\n            ok = false;\n          }\n\n          if (!remoteDoc || !remoteDoc._attachments) {\n            return remoteDoc;\n          }\n\n          return getDocAttachmentsFromTargetOrSource(target, src, remoteDoc).then(function (attachments) {\n            var filenames = Object.keys(remoteDoc._attachments);\n            attachments.forEach(function (attachment, i) {\n              var att = remoteDoc._attachments[filenames[i]];\n              delete att.stub;\n              delete att.length;\n              att.data = attachment;\n            });\n\n            return remoteDoc;\n          });\n        }));\n      })).then(function (results) {\n        resultDocs = resultDocs.concat(flatten(results).filter(Boolean));\n      });\n    });\n  }\n\n  function hasAttachments(doc) {\n    return doc._attachments && Object.keys(doc._attachments).length > 0;\n  }\n\n  function hasConflicts(doc) {\n    return doc._conflicts && doc._conflicts.length > 0;\n  }\n\n  function fetchRevisionOneDocs(ids) {\n    // Optimization: fetch gen-1 docs and attachments in\n    // a single request using _all_docs\n    return src.allDocs({\n      keys: ids,\n      include_docs: true,\n      conflicts: true\n    }).then(function (res) {\n      if (state.cancelled) {\n        throw new Error('cancelled');\n      }\n      res.rows.forEach(function (row) {\n        if (row.deleted || !row.doc || !isGenOne$1(row.value.rev) || hasAttachments(row.doc) || hasConflicts(row.doc)) {\n          // if any of these conditions apply, we need to fetch using get()\n          return;\n        }\n\n        // strip _conflicts array to appease CSG (#5793)\n        /* istanbul ignore if */\n        if (row.doc._conflicts) {\n          delete row.doc._conflicts;\n        }\n\n        // the doc we got back from allDocs() is sufficient\n        resultDocs.push(row.doc);\n        delete diffs[row.id];\n      });\n    });\n  }\n\n  function getRevisionOneDocs() {\n    // filter out the generation 1 docs and get them\n    // leaving the non-generation one docs to be got otherwise\n    var ids = Object.keys(diffs).filter(function (id) {\n      var missing = diffs[id].missing;\n      return missing.length === 1 && isGenOne$1(missing[0]);\n    });\n    if (ids.length > 0) {\n      return fetchRevisionOneDocs(ids);\n    }\n  }\n\n  function returnResult() {\n    return { ok: ok, docs: resultDocs };\n  }\n\n  return PouchPromise$1.resolve().then(getRevisionOneDocs).then(getAllDocs).then(returnResult);\n}\n\nvar CHECKPOINT_VERSION = 1;\nvar REPLICATOR = \"pouchdb\";\n// This is an arbitrary number to limit the\n// amount of replication history we save in the checkpoint.\n// If we save too much, the checkpoing docs will become very big,\n// if we save fewer, we'll run a greater risk of having to\n// read all the changes from 0 when checkpoint PUTs fail\n// CouchDB 2.0 has a more involved history pruning,\n// but let's go for the simple version for now.\nvar CHECKPOINT_HISTORY_SIZE = 5;\nvar LOWEST_SEQ = 0;\n\nfunction updateCheckpoint(db, id, checkpoint, session, returnValue) {\n  return db.get(id).catch(function (err) {\n    if (err.status === 404) {\n      if (db.adapter === 'http' || db.adapter === 'https') {\n        explainError(404, 'PouchDB is just checking if a remote checkpoint exists.');\n      }\n      return {\n        session_id: session,\n        _id: id,\n        history: [],\n        replicator: REPLICATOR,\n        version: CHECKPOINT_VERSION\n      };\n    }\n    throw err;\n  }).then(function (doc) {\n    if (returnValue.cancelled) {\n      return;\n    }\n\n    // if the checkpoint has not changed, do not update\n    if (doc.last_seq === checkpoint) {\n      return;\n    }\n\n    // Filter out current entry for this replication\n    doc.history = (doc.history || []).filter(function (item) {\n      return item.session_id !== session;\n    });\n\n    // Add the latest checkpoint to history\n    doc.history.unshift({\n      last_seq: checkpoint,\n      session_id: session\n    });\n\n    // Just take the last pieces in history, to\n    // avoid really big checkpoint docs.\n    // see comment on history size above\n    doc.history = doc.history.slice(0, CHECKPOINT_HISTORY_SIZE);\n\n    doc.version = CHECKPOINT_VERSION;\n    doc.replicator = REPLICATOR;\n\n    doc.session_id = session;\n    doc.last_seq = checkpoint;\n\n    return db.put(doc).catch(function (err) {\n      if (err.status === 409) {\n        // retry; someone is trying to write a checkpoint simultaneously\n        return updateCheckpoint(db, id, checkpoint, session, returnValue);\n      }\n      throw err;\n    });\n  });\n}\n\nfunction Checkpointer(src, target, id, returnValue, opts) {\n  this.src = src;\n  this.target = target;\n  this.id = id;\n  this.returnValue = returnValue;\n  this.opts = opts;\n}\n\nCheckpointer.prototype.writeCheckpoint = function (checkpoint, session) {\n  var self = this;\n  return this.updateTarget(checkpoint, session).then(function () {\n    return self.updateSource(checkpoint, session);\n  });\n};\n\nCheckpointer.prototype.updateTarget = function (checkpoint, session) {\n  if (this.opts.writeTargetCheckpoint) {\n    return updateCheckpoint(this.target, this.id, checkpoint, session, this.returnValue);\n  } else {\n    return PouchPromise$1.resolve(true);\n  }\n};\n\nCheckpointer.prototype.updateSource = function (checkpoint, session) {\n  if (this.opts.writeSourceCheckpoint) {\n    var self = this;\n    if (this.readOnlySource) {\n      return PouchPromise$1.resolve(true);\n    }\n    return updateCheckpoint(this.src, this.id, checkpoint, session, this.returnValue).catch(function (err) {\n      if (isForbiddenError(err)) {\n        self.readOnlySource = true;\n        return true;\n      }\n      throw err;\n    });\n  } else {\n    return PouchPromise$1.resolve(true);\n  }\n};\n\nvar comparisons = {\n  \"undefined\": function undefined(targetDoc, sourceDoc) {\n    // This is the previous comparison function\n    if (collate(targetDoc.last_seq, sourceDoc.last_seq) === 0) {\n      return sourceDoc.last_seq;\n    }\n    /* istanbul ignore next */\n    return 0;\n  },\n  \"1\": function _(targetDoc, sourceDoc) {\n    // This is the comparison function ported from CouchDB\n    return compareReplicationLogs(sourceDoc, targetDoc).last_seq;\n  }\n};\n\nCheckpointer.prototype.getCheckpoint = function () {\n  var self = this;\n  return self.target.get(self.id).then(function (targetDoc) {\n    if (self.readOnlySource) {\n      return PouchPromise$1.resolve(targetDoc.last_seq);\n    }\n\n    return self.src.get(self.id).then(function (sourceDoc) {\n      // Since we can't migrate an old version doc to a new one\n      // (no session id), we just go with the lowest seq in this case\n      /* istanbul ignore if */\n      if (targetDoc.version !== sourceDoc.version) {\n        return LOWEST_SEQ;\n      }\n\n      var version;\n      if (targetDoc.version) {\n        version = targetDoc.version.toString();\n      } else {\n        version = \"undefined\";\n      }\n\n      if (version in comparisons) {\n        return comparisons[version](targetDoc, sourceDoc);\n      }\n      /* istanbul ignore next */\n      return LOWEST_SEQ;\n    }, function (err) {\n      if (err.status === 404 && targetDoc.last_seq) {\n        return self.src.put({\n          _id: self.id,\n          last_seq: LOWEST_SEQ\n        }).then(function () {\n          return LOWEST_SEQ;\n        }, function (err) {\n          if (isForbiddenError(err)) {\n            self.readOnlySource = true;\n            return targetDoc.last_seq;\n          }\n          /* istanbul ignore next */\n          return LOWEST_SEQ;\n        });\n      }\n      throw err;\n    });\n  }).catch(function (err) {\n    if (err.status !== 404) {\n      throw err;\n    }\n    return LOWEST_SEQ;\n  });\n};\n// This checkpoint comparison is ported from CouchDBs source\n// they come from here:\n// https://github.com/apache/couchdb-couch-replicator/blob/master/src/couch_replicator.erl#L863-L906\n\nfunction compareReplicationLogs(srcDoc, tgtDoc) {\n  if (srcDoc.session_id === tgtDoc.session_id) {\n    return {\n      last_seq: srcDoc.last_seq,\n      history: srcDoc.history\n    };\n  }\n\n  return compareReplicationHistory(srcDoc.history, tgtDoc.history);\n}\n\nfunction compareReplicationHistory(sourceHistory, targetHistory) {\n  // the erlang loop via function arguments is not so easy to repeat in JS\n  // therefore, doing this as recursion\n  var S = sourceHistory[0];\n  var sourceRest = sourceHistory.slice(1);\n  var T = targetHistory[0];\n  var targetRest = targetHistory.slice(1);\n\n  if (!S || targetHistory.length === 0) {\n    return {\n      last_seq: LOWEST_SEQ,\n      history: []\n    };\n  }\n\n  var sourceId = S.session_id;\n  /* istanbul ignore if */\n  if (hasSessionId(sourceId, targetHistory)) {\n    return {\n      last_seq: S.last_seq,\n      history: sourceHistory\n    };\n  }\n\n  var targetId = T.session_id;\n  if (hasSessionId(targetId, sourceRest)) {\n    return {\n      last_seq: T.last_seq,\n      history: targetRest\n    };\n  }\n\n  return compareReplicationHistory(sourceRest, targetRest);\n}\n\nfunction hasSessionId(sessionId, history) {\n  var props = history[0];\n  var rest = history.slice(1);\n\n  if (!sessionId || history.length === 0) {\n    return false;\n  }\n\n  if (sessionId === props.session_id) {\n    return true;\n  }\n\n  return hasSessionId(sessionId, rest);\n}\n\nfunction isForbiddenError(err) {\n  return typeof err.status === 'number' && Math.floor(err.status / 100) === 4;\n}\n\nvar STARTING_BACK_OFF = 0;\n\nfunction backOff(opts, returnValue, error, callback) {\n  if (opts.retry === false) {\n    returnValue.emit('error', error);\n    returnValue.removeAllListeners();\n    return;\n  }\n  if (typeof opts.back_off_function !== 'function') {\n    opts.back_off_function = defaultBackOff;\n  }\n  returnValue.emit('requestError', error);\n  if (returnValue.state === 'active' || returnValue.state === 'pending') {\n    returnValue.emit('paused', error);\n    returnValue.state = 'stopped';\n    var backOffSet = function backoffTimeSet() {\n      opts.current_back_off = STARTING_BACK_OFF;\n    };\n    var removeBackOffSetter = function removeBackOffTimeSet() {\n      returnValue.removeListener('active', backOffSet);\n    };\n    returnValue.once('paused', removeBackOffSetter);\n    returnValue.once('active', backOffSet);\n  }\n\n  opts.current_back_off = opts.current_back_off || STARTING_BACK_OFF;\n  opts.current_back_off = opts.back_off_function(opts.current_back_off);\n  setTimeout(callback, opts.current_back_off);\n}\n\nfunction sortObjectPropertiesByKey(queryParams) {\n  return Object.keys(queryParams).sort(collate).reduce(function (result, key) {\n    result[key] = queryParams[key];\n    return result;\n  }, {});\n}\n\n// Generate a unique id particular to this replication.\n// Not guaranteed to align perfectly with CouchDB's rep ids.\nfunction generateReplicationId(src, target, opts) {\n  var docIds = opts.doc_ids ? opts.doc_ids.sort(collate) : '';\n  var filterFun = opts.filter ? opts.filter.toString() : '';\n  var queryParams = '';\n  var filterViewName = '';\n  var selector = '';\n\n  // possibility for checkpoints to be lost here as behaviour of\n  // JSON.stringify is not stable (see #6226)\n  /* istanbul ignore if */\n  if (opts.selector) {\n    selector = JSON.stringify(opts.selector);\n  }\n\n  if (opts.filter && opts.query_params) {\n    queryParams = JSON.stringify(sortObjectPropertiesByKey(opts.query_params));\n  }\n\n  if (opts.filter && opts.filter === '_view') {\n    filterViewName = opts.view.toString();\n  }\n\n  return PouchPromise$1.all([src.id(), target.id()]).then(function (res) {\n    var queryData = res[0] + res[1] + filterFun + filterViewName + queryParams + docIds + selector;\n    return new PouchPromise$1(function (resolve) {\n      binaryMd5(queryData, resolve);\n    });\n  }).then(function (md5sum) {\n    // can't use straight-up md5 alphabet, because\n    // the char '/' is interpreted as being for attachments,\n    // and + is also not url-safe\n    md5sum = md5sum.replace(/\\//g, '.').replace(/\\+/g, '_');\n    return '_local/' + md5sum;\n  });\n}\n\nfunction replicate(src, target, opts, returnValue, result) {\n  var batches = []; // list of batches to be processed\n  var currentBatch; // the batch currently being processed\n  var pendingBatch = {\n    seq: 0,\n    changes: [],\n    docs: []\n  }; // next batch, not yet ready to be processed\n  var writingCheckpoint = false; // true while checkpoint is being written\n  var changesCompleted = false; // true when all changes received\n  var replicationCompleted = false; // true when replication has completed\n  var last_seq = 0;\n  var continuous = opts.continuous || opts.live || false;\n  var batch_size = opts.batch_size || 100;\n  var batches_limit = opts.batches_limit || 10;\n  var changesPending = false; // true while src.changes is running\n  var doc_ids = opts.doc_ids;\n  var selector = opts.selector;\n  var repId;\n  var checkpointer;\n  var changedDocs = [];\n  // Like couchdb, every replication gets a unique session id\n  var session = uuid();\n\n  result = result || {\n    ok: true,\n    start_time: new Date(),\n    docs_read: 0,\n    docs_written: 0,\n    doc_write_failures: 0,\n    errors: []\n  };\n\n  var changesOpts = {};\n  returnValue.ready(src, target);\n\n  function initCheckpointer() {\n    if (checkpointer) {\n      return PouchPromise$1.resolve();\n    }\n    return generateReplicationId(src, target, opts).then(function (res) {\n      repId = res;\n\n      var checkpointOpts = {};\n      if (opts.checkpoint === false) {\n        checkpointOpts = { writeSourceCheckpoint: false, writeTargetCheckpoint: false };\n      } else if (opts.checkpoint === 'source') {\n        checkpointOpts = { writeSourceCheckpoint: true, writeTargetCheckpoint: false };\n      } else if (opts.checkpoint === 'target') {\n        checkpointOpts = { writeSourceCheckpoint: false, writeTargetCheckpoint: true };\n      } else {\n        checkpointOpts = { writeSourceCheckpoint: true, writeTargetCheckpoint: true };\n      }\n\n      checkpointer = new Checkpointer(src, target, repId, returnValue, checkpointOpts);\n    });\n  }\n\n  function writeDocs() {\n    changedDocs = [];\n\n    if (currentBatch.docs.length === 0) {\n      return;\n    }\n    var docs = currentBatch.docs;\n    var bulkOpts = { timeout: opts.timeout };\n    return target.bulkDocs({ docs: docs, new_edits: false }, bulkOpts).then(function (res) {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n\n      // `res` doesn't include full documents (which live in `docs`), so we create a map of \n      // (id -> error), and check for errors while iterating over `docs`\n      var errorsById = Object.create(null);\n      res.forEach(function (res) {\n        if (res.error) {\n          errorsById[res.id] = res;\n        }\n      });\n\n      var errorsNo = Object.keys(errorsById).length;\n      result.doc_write_failures += errorsNo;\n      result.docs_written += docs.length - errorsNo;\n\n      docs.forEach(function (doc) {\n        var error = errorsById[doc._id];\n        if (error) {\n          result.errors.push(error);\n          if (error.name === 'unauthorized' || error.name === 'forbidden') {\n            returnValue.emit('denied', clone(error));\n          } else {\n            throw error;\n          }\n        } else {\n          changedDocs.push(doc);\n        }\n      });\n    }, function (err) {\n      result.doc_write_failures += docs.length;\n      throw err;\n    });\n  }\n\n  function finishBatch() {\n    if (currentBatch.error) {\n      throw new Error('There was a problem getting docs.');\n    }\n    result.last_seq = last_seq = currentBatch.seq;\n    var outResult = clone(result);\n    if (changedDocs.length) {\n      outResult.docs = changedDocs;\n      returnValue.emit('change', outResult);\n    }\n    writingCheckpoint = true;\n    return checkpointer.writeCheckpoint(currentBatch.seq, session).then(function () {\n      writingCheckpoint = false;\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n      currentBatch = undefined;\n      getChanges();\n    }).catch(function (err) {\n      onCheckpointError(err);\n      throw err;\n    });\n  }\n\n  function getDiffs() {\n    var diff = {};\n    currentBatch.changes.forEach(function (change) {\n      // Couchbase Sync Gateway emits these, but we can ignore them\n      /* istanbul ignore if */\n      if (change.id === \"_user/\") {\n        return;\n      }\n      diff[change.id] = change.changes.map(function (x) {\n        return x.rev;\n      });\n    });\n    return target.revsDiff(diff).then(function (diffs) {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n      // currentBatch.diffs elements are deleted as the documents are written\n      currentBatch.diffs = diffs;\n    });\n  }\n\n  function getBatchDocs() {\n    return getDocs(src, target, currentBatch.diffs, returnValue).then(function (got) {\n      currentBatch.error = !got.ok;\n      got.docs.forEach(function (doc) {\n        delete currentBatch.diffs[doc._id];\n        result.docs_read++;\n        currentBatch.docs.push(doc);\n      });\n    });\n  }\n\n  function startNextBatch() {\n    if (returnValue.cancelled || currentBatch) {\n      return;\n    }\n    if (batches.length === 0) {\n      processPendingBatch(true);\n      return;\n    }\n    currentBatch = batches.shift();\n    getDiffs().then(getBatchDocs).then(writeDocs).then(finishBatch).then(startNextBatch).catch(function (err) {\n      abortReplication('batch processing terminated with error', err);\n    });\n  }\n\n  function processPendingBatch(immediate) {\n    if (pendingBatch.changes.length === 0) {\n      if (batches.length === 0 && !currentBatch) {\n        if (continuous && changesOpts.live || changesCompleted) {\n          returnValue.state = 'pending';\n          returnValue.emit('paused');\n        }\n        if (changesCompleted) {\n          completeReplication();\n        }\n      }\n      return;\n    }\n    if (immediate || changesCompleted || pendingBatch.changes.length >= batch_size) {\n      batches.push(pendingBatch);\n      pendingBatch = {\n        seq: 0,\n        changes: [],\n        docs: []\n      };\n      if (returnValue.state === 'pending' || returnValue.state === 'stopped') {\n        returnValue.state = 'active';\n        returnValue.emit('active');\n      }\n      startNextBatch();\n    }\n  }\n\n  function abortReplication(reason, err) {\n    if (replicationCompleted) {\n      return;\n    }\n    if (!err.message) {\n      err.message = reason;\n    }\n    result.ok = false;\n    result.status = 'aborting';\n    batches = [];\n    pendingBatch = {\n      seq: 0,\n      changes: [],\n      docs: []\n    };\n    completeReplication(err);\n  }\n\n  function completeReplication(fatalError) {\n    if (replicationCompleted) {\n      return;\n    }\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      result.status = 'cancelled';\n      if (writingCheckpoint) {\n        return;\n      }\n    }\n    result.status = result.status || 'complete';\n    result.end_time = new Date();\n    result.last_seq = last_seq;\n    replicationCompleted = true;\n\n    if (fatalError) {\n      // need to extend the error because Firefox considers \".result\" read-only\n      fatalError = createError(fatalError);\n      fatalError.result = result;\n\n      if (fatalError.name === 'unauthorized' || fatalError.name === 'forbidden') {\n        returnValue.emit('error', fatalError);\n        returnValue.removeAllListeners();\n      } else {\n        backOff(opts, returnValue, fatalError, function () {\n          replicate(src, target, opts, returnValue);\n        });\n      }\n    } else {\n      returnValue.emit('complete', result);\n      returnValue.removeAllListeners();\n    }\n  }\n\n  function onChange(change) {\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n    var filter = filterChange(opts)(change);\n    if (!filter) {\n      return;\n    }\n    pendingBatch.seq = change.seq;\n    pendingBatch.changes.push(change);\n    processPendingBatch(batches.length === 0 && changesOpts.live);\n  }\n\n  function onChangesComplete(changes) {\n    changesPending = false;\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n\n    // if no results were returned then we're done,\n    // else fetch more\n    if (changes.results.length > 0) {\n      changesOpts.since = changes.last_seq;\n      getChanges();\n      processPendingBatch(true);\n    } else {\n\n      var complete = function complete() {\n        if (continuous) {\n          changesOpts.live = true;\n          getChanges();\n        } else {\n          changesCompleted = true;\n        }\n        processPendingBatch(true);\n      };\n\n      // update the checkpoint so we start from the right seq next time\n      if (!currentBatch && changes.results.length === 0) {\n        writingCheckpoint = true;\n        checkpointer.writeCheckpoint(changes.last_seq, session).then(function () {\n          writingCheckpoint = false;\n          result.last_seq = last_seq = changes.last_seq;\n          complete();\n        }).catch(onCheckpointError);\n      } else {\n        complete();\n      }\n    }\n  }\n\n  function onChangesError(err) {\n    changesPending = false;\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n    abortReplication('changes rejected', err);\n  }\n\n  function getChanges() {\n    if (!(!changesPending && !changesCompleted && batches.length < batches_limit)) {\n      return;\n    }\n    changesPending = true;\n    function abortChanges() {\n      changes.cancel();\n    }\n    function removeListener() {\n      returnValue.removeListener('cancel', abortChanges);\n    }\n\n    if (returnValue._changes) {\n      // remove old changes() and listeners\n      returnValue.removeListener('cancel', returnValue._abortChanges);\n      returnValue._changes.cancel();\n    }\n    returnValue.once('cancel', abortChanges);\n\n    var changes = src.changes(changesOpts).on('change', onChange);\n    changes.then(removeListener, removeListener);\n    changes.then(onChangesComplete).catch(onChangesError);\n\n    if (opts.retry) {\n      // save for later so we can cancel if necessary\n      returnValue._changes = changes;\n      returnValue._abortChanges = abortChanges;\n    }\n  }\n\n  function startChanges() {\n    initCheckpointer().then(function () {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        return;\n      }\n      return checkpointer.getCheckpoint().then(function (checkpoint) {\n        last_seq = checkpoint;\n        changesOpts = {\n          since: last_seq,\n          limit: batch_size,\n          batch_size: batch_size,\n          style: 'all_docs',\n          doc_ids: doc_ids,\n          selector: selector,\n          return_docs: true // required so we know when we're done\n        };\n        if (opts.filter) {\n          if (typeof opts.filter !== 'string') {\n            // required for the client-side filter in onChange\n            changesOpts.include_docs = true;\n          } else {\n            // ddoc filter\n            changesOpts.filter = opts.filter;\n          }\n        }\n        if ('heartbeat' in opts) {\n          changesOpts.heartbeat = opts.heartbeat;\n        }\n        if ('timeout' in opts) {\n          changesOpts.timeout = opts.timeout;\n        }\n        if (opts.query_params) {\n          changesOpts.query_params = opts.query_params;\n        }\n        if (opts.view) {\n          changesOpts.view = opts.view;\n        }\n        getChanges();\n      });\n    }).catch(function (err) {\n      abortReplication('getCheckpoint rejected with ', err);\n    });\n  }\n\n  /* istanbul ignore next */\n  function onCheckpointError(err) {\n    writingCheckpoint = false;\n    abortReplication('writeCheckpoint completed with error', err);\n  }\n\n  /* istanbul ignore if */\n  if (returnValue.cancelled) {\n    // cancelled immediately\n    completeReplication();\n    return;\n  }\n\n  if (!returnValue._addedListeners) {\n    returnValue.once('cancel', completeReplication);\n\n    if (typeof opts.complete === 'function') {\n      returnValue.once('error', opts.complete);\n      returnValue.once('complete', function (result) {\n        opts.complete(null, result);\n      });\n    }\n    returnValue._addedListeners = true;\n  }\n\n  if (typeof opts.since === 'undefined') {\n    startChanges();\n  } else {\n    initCheckpointer().then(function () {\n      writingCheckpoint = true;\n      return checkpointer.writeCheckpoint(opts.since, session);\n    }).then(function () {\n      writingCheckpoint = false;\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        return;\n      }\n      last_seq = opts.since;\n      startChanges();\n    }).catch(onCheckpointError);\n  }\n}\n\n// We create a basic promise so the caller can cancel the replication possibly\n// before we have actually started listening to changes etc\n__WEBPACK_IMPORTED_MODULE_4_inherits___default()(Replication, __WEBPACK_IMPORTED_MODULE_3_events__[\"EventEmitter\"]);\nfunction Replication() {\n  __WEBPACK_IMPORTED_MODULE_3_events__[\"EventEmitter\"].call(this);\n  this.cancelled = false;\n  this.state = 'pending';\n  var self = this;\n  var promise = new PouchPromise$1(function (fulfill, reject) {\n    self.once('complete', fulfill);\n    self.once('error', reject);\n  });\n  self.then = function (resolve, reject) {\n    return promise.then(resolve, reject);\n  };\n  self.catch = function (reject) {\n    return promise.catch(reject);\n  };\n  // As we allow error handling via \"error\" event as well,\n  // put a stub in here so that rejecting never throws UnhandledError.\n  self.catch(function () {});\n}\n\nReplication.prototype.cancel = function () {\n  this.cancelled = true;\n  this.state = 'cancelled';\n  this.emit('cancel');\n};\n\nReplication.prototype.ready = function (src, target) {\n  var self = this;\n  if (self._readyCalled) {\n    return;\n  }\n  self._readyCalled = true;\n\n  function onDestroy() {\n    self.cancel();\n  }\n  src.once('destroyed', onDestroy);\n  target.once('destroyed', onDestroy);\n  function cleanup() {\n    src.removeListener('destroyed', onDestroy);\n    target.removeListener('destroyed', onDestroy);\n  }\n  self.once('complete', cleanup);\n};\n\nfunction toPouch(db, opts) {\n  var PouchConstructor = opts.PouchConstructor;\n  if (typeof db === 'string') {\n    return new PouchConstructor(db, opts);\n  } else {\n    return db;\n  }\n}\n\nfunction replicateWrapper(src, target, opts, callback) {\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof opts === 'undefined') {\n    opts = {};\n  }\n\n  if (opts.doc_ids && !Array.isArray(opts.doc_ids)) {\n    throw createError(BAD_REQUEST, \"`doc_ids` filter parameter is not a list.\");\n  }\n\n  opts.complete = callback;\n  opts = clone(opts);\n  opts.continuous = opts.continuous || opts.live;\n  opts.retry = 'retry' in opts ? opts.retry : false;\n  /*jshint validthis:true */\n  opts.PouchConstructor = opts.PouchConstructor || this;\n  var replicateRet = new Replication(opts);\n  var srcPouch = toPouch(src, opts);\n  var targetPouch = toPouch(target, opts);\n  replicate(srcPouch, targetPouch, opts, replicateRet);\n  return replicateRet;\n}\n\n__WEBPACK_IMPORTED_MODULE_4_inherits___default()(Sync, __WEBPACK_IMPORTED_MODULE_3_events__[\"EventEmitter\"]);\nfunction sync$1(src, target, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof opts === 'undefined') {\n    opts = {};\n  }\n  opts = clone(opts);\n  /*jshint validthis:true */\n  opts.PouchConstructor = opts.PouchConstructor || this;\n  src = toPouch(src, opts);\n  target = toPouch(target, opts);\n  return new Sync(src, target, opts, callback);\n}\n\nfunction Sync(src, target, opts, callback) {\n  var self = this;\n  this.canceled = false;\n\n  var optsPush = opts.push ? $inject_Object_assign({}, opts, opts.push) : opts;\n  var optsPull = opts.pull ? $inject_Object_assign({}, opts, opts.pull) : opts;\n\n  this.push = replicateWrapper(src, target, optsPush);\n  this.pull = replicateWrapper(target, src, optsPull);\n\n  this.pushPaused = true;\n  this.pullPaused = true;\n\n  function pullChange(change) {\n    self.emit('change', {\n      direction: 'pull',\n      change: change\n    });\n  }\n  function pushChange(change) {\n    self.emit('change', {\n      direction: 'push',\n      change: change\n    });\n  }\n  function pushDenied(doc) {\n    self.emit('denied', {\n      direction: 'push',\n      doc: doc\n    });\n  }\n  function pullDenied(doc) {\n    self.emit('denied', {\n      direction: 'pull',\n      doc: doc\n    });\n  }\n  function pushPaused() {\n    self.pushPaused = true;\n    /* istanbul ignore if */\n    if (self.pullPaused) {\n      self.emit('paused');\n    }\n  }\n  function pullPaused() {\n    self.pullPaused = true;\n    /* istanbul ignore if */\n    if (self.pushPaused) {\n      self.emit('paused');\n    }\n  }\n  function pushActive() {\n    self.pushPaused = false;\n    /* istanbul ignore if */\n    if (self.pullPaused) {\n      self.emit('active', {\n        direction: 'push'\n      });\n    }\n  }\n  function pullActive() {\n    self.pullPaused = false;\n    /* istanbul ignore if */\n    if (self.pushPaused) {\n      self.emit('active', {\n        direction: 'pull'\n      });\n    }\n  }\n\n  var removed = {};\n\n  function removeAll(type) {\n    // type is 'push' or 'pull'\n    return function (event, func) {\n      var isChange = event === 'change' && (func === pullChange || func === pushChange);\n      var isDenied = event === 'denied' && (func === pullDenied || func === pushDenied);\n      var isPaused = event === 'paused' && (func === pullPaused || func === pushPaused);\n      var isActive = event === 'active' && (func === pullActive || func === pushActive);\n\n      if (isChange || isDenied || isPaused || isActive) {\n        if (!(event in removed)) {\n          removed[event] = {};\n        }\n        removed[event][type] = true;\n        if (Object.keys(removed[event]).length === 2) {\n          // both push and pull have asked to be removed\n          self.removeAllListeners(event);\n        }\n      }\n    };\n  }\n\n  if (opts.live) {\n    this.push.on('complete', self.pull.cancel.bind(self.pull));\n    this.pull.on('complete', self.push.cancel.bind(self.push));\n  }\n\n  function addOneListener(ee, event, listener) {\n    if (ee.listeners(event).indexOf(listener) == -1) {\n      ee.on(event, listener);\n    }\n  }\n\n  this.on('newListener', function (event) {\n    if (event === 'change') {\n      addOneListener(self.pull, 'change', pullChange);\n      addOneListener(self.push, 'change', pushChange);\n    } else if (event === 'denied') {\n      addOneListener(self.pull, 'denied', pullDenied);\n      addOneListener(self.push, 'denied', pushDenied);\n    } else if (event === 'active') {\n      addOneListener(self.pull, 'active', pullActive);\n      addOneListener(self.push, 'active', pushActive);\n    } else if (event === 'paused') {\n      addOneListener(self.pull, 'paused', pullPaused);\n      addOneListener(self.push, 'paused', pushPaused);\n    }\n  });\n\n  this.on('removeListener', function (event) {\n    if (event === 'change') {\n      self.pull.removeListener('change', pullChange);\n      self.push.removeListener('change', pushChange);\n    } else if (event === 'denied') {\n      self.pull.removeListener('denied', pullDenied);\n      self.push.removeListener('denied', pushDenied);\n    } else if (event === 'active') {\n      self.pull.removeListener('active', pullActive);\n      self.push.removeListener('active', pushActive);\n    } else if (event === 'paused') {\n      self.pull.removeListener('paused', pullPaused);\n      self.push.removeListener('paused', pushPaused);\n    }\n  });\n\n  this.pull.on('removeListener', removeAll('pull'));\n  this.push.on('removeListener', removeAll('push'));\n\n  var promise = PouchPromise$1.all([this.push, this.pull]).then(function (resp) {\n    var out = {\n      push: resp[0],\n      pull: resp[1]\n    };\n    self.emit('complete', out);\n    if (callback) {\n      callback(null, out);\n    }\n    self.removeAllListeners();\n    return out;\n  }, function (err) {\n    self.cancel();\n    if (callback) {\n      // if there's a callback, then the callback can receive\n      // the error event\n      callback(err);\n    } else {\n      // if there's no callback, then we're safe to emit an error\n      // event, which would otherwise throw an unhandled error\n      // due to 'error' being a special event in EventEmitters\n      self.emit('error', err);\n    }\n    self.removeAllListeners();\n    if (callback) {\n      // no sense throwing if we're already emitting an 'error' event\n      throw err;\n    }\n  });\n\n  this.then = function (success, err) {\n    return promise.then(success, err);\n  };\n\n  this.catch = function (err) {\n    return promise.catch(err);\n  };\n}\n\nSync.prototype.cancel = function () {\n  if (!this.canceled) {\n    this.canceled = true;\n    this.push.cancel();\n    this.pull.cancel();\n  }\n};\n\nfunction replication(PouchDB) {\n  PouchDB.replicate = replicateWrapper;\n  PouchDB.sync = sync$1;\n\n  Object.defineProperty(PouchDB.prototype, 'replicate', {\n    get: function get() {\n      var self = this;\n      return {\n        from: function from(other, opts, callback) {\n          return self.constructor.replicate(other, self, opts, callback);\n        },\n        to: function to(other, opts, callback) {\n          return self.constructor.replicate(self, other, opts, callback);\n        }\n      };\n    }\n  });\n\n  PouchDB.prototype.sync = function (dbName, opts, callback) {\n    return this.constructor.sync(this, dbName, opts, callback);\n  };\n}\n\nPouchDB$5.plugin(IDBPouch).plugin(WebSqlPouch).plugin(HttpPouch$1).plugin(mapreduce).plugin(replication);\n\n// Pull from src because pouchdb-node/pouchdb-browser themselves\n// are aggressively optimized and jsnext:main would normally give us this\n// aggressive bundle.\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (PouchDB$5);\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(\"h4f+\")))\n\n/***/ }),\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(\"osyQ\");\n\n\n/***/ }),\n\n/***/ \"13nb\":\n/***/ (function(module, exports, __webpack_require__) {\n\n(function (factory) {\n    if (true) {\n        // Node/CommonJS\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(factory);\n    } else {\n        // Browser globals (with support for web workers)\n        var glob;\n\n        try {\n            glob = window;\n        } catch (e) {\n            glob = self;\n        }\n\n        glob.SparkMD5 = factory();\n    }\n})(function (undefined) {\n\n    'use strict';\n\n    /*\n     * Fastest md5 implementation around (JKM md5).\n     * Credits: Joseph Myers\n     *\n     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html\n     * @see http://jsperf.com/md5-shootout/7\n     */\n\n    /* this function is much faster,\n      so if possible we use it. Some IEs\n      are the only ones I know of that\n      need the idiotic second function,\n      generated by an if clause.  */\n\n    var add32 = function add32(a, b) {\n        return a + b & 0xFFFFFFFF;\n    },\n        hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n\n    function cmn(q, a, b, x, s, t) {\n        a = add32(add32(a, q), add32(x, t));\n        return add32(a << s | a >>> 32 - s, b);\n    }\n\n    function md5cycle(x, k) {\n        var a = x[0],\n            b = x[1],\n            c = x[2],\n            d = x[3];\n\n        a += (b & c | ~b & d) + k[0] - 680876936 | 0;\n        a = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[1] - 389564586 | 0;\n        d = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[2] + 606105819 | 0;\n        c = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;\n        b = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[4] - 176418897 | 0;\n        a = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;\n        d = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;\n        c = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[7] - 45705983 | 0;\n        b = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;\n        a = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;\n        d = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[10] - 42063 | 0;\n        c = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;\n        b = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;\n        a = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[13] - 40341101 | 0;\n        d = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;\n        c = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;\n        b = (b << 22 | b >>> 10) + c | 0;\n\n        a += (b & d | c & ~d) + k[1] - 165796510 | 0;\n        a = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;\n        d = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[11] + 643717713 | 0;\n        c = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[0] - 373897302 | 0;\n        b = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[5] - 701558691 | 0;\n        a = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[10] + 38016083 | 0;\n        d = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[15] - 660478335 | 0;\n        c = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[4] - 405537848 | 0;\n        b = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[9] + 568446438 | 0;\n        a = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;\n        d = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[3] - 187363961 | 0;\n        c = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;\n        b = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;\n        a = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[2] - 51403784 | 0;\n        d = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;\n        c = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;\n        b = (b << 20 | b >>> 12) + c | 0;\n\n        a += (b ^ c ^ d) + k[5] - 378558 | 0;\n        a = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;\n        d = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;\n        c = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[14] - 35309556 | 0;\n        b = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;\n        a = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;\n        d = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[7] - 155497632 | 0;\n        c = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;\n        b = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[13] + 681279174 | 0;\n        a = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[0] - 358537222 | 0;\n        d = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[3] - 722521979 | 0;\n        c = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[6] + 76029189 | 0;\n        b = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[9] - 640364487 | 0;\n        a = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[12] - 421815835 | 0;\n        d = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[15] + 530742520 | 0;\n        c = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[2] - 995338651 | 0;\n        b = (b << 23 | b >>> 9) + c | 0;\n\n        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;\n        a = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;\n        d = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;\n        c = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;\n        b = (b << 21 | b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;\n        a = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;\n        d = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;\n        c = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;\n        b = (b << 21 | b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;\n        a = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;\n        d = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;\n        c = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;\n        b = (b << 21 | b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;\n        a = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;\n        d = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;\n        c = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;\n        b = (b << 21 | b >>> 11) + c | 0;\n\n        x[0] = a + x[0] | 0;\n        x[1] = b + x[1] | 0;\n        x[2] = c + x[2] | 0;\n        x[3] = d + x[3] | 0;\n    }\n\n    function md5blk(s) {\n        var md5blks = [],\n            i; /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);\n        }\n        return md5blks;\n    }\n\n    function md5blk_array(a) {\n        var md5blks = [],\n            i; /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);\n        }\n        return md5blks;\n    }\n\n    function md51(s) {\n        var n = s.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n            md5cycle(state, md5blk(s.substring(i - 64, i)));\n        }\n        s = s.substring(i - 64);\n        length = s.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= s.charCodeAt(i) << (i % 4 << 3);\n        }\n        tail[i >> 2] |= 0x80 << (i % 4 << 3);\n        if (i > 55) {\n            md5cycle(state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Beware that the final length might not fit in 32 bits so we take care of that\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n\n        md5cycle(state, tail);\n        return state;\n    }\n\n    function md51_array(a) {\n        var n = a.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));\n        }\n\n        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1\n        // containing the last element of the parent array if the sub array specified starts\n        // beyond the length of the parent array - weird.\n        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue\n        a = i - 64 < n ? a.subarray(i - 64) : new Uint8Array(0);\n\n        length = a.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= a[i] << (i % 4 << 3);\n        }\n\n        tail[i >> 2] |= 0x80 << (i % 4 << 3);\n        if (i > 55) {\n            md5cycle(state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Beware that the final length might not fit in 32 bits so we take care of that\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n\n        md5cycle(state, tail);\n\n        return state;\n    }\n\n    function rhex(n) {\n        var s = '',\n            j;\n        for (j = 0; j < 4; j += 1) {\n            s += hex_chr[n >> j * 8 + 4 & 0x0F] + hex_chr[n >> j * 8 & 0x0F];\n        }\n        return s;\n    }\n\n    function hex(x) {\n        var i;\n        for (i = 0; i < x.length; i += 1) {\n            x[i] = rhex(x[i]);\n        }\n        return x.join('');\n    }\n\n    // In some cases the fast add32 function cannot be used..\n    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') {\n        add32 = function add32(x, y) {\n            var lsw = (x & 0xFFFF) + (y & 0xFFFF),\n                msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n            return msw << 16 | lsw & 0xFFFF;\n        };\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * ArrayBuffer slice polyfill.\n     *\n     * @see https://github.com/ttaubert/node-arraybuffer-slice\n     */\n\n    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {\n        (function () {\n            function clamp(val, length) {\n                val = val | 0 || 0;\n\n                if (val < 0) {\n                    return Math.max(val + length, 0);\n                }\n\n                return Math.min(val, length);\n            }\n\n            ArrayBuffer.prototype.slice = function (from, to) {\n                var length = this.byteLength,\n                    begin = clamp(from, length),\n                    end = length,\n                    num,\n                    target,\n                    targetArray,\n                    sourceArray;\n\n                if (to !== undefined) {\n                    end = clamp(to, length);\n                }\n\n                if (begin > end) {\n                    return new ArrayBuffer(0);\n                }\n\n                num = end - begin;\n                target = new ArrayBuffer(num);\n                targetArray = new Uint8Array(target);\n\n                sourceArray = new Uint8Array(this, begin, num);\n                targetArray.set(sourceArray);\n\n                return target;\n            };\n        })();\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * Helpers.\n     */\n\n    function toUtf8(str) {\n        if (/[\\u0080-\\uFFFF]/.test(str)) {\n            str = unescape(encodeURIComponent(str));\n        }\n\n        return str;\n    }\n\n    function utf8Str2ArrayBuffer(str, returnUInt8Array) {\n        var length = str.length,\n            buff = new ArrayBuffer(length),\n            arr = new Uint8Array(buff),\n            i;\n\n        for (i = 0; i < length; i += 1) {\n            arr[i] = str.charCodeAt(i);\n        }\n\n        return returnUInt8Array ? arr : buff;\n    }\n\n    function arrayBuffer2Utf8Str(buff) {\n        return String.fromCharCode.apply(null, new Uint8Array(buff));\n    }\n\n    function concatenateArrayBuffers(first, second, returnUInt8Array) {\n        var result = new Uint8Array(first.byteLength + second.byteLength);\n\n        result.set(new Uint8Array(first));\n        result.set(new Uint8Array(second), first.byteLength);\n\n        return returnUInt8Array ? result : result.buffer;\n    }\n\n    function hexToBinaryString(hex) {\n        var bytes = [],\n            length = hex.length,\n            x;\n\n        for (x = 0; x < length - 1; x += 2) {\n            bytes.push(parseInt(hex.substr(x, 2), 16));\n        }\n\n        return String.fromCharCode.apply(String, bytes);\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * SparkMD5 OOP implementation.\n     *\n     * Use this class to perform an incremental md5, otherwise use the\n     * static methods instead.\n     */\n\n    function SparkMD5() {\n        // call reset to init the instance\n        this.reset();\n    }\n\n    /**\n     * Appends a string.\n     * A conversion will be applied if an utf8 string is detected.\n     *\n     * @param {String} str The string to be appended\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.append = function (str) {\n        // Converts the string to utf8 bytes if necessary\n        // Then append as binary\n        this.appendBinary(toUtf8(str));\n\n        return this;\n    };\n\n    /**\n     * Appends a binary string.\n     *\n     * @param {String} contents The binary string to be appended\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.appendBinary = function (contents) {\n        this._buff += contents;\n        this._length += contents.length;\n\n        var length = this._buff.length,\n            i;\n\n        for (i = 64; i <= length; i += 64) {\n            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));\n        }\n\n        this._buff = this._buff.substring(i - 64);\n\n        return this;\n    };\n\n    /**\n     * Finishes the incremental computation, reseting the internal state and\n     * returning the result.\n     *\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            i,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= buff.charCodeAt(i) << (i % 4 << 3);\n        }\n\n        this._finish(tail, length);\n        ret = hex(this._hash);\n\n        if (raw) {\n            ret = hexToBinaryString(ret);\n        }\n\n        this.reset();\n\n        return ret;\n    };\n\n    /**\n     * Resets the internal state of the computation.\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.reset = function () {\n        this._buff = '';\n        this._length = 0;\n        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\n        return this;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @return {Object} The state\n     */\n    SparkMD5.prototype.getState = function () {\n        return {\n            buff: this._buff,\n            length: this._length,\n            hash: this._hash\n        };\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @param {Object} state The state\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.setState = function (state) {\n        this._buff = state.buff;\n        this._length = state.length;\n        this._hash = state.hash;\n\n        return this;\n    };\n\n    /**\n     * Releases memory used by the incremental buffer and other additional\n     * resources. If you plan to use the instance again, use reset instead.\n     */\n    SparkMD5.prototype.destroy = function () {\n        delete this._hash;\n        delete this._buff;\n        delete this._length;\n    };\n\n    /**\n     * Finish the final calculation based on the tail.\n     *\n     * @param {Array}  tail   The tail (will be modified)\n     * @param {Number} length The length of the remaining buffer\n     */\n    SparkMD5.prototype._finish = function (tail, length) {\n        var i = length,\n            tmp,\n            lo,\n            hi;\n\n        tail[i >> 2] |= 0x80 << (i % 4 << 3);\n        if (i > 55) {\n            md5cycle(this._hash, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Do the final computation based on the tail and length\n        // Beware that the final length may not fit in 32 bits so we take care of that\n        tmp = this._length * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n        md5cycle(this._hash, tail);\n    };\n\n    /**\n     * Performs the md5 hash on a string.\n     * A conversion will be applied if utf8 string is detected.\n     *\n     * @param {String}  str The string\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.hash = function (str, raw) {\n        // Converts the string to utf8 bytes if necessary\n        // Then compute it using the binary function\n        return SparkMD5.hashBinary(toUtf8(str), raw);\n    };\n\n    /**\n     * Performs the md5 hash on a binary string.\n     *\n     * @param {String}  content The binary string\n     * @param {Boolean} raw     True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.hashBinary = function (content, raw) {\n        var hash = md51(content),\n            ret = hex(hash);\n\n        return raw ? hexToBinaryString(ret) : ret;\n    };\n\n    // ---------------------------------------------------\n\n    /**\n     * SparkMD5 OOP implementation for array buffers.\n     *\n     * Use this class to perform an incremental md5 ONLY for array buffers.\n     */\n    SparkMD5.ArrayBuffer = function () {\n        // call reset to init the instance\n        this.reset();\n    };\n\n    /**\n     * Appends an array buffer.\n     *\n     * @param {ArrayBuffer} arr The array to be appended\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.append = function (arr) {\n        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),\n            length = buff.length,\n            i;\n\n        this._length += arr.byteLength;\n\n        for (i = 64; i <= length; i += 64) {\n            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));\n        }\n\n        this._buff = i - 64 < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);\n\n        return this;\n    };\n\n    /**\n     * Finishes the incremental computation, reseting the internal state and\n     * returning the result.\n     *\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.ArrayBuffer.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            i,\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= buff[i] << (i % 4 << 3);\n        }\n\n        this._finish(tail, length);\n        ret = hex(this._hash);\n\n        if (raw) {\n            ret = hexToBinaryString(ret);\n        }\n\n        this.reset();\n\n        return ret;\n    };\n\n    /**\n     * Resets the internal state of the computation.\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.reset = function () {\n        this._buff = new Uint8Array(0);\n        this._length = 0;\n        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\n        return this;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @return {Object} The state\n     */\n    SparkMD5.ArrayBuffer.prototype.getState = function () {\n        var state = SparkMD5.prototype.getState.call(this);\n\n        // Convert buffer to a string\n        state.buff = arrayBuffer2Utf8Str(state.buff);\n\n        return state;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @param {Object} state The state\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.setState = function (state) {\n        // Convert string to buffer\n        state.buff = utf8Str2ArrayBuffer(state.buff, true);\n\n        return SparkMD5.prototype.setState.call(this, state);\n    };\n\n    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;\n\n    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;\n\n    /**\n     * Performs the md5 hash on an array buffer.\n     *\n     * @param {ArrayBuffer} arr The array buffer\n     * @param {Boolean}     raw True to get the raw string, false to get the hex one\n     *\n     * @return {String} The result\n     */\n    SparkMD5.ArrayBuffer.hash = function (arr, raw) {\n        var hash = md51_array(new Uint8Array(arr)),\n            ret = hex(hash);\n\n        return raw ? hexToBinaryString(ret) : ret;\n    };\n\n    return SparkMD5;\n});\n\n/***/ }),\n\n/***/ \"1XVU\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return collate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return normalizeKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return toIndexableString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return parseIndexableString; });\nfunction pad(str, padWith, upToLength) {\n  var padding = '';\n  var targetLength = upToLength - str.length;\n  /* istanbul ignore next */\n  while (padding.length < targetLength) {\n    padding += padWith;\n  }\n  return padding;\n}\n\nfunction padLeft(str, padWith, upToLength) {\n  var padding = pad(str, padWith, upToLength);\n  return padding + str;\n}\n\nvar MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE\nvar MAGNITUDE_DIGITS = 3; // ditto\nvar SEP = ''; // set to '_' for easier debugging \n\nfunction collate(a, b) {\n\n  if (a === b) {\n    return 0;\n  }\n\n  a = normalizeKey(a);\n  b = normalizeKey(b);\n\n  var ai = collationIndex(a);\n  var bi = collationIndex(b);\n  if (ai - bi !== 0) {\n    return ai - bi;\n  }\n  switch (typeof a) {\n    case 'number':\n      return a - b;\n    case 'boolean':\n      return a < b ? -1 : 1;\n    case 'string':\n      return stringCollate(a, b);\n  }\n  return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);\n}\n\n// couch considers null/NaN/Infinity/-Infinity === undefined,\n// for the purposes of mapreduce indexes. also, dates get stringified.\nfunction normalizeKey(key) {\n  switch (typeof key) {\n    case 'undefined':\n      return null;\n    case 'number':\n      if (key === Infinity || key === -Infinity || isNaN(key)) {\n        return null;\n      }\n      return key;\n    case 'object':\n      var origKey = key;\n      if (Array.isArray(key)) {\n        var len = key.length;\n        key = new Array(len);\n        for (var i = 0; i < len; i++) {\n          key[i] = normalizeKey(origKey[i]);\n        }\n        /* istanbul ignore next */\n      } else if (key instanceof Date) {\n        return key.toJSON();\n      } else if (key !== null) {\n        // generic object\n        key = {};\n        for (var k in origKey) {\n          if (origKey.hasOwnProperty(k)) {\n            var val = origKey[k];\n            if (typeof val !== 'undefined') {\n              key[k] = normalizeKey(val);\n            }\n          }\n        }\n      }\n  }\n  return key;\n}\n\nfunction indexify(key) {\n  if (key !== null) {\n    switch (typeof key) {\n      case 'boolean':\n        return key ? 1 : 0;\n      case 'number':\n        return numToIndexableString(key);\n      case 'string':\n        // We've to be sure that key does not contain \\u0000\n        // Do order-preserving replacements:\n        // 0 -> 1, 1\n        // 1 -> 1, 2\n        // 2 -> 2, 2\n        return key.replace(/\\u0002/g, '\\x02\\x02').replace(/\\u0001/g, '\\x01\\x02').replace(/\\u0000/g, '\\x01\\x01');\n      case 'object':\n        var isArray = Array.isArray(key);\n        var arr = isArray ? key : Object.keys(key);\n        var i = -1;\n        var len = arr.length;\n        var result = '';\n        if (isArray) {\n          while (++i < len) {\n            result += toIndexableString(arr[i]);\n          }\n        } else {\n          while (++i < len) {\n            var objKey = arr[i];\n            result += toIndexableString(objKey) + toIndexableString(key[objKey]);\n          }\n        }\n        return result;\n    }\n  }\n  return '';\n}\n\n// convert the given key to a string that would be appropriate\n// for lexical sorting, e.g. within a database, where the\n// sorting is the same given by the collate() function.\nfunction toIndexableString(key) {\n  var zero = '\\0';\n  key = normalizeKey(key);\n  return collationIndex(key) + SEP + indexify(key) + zero;\n}\n\nfunction parseNumber(str, i) {\n  var originalIdx = i;\n  var num;\n  var zero = str[i] === '1';\n  if (zero) {\n    num = 0;\n    i++;\n  } else {\n    var neg = str[i] === '0';\n    i++;\n    var numAsString = '';\n    var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);\n    var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;\n    /* istanbul ignore next */\n    if (neg) {\n      magnitude = -magnitude;\n    }\n    i += MAGNITUDE_DIGITS;\n    while (true) {\n      var ch = str[i];\n      if (ch === '\\0') {\n        break;\n      } else {\n        numAsString += ch;\n      }\n      i++;\n    }\n    numAsString = numAsString.split('.');\n    if (numAsString.length === 1) {\n      num = parseInt(numAsString, 10);\n    } else {\n      /* istanbul ignore next */\n      num = parseFloat(numAsString[0] + '.' + numAsString[1]);\n    }\n    /* istanbul ignore next */\n    if (neg) {\n      num = num - 10;\n    }\n    /* istanbul ignore next */\n    if (magnitude !== 0) {\n      // parseFloat is more reliable than pow due to rounding errors\n      // e.g. Number.MAX_VALUE would return Infinity if we did\n      // num * Math.pow(10, magnitude);\n      num = parseFloat(num + 'e' + magnitude);\n    }\n  }\n  return { num: num, length: i - originalIdx };\n}\n\n// move up the stack while parsing\n// this function moved outside of parseIndexableString for performance\nfunction pop(stack, metaStack) {\n  var obj = stack.pop();\n\n  if (metaStack.length) {\n    var lastMetaElement = metaStack[metaStack.length - 1];\n    if (obj === lastMetaElement.element) {\n      // popping a meta-element, e.g. an object whose value is another object\n      metaStack.pop();\n      lastMetaElement = metaStack[metaStack.length - 1];\n    }\n    var element = lastMetaElement.element;\n    var lastElementIndex = lastMetaElement.index;\n    if (Array.isArray(element)) {\n      element.push(obj);\n    } else if (lastElementIndex === stack.length - 2) {\n      // obj with key+value\n      var key = stack.pop();\n      element[key] = obj;\n    } else {\n      stack.push(obj); // obj with key only\n    }\n  }\n}\n\nfunction parseIndexableString(str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n\n  /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n  while (true) {\n    var collationIndex = str[i++];\n    if (collationIndex === '\\0') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case '1':\n        stack.push(null);\n        break;\n      case '2':\n        stack.push(str[i] === '1');\n        i++;\n        break;\n      case '3':\n        var parsedNum = parseNumber(str, i);\n        stack.push(parsedNum.num);\n        i += parsedNum.length;\n        break;\n      case '4':\n        var parsedStr = '';\n        /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n        while (true) {\n          var ch = str[i];\n          if (ch === '\\0') {\n            break;\n          }\n          parsedStr += ch;\n          i++;\n        }\n        // perform the reverse of the order-preserving replacement\n        // algorithm (see above)\n        parsedStr = parsedStr.replace(/\\u0001\\u0001/g, '\\0').replace(/\\u0001\\u0002/g, '\\x01').replace(/\\u0002\\u0002/g, '\\x02');\n        stack.push(parsedStr);\n        break;\n      case '5':\n        var arrayElement = { element: [], index: stack.length };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '6':\n        var objElement = { element: {}, index: stack.length };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      /* istanbul ignore next */\n      default:\n        throw new Error('bad collationIndex or unexpectedly reached end of input: ' + collationIndex);\n    }\n  }\n}\n\nfunction arrayCollate(a, b) {\n  var len = Math.min(a.length, b.length);\n  for (var i = 0; i < len; i++) {\n    var sort = collate(a[i], b[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n  }\n  return a.length === b.length ? 0 : a.length > b.length ? 1 : -1;\n}\nfunction stringCollate(a, b) {\n  // See: https://github.com/daleharvey/pouchdb/issues/40\n  // This is incompatible with the CouchDB implementation, but its the\n  // best we can do for now\n  return a === b ? 0 : a > b ? 1 : -1;\n}\nfunction objectCollate(a, b) {\n  var ak = Object.keys(a),\n      bk = Object.keys(b);\n  var len = Math.min(ak.length, bk.length);\n  for (var i = 0; i < len; i++) {\n    // First sort the keys\n    var sort = collate(ak[i], bk[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n    // if the keys are equal sort the values\n    sort = collate(a[ak[i]], b[bk[i]]);\n    if (sort !== 0) {\n      return sort;\n    }\n  }\n  return ak.length === bk.length ? 0 : ak.length > bk.length ? 1 : -1;\n}\n// The collation is defined by erlangs ordered terms\n// the atoms null, true, false come first, then numbers, strings,\n// arrays, then objects\n// null/undefined/NaN/Infinity/-Infinity are all considered null\nfunction collationIndex(x) {\n  var id = ['boolean', 'number', 'string', 'object'];\n  var idx = id.indexOf(typeof x);\n  //false if -1 otherwise true, but fast!!!!1\n  if (~idx) {\n    if (x === null) {\n      return 1;\n    }\n    if (Array.isArray(x)) {\n      return 5;\n    }\n    return idx < 3 ? idx + 2 : idx + 3;\n  }\n  /* istanbul ignore next */\n  if (Array.isArray(x)) {\n    return 5;\n  }\n}\n\n// conversion:\n// x yyy zz...zz\n// x = 0 for negative, 1 for 0, 2 for positive\n// y = exponent (for negative numbers negated) moved so that it's >= 0\n// z = mantisse\nfunction numToIndexableString(num) {\n\n  if (num === 0) {\n    return '1';\n  }\n\n  // convert number to exponential format for easier and\n  // more succinct string sorting\n  var expFormat = num.toExponential().split(/e\\+?/);\n  var magnitude = parseInt(expFormat[1], 10);\n\n  var neg = num < 0;\n\n  var result = neg ? '0' : '2';\n\n  // first sort by magnitude\n  // it's easier if all magnitudes are positive\n  var magForComparison = (neg ? -magnitude : magnitude) - MIN_MAGNITUDE;\n  var magString = padLeft(magForComparison.toString(), '0', MAGNITUDE_DIGITS);\n\n  result += SEP + magString;\n\n  // then sort by the factor\n  var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)\n  /* istanbul ignore next */\n  if (neg) {\n    // for negative reverse ordering\n    factor = 10 - factor;\n  }\n\n  var factorStr = factor.toFixed(20);\n\n  // strip zeros from the end\n  factorStr = factorStr.replace(/\\.?0+$/, '');\n\n  result += SEP + factorStr;\n\n  return result;\n}\n\n\n\n/***/ }),\n\n/***/ \"1ipf\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ShoppingListRepository = function () {\n  function ShoppingListRepository() {\n    _classCallCheck(this, ShoppingListRepository);\n  }\n\n  ShoppingListRepository.prototype.put = function put(shoppingList) {};\n\n  ShoppingListRepository.prototype.putBulk = function putBulk(shoppingLists) {};\n\n  ShoppingListRepository.prototype.get = function get(shoppingListId) {};\n\n  ShoppingListRepository.prototype.find = function find(request) {};\n\n  ShoppingListRepository.prototype.delete = function _delete(shoppingList) {};\n\n  ShoppingListRepository.prototype.putItem = function putItem(shoppingListItem) {};\n\n  ShoppingListRepository.prototype.putItemsBulk = function putItemsBulk(shoppingListItems) {};\n\n  ShoppingListRepository.prototype.getItem = function getItem(shoppingListItemId) {};\n\n  ShoppingListRepository.prototype.findItems = function findItems(request) {};\n\n  ShoppingListRepository.prototype.findItemsCountByList = function findItemsCountByList(request) {};\n\n  ShoppingListRepository.prototype.deleteItem = function deleteItem(shoppingListItem) {};\n\n  return ShoppingListRepository;\n}();\n\nexports.ShoppingListRepository = ShoppingListRepository;\n\n/***/ }),\n\n/***/ \"38I5\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = argsArray;\n\nfunction argsArray(fun) {\n  return function () {\n    var len = arguments.length;\n    if (len) {\n      var args = [];\n      var i = -1;\n      while (++i < len) {\n        args[i] = arguments[i];\n      }\n      return fun.call(this, args);\n    } else {\n      return fun.call(this, []);\n    }\n  };\n}\n\n/***/ }),\n\n/***/ \"435A\":\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * cuid.js\n * Collision-resistant UID generator for browsers and node.\n * Sequential for fast db lookups and recency sorting.\n * Safe for element IDs and server-side lookups.\n *\n * Extracted from CLCTR\n *\n * Copyright (c) Eric Elliott 2012\n * MIT License\n */\n\n/*global window, navigator, document, require, process, module */\n(function (app) {\n  'use strict';\n\n  var namespace = 'cuid',\n      c = 0,\n      blockSize = 4,\n      base = 36,\n      discreteValues = Math.pow(base, blockSize),\n      pad = function pad(num, size) {\n    var s = \"000000000\" + num;\n    return s.substr(s.length - size);\n  },\n      randomBlock = function randomBlock() {\n    return pad((Math.random() * discreteValues << 0).toString(base), blockSize);\n  },\n      safeCounter = function safeCounter() {\n    c = c < discreteValues ? c : 0;\n    c++; // this is not subliminal\n    return c - 1;\n  },\n      api = function cuid() {\n    // Starting with a lowercase letter makes\n    // it HTML element ID friendly.\n    var letter = 'c',\n        // hard-coded allows for sequential access\n\n    // timestamp\n    // warning: this exposes the exact date and time\n    // that the uid was created.\n    timestamp = new Date().getTime().toString(base),\n\n\n    // Prevent same-machine collisions.\n    counter,\n\n\n    // A few chars to generate distinct ids for different\n    // clients (so different computers are far less\n    // likely to generate the same id)\n    fingerprint = api.fingerprint(),\n\n\n    // Grab some more chars from Math.random()\n    random = randomBlock() + randomBlock();\n\n    counter = pad(safeCounter().toString(base), blockSize);\n\n    return letter + timestamp + counter + fingerprint + random;\n  };\n\n  api.slug = function slug() {\n    var date = new Date().getTime().toString(36),\n        counter,\n        print = api.fingerprint().slice(0, 1) + api.fingerprint().slice(-1),\n        random = randomBlock().slice(-2);\n\n    counter = safeCounter().toString(36).slice(-4);\n\n    return date.slice(-2) + counter + print + random;\n  };\n\n  api.globalCount = function globalCount() {\n    // We want to cache the results of this\n    var cache = function calc() {\n      var i,\n          count = 0;\n\n      for (i in window) {\n        count++;\n      }\n\n      return count;\n    }();\n\n    api.globalCount = function () {\n      return cache;\n    };\n    return cache;\n  };\n\n  api.fingerprint = function browserPrint() {\n    return pad((navigator.mimeTypes.length + navigator.userAgent.length).toString(36) + api.globalCount().toString(36), 4);\n  };\n\n  // don't change anything from here down.\n  if (app.register) {\n    app.register(namespace, api);\n  } else if (true) {\n    module.exports = api;\n  } else {\n    app[namespace] = api;\n  }\n})(this.applitude || this);\n\n/***/ }),\n\n/***/ \"4Bm0\":\n/***/ (function(module, exports) {\n\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor;\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor;\n    var TempCtor = function TempCtor() {};\n    TempCtor.prototype = superCtor.prototype;\n    ctor.prototype = new TempCtor();\n    ctor.prototype.constructor = ctor;\n  };\n}\n\n/***/ }),\n\n/***/ \"5euN\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lie__ = __webpack_require__(\"xz3w\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lie___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lie__);\n\n\n/* istanbul ignore next */\nvar PouchPromise = typeof Promise === 'function' ? Promise : __WEBPACK_IMPORTED_MODULE_0_lie___default.a;\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (PouchPromise);\n\n/***/ }),\n\n/***/ \"6IAg\":\n/***/ (function(module, exports) {\n\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 10000) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n/***/ }),\n\n/***/ \"8/Wf\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export atob */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return thisBtoa; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return b64ToBluffer; });\n/* unused harmony export binaryStringToArrayBuffer */\n/* unused harmony export binaryStringToBlobOrBuffer */\n/* unused harmony export blob */\n/* unused harmony export blobOrBufferToBase64 */\n/* unused harmony export blobOrBufferToBinaryString */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return readAsArrayBuffer; });\n/* unused harmony export readAsBinaryString */\n/* unused harmony export typedBuffer */\nvar thisAtob = function thisAtob(str) {\n  return atob(str);\n};\n\nvar thisBtoa = function thisBtoa(str) {\n  return btoa(str);\n};\n\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor (e.g.\n// old QtWebKit versions, Android < 4.4).\nfunction createBlob(parts, properties) {\n  /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n  parts = parts || [];\n  properties = properties || {};\n  try {\n    return new Blob(parts, properties);\n  } catch (e) {\n    if (e.name !== \"TypeError\") {\n      throw e;\n    }\n    var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;\n    var builder = new Builder();\n    for (var i = 0; i < parts.length; i += 1) {\n      builder.append(parts[i]);\n    }\n    return builder.getBlob(properties.type);\n  }\n}\n\n// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n// encode-decode-image-with-base64-breaks-image (2013-04-21)\nfunction binaryStringToArrayBuffer(bin) {\n  var length = bin.length;\n  var buf = new ArrayBuffer(length);\n  var arr = new Uint8Array(buf);\n  for (var i = 0; i < length; i++) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return buf;\n}\n\nfunction binStringToBluffer(binString, type) {\n  return createBlob([binaryStringToArrayBuffer(binString)], { type: type });\n}\n\nfunction b64ToBluffer(b64, type) {\n  return binStringToBluffer(thisAtob(b64), type);\n}\n\n//Can't find original post, but this is close\n//http://stackoverflow.com/questions/6965107/ (continues on next line)\n//converting-between-strings-and-arraybuffers\nfunction arrayBufferToBinaryString(buffer) {\n  var binary = '';\n  var bytes = new Uint8Array(buffer);\n  var length = bytes.byteLength;\n  for (var i = 0; i < length; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return binary;\n}\n\n// shim for browsers that don't support it\nfunction readAsBinaryString(blob, callback) {\n  if (typeof FileReader === 'undefined') {\n    // fix for Firefox in a web worker\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n    return callback(arrayBufferToBinaryString(new FileReaderSync().readAsArrayBuffer(blob)));\n  }\n\n  var reader = new FileReader();\n  var hasBinaryString = typeof reader.readAsBinaryString === 'function';\n  reader.onloadend = function (e) {\n    var result = e.target.result || '';\n    if (hasBinaryString) {\n      return callback(result);\n    }\n    callback(arrayBufferToBinaryString(result));\n  };\n  if (hasBinaryString) {\n    reader.readAsBinaryString(blob);\n  } else {\n    reader.readAsArrayBuffer(blob);\n  }\n}\n\nfunction blobToBinaryString(blobOrBuffer, callback) {\n  readAsBinaryString(blobOrBuffer, function (bin) {\n    callback(bin);\n  });\n}\n\nfunction blobToBase64(blobOrBuffer, callback) {\n  blobToBinaryString(blobOrBuffer, function (base64) {\n    callback(thisBtoa(base64));\n  });\n}\n\n// simplified API. universal browser support is assumed\nfunction readAsArrayBuffer(blob, callback) {\n  if (typeof FileReader === 'undefined') {\n    // fix for Firefox in a web worker:\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n    return callback(new FileReaderSync().readAsArrayBuffer(blob));\n  }\n\n  var reader = new FileReader();\n  reader.onloadend = function (e) {\n    var result = e.target.result || new ArrayBuffer(0);\n    callback(result);\n  };\n  reader.readAsArrayBuffer(blob);\n}\n\n// this is not used in the browser\nfunction typedBuffer() {}\n\n\n\n/***/ }),\n\n/***/ \"9RN+\":\n/***/ (function(module, exports) {\n\n// removed by extract-text-webpack-plugin\n\n/***/ }),\n\n/***/ \"9oy1\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar Credentials = {\n  \"cloudant_url\": \"https://disheserentleaveratedgai:928a6f0a42cd1079d9846604913131d6d5b25ee9@rajsingh.cloudant.com/preact-pwa\"\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Credentials);\n\n/***/ }),\n\n/***/ \"C9XX\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return massageSelector; });\n/* unused harmony export matchesSelector */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return filterInMemoryFields; });\n/* unused harmony export createFieldSorter */\n/* unused harmony export rowFilter */\n/* unused harmony export isCombinationalField */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return getKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return getValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return getFieldFromDoc; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return setFieldInDoc; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return compare; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return parseField; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_pouchdb_utils__ = __webpack_require__(\"mY35\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_pouchdb_collate__ = __webpack_require__(\"1XVU\");\n\n\n\n// this would just be \"return doc[field]\", but fields\n// can be \"deep\" due to dot notation\nfunction getFieldFromDoc(doc, parsedField) {\n  var value = doc;\n  for (var i = 0, len = parsedField.length; i < len; i++) {\n    var key = parsedField[i];\n    value = value[key];\n    if (!value) {\n      break;\n    }\n  }\n  return value;\n}\n\nfunction setFieldInDoc(doc, parsedField, value) {\n  for (var i = 0, len = parsedField.length; i < len - 1; i++) {\n    var elem = parsedField[i];\n    doc = doc[elem] = {};\n  }\n  doc[parsedField[len - 1]] = value;\n}\n\nfunction compare(left, right) {\n  return left < right ? -1 : left > right ? 1 : 0;\n}\n\n// Converts a string in dot notation to an array of its components, with backslash escaping\nfunction parseField(fieldName) {\n  // fields may be deep (e.g. \"foo.bar.baz\"), so parse\n  var fields = [];\n  var current = '';\n  for (var i = 0, len = fieldName.length; i < len; i++) {\n    var ch = fieldName[i];\n    if (ch === '.') {\n      if (i > 0 && fieldName[i - 1] === '\\\\') {\n        // escaped delimiter\n        current = current.substring(0, current.length - 1) + '.';\n      } else {\n        // not escaped, so delimiter\n        fields.push(current);\n        current = '';\n      }\n    } else {\n      // normal character\n      current += ch;\n    }\n  }\n  fields.push(current);\n  return fields;\n}\n\nvar combinationFields = ['$or', '$nor', '$not'];\nfunction isCombinationalField(field) {\n  return combinationFields.indexOf(field) > -1;\n}\n\nfunction getKey(obj) {\n  return Object.keys(obj)[0];\n}\n\nfunction getValue(obj) {\n  return obj[getKey(obj)];\n}\n\n// flatten an array of selectors joined by an $and operator\nfunction mergeAndedSelectors(selectors) {\n\n  // sort to ensure that e.g. if the user specified\n  // $and: [{$gt: 'a'}, {$gt: 'b'}], then it's collapsed into\n  // just {$gt: 'b'}\n  var res = {};\n\n  selectors.forEach(function (selector) {\n    Object.keys(selector).forEach(function (field) {\n      var matcher = selector[field];\n      if (typeof matcher !== 'object') {\n        matcher = { $eq: matcher };\n      }\n\n      if (isCombinationalField(field)) {\n        if (matcher instanceof Array) {\n          res[field] = matcher.map(function (m) {\n            return mergeAndedSelectors([m]);\n          });\n        } else {\n          res[field] = mergeAndedSelectors([matcher]);\n        }\n      } else {\n        var fieldMatchers = res[field] = res[field] || {};\n        Object.keys(matcher).forEach(function (operator) {\n          var value = matcher[operator];\n\n          if (operator === '$gt' || operator === '$gte') {\n            return mergeGtGte(operator, value, fieldMatchers);\n          } else if (operator === '$lt' || operator === '$lte') {\n            return mergeLtLte(operator, value, fieldMatchers);\n          } else if (operator === '$ne') {\n            return mergeNe(value, fieldMatchers);\n          } else if (operator === '$eq') {\n            return mergeEq(value, fieldMatchers);\n          }\n          fieldMatchers[operator] = value;\n        });\n      }\n    });\n  });\n\n  return res;\n}\n\n// collapse logically equivalent gt/gte values\nfunction mergeGtGte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$gte !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gte) {\n        // more specificity\n        fieldMatchers.$gte = value;\n      }\n    } else {\n      // operator === '$gt'\n      if (value >= fieldMatchers.$gte) {\n        // more specificity\n        delete fieldMatchers.$gte;\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$gt !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gt) {\n        // more specificity\n        delete fieldMatchers.$gt;\n        fieldMatchers.$gte = value;\n      }\n    } else {\n      // operator === '$gt'\n      if (value > fieldMatchers.$gt) {\n        // more specificity\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// collapse logically equivalent lt/lte values\nfunction mergeLtLte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$lte !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lte) {\n        // more specificity\n        fieldMatchers.$lte = value;\n      }\n    } else {\n      // operator === '$gt'\n      if (value <= fieldMatchers.$lte) {\n        // more specificity\n        delete fieldMatchers.$lte;\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$lt !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lt) {\n        // more specificity\n        delete fieldMatchers.$lt;\n        fieldMatchers.$lte = value;\n      }\n    } else {\n      // operator === '$gt'\n      if (value < fieldMatchers.$lt) {\n        // more specificity\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// combine $ne values into one array\nfunction mergeNe(value, fieldMatchers) {\n  if ('$ne' in fieldMatchers) {\n    // there are many things this could \"not\" be\n    fieldMatchers.$ne.push(value);\n  } else {\n    // doesn't exist yet\n    fieldMatchers.$ne = [value];\n  }\n}\n\n// add $eq into the mix\nfunction mergeEq(value, fieldMatchers) {\n  // these all have less specificity than the $eq\n  // TODO: check for user errors here\n  delete fieldMatchers.$gt;\n  delete fieldMatchers.$gte;\n  delete fieldMatchers.$lt;\n  delete fieldMatchers.$lte;\n  delete fieldMatchers.$ne;\n  fieldMatchers.$eq = value;\n}\n\n//\n// normalize the selector\n//\nfunction massageSelector(input) {\n  var result = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_pouchdb_utils__[\"a\" /* clone */])(input);\n  var wasAnded = false;\n  if ('$and' in result) {\n    result = mergeAndedSelectors(result['$and']);\n    wasAnded = true;\n  }\n\n  ['$or', '$nor'].forEach(function (orOrNor) {\n    if (orOrNor in result) {\n      // message each individual selector\n      // e.g. {foo: 'bar'} becomes {foo: {$eq: 'bar'}}\n      result[orOrNor].forEach(function (subSelector) {\n        var fields = Object.keys(subSelector);\n        for (var i = 0; i < fields.length; i++) {\n          var field = fields[i];\n          var matcher = subSelector[field];\n          if (typeof matcher !== 'object' || matcher === null) {\n            subSelector[field] = { $eq: matcher };\n          }\n        }\n      });\n    }\n  });\n\n  if ('$not' in result) {\n    //This feels a little like forcing, but it will work for now,\n    //I would like to come back to this and make the merging of selectors a little more generic\n    result['$not'] = mergeAndedSelectors([result['$not']]);\n  }\n\n  var fields = Object.keys(result);\n\n  for (var i = 0; i < fields.length; i++) {\n    var field = fields[i];\n    var matcher = result[field];\n\n    if (typeof matcher !== 'object' || matcher === null) {\n      matcher = { $eq: matcher };\n    } else if ('$ne' in matcher && !wasAnded) {\n      // I put these in an array, since there may be more than one\n      // but in the \"mergeAnded\" operation, I already take care of that\n      matcher.$ne = [matcher.$ne];\n    }\n    result[field] = matcher;\n  }\n\n  return result;\n}\n\n// create a comparator based on the sort object\nfunction createFieldSorter(sort) {\n\n  function getFieldValuesAsArray(doc) {\n    return sort.map(function (sorting) {\n      var fieldName = getKey(sorting);\n      var parsedField = parseField(fieldName);\n      var docFieldValue = getFieldFromDoc(doc, parsedField);\n      return docFieldValue;\n    });\n  }\n\n  return function (aRow, bRow) {\n    var aFieldValues = getFieldValuesAsArray(aRow.doc);\n    var bFieldValues = getFieldValuesAsArray(bRow.doc);\n    var collation = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_pouchdb_collate__[\"a\" /* collate */])(aFieldValues, bFieldValues);\n    if (collation !== 0) {\n      return collation;\n    }\n    // this is what mango seems to do\n    return compare(aRow.doc._id, bRow.doc._id);\n  };\n}\n\nfunction filterInMemoryFields(rows, requestDef, inMemoryFields) {\n  rows = rows.filter(function (row) {\n    return rowFilter(row.doc, requestDef.selector, inMemoryFields);\n  });\n\n  if (requestDef.sort) {\n    // in-memory sort\n    var fieldSorter = createFieldSorter(requestDef.sort);\n    rows = rows.sort(fieldSorter);\n    if (typeof requestDef.sort[0] !== 'string' && getValue(requestDef.sort[0]) === 'desc') {\n      rows = rows.reverse();\n    }\n  }\n\n  if ('limit' in requestDef || 'skip' in requestDef) {\n    // have to do the limit in-memory\n    var skip = requestDef.skip || 0;\n    var limit = ('limit' in requestDef ? requestDef.limit : rows.length) + skip;\n    rows = rows.slice(skip, limit);\n  }\n  return rows;\n}\n\nfunction rowFilter(doc, selector, inMemoryFields) {\n  return inMemoryFields.every(function (field) {\n    var matcher = selector[field];\n    var parsedField = parseField(field);\n    var docFieldValue = getFieldFromDoc(doc, parsedField);\n    if (isCombinationalField(field)) {\n      return matchCominationalSelector(field, matcher, doc);\n    }\n\n    return matchSelector(matcher, doc, parsedField, docFieldValue);\n  });\n}\n\nfunction matchSelector(matcher, doc, parsedField, docFieldValue) {\n  if (!matcher) {\n    // no filtering necessary; this field is just needed for sorting\n    return true;\n  }\n\n  return Object.keys(matcher).every(function (userOperator) {\n    var userValue = matcher[userOperator];\n    return match(userOperator, doc, userValue, parsedField, docFieldValue);\n  });\n}\n\nfunction matchCominationalSelector(field, matcher, doc) {\n\n  if (field === '$or') {\n    return matcher.some(function (orMatchers) {\n      return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n    });\n  }\n\n  if (field === '$not') {\n    return !rowFilter(doc, matcher, Object.keys(matcher));\n  }\n\n  //`$nor`\n  return !matcher.find(function (orMatchers) {\n    return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n  });\n}\n\nfunction match(userOperator, doc, userValue, parsedField, docFieldValue) {\n  if (!matchers[userOperator]) {\n    throw new Error('unknown operator \"' + userOperator + '\" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, ' + '$nin, $size, $mod, $regex, $elemMatch, $type, $allMatch or $all');\n  }\n  return matchers[userOperator](doc, userValue, parsedField, docFieldValue);\n}\n\nfunction fieldExists(docFieldValue) {\n  return typeof docFieldValue !== 'undefined' && docFieldValue !== null;\n}\n\nfunction fieldIsNotUndefined(docFieldValue) {\n  return typeof docFieldValue !== 'undefined';\n}\n\nfunction modField(docFieldValue, userValue) {\n  var divisor = userValue[0];\n  var mod = userValue[1];\n  if (divisor === 0) {\n    throw new Error('Bad divisor, cannot divide by zero');\n  }\n\n  if (parseInt(divisor, 10) !== divisor) {\n    throw new Error('Divisor is not an integer');\n  }\n\n  if (parseInt(mod, 10) !== mod) {\n    throw new Error('Modulus is not an integer');\n  }\n\n  if (parseInt(docFieldValue, 10) !== docFieldValue) {\n    return false;\n  }\n\n  return docFieldValue % divisor === mod;\n}\n\nfunction arrayContainsValue(docFieldValue, userValue) {\n  return userValue.some(function (val) {\n    if (docFieldValue instanceof Array) {\n      return docFieldValue.indexOf(val) > -1;\n    }\n\n    return docFieldValue === val;\n  });\n}\n\nfunction arrayContainsAllValues(docFieldValue, userValue) {\n  return userValue.every(function (val) {\n    return docFieldValue.indexOf(val) > -1;\n  });\n}\n\nfunction arraySize(docFieldValue, userValue) {\n  return docFieldValue.length === userValue;\n}\n\nfunction regexMatch(docFieldValue, userValue) {\n  var re = new RegExp(userValue);\n\n  return re.test(docFieldValue);\n}\n\nfunction typeMatch(docFieldValue, userValue) {\n\n  switch (userValue) {\n    case 'null':\n      return docFieldValue === null;\n    case 'boolean':\n      return typeof docFieldValue === 'boolean';\n    case 'number':\n      return typeof docFieldValue === 'number';\n    case 'string':\n      return typeof docFieldValue === 'string';\n    case 'array':\n      return docFieldValue instanceof Array;\n    case 'object':\n      return {}.toString.call(docFieldValue) === '[object Object]';\n  }\n\n  throw new Error(userValue + ' not supported as a type.' + 'Please use one of object, string, array, number, boolean or null.');\n}\n\nvar matchers = {\n\n  '$elemMatch': function $elemMatch(doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object') {\n      return docFieldValue.some(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.some(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n\n  '$allMatch': function $allMatch(doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n\n    /* istanbul ignore next */\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object') {\n      return docFieldValue.every(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.every(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n\n  '$eq': function $eq(doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_pouchdb_collate__[\"a\" /* collate */])(docFieldValue, userValue) === 0;\n  },\n\n  '$gte': function $gte(doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_pouchdb_collate__[\"a\" /* collate */])(docFieldValue, userValue) >= 0;\n  },\n\n  '$gt': function $gt(doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_pouchdb_collate__[\"a\" /* collate */])(docFieldValue, userValue) > 0;\n  },\n\n  '$lte': function $lte(doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_pouchdb_collate__[\"a\" /* collate */])(docFieldValue, userValue) <= 0;\n  },\n\n  '$lt': function $lt(doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_pouchdb_collate__[\"a\" /* collate */])(docFieldValue, userValue) < 0;\n  },\n\n  '$exists': function $exists(doc, userValue, parsedField, docFieldValue) {\n    //a field that is null is still considered to exist\n    if (userValue) {\n      return fieldIsNotUndefined(docFieldValue);\n    }\n\n    return !fieldIsNotUndefined(docFieldValue);\n  },\n\n  '$mod': function $mod(doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && modField(docFieldValue, userValue);\n  },\n\n  '$ne': function $ne(doc, userValue, parsedField, docFieldValue) {\n    return userValue.every(function (neValue) {\n      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_pouchdb_collate__[\"a\" /* collate */])(docFieldValue, neValue) !== 0;\n    });\n  },\n  '$in': function $in(doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$nin': function $nin(doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && !arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$size': function $size(doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arraySize(docFieldValue, userValue);\n  },\n\n  '$all': function $all(doc, userValue, parsedField, docFieldValue) {\n    return Array.isArray(docFieldValue) && arrayContainsAllValues(docFieldValue, userValue);\n  },\n\n  '$regex': function $regex(doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && regexMatch(docFieldValue, userValue);\n  },\n\n  '$type': function $type(doc, userValue, parsedField, docFieldValue) {\n    return typeMatch(docFieldValue, userValue);\n  }\n};\n\n// return true if the given doc matches the supplied selector\nfunction matchesSelector(doc, selector) {\n  /* istanbul ignore if */\n  if (typeof selector !== 'object') {\n    // match the CouchDB error message\n    throw new Error('Selector error: expected a JSON object');\n  }\n\n  selector = massageSelector(selector);\n  var row = {\n    'doc': doc\n  };\n\n  var rowsMatched = filterInMemoryFields([row], { 'selector': selector }, Object.keys(selector));\n  return rowsMatched && rowsMatched.length === 1;\n}\n\n\n\n/***/ }),\n\n/***/ \"CR5u\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_preact__ = __webpack_require__(\"KM04\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_preact___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_preact__);\n\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\nvar _ref = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n  'i',\n  { className: 'material-icons' },\n  'close'\n);\n\nvar _ref3 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n  'i',\n  { className: 'material-icons' },\n  'play_arrow'\n);\n\nvar _ref4 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n  'i',\n  { className: 'material-icons' },\n  'mode_edit'\n);\n\nvar _ref5 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n  'i',\n  { className: 'material-icons' },\n  'delete_forever'\n);\n\nvar ShoppingLists = function (_Component) {\n  _inherits(ShoppingLists, _Component);\n\n  function ShoppingLists() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, ShoppingLists);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.state = {\n      editingName: false,\n      activeListId: '',\n      oldName: '',\n      newName: ''\n    }, _this.handleEditingStart = function (listid, listtitle) {\n      _this.setState({ editingName: true, activeListId: listid, oldName: listtitle });\n    }, _this.handleEditingDone = function () {\n      _this.setState({ editingName: false });\n    }, _this.handleEditingSubmit = function (e) {\n      _this.props.renameListFunc(_this.state.activeListId, _this.state.newName);\n      _this.handleEditingDone();\n    }, _this.updateName = function (e) {\n      _this.setState({ newName: e.target.value });\n    }, _this.renderEditNameUI = function () {\n      var _h;\n\n      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n        'div',\n        { className: 'editing' },\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n          'div',\n          { className: 'col s9' },\n          __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n            'form',\n            { onSubmit: _this.handleEditingSubmit },\n            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n              'div',\n              { 'class': 'input-field',\n                style: { \"margin-top\": \"0.5rem\", \"background-color\": \"aliceblue\" } },\n              __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])('input', { type: 'text', id: 'input-name',\n                ref: function ref(inp) {\n                  _this.nameInput = inp;\n                },\n                value: _this.state.oldName,\n                onChange: _this.updateName,\n                style: { height: \"unset\", \"font-size\": \"18pt\", \"margin-bottom\": \"8px\" } })\n            )\n          )\n        ),\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n          'div',\n          { className: 'col s3' },\n          __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n            'a',\n            (_h = { className: 'btn-flat btn-large', style: { padding: \"0 0.5rem\" } }, _h['style'] = { padding: \"0px\" }, _h.onClick = _this.handleEditingDone, _h),\n            _ref\n          )\n        )\n      );\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n  /* all state actions are for handling the renaming dialog */\n\n\n  ShoppingLists.prototype.componentDidUpdate = function componentDidUpdate() {\n    if (this.state.editingName === true) {\n      this.nameInput.focus();\n    }\n  };\n\n  ShoppingLists.prototype.render = function render() {\n    var _this2 = this;\n\n    var listItems = [];\n\n    var _loop = function _loop(list) {\n      listItems.push(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n        'div',\n        { className: 'shoppinglist', key: list._id, style: { margin: \"12px 0\", padding: \"12px\" } },\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n          'div',\n          { 'class': 'row', style: 'margin-bottom: 0px' },\n          _this2.state.editingName && _this2.state.activeListId === list._id ? _this2.renderEditNameUI() : __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n            'div',\n            { className: 'notediting' },\n            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n              'div',\n              { className: 'col s7' },\n              __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n                'h5',\n                null,\n                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n                  'a',\n                  { href: '#', onClick: function onClick() {\n                      return _this2.props.openListFunc(list._id);\n                    } },\n                  list.title\n                )\n              )\n            ),\n            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n              'div',\n              { className: 'col s5 right-align' },\n              __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n                'a',\n                { className: 'btn-flat btn-large', style: { padding: \"0 0.5rem\" },\n                  onClick: function onClick() {\n                    return _this2.props.openListFunc(list._id);\n                  } },\n                _ref3\n              ),\n              __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n                'a',\n                { className: 'btn-flat btn-large', style: { padding: \"0 0.5rem\" },\n                  onClick: function onClick() {\n                    return _this2.handleEditingStart(list._id, list.title);\n                  } },\n                _ref4\n              ),\n              __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n                'a',\n                { className: 'btn-flat btn-large', style: { padding: \"0 0.5rem\" },\n                  onClick: function onClick() {\n                    return _this2.props.deleteListFunc(list._id);\n                  } },\n                _ref5\n              )\n            )\n          )\n        ),\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n          'div',\n          { className: 'row' },\n          __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n            'div',\n            { className: 'col s1' },\n            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])('input', { type: 'checkbox', id: \"cb_\" + list._id,\n              onChange: function onChange() {\n                return _this2.props.checkAllFunc(list._id);\n              },\n              defaultChecked: false }),\n            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n              'label',\n              { 'for': \"cb_\" + list._id },\n              '\\xA0'\n            )\n          ),\n          __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n            'div',\n            { className: 'col s11' },\n            (_this2.props.checkedCounts.get(list._id) || 0) + ' of ' + (_this2.props.totalCounts.get(list._id) || 0) + ' items checked'\n          )\n        )\n      ));\n    };\n\n    for (var _iterator = this.props.shoppingLists, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref2 = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref2 = _i.value;\n      }\n\n      var list = _ref2;\n\n      _loop(list);\n    }\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n      'div',\n      null,\n      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n        'div',\n        null,\n        listItems\n      )\n    );\n  };\n\n  return ShoppingLists;\n}(__WEBPACK_IMPORTED_MODULE_0_preact__[\"Component\"]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (ShoppingLists);\n\n/***/ }),\n\n/***/ \"HSMo\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _require = __webpack_require__(\"YrHc\"),\n    ShoppingListFactory = _require.ShoppingListFactory;\n\nvar _require2 = __webpack_require__(\"1ipf\"),\n    ShoppingListRepository = _require2.ShoppingListRepository;\n\nvar _require3 = __webpack_require__(\"wdwc\"),\n    ShoppingListRepositoryPouchDB = _require3.ShoppingListRepositoryPouchDB;\n\nexports.ShoppingListFactory = ShoppingListFactory;\nexports.ShoppingListRepository = ShoppingListRepository;\nexports.ShoppingListRepositoryPouchDB = ShoppingListRepositoryPouchDB;\n\n/***/ }),\n\n/***/ \"IFa6\":\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function splitPath(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function () {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = i >= 0 ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function (path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function (p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function (path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function () {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function (p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n// path.relative(from, to)\n// posix version\nexports.relative = function (from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function (path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\nexports.basename = function (path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\nexports.extname = function (path) {\n  return splitPath(path)[3];\n};\n\nfunction filter(xs, f) {\n  if (xs.filter) return xs.filter(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    if (f(xs[i], i, xs)) res.push(xs[i]);\n  }\n  return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {\n  return str.substr(start, len);\n} : function (str, start, len) {\n  if (start < 0) start = str.length + start;\n  return str.substr(start, len);\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(\"xdep\")))\n\n/***/ }),\n\n/***/ \"JkW7\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_preact__ = __webpack_require__(\"KM04\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_preact___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_preact__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ibm_shopping_list_model__ = __webpack_require__(\"HSMo\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ibm_shopping_list_model___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_ibm_shopping_list_model__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_pouchdb__ = __webpack_require__(\"+bp/\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_pouchdb_find__ = __webpack_require__(\"rsNZ\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__secret__ = __webpack_require__(\"9oy1\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__material_icons_css__ = __webpack_require__(\"9RN+\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__material_icons_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__material_icons_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__materialize_min_css__ = __webpack_require__(\"RIsC\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__materialize_min_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6__materialize_min_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__App_css__ = __webpack_require__(\"S03M\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__App_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7__App_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__App__ = __webpack_require__(\"UuX/\");\n\n\n\n\n\n\n\n\n// import './materialize.min.js';\n\n\n__WEBPACK_IMPORTED_MODULE_2_pouchdb__[\"a\" /* default */].plugin(__WEBPACK_IMPORTED_MODULE_3_pouchdb_find__[\"a\" /* default */]);\nvar localDB = new __WEBPACK_IMPORTED_MODULE_2_pouchdb__[\"a\" /* default */]('shopping_list_react');\nvar remoteDB = new __WEBPACK_IMPORTED_MODULE_2_pouchdb__[\"a\" /* default */](__WEBPACK_IMPORTED_MODULE_4__secret__[\"a\" /* default */].cloudant_url);\nvar shoppingListFactory = new __WEBPACK_IMPORTED_MODULE_1_ibm_shopping_list_model__[\"ShoppingListFactory\"]();\nvar shoppingListRepository = new __WEBPACK_IMPORTED_MODULE_1_ibm_shopping_list_model__[\"ShoppingListRepositoryPouchDB\"](localDB);\n\n\n\nshoppingListRepository.ensureIndexes().then(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"render\"])(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(__WEBPACK_IMPORTED_MODULE_8__App__[\"a\" /* default */], {\n  shoppingListFactory: shoppingListFactory,\n  shoppingListRepository: shoppingListRepository,\n  localDB: localDB, remoteDB: remoteDB }), document.body)).catch(function (err) {\n  console.log(\"ERROR in ensureIndexes\");\n  console.log(err);\n});\n\n/***/ }),\n\n/***/ \"KM04\":\n/***/ (function(module, exports, __webpack_require__) {\n\n!function () {\n  \"use strict\";\n  function e() {}function t(t, n) {\n    var o,\n        r,\n        i,\n        l,\n        a = E;for (l = arguments.length; l-- > 2;) {\n      W.push(arguments[l]);\n    }n && null != n.children && (W.length || W.push(n.children), delete n.children);while (W.length) {\n      if ((r = W.pop()) && void 0 !== r.pop) for (l = r.length; l--;) {\n        W.push(r[l]);\n      } else \"boolean\" == typeof r && (r = null), (i = \"function\" != typeof t) && (null == r ? r = \"\" : \"number\" == typeof r ? r += \"\" : \"string\" != typeof r && (i = !1)), i && o ? a[a.length - 1] += r : a === E ? a = [r] : a.push(r), o = i;\n    }var u = new e();return u.nodeName = t, u.children = a, u.attributes = null == n ? void 0 : n, u.key = null == n ? void 0 : n.key, void 0 !== S.vnode && S.vnode(u), u;\n  }function n(e, t) {\n    for (var n in t) {\n      e[n] = t[n];\n    }return e;\n  }function o(e, o) {\n    return t(e.nodeName, n(n({}, e.attributes), o), arguments.length > 2 ? [].slice.call(arguments, 2) : e.children);\n  }function r(e) {\n    !e.__d && (e.__d = !0) && 1 == A.push(e) && (S.debounceRendering || P)(i);\n  }function i() {\n    var e,\n        t = A;A = [];while (e = t.pop()) {\n      e.__d && k(e);\n    }\n  }function l(e, t, n) {\n    return \"string\" == typeof t || \"number\" == typeof t ? void 0 !== e.splitText : \"string\" == typeof t.nodeName ? !e._componentConstructor && a(e, t.nodeName) : n || e._componentConstructor === t.nodeName;\n  }function a(e, t) {\n    return e.__n === t || e.nodeName.toLowerCase() === t.toLowerCase();\n  }function u(e) {\n    var t = n({}, e.attributes);t.children = e.children;var o = e.nodeName.defaultProps;if (void 0 !== o) for (var r in o) {\n      void 0 === t[r] && (t[r] = o[r]);\n    }return t;\n  }function _(e, t) {\n    var n = t ? document.createElementNS(\"http://www.w3.org/2000/svg\", e) : document.createElement(e);return n.__n = e, n;\n  }function p(e) {\n    var t = e.parentNode;t && t.removeChild(e);\n  }function c(e, t, n, o, r) {\n    if (\"className\" === t && (t = \"class\"), \"key\" === t) ;else if (\"ref\" === t) n && n(null), o && o(e);else if (\"class\" !== t || r) {\n      if (\"style\" === t) {\n        if (o && \"string\" != typeof o && \"string\" != typeof n || (e.style.cssText = o || \"\"), o && \"object\" == typeof o) {\n          if (\"string\" != typeof n) for (var i in n) {\n            i in o || (e.style[i] = \"\");\n          }for (var i in o) {\n            e.style[i] = \"number\" == typeof o[i] && !1 === V.test(i) ? o[i] + \"px\" : o[i];\n          }\n        }\n      } else if (\"dangerouslySetInnerHTML\" === t) o && (e.innerHTML = o.__html || \"\");else if (\"o\" == t[0] && \"n\" == t[1]) {\n        var l = t !== (t = t.replace(/Capture$/, \"\"));t = t.toLowerCase().substring(2), o ? n || e.addEventListener(t, f, l) : e.removeEventListener(t, f, l), (e.__l || (e.__l = {}))[t] = o;\n      } else if (\"list\" !== t && \"type\" !== t && !r && t in e) s(e, t, null == o ? \"\" : o), null != o && !1 !== o || e.removeAttribute(t);else {\n        var a = r && t !== (t = t.replace(/^xlink\\:?/, \"\"));null == o || !1 === o ? a ? e.removeAttributeNS(\"http://www.w3.org/1999/xlink\", t.toLowerCase()) : e.removeAttribute(t) : \"function\" != typeof o && (a ? e.setAttributeNS(\"http://www.w3.org/1999/xlink\", t.toLowerCase(), o) : e.setAttribute(t, o));\n      }\n    } else e.className = o || \"\";\n  }function s(e, t, n) {\n    try {\n      e[t] = n;\n    } catch (e) {}\n  }function f(e) {\n    return this.__l[e.type](S.event && S.event(e) || e);\n  }function d() {\n    var e;while (e = D.pop()) {\n      S.afterMount && S.afterMount(e), e.componentDidMount && e.componentDidMount();\n    }\n  }function h(e, t, n, o, r, i) {\n    H++ || (R = null != r && void 0 !== r.ownerSVGElement, j = null != e && !(\"__preactattr_\" in e));var l = m(e, t, n, o, i);return r && l.parentNode !== r && r.appendChild(l), --H || (j = !1, i || d()), l;\n  }function m(e, t, n, o, r) {\n    var i = e,\n        l = R;if (null != t && \"boolean\" != typeof t || (t = \"\"), \"string\" == typeof t || \"number\" == typeof t) return e && void 0 !== e.splitText && e.parentNode && (!e._component || r) ? e.nodeValue != t && (e.nodeValue = t) : (i = document.createTextNode(t), e && (e.parentNode && e.parentNode.replaceChild(i, e), b(e, !0))), i.__preactattr_ = !0, i;var u = t.nodeName;if (\"function\" == typeof u) return U(e, t, n, o);if (R = \"svg\" === u || \"foreignObject\" !== u && R, u += \"\", (!e || !a(e, u)) && (i = _(u, R), e)) {\n      while (e.firstChild) {\n        i.appendChild(e.firstChild);\n      }e.parentNode && e.parentNode.replaceChild(i, e), b(e, !0);\n    }var p = i.firstChild,\n        c = i.__preactattr_,\n        s = t.children;if (null == c) {\n      c = i.__preactattr_ = {};for (var f = i.attributes, d = f.length; d--;) {\n        c[f[d].name] = f[d].value;\n      }\n    }return !j && s && 1 === s.length && \"string\" == typeof s[0] && null != p && void 0 !== p.splitText && null == p.nextSibling ? p.nodeValue != s[0] && (p.nodeValue = s[0]) : (s && s.length || null != p) && v(i, s, n, o, j || null != c.dangerouslySetInnerHTML), g(i, t.attributes, c), R = l, i;\n  }function v(e, t, n, o, r) {\n    var i,\n        a,\n        u,\n        _,\n        c,\n        s = e.childNodes,\n        f = [],\n        d = {},\n        h = 0,\n        v = 0,\n        y = s.length,\n        g = 0,\n        w = t ? t.length : 0;if (0 !== y) for (var C = 0; C < y; C++) {\n      var x = s[C],\n          N = x.__preactattr_,\n          k = w && N ? x._component ? x._component.__k : N.key : null;null != k ? (h++, d[k] = x) : (N || (void 0 !== x.splitText ? !r || x.nodeValue.trim() : r)) && (f[g++] = x);\n    }if (0 !== w) for (var C = 0; C < w; C++) {\n      _ = t[C], c = null;var k = _.key;if (null != k) h && void 0 !== d[k] && (c = d[k], d[k] = void 0, h--);else if (!c && v < g) for (i = v; i < g; i++) {\n        if (void 0 !== f[i] && l(a = f[i], _, r)) {\n          c = a, f[i] = void 0, i === g - 1 && g--, i === v && v++;break;\n        }\n      }c = m(c, _, n, o), u = s[C], c && c !== e && c !== u && (null == u ? e.appendChild(c) : c === u.nextSibling ? p(u) : e.insertBefore(c, u));\n    }if (h) for (var C in d) {\n      void 0 !== d[C] && b(d[C], !1);\n    }while (v <= g) {\n      void 0 !== (c = f[g--]) && b(c, !1);\n    }\n  }function b(e, t) {\n    var n = e._component;n ? L(n) : (null != e.__preactattr_ && e.__preactattr_.ref && e.__preactattr_.ref(null), !1 !== t && null != e.__preactattr_ || p(e), y(e));\n  }function y(e) {\n    e = e.lastChild;while (e) {\n      var t = e.previousSibling;b(e, !0), e = t;\n    }\n  }function g(e, t, n) {\n    var o;for (o in n) {\n      t && null != t[o] || null == n[o] || c(e, o, n[o], n[o] = void 0, R);\n    }for (o in t) {\n      \"children\" === o || \"innerHTML\" === o || o in n && t[o] === (\"value\" === o || \"checked\" === o ? e[o] : n[o]) || c(e, o, n[o], n[o] = t[o], R);\n    }\n  }function w(e) {\n    var t = e.constructor.name;(I[t] || (I[t] = [])).push(e);\n  }function C(e, t, n) {\n    var o,\n        r = I[e.name];if (e.prototype && e.prototype.render ? (o = new e(t, n), T.call(o, t, n)) : (o = new T(t, n), o.constructor = e, o.render = x), r) for (var i = r.length; i--;) {\n      if (r[i].constructor === e) {\n        o.__b = r[i].__b, r.splice(i, 1);break;\n      }\n    }return o;\n  }function x(e, t, n) {\n    return this.constructor(e, n);\n  }function N(e, t, n, o, i) {\n    e.__x || (e.__x = !0, (e.__r = t.ref) && delete t.ref, (e.__k = t.key) && delete t.key, !e.base || i ? e.componentWillMount && e.componentWillMount() : e.componentWillReceiveProps && e.componentWillReceiveProps(t, o), o && o !== e.context && (e.__c || (e.__c = e.context), e.context = o), e.__p || (e.__p = e.props), e.props = t, e.__x = !1, 0 !== n && (1 !== n && !1 === S.syncComponentUpdates && e.base ? r(e) : k(e, 1, i)), e.__r && e.__r(e));\n  }function k(e, t, o, r) {\n    if (!e.__x) {\n      var i,\n          l,\n          a,\n          _ = e.props,\n          p = e.state,\n          c = e.context,\n          s = e.__p || _,\n          f = e.__s || p,\n          m = e.__c || c,\n          v = e.base,\n          y = e.__b,\n          g = v || y,\n          w = e._component,\n          x = !1;if (v && (e.props = s, e.state = f, e.context = m, 2 !== t && e.shouldComponentUpdate && !1 === e.shouldComponentUpdate(_, p, c) ? x = !0 : e.componentWillUpdate && e.componentWillUpdate(_, p, c), e.props = _, e.state = p, e.context = c), e.__p = e.__s = e.__c = e.__b = null, e.__d = !1, !x) {\n        i = e.render(_, p, c), e.getChildContext && (c = n(n({}, c), e.getChildContext()));var U,\n            T,\n            M = i && i.nodeName;if (\"function\" == typeof M) {\n          var W = u(i);l = w, l && l.constructor === M && W.key == l.__k ? N(l, W, 1, c, !1) : (U = l, e._component = l = C(M, W, c), l.__b = l.__b || y, l.__u = e, N(l, W, 0, c, !1), k(l, 1, o, !0)), T = l.base;\n        } else a = g, U = w, U && (a = e._component = null), (g || 1 === t) && (a && (a._component = null), T = h(a, i, c, o || !v, g && g.parentNode, !0));if (g && T !== g && l !== w) {\n          var E = g.parentNode;E && T !== E && (E.replaceChild(T, g), U || (g._component = null, b(g, !1)));\n        }if (U && L(U), e.base = T, T && !r) {\n          var P = e,\n              V = e;while (V = V.__u) {\n            (P = V).base = T;\n          }T._component = P, T._componentConstructor = P.constructor;\n        }\n      }if (!v || o ? D.unshift(e) : x || (e.componentDidUpdate && e.componentDidUpdate(s, f, m), S.afterUpdate && S.afterUpdate(e)), null != e.__h) while (e.__h.length) {\n        e.__h.pop().call(e);\n      }H || r || d();\n    }\n  }function U(e, t, n, o) {\n    var r = e && e._component,\n        i = r,\n        l = e,\n        a = r && e._componentConstructor === t.nodeName,\n        _ = a,\n        p = u(t);while (r && !_ && (r = r.__u)) {\n      _ = r.constructor === t.nodeName;\n    }return r && _ && (!o || r._component) ? (N(r, p, 3, n, o), e = r.base) : (i && !a && (L(i), e = l = null), r = C(t.nodeName, p, n), e && !r.__b && (r.__b = e, l = null), N(r, p, 1, n, o), e = r.base, l && e !== l && (l._component = null, b(l, !1))), e;\n  }function L(e) {\n    S.beforeUnmount && S.beforeUnmount(e);var t = e.base;e.__x = !0, e.componentWillUnmount && e.componentWillUnmount(), e.base = null;var n = e._component;n ? L(n) : t && (t.__preactattr_ && t.__preactattr_.ref && t.__preactattr_.ref(null), e.__b = t, p(t), w(e), y(t)), e.__r && e.__r(null);\n  }function T(e, t) {\n    this.__d = !0, this.context = t, this.props = e, this.state = this.state || {};\n  }function M(e, t, n) {\n    return h(n, e, {}, !1, t, !1);\n  }var S = {},\n      W = [],\n      E = [],\n      P = \"function\" == typeof Promise ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout,\n      V = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i,\n      A = [],\n      D = [],\n      H = 0,\n      R = !1,\n      j = !1,\n      I = {};n(T.prototype, { setState: function setState(e, t) {\n      var o = this.state;this.__s || (this.__s = n({}, o)), n(o, \"function\" == typeof e ? e(o, this.props) : e), t && (this.__h = this.__h || []).push(t), r(this);\n    }, forceUpdate: function forceUpdate(e) {\n      e && (this.__h = this.__h || []).push(e), k(this, 2);\n    }, render: function render() {} });var $ = { h: t, createElement: t, cloneElement: o, Component: T, render: M, rerender: i, options: S }; true ? module.exports = $ : self.preact = $;\n}();\n//# sourceMappingURL=preact.min.js.map\n\n/***/ }),\n\n/***/ \"NPHD\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_preact__ = __webpack_require__(\"KM04\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_preact___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_preact__);\n\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\nvar _ref = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n  'i',\n  { className: 'material-icons' },\n  'close'\n);\n\nvar _ref3 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n  'i',\n  { className: 'material-icons' },\n  'mode_edit'\n);\n\nvar _ref4 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n  'i',\n  { className: 'material-icons' },\n  'delete_forever'\n);\n\nvar _ref5 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])('div', { className: 'divider' });\n\nvar ShoppingList = function (_Component) {\n  _inherits(ShoppingList, _Component);\n\n  function ShoppingList() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, ShoppingList);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.state = {\n      editingName: false,\n      activeItemId: '',\n      oldName: '',\n      newName: ''\n    }, _this.handleEditingStart = function (itemid, itemtitle) {\n      _this.setState({ editingName: true, activeItemId: itemid, oldName: itemtitle });\n    }, _this.handleEditingDone = function () {\n      _this.setState({ editingName: false });\n    }, _this.handleEditingSubmit = function (e) {\n      _this.props.renameItemFunc(_this.state.activeItemId, _this.state.newName);\n      _this.handleEditingDone();\n    }, _this.updateName = function (e) {\n      _this.setState({ newName: e.target.value });\n    }, _this.renderEditNameUI = function () {\n      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n        'div',\n        null,\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n          'div',\n          { className: 'col s6' },\n          __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n            'form',\n            { onSubmit: _this.handleEditingSubmit },\n            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n              'div',\n              { 'class': 'input-field',\n                style: { \"margin-top\": \"0.5rem\", \"background-color\": \"aliceblue\" } },\n              __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])('input', { type: 'text', id: 'input-name',\n                ref: function ref(inp) {\n                  _this.nameInput = inp;\n                },\n                value: _this.state.oldName,\n                onChange: _this.updateName,\n                style: { height: \"unset\", \"margin-bottom\": \"8px\" } })\n            )\n          )\n        ),\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n          'div',\n          { className: 'col s1' },\n          __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n            'a',\n            { className: 'btn-flat', onClick: _this.handleEditingDone, style: { padding: \"0px\" } },\n            _ref\n          )\n        )\n      );\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n  /* all state actions are for handling the renaming dialog */\n\n\n  ShoppingList.prototype.componentDidUpdate = function componentDidUpdate() {\n    if (this.state.editingName === true) {\n      this.nameInput.focus();\n    }\n  };\n\n  ShoppingList.prototype.render = function render() {\n    var _this2 = this;\n\n    var items = [];\n\n    var _loop = function _loop(item) {\n      items.push(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n        'div',\n        null,\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n          'div',\n          { className: 'row', key: 'listitem_' + item._id, style: { margin: \"0.5rem 0 0.5rem 0\" } },\n          __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n            'div',\n            { className: 'col s1' },\n            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])('input', { type: 'checkbox', id: \"cb_\" + item._id,\n              onChange: function onChange() {\n                return _this2.props.toggleItemCheckFunc(item._id);\n              },\n              defaultChecked: item.checked }),\n            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n              'label',\n              { 'for': \"cb_\" + item._id },\n              '\\xA0'\n            )\n          ),\n          _this2.state.editingName && _this2.state.activeItemId === item._id ? _this2.renderEditNameUI() : __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n            'div',\n            { className: 'col s7' },\n            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n              'span',\n              { className: item.checked ? \"checkeditem\" : \"uci\" },\n              item.title\n            )\n          ),\n          __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n            'div',\n            { className: 'col s4 right-align ' },\n            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n              'a',\n              { 'class': 'btn-flat itemactionbutton', onClick: function onClick() {\n                  return _this2.handleEditingStart(item._id, item.title);\n                } },\n              _ref3\n            ),\n            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n              'a',\n              { 'class': 'btn-flat itemactionbutton', onClick: function onClick() {\n                  return _this2.props.deleteFunc(item._id);\n                } },\n              _ref4\n            )\n          )\n        ),\n        _ref5\n      ));\n    };\n\n    for (var _iterator = this.props.shoppingListItems, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref2 = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref2 = _i.value;\n      }\n\n      var item = _ref2;\n\n      _loop(item);\n    }\n\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n      'div',\n      null,\n      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n        'div',\n        null,\n        items\n      )\n    );\n  };\n\n  return ShoppingList;\n}(__WEBPACK_IMPORTED_MODULE_0_preact__[\"Component\"]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (ShoppingList);\n\n/***/ }),\n\n/***/ \"RIsC\":\n/***/ (function(module, exports) {\n\n// removed by extract-text-webpack-plugin\n\n/***/ }),\n\n/***/ \"S03M\":\n/***/ (function(module, exports) {\n\n// removed by extract-text-webpack-plugin\n\n/***/ }),\n\n/***/ \"T/c0\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return uniq; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return sequentialize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return fin; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"i\", function() { return callbackify; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return promisedCallback; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return mapToKeysArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return QueryParseError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return NotFoundError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return BuiltInError; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_pouchdb_collections__ = __webpack_require__(\"qpbW\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_argsarray__ = __webpack_require__(\"38I5\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_argsarray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_argsarray__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_pouchdb_utils__ = __webpack_require__(\"mY35\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_inherits__ = __webpack_require__(\"4Bm0\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_inherits__);\n\n\n\n\n\nfunction QueryParseError(message) {\n  this.status = 400;\n  this.name = 'query_parse_error';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, QueryParseError);\n  } catch (e) {}\n}\n\n__WEBPACK_IMPORTED_MODULE_3_inherits___default()(QueryParseError, Error);\n\nfunction NotFoundError(message) {\n  this.status = 404;\n  this.name = 'not_found';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, NotFoundError);\n  } catch (e) {}\n}\n\n__WEBPACK_IMPORTED_MODULE_3_inherits___default()(NotFoundError, Error);\n\nfunction BuiltInError(message) {\n  this.status = 500;\n  this.name = 'invalid_value';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, BuiltInError);\n  } catch (e) {}\n}\n\n__WEBPACK_IMPORTED_MODULE_3_inherits___default()(BuiltInError, Error);\n\nfunction promisedCallback(promise, callback) {\n  if (callback) {\n    promise.then(function (res) {\n      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_pouchdb_utils__[\"h\" /* nextTick */])(function () {\n        callback(null, res);\n      });\n    }, function (reason) {\n      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_pouchdb_utils__[\"h\" /* nextTick */])(function () {\n        callback(reason);\n      });\n    });\n  }\n  return promise;\n}\n\nfunction callbackify(fun) {\n  return __WEBPACK_IMPORTED_MODULE_1_argsarray___default()(function (args) {\n    var cb = args.pop();\n    var promise = fun.apply(this, args);\n    if (typeof cb === 'function') {\n      promisedCallback(promise, cb);\n    }\n    return promise;\n  });\n}\n\n// Promise finally util similar to Q.finally\nfunction fin(promise, finalPromiseFactory) {\n  return promise.then(function (res) {\n    return finalPromiseFactory().then(function () {\n      return res;\n    });\n  }, function (reason) {\n    return finalPromiseFactory().then(function () {\n      throw reason;\n    });\n  });\n}\n\nfunction sequentialize(queue, promiseFactory) {\n  return function () {\n    var args = arguments;\n    var that = this;\n    return queue.add(function () {\n      return promiseFactory.apply(that, args);\n    });\n  };\n}\n\n// uniq an array of strings, order not guaranteed\n// similar to underscore/lodash _.uniq\nfunction uniq(arr) {\n  var theSet = new __WEBPACK_IMPORTED_MODULE_0_pouchdb_collections__[\"b\" /* Set */](arr);\n  var result = new Array(theSet.size);\n  var index = -1;\n  theSet.forEach(function (value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nfunction mapToKeysArray(map) {\n  var result = new Array(map.size);\n  var index = -1;\n  map.forEach(function (value, key) {\n    result[++index] = key;\n  });\n  return result;\n}\n\n\n\n/***/ }),\n\n/***/ \"UuX/\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_preact__ = __webpack_require__(\"KM04\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_preact___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_preact__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_immutable__ = __webpack_require__(\"Zuze\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_immutable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_immutable__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ibm_shopping_list_model__ = __webpack_require__(\"HSMo\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ibm_shopping_list_model___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_ibm_shopping_list_model__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__components_ShoppingList__ = __webpack_require__(\"NPHD\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__components_ShoppingLists__ = __webpack_require__(\"CR5u\");\n\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\n\nvar NOLISTMSG = \"Click the + sign above to create a shopping list.\";\nvar NOITEMSMSG = \"Click the + sign above to create a shopping list item.\";\n\nvar appBarStyle = {\n  width: \"100%\"\n};\n\nvar _ref = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n  \"h5\",\n  null,\n  NOLISTMSG\n);\n\nvar _ref2 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n  \"h5\",\n  null,\n  NOITEMSMSG\n);\n\nvar _ref3 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n  \"i\",\n  { className: \"material-icons\" },\n  \"keyboard_backspace\"\n);\n\nvar _ref4 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\"span\", null);\n\nvar _ref5 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\"span\", null);\n\nvar App = function (_Component) {\n  _inherits(App, _Component);\n\n  function App(props) {\n    _classCallCheck(this, App);\n\n    var _this = _possibleConstructorReturn(this, _Component.call(this, props));\n\n    _this.componentDidMount = function () {\n      _this.getShoppingLists();\n      _this.props.localDB.sync(_this.props.remoteDB, { live: true, retry: true }).on(\"change\", function (change) {\n        // console.log(\"something changed!\");\n        _this.getPouchDocs();\n      })\n      // .on(\"paused\", info => console.log(\"replication paused.\"))\n      // .on(\"active\", info => console.log(\"replication resumed.\"))\n      .on(\"error\", function (err) {\n        return console.log(\"uh oh! an error occured.\");\n      });\n    };\n\n    _this.getShoppingLists = function () {\n      var checkedCount = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_immutable__[\"List\"])();\n      var totalCount = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_immutable__[\"List\"])();\n      var lists = null;\n      _this.props.shoppingListRepository.find().then(function (foundLists) {\n        lists = foundLists;\n        return foundLists;\n      }).then(function (foundLists) {\n        return _this.props.shoppingListRepository.findItemsCountByList();\n      }).then(function (countsList) {\n        totalCount = countsList;\n        return _this.props.shoppingListRepository.findItemsCountByList({\n          selector: {\n            type: \"item\",\n            checked: true\n          },\n          fields: [\"list\"]\n        });\n      }).then(function (checkedList) {\n        checkedCount = checkedList;\n        _this.setState({\n          view: \"lists\",\n          shoppingLists: lists,\n          shoppingList: null,\n          shoppingListItems: null,\n          checkedTotalShoppingListItemCount: checkedCount,\n          totalShoppingListItemCount: totalCount\n        });\n      }).catch(function (err) {\n        console.log(\"ERROR in getShoppingLists\");\n        console.log(err);\n      });\n    };\n\n    _this.openShoppingList = function (listid) {\n      _this.props.shoppingListRepository.get(listid).then(function (list) {\n        return list;\n      }).then(function (list) {\n        _this.getShoppingListItems(listid).then(function (items) {\n          _this.setState({\n            view: \"items\",\n            shoppingList: list,\n            shoppingListItems: items\n          });\n        });\n      });\n    };\n\n    _this.getShoppingListItems = function (listid) {\n      return _this.props.shoppingListRepository.findItems({\n        selector: {\n          type: \"item\",\n          list: listid\n        }\n      });\n    };\n\n    _this.refreshShoppingListItems = function (listid) {\n      _this.props.shoppingListRepository.findItems({\n        selector: {\n          type: \"item\",\n          list: listid\n        }\n      }).then(function (items) {\n        _this.setState({\n          view: \"items\",\n          shoppingListItems: items\n        });\n      });\n    };\n\n    _this.renameShoppingListItem = function (itemid, newname) {\n      console.log(\"IN renameShoppingListItem with id=\" + itemid + \", name=\" + newname);\n      _this.props.shoppingListRepository.getItem(itemid).then(function (item) {\n        item = item.set(\"title\", newname);\n        return _this.props.shoppingListRepository.putItem(item);\n      }).then(_this.refreshShoppingListItems(_this.state.shoppingList._id));\n    };\n\n    _this.deleteShoppingListItem = function (itemid) {\n      _this.props.shoppingListRepository.getItem(itemid).then(function (item) {\n        return _this.props.shoppingListRepository.deleteItem(item);\n      }).then(_this.refreshShoppingListItems(_this.state.shoppingList._id));\n    };\n\n    _this.toggleItemCheck = function (itemid) {\n      _this.props.shoppingListRepository.getItem(itemid).then(function (item) {\n        item = item.set(\"checked\", !item.checked);\n        return _this.props.shoppingListRepository.putItem(item);\n      }).then(_this.refreshShoppingListItems(_this.state.shoppingList._id));\n    };\n\n    _this.checkAllListItems = function (listid) {\n      var listcheck = true;\n      _this.getShoppingListItems(listid).then(function (items) {\n        var newitems = [];\n        items.forEach(function (item) {\n          if (!item.checked) {\n            newitems.push(item.mergeDeep({ checked: true }));\n          }\n        }, _this);\n        // if all items were already checked let's uncheck them all\n        if (newitems.length == 0) {\n          listcheck = false;\n          items.forEach(function (item) {\n            newitems.push(item.mergeDeep({ checked: false }));\n          }, _this);\n        }\n        var listOfShoppingListItems = _this.props.shoppingListFactory.newListOfShoppingListItems(newitems);\n        return _this.props.shoppingListRepository.putItemsBulk(listOfShoppingListItems);\n      }).then(function (newitemsresponse) {\n        return _this.props.shoppingListRepository.get(listid);\n      }).then(function (shoppingList) {\n        shoppingList = shoppingList.set(\"checked\", listcheck);\n        return _this.props.shoppingListRepository.put(shoppingList);\n      }).then(function (shoppingList) {\n        _this.getShoppingLists();\n      });\n    };\n\n    _this.deleteShoppingList = function (listid) {\n      _this.props.shoppingListRepository.get(listid).then(function (shoppingList) {\n        shoppingList = shoppingList.set(\"_deleted\", true);\n        return _this.props.shoppingListRepository.put(shoppingList);\n      }).then(function (result) {\n        _this.getShoppingLists();\n      });\n    };\n\n    _this.renameShoppingList = function (listid, newname) {\n      console.log(\"HERE IN renameShoppingList with id=\" + listid + \", title=\" + newname);\n      _this.props.shoppingListRepository.get(listid).then(function (shoppingList) {\n        shoppingList = shoppingList.set(\"title\", newname);\n        return _this.props.shoppingListRepository.put(shoppingList);\n      }).then(_this.getShoppingLists);\n    };\n\n    _this.createNewShoppingListOrItem = function (e) {\n      e.preventDefault();\n      _this.setState({ adding: false });\n\n      if (_this.state.view === \"lists\") {\n        var shoppingList = _this.props.shoppingListFactory.newShoppingList({\n          title: _this.state.newName\n        });\n        _this.props.shoppingListRepository.put(shoppingList).then(_this.getShoppingLists);\n      } else if (_this.state.view === \"items\") {\n        var item = _this.props.shoppingListFactory.newShoppingListItem({\n          title: _this.state.newName\n        }, _this.state.shoppingList);\n        _this.props.shoppingListRepository.putItem(item).then(function (item) {\n          _this.getShoppingListItems(_this.state.shoppingList._id).then(function (items) {\n            _this.setState({\n              view: \"items\",\n              shoppingListItems: items\n            });\n          });\n        });\n      }\n    };\n\n    _this.updateName = function (e) {\n      _this.setState({ newName: e.target.value });\n    };\n\n    _this.displayAddingUI = function () {\n      _this.setState({ adding: true });\n    };\n\n    _this.renderNewNameUI = function () {\n      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n        \"form\",\n        { onSubmit: _this.createNewShoppingListOrItem, style: { marginTop: \"12px\" } },\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n          \"div\",\n          { \"class\": \"input-field\" },\n          __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\"input\", { className: \"validate\", type: \"text\",\n            placeholder: \"Name...\", id: \"input-name\",\n            onChange: _this.updateName,\n            fullWidth: false,\n            style: { padding: \"0px 12px\", width: \"calc(100% - 24px)\" },\n            underlineStyle: { width: \"calc(100% - 24px)\" } })\n        )\n      );\n    };\n\n    _this.renderShoppingLists = function () {\n      if (_this.state.shoppingLists.length < 1) return _ref;\n      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(__WEBPACK_IMPORTED_MODULE_4__components_ShoppingLists__[\"a\" /* default */], {\n        shoppingLists: _this.state.shoppingLists,\n        openListFunc: _this.openShoppingList,\n        deleteListFunc: _this.deleteShoppingList,\n        renameListFunc: _this.renameShoppingList,\n        checkAllFunc: _this.checkAllListItems,\n        totalCounts: _this.state.totalShoppingListItemCount,\n        checkedCounts: _this.state.checkedTotalShoppingListItemCount });\n    };\n\n    _this.renderShoppingListItems = function () {\n      if (_this.state.shoppingListItems.size < 1) return _ref2;\n      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(__WEBPACK_IMPORTED_MODULE_3__components_ShoppingList__[\"a\" /* default */], {\n        shoppingListItems: _this.state.shoppingListItems,\n        deleteFunc: _this.deleteShoppingListItem,\n        toggleItemCheckFunc: _this.toggleItemCheck,\n        renameItemFunc: _this.renameShoppingListItem });\n    };\n\n    _this.renderBackButton = function () {\n      if (_this.state.view === \"items\") return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n        \"a\",\n        { className: \"btn-flat btn-large white-text\", onClick: _this.getShoppingLists, style: { \"padding\": \"0px\", \"vertical-align\": \"middle\" } },\n        _ref3\n      );else return _ref4;\n    };\n\n    _this.state = {\n      shoppingList: null,\n      shoppingLists: [],\n      totalShoppingListItemCount: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_immutable__[\"List\"])(), //Immutable.js List with list ids as keys\n      checkedTotalShoppingListItemCount: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_immutable__[\"List\"])(), //Immutable.js List with list ids as keys\n      shoppingListItems: null,\n      adding: false,\n      view: \"lists\",\n      newName: \"\"\n    };\n    return _this;\n  }\n\n  App.prototype.render = function render() {\n    var screenname = \"Shopping Lists\";\n    if (this.state.view === \"items\") screenname = this.state.shoppingList.title;\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n      \"div\",\n      { className: \"App\" },\n      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n        \"nav\",\n        null,\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n          \"div\",\n          { className: \"nav-wrapper\" },\n          __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n            \"div\",\n            { className: \"brand-logo left\" },\n            this.renderBackButton(),\n            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n              \"span\",\n              { className: \"hide-on-small-only\" },\n              screenname\n            ),\n            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n              \"span\",\n              { className: \"show-on-medium-and-up\", style: { \"font-size\": \"14pt\" } },\n              screenname\n            )\n          ),\n          __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n            \"div\",\n            { className: \"right\" },\n            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n              \"a\",\n              { className: \"btn-floating\", style: { \"margin-right\": \"8px\" },\n                onClick: this.displayAddingUI },\n              __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n                \"i\",\n                { className: \"material-icons\", style: { \"line-height\": \"unset\" } },\n                \"add\"\n              )\n            )\n          )\n        )\n      ),\n      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(\n        \"div\",\n        { className: \"listsanditems container\", style: { margin: \"8px\" } },\n        this.state.adding ? this.renderNewNameUI() : _ref5,\n        this.state.view === \"lists\" ? this.renderShoppingLists() : this.renderShoppingListItems()\n      )\n    );\n  };\n\n  return App;\n}(__WEBPACK_IMPORTED_MODULE_0_preact__[\"Component\"]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (App);\n\n/***/ }),\n\n/***/ \"YrHc\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar cuid = __webpack_require__(\"435A\");\n\nvar _require = __webpack_require__(\"d18E\"),\n    Record = _require.Record,\n    List = _require.List;\n\nvar ShoppingListFactory = function () {\n  function ShoppingListFactory() {\n    _classCallCheck(this, ShoppingListFactory);\n\n    this._ShoppingList = Record({\n      _id: undefined,\n      _rev: undefined,\n      _deleted: false,\n      type: \"list\",\n      version: 1,\n      title: undefined,\n      checked: false,\n      place: undefined,\n      createdAt: undefined,\n      updatedAt: undefined\n    });\n    this._ShoppingListItem = Record({\n      _id: undefined,\n      _rev: undefined,\n      _deleted: false,\n      type: \"item\",\n      version: 1,\n      list: undefined,\n      title: undefined,\n      checked: false,\n      createdAt: undefined,\n      updatedAt: undefined\n    });\n  }\n\n  ShoppingListFactory.prototype._guardShoppingList = function _guardShoppingList(shoppingList) {\n    if (!Record.isRecord(shoppingList)) {\n      throw new Error(\"Shopping List must be a Record\");\n    }\n    if (shoppingList.type != \"list\") {\n      throw new Error(\"Shopping List type must be list\");\n    }\n  };\n\n  ShoppingListFactory.prototype._guardListOfShoppingLists = function _guardListOfShoppingLists(listOfShoppingLists) {\n    var _this = this;\n\n    listOfShoppingLists.forEach(function (shoppingList) {\n      return _this._guardShoppingList(shoppingList);\n    });\n  };\n\n  ShoppingListFactory.prototype._guardShoppingListItem = function _guardShoppingListItem(shoppingListItem) {\n    if (!Record.isRecord(shoppingListItem)) {\n      throw new Error(\"Shopping List Item must be a Record\");\n    }\n    if (shoppingListItem.type != \"item\") {\n      throw new Error(\"Shopping List Item type must be item\");\n    }\n  };\n\n  ShoppingListFactory.prototype._guardListOfShoppingListItems = function _guardListOfShoppingListItems(listOfShoppingListItems) {\n    var _this2 = this;\n\n    listOfShoppingListItems.forEach(function (shoppingListItem) {\n      return _this2._guardShoppingListItem(shoppingListItem);\n    });\n  };\n\n  ShoppingListFactory.prototype.newShoppingList = function newShoppingList(values) {\n    var shoppingList = new this._ShoppingList(values);\n    if (shoppingList._id === undefined) {\n      shoppingList = shoppingList.set(\"_id\", \"list:\" + cuid());\n    }\n    return shoppingList;\n  };\n\n  ShoppingListFactory.prototype.newListOfShoppingLists = function newListOfShoppingLists(shoppingLists) {\n    var listOfShoppingLists = new List(shoppingLists);\n    this._guardListOfShoppingLists(listOfShoppingLists);\n    return listOfShoppingLists;\n  };\n\n  ShoppingListFactory.prototype.newShoppingListItem = function newShoppingListItem(values, shoppingList) {\n    var shoppingListItem = new this._ShoppingListItem(values);\n    if (shoppingListItem._id === undefined) {\n      shoppingListItem = shoppingListItem.set(\"_id\", \"item:\" + cuid());\n    }\n    if (shoppingListItem.list === undefined && shoppingList) {\n      shoppingListItem = shoppingListItem.set(\"list\", shoppingList._id);\n    }\n    return shoppingListItem;\n  };\n\n  ShoppingListFactory.prototype.newListOfShoppingListItems = function newListOfShoppingListItems(shoppingListItems) {\n    var listOfShoppingListItems = new List(shoppingListItems);\n    this._guardListOfShoppingListItems(listOfShoppingListItems);\n    return listOfShoppingListItems;\n  };\n\n  return ShoppingListFactory;\n}();\n\nexports.ShoppingListFactory = ShoppingListFactory;\n\n/***/ }),\n\n/***/ \"ZfEw\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/* unused harmony export binaryMd5 */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return stringMd5; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_pouchdb_binary_utils__ = __webpack_require__(\"8/Wf\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_spark_md5__ = __webpack_require__(\"13nb\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_spark_md5___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_spark_md5__);\n\n\n\nvar setImmediateShim = global.setImmediate || global.setTimeout;\nvar MD5_CHUNK_SIZE = 32768;\n\nfunction rawToBase64(raw) {\n  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_pouchdb_binary_utils__[\"a\" /* btoa */])(raw);\n}\n\nfunction sliceBlob(blob, start, end) {\n  if (blob.webkitSlice) {\n    return blob.webkitSlice(start, end);\n  }\n  return blob.slice(start, end);\n}\n\nfunction appendBlob(buffer, blob, start, end, callback) {\n  if (start > 0 || end < blob.size) {\n    // only slice blob if we really need to\n    blob = sliceBlob(blob, start, end);\n  }\n  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_pouchdb_binary_utils__[\"b\" /* readAsArrayBuffer */])(blob, function (arrayBuffer) {\n    buffer.append(arrayBuffer);\n    callback();\n  });\n}\n\nfunction appendString(buffer, string, start, end, callback) {\n  if (start > 0 || end < string.length) {\n    // only create a substring if we really need to\n    string = string.substring(start, end);\n  }\n  buffer.appendBinary(string);\n  callback();\n}\n\nfunction binaryMd5(data, callback) {\n  var inputIsString = typeof data === 'string';\n  var len = inputIsString ? data.length : data.size;\n  var chunkSize = Math.min(MD5_CHUNK_SIZE, len);\n  var chunks = Math.ceil(len / chunkSize);\n  var currentChunk = 0;\n  var buffer = inputIsString ? new __WEBPACK_IMPORTED_MODULE_1_spark_md5___default.a() : new __WEBPACK_IMPORTED_MODULE_1_spark_md5___default.a.ArrayBuffer();\n\n  var append = inputIsString ? appendString : appendBlob;\n\n  function next() {\n    setImmediateShim(loadNextChunk);\n  }\n\n  function done() {\n    var raw = buffer.end(true);\n    var base64 = rawToBase64(raw);\n    callback(base64);\n    buffer.destroy();\n  }\n\n  function loadNextChunk() {\n    var start = currentChunk * chunkSize;\n    var end = start + chunkSize;\n    currentChunk++;\n    if (currentChunk < chunks) {\n      append(buffer, data, start, end, next);\n    } else {\n      append(buffer, data, start, end, done);\n    }\n  }\n  loadNextChunk();\n}\n\nfunction stringMd5(string) {\n  return __WEBPACK_IMPORTED_MODULE_1_spark_md5___default.a.hash(string);\n}\n\n\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(\"h4f+\")))\n\n/***/ }),\n\n/***/ \"Zuze\":\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n *  Copyright (c) 2014-2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n(function (global, factory) {\n   true ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.Immutable = factory();\n})(this, function () {\n  'use strict';\n  var SLICE$0 = Array.prototype.slice;\n\n  function createClass(ctor, superClass) {\n    if (superClass) {\n      ctor.prototype = Object.create(superClass.prototype);\n    }\n    ctor.prototype.constructor = ctor;\n  }\n\n  function Iterable(value) {\n    return isIterable(value) ? value : Seq(value);\n  }\n\n  createClass(KeyedIterable, Iterable);\n  function KeyedIterable(value) {\n    return isKeyed(value) ? value : KeyedSeq(value);\n  }\n\n  createClass(IndexedIterable, Iterable);\n  function IndexedIterable(value) {\n    return isIndexed(value) ? value : IndexedSeq(value);\n  }\n\n  createClass(SetIterable, Iterable);\n  function SetIterable(value) {\n    return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);\n  }\n\n  function isIterable(maybeIterable) {\n    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);\n  }\n\n  function isKeyed(maybeKeyed) {\n    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);\n  }\n\n  function isIndexed(maybeIndexed) {\n    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);\n  }\n\n  function isAssociative(maybeAssociative) {\n    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);\n  }\n\n  function isOrdered(maybeOrdered) {\n    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);\n  }\n\n  Iterable.isIterable = isIterable;\n  Iterable.isKeyed = isKeyed;\n  Iterable.isIndexed = isIndexed;\n  Iterable.isAssociative = isAssociative;\n  Iterable.isOrdered = isOrdered;\n\n  Iterable.Keyed = KeyedIterable;\n  Iterable.Indexed = IndexedIterable;\n  Iterable.Set = SetIterable;\n\n  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\n  // Used for setting prototype methods that IE8 chokes on.\n  var DELETE = 'delete';\n\n  // Constants describing the size of trie nodes.\n  var SHIFT = 5; // Resulted in best performance after ______?\n  var SIZE = 1 << SHIFT;\n  var MASK = SIZE - 1;\n\n  // A consistent shared value representing \"not set\" which equals nothing other\n  // than itself, and nothing that could be provided externally.\n  var NOT_SET = {};\n\n  // Boolean references, Rough equivalent of `bool &`.\n  var CHANGE_LENGTH = { value: false };\n  var DID_ALTER = { value: false };\n\n  function MakeRef(ref) {\n    ref.value = false;\n    return ref;\n  }\n\n  function SetRef(ref) {\n    ref && (ref.value = true);\n  }\n\n  // A function which returns a value representing an \"owner\" for transient writes\n  // to tries. The return value will only ever equal itself, and will not equal\n  // the return of any subsequent call of this function.\n  function OwnerID() {}\n\n  // http://jsperf.com/copy-array-inline\n  function arrCopy(arr, offset) {\n    offset = offset || 0;\n    var len = Math.max(0, arr.length - offset);\n    var newArr = new Array(len);\n    for (var ii = 0; ii < len; ii++) {\n      newArr[ii] = arr[ii + offset];\n    }\n    return newArr;\n  }\n\n  function ensureSize(iter) {\n    if (iter.size === undefined) {\n      iter.size = iter.__iterate(returnTrue);\n    }\n    return iter.size;\n  }\n\n  function wrapIndex(iter, index) {\n    // This implements \"is array index\" which the ECMAString spec defines as:\n    //\n    //     A String property name P is an array index if and only if\n    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal\n    //     to 2^32−1.\n    //\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects\n    if (typeof index !== 'number') {\n      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32\n      if ('' + uint32Index !== index || uint32Index === 4294967295) {\n        return NaN;\n      }\n      index = uint32Index;\n    }\n    return index < 0 ? ensureSize(iter) + index : index;\n  }\n\n  function returnTrue() {\n    return true;\n  }\n\n  function wholeSlice(begin, end, size) {\n    return (begin === 0 || size !== undefined && begin <= -size) && (end === undefined || size !== undefined && end >= size);\n  }\n\n  function resolveBegin(begin, size) {\n    return resolveIndex(begin, size, 0);\n  }\n\n  function resolveEnd(end, size) {\n    return resolveIndex(end, size, size);\n  }\n\n  function resolveIndex(index, size, defaultIndex) {\n    return index === undefined ? defaultIndex : index < 0 ? Math.max(0, size + index) : size === undefined ? index : Math.min(size, index);\n  }\n\n  /* global Symbol */\n\n  var ITERATE_KEYS = 0;\n  var ITERATE_VALUES = 1;\n  var ITERATE_ENTRIES = 2;\n\n  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator';\n\n  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;\n\n  function Iterator(next) {\n    this.next = next;\n  }\n\n  Iterator.prototype.toString = function () {\n    return '[Iterator]';\n  };\n\n  Iterator.KEYS = ITERATE_KEYS;\n  Iterator.VALUES = ITERATE_VALUES;\n  Iterator.ENTRIES = ITERATE_ENTRIES;\n\n  Iterator.prototype.inspect = Iterator.prototype.toSource = function () {\n    return this.toString();\n  };\n  Iterator.prototype[ITERATOR_SYMBOL] = function () {\n    return this;\n  };\n\n  function iteratorValue(type, k, v, iteratorResult) {\n    var value = type === 0 ? k : type === 1 ? v : [k, v];\n    iteratorResult ? iteratorResult.value = value : iteratorResult = {\n      value: value, done: false\n    };\n    return iteratorResult;\n  }\n\n  function iteratorDone() {\n    return { value: undefined, done: true };\n  }\n\n  function hasIterator(maybeIterable) {\n    return !!getIteratorFn(maybeIterable);\n  }\n\n  function isIterator(maybeIterator) {\n    return maybeIterator && typeof maybeIterator.next === 'function';\n  }\n\n  function getIterator(iterable) {\n    var iteratorFn = getIteratorFn(iterable);\n    return iteratorFn && iteratorFn.call(iterable);\n  }\n\n  function getIteratorFn(iterable) {\n    var iteratorFn = iterable && (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL] || iterable[FAUX_ITERATOR_SYMBOL]);\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  function isArrayLike(value) {\n    return value && typeof value.length === 'number';\n  }\n\n  createClass(Seq, Iterable);\n  function Seq(value) {\n    return value === null || value === undefined ? emptySequence() : isIterable(value) ? value.toSeq() : seqFromValue(value);\n  }\n\n  Seq.of = function () /*...values*/{\n    return Seq(arguments);\n  };\n\n  Seq.prototype.toSeq = function () {\n    return this;\n  };\n\n  Seq.prototype.toString = function () {\n    return this.__toString('Seq {', '}');\n  };\n\n  Seq.prototype.cacheResult = function () {\n    if (!this._cache && this.__iterateUncached) {\n      this._cache = this.entrySeq().toArray();\n      this.size = this._cache.length;\n    }\n    return this;\n  };\n\n  // abstract __iterateUncached(fn, reverse)\n\n  Seq.prototype.__iterate = function (fn, reverse) {\n    return seqIterate(this, fn, reverse, true);\n  };\n\n  // abstract __iteratorUncached(type, reverse)\n\n  Seq.prototype.__iterator = function (type, reverse) {\n    return seqIterator(this, type, reverse, true);\n  };\n\n  createClass(KeyedSeq, Seq);\n  function KeyedSeq(value) {\n    return value === null || value === undefined ? emptySequence().toKeyedSeq() : isIterable(value) ? isKeyed(value) ? value.toSeq() : value.fromEntrySeq() : keyedSeqFromValue(value);\n  }\n\n  KeyedSeq.prototype.toKeyedSeq = function () {\n    return this;\n  };\n\n  createClass(IndexedSeq, Seq);\n  function IndexedSeq(value) {\n    return value === null || value === undefined ? emptySequence() : !isIterable(value) ? indexedSeqFromValue(value) : isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();\n  }\n\n  IndexedSeq.of = function () /*...values*/{\n    return IndexedSeq(arguments);\n  };\n\n  IndexedSeq.prototype.toIndexedSeq = function () {\n    return this;\n  };\n\n  IndexedSeq.prototype.toString = function () {\n    return this.__toString('Seq [', ']');\n  };\n\n  IndexedSeq.prototype.__iterate = function (fn, reverse) {\n    return seqIterate(this, fn, reverse, false);\n  };\n\n  IndexedSeq.prototype.__iterator = function (type, reverse) {\n    return seqIterator(this, type, reverse, false);\n  };\n\n  createClass(SetSeq, Seq);\n  function SetSeq(value) {\n    return (value === null || value === undefined ? emptySequence() : !isIterable(value) ? indexedSeqFromValue(value) : isKeyed(value) ? value.entrySeq() : value).toSetSeq();\n  }\n\n  SetSeq.of = function () /*...values*/{\n    return SetSeq(arguments);\n  };\n\n  SetSeq.prototype.toSetSeq = function () {\n    return this;\n  };\n\n  Seq.isSeq = isSeq;\n  Seq.Keyed = KeyedSeq;\n  Seq.Set = SetSeq;\n  Seq.Indexed = IndexedSeq;\n\n  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';\n\n  Seq.prototype[IS_SEQ_SENTINEL] = true;\n\n  createClass(ArraySeq, IndexedSeq);\n  function ArraySeq(array) {\n    this._array = array;\n    this.size = array.length;\n  }\n\n  ArraySeq.prototype.get = function (index, notSetValue) {\n    return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;\n  };\n\n  ArraySeq.prototype.__iterate = function (fn, reverse) {\n    var array = this._array;\n    var maxIndex = array.length - 1;\n    for (var ii = 0; ii <= maxIndex; ii++) {\n      if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {\n        return ii + 1;\n      }\n    }\n    return ii;\n  };\n\n  ArraySeq.prototype.__iterator = function (type, reverse) {\n    var array = this._array;\n    var maxIndex = array.length - 1;\n    var ii = 0;\n    return new Iterator(function () {\n      return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++]);\n    });\n  };\n\n  createClass(ObjectSeq, KeyedSeq);\n  function ObjectSeq(object) {\n    var keys = Object.keys(object);\n    this._object = object;\n    this._keys = keys;\n    this.size = keys.length;\n  }\n\n  ObjectSeq.prototype.get = function (key, notSetValue) {\n    if (notSetValue !== undefined && !this.has(key)) {\n      return notSetValue;\n    }\n    return this._object[key];\n  };\n\n  ObjectSeq.prototype.has = function (key) {\n    return this._object.hasOwnProperty(key);\n  };\n\n  ObjectSeq.prototype.__iterate = function (fn, reverse) {\n    var object = this._object;\n    var keys = this._keys;\n    var maxIndex = keys.length - 1;\n    for (var ii = 0; ii <= maxIndex; ii++) {\n      var key = keys[reverse ? maxIndex - ii : ii];\n      if (fn(object[key], key, this) === false) {\n        return ii + 1;\n      }\n    }\n    return ii;\n  };\n\n  ObjectSeq.prototype.__iterator = function (type, reverse) {\n    var object = this._object;\n    var keys = this._keys;\n    var maxIndex = keys.length - 1;\n    var ii = 0;\n    return new Iterator(function () {\n      var key = keys[reverse ? maxIndex - ii : ii];\n      return ii++ > maxIndex ? iteratorDone() : iteratorValue(type, key, object[key]);\n    });\n  };\n\n  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;\n\n  createClass(IterableSeq, IndexedSeq);\n  function IterableSeq(iterable) {\n    this._iterable = iterable;\n    this.size = iterable.length || iterable.size;\n  }\n\n  IterableSeq.prototype.__iterateUncached = function (fn, reverse) {\n    if (reverse) {\n      return this.cacheResult().__iterate(fn, reverse);\n    }\n    var iterable = this._iterable;\n    var iterator = getIterator(iterable);\n    var iterations = 0;\n    if (isIterator(iterator)) {\n      var step;\n      while (!(step = iterator.next()).done) {\n        if (fn(step.value, iterations++, this) === false) {\n          break;\n        }\n      }\n    }\n    return iterations;\n  };\n\n  IterableSeq.prototype.__iteratorUncached = function (type, reverse) {\n    if (reverse) {\n      return this.cacheResult().__iterator(type, reverse);\n    }\n    var iterable = this._iterable;\n    var iterator = getIterator(iterable);\n    if (!isIterator(iterator)) {\n      return new Iterator(iteratorDone);\n    }\n    var iterations = 0;\n    return new Iterator(function () {\n      var step = iterator.next();\n      return step.done ? step : iteratorValue(type, iterations++, step.value);\n    });\n  };\n\n  createClass(IteratorSeq, IndexedSeq);\n  function IteratorSeq(iterator) {\n    this._iterator = iterator;\n    this._iteratorCache = [];\n  }\n\n  IteratorSeq.prototype.__iterateUncached = function (fn, reverse) {\n    if (reverse) {\n      return this.cacheResult().__iterate(fn, reverse);\n    }\n    var iterator = this._iterator;\n    var cache = this._iteratorCache;\n    var iterations = 0;\n    while (iterations < cache.length) {\n      if (fn(cache[iterations], iterations++, this) === false) {\n        return iterations;\n      }\n    }\n    var step;\n    while (!(step = iterator.next()).done) {\n      var val = step.value;\n      cache[iterations] = val;\n      if (fn(val, iterations++, this) === false) {\n        break;\n      }\n    }\n    return iterations;\n  };\n\n  IteratorSeq.prototype.__iteratorUncached = function (type, reverse) {\n    if (reverse) {\n      return this.cacheResult().__iterator(type, reverse);\n    }\n    var iterator = this._iterator;\n    var cache = this._iteratorCache;\n    var iterations = 0;\n    return new Iterator(function () {\n      if (iterations >= cache.length) {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        cache[iterations] = step.value;\n      }\n      return iteratorValue(type, iterations, cache[iterations++]);\n    });\n  };\n\n  // # pragma Helper functions\n\n  function isSeq(maybeSeq) {\n    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);\n  }\n\n  var EMPTY_SEQ;\n\n  function emptySequence() {\n    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));\n  }\n\n  function keyedSeqFromValue(value) {\n    var seq = Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() : isIterator(value) ? new IteratorSeq(value).fromEntrySeq() : hasIterator(value) ? new IterableSeq(value).fromEntrySeq() : typeof value === 'object' ? new ObjectSeq(value) : undefined;\n    if (!seq) {\n      throw new TypeError('Expected Array or iterable object of [k, v] entries, ' + 'or keyed object: ' + value);\n    }\n    return seq;\n  }\n\n  function indexedSeqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value);\n    if (!seq) {\n      throw new TypeError('Expected Array or iterable object of values: ' + value);\n    }\n    return seq;\n  }\n\n  function seqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value) || typeof value === 'object' && new ObjectSeq(value);\n    if (!seq) {\n      throw new TypeError('Expected Array or iterable object of values, or keyed object: ' + value);\n    }\n    return seq;\n  }\n\n  function maybeIndexedSeqFromValue(value) {\n    return isArrayLike(value) ? new ArraySeq(value) : isIterator(value) ? new IteratorSeq(value) : hasIterator(value) ? new IterableSeq(value) : undefined;\n  }\n\n  function seqIterate(seq, fn, reverse, useKeys) {\n    var cache = seq._cache;\n    if (cache) {\n      var maxIndex = cache.length - 1;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        var entry = cache[reverse ? maxIndex - ii : ii];\n        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    }\n    return seq.__iterateUncached(fn, reverse);\n  }\n\n  function seqIterator(seq, type, reverse, useKeys) {\n    var cache = seq._cache;\n    if (cache) {\n      var maxIndex = cache.length - 1;\n      var ii = 0;\n      return new Iterator(function () {\n        var entry = cache[reverse ? maxIndex - ii : ii];\n        return ii++ > maxIndex ? iteratorDone() : iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);\n      });\n    }\n    return seq.__iteratorUncached(type, reverse);\n  }\n\n  function fromJS(json, converter) {\n    return converter ? fromJSWith(converter, json, '', { '': json }) : fromJSDefault(json);\n  }\n\n  function fromJSWith(converter, json, key, parentJSON) {\n    if (Array.isArray(json)) {\n      return converter.call(parentJSON, key, IndexedSeq(json).map(function (v, k) {\n        return fromJSWith(converter, v, k, json);\n      }));\n    }\n    if (isPlainObj(json)) {\n      return converter.call(parentJSON, key, KeyedSeq(json).map(function (v, k) {\n        return fromJSWith(converter, v, k, json);\n      }));\n    }\n    return json;\n  }\n\n  function fromJSDefault(json) {\n    if (Array.isArray(json)) {\n      return IndexedSeq(json).map(fromJSDefault).toList();\n    }\n    if (isPlainObj(json)) {\n      return KeyedSeq(json).map(fromJSDefault).toMap();\n    }\n    return json;\n  }\n\n  function isPlainObj(value) {\n    return value && (value.constructor === Object || value.constructor === undefined);\n  }\n\n  /**\n   * An extension of the \"same-value\" algorithm as [described for use by ES6 Map\n   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)\n   *\n   * NaN is considered the same as NaN, however -0 and 0 are considered the same\n   * value, which is different from the algorithm described by\n   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n   *\n   * This is extended further to allow Objects to describe the values they\n   * represent, by way of `valueOf` or `equals` (and `hashCode`).\n   *\n   * Note: because of this extension, the key equality of Immutable.Map and the\n   * value equality of Immutable.Set will differ from ES6 Map and Set.\n   *\n   * ### Defining custom values\n   *\n   * The easiest way to describe the value an object represents is by implementing\n   * `valueOf`. For example, `Date` represents a value by returning a unix\n   * timestamp for `valueOf`:\n   *\n   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...\n   *     var date2 = new Date(1234567890000);\n   *     date1.valueOf(); // 1234567890000\n   *     assert( date1 !== date2 );\n   *     assert( Immutable.is( date1, date2 ) );\n   *\n   * Note: overriding `valueOf` may have other implications if you use this object\n   * where JavaScript expects a primitive, such as implicit string coercion.\n   *\n   * For more complex types, especially collections, implementing `valueOf` may\n   * not be performant. An alternative is to implement `equals` and `hashCode`.\n   *\n   * `equals` takes another object, presumably of similar type, and returns true\n   * if the it is equal. Equality is symmetrical, so the same result should be\n   * returned if this and the argument are flipped.\n   *\n   *     assert( a.equals(b) === b.equals(a) );\n   *\n   * `hashCode` returns a 32bit integer number representing the object which will\n   * be used to determine how to store the value object in a Map or Set. You must\n   * provide both or neither methods, one must not exist without the other.\n   *\n   * Also, an important relationship between these methods must be upheld: if two\n   * values are equal, they *must* return the same hashCode. If the values are not\n   * equal, they might have the same hashCode; this is called a hash collision,\n   * and while undesirable for performance reasons, it is acceptable.\n   *\n   *     if (a.equals(b)) {\n   *       assert( a.hashCode() === b.hashCode() );\n   *     }\n   *\n   * All Immutable collections implement `equals` and `hashCode`.\n   *\n   */\n  function is(valueA, valueB) {\n    if (valueA === valueB || valueA !== valueA && valueB !== valueB) {\n      return true;\n    }\n    if (!valueA || !valueB) {\n      return false;\n    }\n    if (typeof valueA.valueOf === 'function' && typeof valueB.valueOf === 'function') {\n      valueA = valueA.valueOf();\n      valueB = valueB.valueOf();\n      if (valueA === valueB || valueA !== valueA && valueB !== valueB) {\n        return true;\n      }\n      if (!valueA || !valueB) {\n        return false;\n      }\n    }\n    if (typeof valueA.equals === 'function' && typeof valueB.equals === 'function' && valueA.equals(valueB)) {\n      return true;\n    }\n    return false;\n  }\n\n  function deepEqual(a, b) {\n    if (a === b) {\n      return true;\n    }\n\n    if (!isIterable(b) || a.size !== undefined && b.size !== undefined && a.size !== b.size || a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash || isKeyed(a) !== isKeyed(b) || isIndexed(a) !== isIndexed(b) || isOrdered(a) !== isOrdered(b)) {\n      return false;\n    }\n\n    if (a.size === 0 && b.size === 0) {\n      return true;\n    }\n\n    var notAssociative = !isAssociative(a);\n\n    if (isOrdered(a)) {\n      var entries = a.entries();\n      return b.every(function (v, k) {\n        var entry = entries.next().value;\n        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));\n      }) && entries.next().done;\n    }\n\n    var flipped = false;\n\n    if (a.size === undefined) {\n      if (b.size === undefined) {\n        if (typeof a.cacheResult === 'function') {\n          a.cacheResult();\n        }\n      } else {\n        flipped = true;\n        var _ = a;\n        a = b;\n        b = _;\n      }\n    }\n\n    var allEqual = true;\n    var bSize = b.__iterate(function (v, k) {\n      if (notAssociative ? !a.has(v) : flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {\n        allEqual = false;\n        return false;\n      }\n    });\n\n    return allEqual && a.size === bSize;\n  }\n\n  createClass(Repeat, IndexedSeq);\n\n  function Repeat(value, times) {\n    if (!(this instanceof Repeat)) {\n      return new Repeat(value, times);\n    }\n    this._value = value;\n    this.size = times === undefined ? Infinity : Math.max(0, times);\n    if (this.size === 0) {\n      if (EMPTY_REPEAT) {\n        return EMPTY_REPEAT;\n      }\n      EMPTY_REPEAT = this;\n    }\n  }\n\n  Repeat.prototype.toString = function () {\n    if (this.size === 0) {\n      return 'Repeat []';\n    }\n    return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';\n  };\n\n  Repeat.prototype.get = function (index, notSetValue) {\n    return this.has(index) ? this._value : notSetValue;\n  };\n\n  Repeat.prototype.includes = function (searchValue) {\n    return is(this._value, searchValue);\n  };\n\n  Repeat.prototype.slice = function (begin, end) {\n    var size = this.size;\n    return wholeSlice(begin, end, size) ? this : new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));\n  };\n\n  Repeat.prototype.reverse = function () {\n    return this;\n  };\n\n  Repeat.prototype.indexOf = function (searchValue) {\n    if (is(this._value, searchValue)) {\n      return 0;\n    }\n    return -1;\n  };\n\n  Repeat.prototype.lastIndexOf = function (searchValue) {\n    if (is(this._value, searchValue)) {\n      return this.size;\n    }\n    return -1;\n  };\n\n  Repeat.prototype.__iterate = function (fn, reverse) {\n    for (var ii = 0; ii < this.size; ii++) {\n      if (fn(this._value, ii, this) === false) {\n        return ii + 1;\n      }\n    }\n    return ii;\n  };\n\n  Repeat.prototype.__iterator = function (type, reverse) {\n    var this$0 = this;\n    var ii = 0;\n    return new Iterator(function () {\n      return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone();\n    });\n  };\n\n  Repeat.prototype.equals = function (other) {\n    return other instanceof Repeat ? is(this._value, other._value) : deepEqual(other);\n  };\n\n  var EMPTY_REPEAT;\n\n  function invariant(condition, error) {\n    if (!condition) throw new Error(error);\n  }\n\n  createClass(Range, IndexedSeq);\n\n  function Range(start, end, step) {\n    if (!(this instanceof Range)) {\n      return new Range(start, end, step);\n    }\n    invariant(step !== 0, 'Cannot step a Range by 0');\n    start = start || 0;\n    if (end === undefined) {\n      end = Infinity;\n    }\n    step = step === undefined ? 1 : Math.abs(step);\n    if (end < start) {\n      step = -step;\n    }\n    this._start = start;\n    this._end = end;\n    this._step = step;\n    this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);\n    if (this.size === 0) {\n      if (EMPTY_RANGE) {\n        return EMPTY_RANGE;\n      }\n      EMPTY_RANGE = this;\n    }\n  }\n\n  Range.prototype.toString = function () {\n    if (this.size === 0) {\n      return 'Range []';\n    }\n    return 'Range [ ' + this._start + '...' + this._end + (this._step !== 1 ? ' by ' + this._step : '') + ' ]';\n  };\n\n  Range.prototype.get = function (index, notSetValue) {\n    return this.has(index) ? this._start + wrapIndex(this, index) * this._step : notSetValue;\n  };\n\n  Range.prototype.includes = function (searchValue) {\n    var possibleIndex = (searchValue - this._start) / this._step;\n    return possibleIndex >= 0 && possibleIndex < this.size && possibleIndex === Math.floor(possibleIndex);\n  };\n\n  Range.prototype.slice = function (begin, end) {\n    if (wholeSlice(begin, end, this.size)) {\n      return this;\n    }\n    begin = resolveBegin(begin, this.size);\n    end = resolveEnd(end, this.size);\n    if (end <= begin) {\n      return new Range(0, 0);\n    }\n    return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);\n  };\n\n  Range.prototype.indexOf = function (searchValue) {\n    var offsetValue = searchValue - this._start;\n    if (offsetValue % this._step === 0) {\n      var index = offsetValue / this._step;\n      if (index >= 0 && index < this.size) {\n        return index;\n      }\n    }\n    return -1;\n  };\n\n  Range.prototype.lastIndexOf = function (searchValue) {\n    return this.indexOf(searchValue);\n  };\n\n  Range.prototype.__iterate = function (fn, reverse) {\n    var maxIndex = this.size - 1;\n    var step = this._step;\n    var value = reverse ? this._start + maxIndex * step : this._start;\n    for (var ii = 0; ii <= maxIndex; ii++) {\n      if (fn(value, ii, this) === false) {\n        return ii + 1;\n      }\n      value += reverse ? -step : step;\n    }\n    return ii;\n  };\n\n  Range.prototype.__iterator = function (type, reverse) {\n    var maxIndex = this.size - 1;\n    var step = this._step;\n    var value = reverse ? this._start + maxIndex * step : this._start;\n    var ii = 0;\n    return new Iterator(function () {\n      var v = value;\n      value += reverse ? -step : step;\n      return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);\n    });\n  };\n\n  Range.prototype.equals = function (other) {\n    return other instanceof Range ? this._start === other._start && this._end === other._end && this._step === other._step : deepEqual(this, other);\n  };\n\n  var EMPTY_RANGE;\n\n  createClass(Collection, Iterable);\n  function Collection() {\n    throw TypeError('Abstract');\n  }\n\n  createClass(KeyedCollection, Collection);function KeyedCollection() {}\n\n  createClass(IndexedCollection, Collection);function IndexedCollection() {}\n\n  createClass(SetCollection, Collection);function SetCollection() {}\n\n  Collection.Keyed = KeyedCollection;\n  Collection.Indexed = IndexedCollection;\n  Collection.Set = SetCollection;\n\n  var imul = typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ? Math.imul : function imul(a, b) {\n    a = a | 0; // int\n    b = b | 0; // int\n    var c = a & 0xffff;\n    var d = b & 0xffff;\n    // Shift by 0 fixes the sign on the high part.\n    return c * d + ((a >>> 16) * d + c * (b >>> 16) << 16 >>> 0) | 0; // int\n  };\n\n  // v8 has an optimization for storing 31-bit signed numbers.\n  // Values which have either 00 or 11 as the high order bits qualify.\n  // This function drops the highest order bit in a signed number, maintaining\n  // the sign bit.\n  function smi(i32) {\n    return i32 >>> 1 & 0x40000000 | i32 & 0xBFFFFFFF;\n  }\n\n  function hash(o) {\n    if (o === false || o === null || o === undefined) {\n      return 0;\n    }\n    if (typeof o.valueOf === 'function') {\n      o = o.valueOf();\n      if (o === false || o === null || o === undefined) {\n        return 0;\n      }\n    }\n    if (o === true) {\n      return 1;\n    }\n    var type = typeof o;\n    if (type === 'number') {\n      if (o !== o || o === Infinity) {\n        return 0;\n      }\n      var h = o | 0;\n      if (h !== o) {\n        h ^= o * 0xFFFFFFFF;\n      }\n      while (o > 0xFFFFFFFF) {\n        o /= 0xFFFFFFFF;\n        h ^= o;\n      }\n      return smi(h);\n    }\n    if (type === 'string') {\n      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);\n    }\n    if (typeof o.hashCode === 'function') {\n      return o.hashCode();\n    }\n    if (type === 'object') {\n      return hashJSObj(o);\n    }\n    if (typeof o.toString === 'function') {\n      return hashString(o.toString());\n    }\n    throw new Error('Value type ' + type + ' cannot be hashed.');\n  }\n\n  function cachedHashString(string) {\n    var hash = stringHashCache[string];\n    if (hash === undefined) {\n      hash = hashString(string);\n      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {\n        STRING_HASH_CACHE_SIZE = 0;\n        stringHashCache = {};\n      }\n      STRING_HASH_CACHE_SIZE++;\n      stringHashCache[string] = hash;\n    }\n    return hash;\n  }\n\n  // http://jsperf.com/hashing-strings\n  function hashString(string) {\n    // This is the hash from JVM\n    // The hash code for a string is computed as\n    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\n    // where s[i] is the ith character of the string and n is the length of\n    // the string. We \"mod\" the result to make it between 0 (inclusive) and 2^31\n    // (exclusive) by dropping high bits.\n    var hash = 0;\n    for (var ii = 0; ii < string.length; ii++) {\n      hash = 31 * hash + string.charCodeAt(ii) | 0;\n    }\n    return smi(hash);\n  }\n\n  function hashJSObj(obj) {\n    var hash;\n    if (usingWeakMap) {\n      hash = weakMap.get(obj);\n      if (hash !== undefined) {\n        return hash;\n      }\n    }\n\n    hash = obj[UID_HASH_KEY];\n    if (hash !== undefined) {\n      return hash;\n    }\n\n    if (!canDefineProperty) {\n      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];\n      if (hash !== undefined) {\n        return hash;\n      }\n\n      hash = getIENodeHash(obj);\n      if (hash !== undefined) {\n        return hash;\n      }\n    }\n\n    hash = ++objHashUID;\n    if (objHashUID & 0x40000000) {\n      objHashUID = 0;\n    }\n\n    if (usingWeakMap) {\n      weakMap.set(obj, hash);\n    } else if (isExtensible !== undefined && isExtensible(obj) === false) {\n      throw new Error('Non-extensible objects are not allowed as keys.');\n    } else if (canDefineProperty) {\n      Object.defineProperty(obj, UID_HASH_KEY, {\n        'enumerable': false,\n        'configurable': false,\n        'writable': false,\n        'value': hash\n      });\n    } else if (obj.propertyIsEnumerable !== undefined && obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {\n      // Since we can't define a non-enumerable property on the object\n      // we'll hijack one of the less-used non-enumerable properties to\n      // save our hash on it. Since this is a function it will not show up in\n      // `JSON.stringify` which is what we want.\n      obj.propertyIsEnumerable = function () {\n        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);\n      };\n      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;\n    } else if (obj.nodeType !== undefined) {\n      // At this point we couldn't get the IE `uniqueID` to use as a hash\n      // and we couldn't use a non-enumerable property to exploit the\n      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node\n      // itself.\n      obj[UID_HASH_KEY] = hash;\n    } else {\n      throw new Error('Unable to set a non-enumerable property on object.');\n    }\n\n    return hash;\n  }\n\n  // Get references to ES5 object methods.\n  var isExtensible = Object.isExtensible;\n\n  // True if Object.defineProperty works as expected. IE8 fails this test.\n  var canDefineProperty = function () {\n    try {\n      Object.defineProperty({}, '@', {});\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }();\n\n  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it\n  // and avoid memory leaks from the IE cloneNode bug.\n  function getIENodeHash(node) {\n    if (node && node.nodeType > 0) {\n      switch (node.nodeType) {\n        case 1:\n          // Element\n          return node.uniqueID;\n        case 9:\n          // Document\n          return node.documentElement && node.documentElement.uniqueID;\n      }\n    }\n  }\n\n  // If possible, use a WeakMap.\n  var usingWeakMap = typeof WeakMap === 'function';\n  var weakMap;\n  if (usingWeakMap) {\n    weakMap = new WeakMap();\n  }\n\n  var objHashUID = 0;\n\n  var UID_HASH_KEY = '__immutablehash__';\n  if (typeof Symbol === 'function') {\n    UID_HASH_KEY = Symbol(UID_HASH_KEY);\n  }\n\n  var STRING_HASH_CACHE_MIN_STRLEN = 16;\n  var STRING_HASH_CACHE_MAX_SIZE = 255;\n  var STRING_HASH_CACHE_SIZE = 0;\n  var stringHashCache = {};\n\n  function assertNotInfinite(size) {\n    invariant(size !== Infinity, 'Cannot perform this action with an infinite size.');\n  }\n\n  createClass(Map, KeyedCollection);\n\n  // @pragma Construction\n\n  function Map(value) {\n    return value === null || value === undefined ? emptyMap() : isMap(value) && !isOrdered(value) ? value : emptyMap().withMutations(function (map) {\n      var iter = KeyedIterable(value);\n      assertNotInfinite(iter.size);\n      iter.forEach(function (v, k) {\n        return map.set(k, v);\n      });\n    });\n  }\n\n  Map.of = function () {\n    var keyValues = SLICE$0.call(arguments, 0);\n    return emptyMap().withMutations(function (map) {\n      for (var i = 0; i < keyValues.length; i += 2) {\n        if (i + 1 >= keyValues.length) {\n          throw new Error('Missing value for key: ' + keyValues[i]);\n        }\n        map.set(keyValues[i], keyValues[i + 1]);\n      }\n    });\n  };\n\n  Map.prototype.toString = function () {\n    return this.__toString('Map {', '}');\n  };\n\n  // @pragma Access\n\n  Map.prototype.get = function (k, notSetValue) {\n    return this._root ? this._root.get(0, undefined, k, notSetValue) : notSetValue;\n  };\n\n  // @pragma Modification\n\n  Map.prototype.set = function (k, v) {\n    return updateMap(this, k, v);\n  };\n\n  Map.prototype.setIn = function (keyPath, v) {\n    return this.updateIn(keyPath, NOT_SET, function () {\n      return v;\n    });\n  };\n\n  Map.prototype.remove = function (k) {\n    return updateMap(this, k, NOT_SET);\n  };\n\n  Map.prototype.deleteIn = function (keyPath) {\n    return this.updateIn(keyPath, function () {\n      return NOT_SET;\n    });\n  };\n\n  Map.prototype.update = function (k, notSetValue, updater) {\n    return arguments.length === 1 ? k(this) : this.updateIn([k], notSetValue, updater);\n  };\n\n  Map.prototype.updateIn = function (keyPath, notSetValue, updater) {\n    if (!updater) {\n      updater = notSetValue;\n      notSetValue = undefined;\n    }\n    var updatedValue = updateInDeepMap(this, forceIterator(keyPath), notSetValue, updater);\n    return updatedValue === NOT_SET ? undefined : updatedValue;\n  };\n\n  Map.prototype.clear = function () {\n    if (this.size === 0) {\n      return this;\n    }\n    if (this.__ownerID) {\n      this.size = 0;\n      this._root = null;\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return emptyMap();\n  };\n\n  // @pragma Composition\n\n  Map.prototype.merge = function () /*...iters*/{\n    return mergeIntoMapWith(this, undefined, arguments);\n  };\n\n  Map.prototype.mergeWith = function (merger) {\n    var iters = SLICE$0.call(arguments, 1);\n    return mergeIntoMapWith(this, merger, iters);\n  };\n\n  Map.prototype.mergeIn = function (keyPath) {\n    var iters = SLICE$0.call(arguments, 1);\n    return this.updateIn(keyPath, emptyMap(), function (m) {\n      return typeof m.merge === 'function' ? m.merge.apply(m, iters) : iters[iters.length - 1];\n    });\n  };\n\n  Map.prototype.mergeDeep = function () /*...iters*/{\n    return mergeIntoMapWith(this, deepMerger, arguments);\n  };\n\n  Map.prototype.mergeDeepWith = function (merger) {\n    var iters = SLICE$0.call(arguments, 1);\n    return mergeIntoMapWith(this, deepMergerWith(merger), iters);\n  };\n\n  Map.prototype.mergeDeepIn = function (keyPath) {\n    var iters = SLICE$0.call(arguments, 1);\n    return this.updateIn(keyPath, emptyMap(), function (m) {\n      return typeof m.mergeDeep === 'function' ? m.mergeDeep.apply(m, iters) : iters[iters.length - 1];\n    });\n  };\n\n  Map.prototype.sort = function (comparator) {\n    // Late binding\n    return OrderedMap(sortFactory(this, comparator));\n  };\n\n  Map.prototype.sortBy = function (mapper, comparator) {\n    // Late binding\n    return OrderedMap(sortFactory(this, comparator, mapper));\n  };\n\n  // @pragma Mutability\n\n  Map.prototype.withMutations = function (fn) {\n    var mutable = this.asMutable();\n    fn(mutable);\n    return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;\n  };\n\n  Map.prototype.asMutable = function () {\n    return this.__ownerID ? this : this.__ensureOwner(new OwnerID());\n  };\n\n  Map.prototype.asImmutable = function () {\n    return this.__ensureOwner();\n  };\n\n  Map.prototype.wasAltered = function () {\n    return this.__altered;\n  };\n\n  Map.prototype.__iterator = function (type, reverse) {\n    return new MapIterator(this, type, reverse);\n  };\n\n  Map.prototype.__iterate = function (fn, reverse) {\n    var this$0 = this;\n    var iterations = 0;\n    this._root && this._root.iterate(function (entry) {\n      iterations++;\n      return fn(entry[1], entry[0], this$0);\n    }, reverse);\n    return iterations;\n  };\n\n  Map.prototype.__ensureOwner = function (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    if (!ownerID) {\n      this.__ownerID = ownerID;\n      this.__altered = false;\n      return this;\n    }\n    return makeMap(this.size, this._root, ownerID, this.__hash);\n  };\n\n  function isMap(maybeMap) {\n    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);\n  }\n\n  Map.isMap = isMap;\n\n  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';\n\n  var MapPrototype = Map.prototype;\n  MapPrototype[IS_MAP_SENTINEL] = true;\n  MapPrototype[DELETE] = MapPrototype.remove;\n  MapPrototype.removeIn = MapPrototype.deleteIn;\n\n  // #pragma Trie Nodes\n\n\n  function ArrayMapNode(ownerID, entries) {\n    this.ownerID = ownerID;\n    this.entries = entries;\n  }\n\n  ArrayMapNode.prototype.get = function (shift, keyHash, key, notSetValue) {\n    var entries = this.entries;\n    for (var ii = 0, len = entries.length; ii < len; ii++) {\n      if (is(key, entries[ii][0])) {\n        return entries[ii][1];\n      }\n    }\n    return notSetValue;\n  };\n\n  ArrayMapNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    var removed = value === NOT_SET;\n\n    var entries = this.entries;\n    var idx = 0;\n    for (var len = entries.length; idx < len; idx++) {\n      if (is(key, entries[idx][0])) {\n        break;\n      }\n    }\n    var exists = idx < len;\n\n    if (exists ? entries[idx][1] === value : removed) {\n      return this;\n    }\n\n    SetRef(didAlter);\n    (removed || !exists) && SetRef(didChangeSize);\n\n    if (removed && entries.length === 1) {\n      return; // undefined\n    }\n\n    if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {\n      return createNodes(ownerID, entries, key, value);\n    }\n\n    var isEditable = ownerID && ownerID === this.ownerID;\n    var newEntries = isEditable ? entries : arrCopy(entries);\n\n    if (exists) {\n      if (removed) {\n        idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();\n      } else {\n        newEntries[idx] = [key, value];\n      }\n    } else {\n      newEntries.push([key, value]);\n    }\n\n    if (isEditable) {\n      this.entries = newEntries;\n      return this;\n    }\n\n    return new ArrayMapNode(ownerID, newEntries);\n  };\n\n  function BitmapIndexedNode(ownerID, bitmap, nodes) {\n    this.ownerID = ownerID;\n    this.bitmap = bitmap;\n    this.nodes = nodes;\n  }\n\n  BitmapIndexedNode.prototype.get = function (shift, keyHash, key, notSetValue) {\n    if (keyHash === undefined) {\n      keyHash = hash(key);\n    }\n    var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);\n    var bitmap = this.bitmap;\n    return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & bit - 1)].get(shift + SHIFT, keyHash, key, notSetValue);\n  };\n\n  BitmapIndexedNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (keyHash === undefined) {\n      keyHash = hash(key);\n    }\n    var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n    var bit = 1 << keyHashFrag;\n    var bitmap = this.bitmap;\n    var exists = (bitmap & bit) !== 0;\n\n    if (!exists && value === NOT_SET) {\n      return this;\n    }\n\n    var idx = popCount(bitmap & bit - 1);\n    var nodes = this.nodes;\n    var node = exists ? nodes[idx] : undefined;\n    var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n\n    if (newNode === node) {\n      return this;\n    }\n\n    if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {\n      return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);\n    }\n\n    if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {\n      return nodes[idx ^ 1];\n    }\n\n    if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {\n      return newNode;\n    }\n\n    var isEditable = ownerID && ownerID === this.ownerID;\n    var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;\n    var newNodes = exists ? newNode ? setIn(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);\n\n    if (isEditable) {\n      this.bitmap = newBitmap;\n      this.nodes = newNodes;\n      return this;\n    }\n\n    return new BitmapIndexedNode(ownerID, newBitmap, newNodes);\n  };\n\n  function HashArrayMapNode(ownerID, count, nodes) {\n    this.ownerID = ownerID;\n    this.count = count;\n    this.nodes = nodes;\n  }\n\n  HashArrayMapNode.prototype.get = function (shift, keyHash, key, notSetValue) {\n    if (keyHash === undefined) {\n      keyHash = hash(key);\n    }\n    var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n    var node = this.nodes[idx];\n    return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;\n  };\n\n  HashArrayMapNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (keyHash === undefined) {\n      keyHash = hash(key);\n    }\n    var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n    var removed = value === NOT_SET;\n    var nodes = this.nodes;\n    var node = nodes[idx];\n\n    if (removed && !node) {\n      return this;\n    }\n\n    var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n    if (newNode === node) {\n      return this;\n    }\n\n    var newCount = this.count;\n    if (!node) {\n      newCount++;\n    } else if (!newNode) {\n      newCount--;\n      if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {\n        return packNodes(ownerID, nodes, newCount, idx);\n      }\n    }\n\n    var isEditable = ownerID && ownerID === this.ownerID;\n    var newNodes = setIn(nodes, idx, newNode, isEditable);\n\n    if (isEditable) {\n      this.count = newCount;\n      this.nodes = newNodes;\n      return this;\n    }\n\n    return new HashArrayMapNode(ownerID, newCount, newNodes);\n  };\n\n  function HashCollisionNode(ownerID, keyHash, entries) {\n    this.ownerID = ownerID;\n    this.keyHash = keyHash;\n    this.entries = entries;\n  }\n\n  HashCollisionNode.prototype.get = function (shift, keyHash, key, notSetValue) {\n    var entries = this.entries;\n    for (var ii = 0, len = entries.length; ii < len; ii++) {\n      if (is(key, entries[ii][0])) {\n        return entries[ii][1];\n      }\n    }\n    return notSetValue;\n  };\n\n  HashCollisionNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (keyHash === undefined) {\n      keyHash = hash(key);\n    }\n\n    var removed = value === NOT_SET;\n\n    if (keyHash !== this.keyHash) {\n      if (removed) {\n        return this;\n      }\n      SetRef(didAlter);\n      SetRef(didChangeSize);\n      return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);\n    }\n\n    var entries = this.entries;\n    var idx = 0;\n    for (var len = entries.length; idx < len; idx++) {\n      if (is(key, entries[idx][0])) {\n        break;\n      }\n    }\n    var exists = idx < len;\n\n    if (exists ? entries[idx][1] === value : removed) {\n      return this;\n    }\n\n    SetRef(didAlter);\n    (removed || !exists) && SetRef(didChangeSize);\n\n    if (removed && len === 2) {\n      return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);\n    }\n\n    var isEditable = ownerID && ownerID === this.ownerID;\n    var newEntries = isEditable ? entries : arrCopy(entries);\n\n    if (exists) {\n      if (removed) {\n        idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();\n      } else {\n        newEntries[idx] = [key, value];\n      }\n    } else {\n      newEntries.push([key, value]);\n    }\n\n    if (isEditable) {\n      this.entries = newEntries;\n      return this;\n    }\n\n    return new HashCollisionNode(ownerID, this.keyHash, newEntries);\n  };\n\n  function ValueNode(ownerID, keyHash, entry) {\n    this.ownerID = ownerID;\n    this.keyHash = keyHash;\n    this.entry = entry;\n  }\n\n  ValueNode.prototype.get = function (shift, keyHash, key, notSetValue) {\n    return is(key, this.entry[0]) ? this.entry[1] : notSetValue;\n  };\n\n  ValueNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    var removed = value === NOT_SET;\n    var keyMatch = is(key, this.entry[0]);\n    if (keyMatch ? value === this.entry[1] : removed) {\n      return this;\n    }\n\n    SetRef(didAlter);\n\n    if (removed) {\n      SetRef(didChangeSize);\n      return; // undefined\n    }\n\n    if (keyMatch) {\n      if (ownerID && ownerID === this.ownerID) {\n        this.entry[1] = value;\n        return this;\n      }\n      return new ValueNode(ownerID, this.keyHash, [key, value]);\n    }\n\n    SetRef(didChangeSize);\n    return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);\n  };\n\n  // #pragma Iterators\n\n  ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function (fn, reverse) {\n    var entries = this.entries;\n    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {\n      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {\n        return false;\n      }\n    }\n  };\n\n  BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function (fn, reverse) {\n    var nodes = this.nodes;\n    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {\n      var node = nodes[reverse ? maxIndex - ii : ii];\n      if (node && node.iterate(fn, reverse) === false) {\n        return false;\n      }\n    }\n  };\n\n  ValueNode.prototype.iterate = function (fn, reverse) {\n    return fn(this.entry);\n  };\n\n  createClass(MapIterator, Iterator);\n\n  function MapIterator(map, type, reverse) {\n    this._type = type;\n    this._reverse = reverse;\n    this._stack = map._root && mapIteratorFrame(map._root);\n  }\n\n  MapIterator.prototype.next = function () {\n    var type = this._type;\n    var stack = this._stack;\n    while (stack) {\n      var node = stack.node;\n      var index = stack.index++;\n      var maxIndex;\n      if (node.entry) {\n        if (index === 0) {\n          return mapIteratorValue(type, node.entry);\n        }\n      } else if (node.entries) {\n        maxIndex = node.entries.length - 1;\n        if (index <= maxIndex) {\n          return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);\n        }\n      } else {\n        maxIndex = node.nodes.length - 1;\n        if (index <= maxIndex) {\n          var subNode = node.nodes[this._reverse ? maxIndex - index : index];\n          if (subNode) {\n            if (subNode.entry) {\n              return mapIteratorValue(type, subNode.entry);\n            }\n            stack = this._stack = mapIteratorFrame(subNode, stack);\n          }\n          continue;\n        }\n      }\n      stack = this._stack = this._stack.__prev;\n    }\n    return iteratorDone();\n  };\n\n  function mapIteratorValue(type, entry) {\n    return iteratorValue(type, entry[0], entry[1]);\n  }\n\n  function mapIteratorFrame(node, prev) {\n    return {\n      node: node,\n      index: 0,\n      __prev: prev\n    };\n  }\n\n  function makeMap(size, root, ownerID, hash) {\n    var map = Object.create(MapPrototype);\n    map.size = size;\n    map._root = root;\n    map.__ownerID = ownerID;\n    map.__hash = hash;\n    map.__altered = false;\n    return map;\n  }\n\n  var EMPTY_MAP;\n  function emptyMap() {\n    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));\n  }\n\n  function updateMap(map, k, v) {\n    var newRoot;\n    var newSize;\n    if (!map._root) {\n      if (v === NOT_SET) {\n        return map;\n      }\n      newSize = 1;\n      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);\n    } else {\n      var didChangeSize = MakeRef(CHANGE_LENGTH);\n      var didAlter = MakeRef(DID_ALTER);\n      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);\n      if (!didAlter.value) {\n        return map;\n      }\n      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);\n    }\n    if (map.__ownerID) {\n      map.size = newSize;\n      map._root = newRoot;\n      map.__hash = undefined;\n      map.__altered = true;\n      return map;\n    }\n    return newRoot ? makeMap(newSize, newRoot) : emptyMap();\n  }\n\n  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (!node) {\n      if (value === NOT_SET) {\n        return node;\n      }\n      SetRef(didAlter);\n      SetRef(didChangeSize);\n      return new ValueNode(ownerID, keyHash, [key, value]);\n    }\n    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);\n  }\n\n  function isLeafNode(node) {\n    return node.constructor === ValueNode || node.constructor === HashCollisionNode;\n  }\n\n  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {\n    if (node.keyHash === keyHash) {\n      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);\n    }\n\n    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;\n    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\n    var newNode;\n    var nodes = idx1 === idx2 ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] : (newNode = new ValueNode(ownerID, keyHash, entry), idx1 < idx2 ? [node, newNode] : [newNode, node]);\n\n    return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);\n  }\n\n  function createNodes(ownerID, entries, key, value) {\n    if (!ownerID) {\n      ownerID = new OwnerID();\n    }\n    var node = new ValueNode(ownerID, hash(key), [key, value]);\n    for (var ii = 0; ii < entries.length; ii++) {\n      var entry = entries[ii];\n      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);\n    }\n    return node;\n  }\n\n  function packNodes(ownerID, nodes, count, excluding) {\n    var bitmap = 0;\n    var packedII = 0;\n    var packedNodes = new Array(count);\n    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {\n      var node = nodes[ii];\n      if (node !== undefined && ii !== excluding) {\n        bitmap |= bit;\n        packedNodes[packedII++] = node;\n      }\n    }\n    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);\n  }\n\n  function expandNodes(ownerID, nodes, bitmap, including, node) {\n    var count = 0;\n    var expandedNodes = new Array(SIZE);\n    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {\n      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;\n    }\n    expandedNodes[including] = node;\n    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);\n  }\n\n  function mergeIntoMapWith(map, merger, iterables) {\n    var iters = [];\n    for (var ii = 0; ii < iterables.length; ii++) {\n      var value = iterables[ii];\n      var iter = KeyedIterable(value);\n      if (!isIterable(value)) {\n        iter = iter.map(function (v) {\n          return fromJS(v);\n        });\n      }\n      iters.push(iter);\n    }\n    return mergeIntoCollectionWith(map, merger, iters);\n  }\n\n  function deepMerger(existing, value, key) {\n    return existing && existing.mergeDeep && isIterable(value) ? existing.mergeDeep(value) : is(existing, value) ? existing : value;\n  }\n\n  function deepMergerWith(merger) {\n    return function (existing, value, key) {\n      if (existing && existing.mergeDeepWith && isIterable(value)) {\n        return existing.mergeDeepWith(merger, value);\n      }\n      var nextValue = merger(existing, value, key);\n      return is(existing, nextValue) ? existing : nextValue;\n    };\n  }\n\n  function mergeIntoCollectionWith(collection, merger, iters) {\n    iters = iters.filter(function (x) {\n      return x.size !== 0;\n    });\n    if (iters.length === 0) {\n      return collection;\n    }\n    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {\n      return collection.constructor(iters[0]);\n    }\n    return collection.withMutations(function (collection) {\n      var mergeIntoMap = merger ? function (value, key) {\n        collection.update(key, NOT_SET, function (existing) {\n          return existing === NOT_SET ? value : merger(existing, value, key);\n        });\n      } : function (value, key) {\n        collection.set(key, value);\n      };\n      for (var ii = 0; ii < iters.length; ii++) {\n        iters[ii].forEach(mergeIntoMap);\n      }\n    });\n  }\n\n  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {\n    var isNotSet = existing === NOT_SET;\n    var step = keyPathIter.next();\n    if (step.done) {\n      var existingValue = isNotSet ? notSetValue : existing;\n      var newValue = updater(existingValue);\n      return newValue === existingValue ? existing : newValue;\n    }\n    invariant(isNotSet || existing && existing.set, 'invalid keyPath');\n    var key = step.value;\n    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);\n    var nextUpdated = updateInDeepMap(nextExisting, keyPathIter, notSetValue, updater);\n    return nextUpdated === nextExisting ? existing : nextUpdated === NOT_SET ? existing.remove(key) : (isNotSet ? emptyMap() : existing).set(key, nextUpdated);\n  }\n\n  function popCount(x) {\n    x = x - (x >> 1 & 0x55555555);\n    x = (x & 0x33333333) + (x >> 2 & 0x33333333);\n    x = x + (x >> 4) & 0x0f0f0f0f;\n    x = x + (x >> 8);\n    x = x + (x >> 16);\n    return x & 0x7f;\n  }\n\n  function setIn(array, idx, val, canEdit) {\n    var newArray = canEdit ? array : arrCopy(array);\n    newArray[idx] = val;\n    return newArray;\n  }\n\n  function spliceIn(array, idx, val, canEdit) {\n    var newLen = array.length + 1;\n    if (canEdit && idx + 1 === newLen) {\n      array[idx] = val;\n      return array;\n    }\n    var newArray = new Array(newLen);\n    var after = 0;\n    for (var ii = 0; ii < newLen; ii++) {\n      if (ii === idx) {\n        newArray[ii] = val;\n        after = -1;\n      } else {\n        newArray[ii] = array[ii + after];\n      }\n    }\n    return newArray;\n  }\n\n  function spliceOut(array, idx, canEdit) {\n    var newLen = array.length - 1;\n    if (canEdit && idx === newLen) {\n      array.pop();\n      return array;\n    }\n    var newArray = new Array(newLen);\n    var after = 0;\n    for (var ii = 0; ii < newLen; ii++) {\n      if (ii === idx) {\n        after = 1;\n      }\n      newArray[ii] = array[ii + after];\n    }\n    return newArray;\n  }\n\n  var MAX_ARRAY_MAP_SIZE = SIZE / 4;\n  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;\n  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;\n\n  createClass(List, IndexedCollection);\n\n  // @pragma Construction\n\n  function List(value) {\n    var empty = emptyList();\n    if (value === null || value === undefined) {\n      return empty;\n    }\n    if (isList(value)) {\n      return value;\n    }\n    var iter = IndexedIterable(value);\n    var size = iter.size;\n    if (size === 0) {\n      return empty;\n    }\n    assertNotInfinite(size);\n    if (size > 0 && size < SIZE) {\n      return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));\n    }\n    return empty.withMutations(function (list) {\n      list.setSize(size);\n      iter.forEach(function (v, i) {\n        return list.set(i, v);\n      });\n    });\n  }\n\n  List.of = function () /*...values*/{\n    return this(arguments);\n  };\n\n  List.prototype.toString = function () {\n    return this.__toString('List [', ']');\n  };\n\n  // @pragma Access\n\n  List.prototype.get = function (index, notSetValue) {\n    index = wrapIndex(this, index);\n    if (index >= 0 && index < this.size) {\n      index += this._origin;\n      var node = listNodeFor(this, index);\n      return node && node.array[index & MASK];\n    }\n    return notSetValue;\n  };\n\n  // @pragma Modification\n\n  List.prototype.set = function (index, value) {\n    return updateList(this, index, value);\n  };\n\n  List.prototype.remove = function (index) {\n    return !this.has(index) ? this : index === 0 ? this.shift() : index === this.size - 1 ? this.pop() : this.splice(index, 1);\n  };\n\n  List.prototype.insert = function (index, value) {\n    return this.splice(index, 0, value);\n  };\n\n  List.prototype.clear = function () {\n    if (this.size === 0) {\n      return this;\n    }\n    if (this.__ownerID) {\n      this.size = this._origin = this._capacity = 0;\n      this._level = SHIFT;\n      this._root = this._tail = null;\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return emptyList();\n  };\n\n  List.prototype.push = function () /*...values*/{\n    var values = arguments;\n    var oldSize = this.size;\n    return this.withMutations(function (list) {\n      setListBounds(list, 0, oldSize + values.length);\n      for (var ii = 0; ii < values.length; ii++) {\n        list.set(oldSize + ii, values[ii]);\n      }\n    });\n  };\n\n  List.prototype.pop = function () {\n    return setListBounds(this, 0, -1);\n  };\n\n  List.prototype.unshift = function () /*...values*/{\n    var values = arguments;\n    return this.withMutations(function (list) {\n      setListBounds(list, -values.length);\n      for (var ii = 0; ii < values.length; ii++) {\n        list.set(ii, values[ii]);\n      }\n    });\n  };\n\n  List.prototype.shift = function () {\n    return setListBounds(this, 1);\n  };\n\n  // @pragma Composition\n\n  List.prototype.merge = function () /*...iters*/{\n    return mergeIntoListWith(this, undefined, arguments);\n  };\n\n  List.prototype.mergeWith = function (merger) {\n    var iters = SLICE$0.call(arguments, 1);\n    return mergeIntoListWith(this, merger, iters);\n  };\n\n  List.prototype.mergeDeep = function () /*...iters*/{\n    return mergeIntoListWith(this, deepMerger, arguments);\n  };\n\n  List.prototype.mergeDeepWith = function (merger) {\n    var iters = SLICE$0.call(arguments, 1);\n    return mergeIntoListWith(this, deepMergerWith(merger), iters);\n  };\n\n  List.prototype.setSize = function (size) {\n    return setListBounds(this, 0, size);\n  };\n\n  // @pragma Iteration\n\n  List.prototype.slice = function (begin, end) {\n    var size = this.size;\n    if (wholeSlice(begin, end, size)) {\n      return this;\n    }\n    return setListBounds(this, resolveBegin(begin, size), resolveEnd(end, size));\n  };\n\n  List.prototype.__iterator = function (type, reverse) {\n    var index = 0;\n    var values = iterateList(this, reverse);\n    return new Iterator(function () {\n      var value = values();\n      return value === DONE ? iteratorDone() : iteratorValue(type, index++, value);\n    });\n  };\n\n  List.prototype.__iterate = function (fn, reverse) {\n    var index = 0;\n    var values = iterateList(this, reverse);\n    var value;\n    while ((value = values()) !== DONE) {\n      if (fn(value, index++, this) === false) {\n        break;\n      }\n    }\n    return index;\n  };\n\n  List.prototype.__ensureOwner = function (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    if (!ownerID) {\n      this.__ownerID = ownerID;\n      return this;\n    }\n    return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);\n  };\n\n  function isList(maybeList) {\n    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);\n  }\n\n  List.isList = isList;\n\n  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';\n\n  var ListPrototype = List.prototype;\n  ListPrototype[IS_LIST_SENTINEL] = true;\n  ListPrototype[DELETE] = ListPrototype.remove;\n  ListPrototype.setIn = MapPrototype.setIn;\n  ListPrototype.deleteIn = ListPrototype.removeIn = MapPrototype.removeIn;\n  ListPrototype.update = MapPrototype.update;\n  ListPrototype.updateIn = MapPrototype.updateIn;\n  ListPrototype.mergeIn = MapPrototype.mergeIn;\n  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n  ListPrototype.withMutations = MapPrototype.withMutations;\n  ListPrototype.asMutable = MapPrototype.asMutable;\n  ListPrototype.asImmutable = MapPrototype.asImmutable;\n  ListPrototype.wasAltered = MapPrototype.wasAltered;\n\n  function VNode(array, ownerID) {\n    this.array = array;\n    this.ownerID = ownerID;\n  }\n\n  // TODO: seems like these methods are very similar\n\n  VNode.prototype.removeBefore = function (ownerID, level, index) {\n    if (index === level ? 1 << level : 0 || this.array.length === 0) {\n      return this;\n    }\n    var originIndex = index >>> level & MASK;\n    if (originIndex >= this.array.length) {\n      return new VNode([], ownerID);\n    }\n    var removingFirst = originIndex === 0;\n    var newChild;\n    if (level > 0) {\n      var oldChild = this.array[originIndex];\n      newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);\n      if (newChild === oldChild && removingFirst) {\n        return this;\n      }\n    }\n    if (removingFirst && !newChild) {\n      return this;\n    }\n    var editable = editableVNode(this, ownerID);\n    if (!removingFirst) {\n      for (var ii = 0; ii < originIndex; ii++) {\n        editable.array[ii] = undefined;\n      }\n    }\n    if (newChild) {\n      editable.array[originIndex] = newChild;\n    }\n    return editable;\n  };\n\n  VNode.prototype.removeAfter = function (ownerID, level, index) {\n    if (index === (level ? 1 << level : 0) || this.array.length === 0) {\n      return this;\n    }\n    var sizeIndex = index - 1 >>> level & MASK;\n    if (sizeIndex >= this.array.length) {\n      return this;\n    }\n\n    var newChild;\n    if (level > 0) {\n      var oldChild = this.array[sizeIndex];\n      newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);\n      if (newChild === oldChild && sizeIndex === this.array.length - 1) {\n        return this;\n      }\n    }\n\n    var editable = editableVNode(this, ownerID);\n    editable.array.splice(sizeIndex + 1);\n    if (newChild) {\n      editable.array[sizeIndex] = newChild;\n    }\n    return editable;\n  };\n\n  var DONE = {};\n\n  function iterateList(list, reverse) {\n    var left = list._origin;\n    var right = list._capacity;\n    var tailPos = getTailOffset(right);\n    var tail = list._tail;\n\n    return iterateNodeOrLeaf(list._root, list._level, 0);\n\n    function iterateNodeOrLeaf(node, level, offset) {\n      return level === 0 ? iterateLeaf(node, offset) : iterateNode(node, level, offset);\n    }\n\n    function iterateLeaf(node, offset) {\n      var array = offset === tailPos ? tail && tail.array : node && node.array;\n      var from = offset > left ? 0 : left - offset;\n      var to = right - offset;\n      if (to > SIZE) {\n        to = SIZE;\n      }\n      return function () {\n        if (from === to) {\n          return DONE;\n        }\n        var idx = reverse ? --to : from++;\n        return array && array[idx];\n      };\n    }\n\n    function iterateNode(node, level, offset) {\n      var values;\n      var array = node && node.array;\n      var from = offset > left ? 0 : left - offset >> level;\n      var to = (right - offset >> level) + 1;\n      if (to > SIZE) {\n        to = SIZE;\n      }\n      return function () {\n        do {\n          if (values) {\n            var value = values();\n            if (value !== DONE) {\n              return value;\n            }\n            values = null;\n          }\n          if (from === to) {\n            return DONE;\n          }\n          var idx = reverse ? --to : from++;\n          values = iterateNodeOrLeaf(array && array[idx], level - SHIFT, offset + (idx << level));\n        } while (true);\n      };\n    }\n  }\n\n  function makeList(origin, capacity, level, root, tail, ownerID, hash) {\n    var list = Object.create(ListPrototype);\n    list.size = capacity - origin;\n    list._origin = origin;\n    list._capacity = capacity;\n    list._level = level;\n    list._root = root;\n    list._tail = tail;\n    list.__ownerID = ownerID;\n    list.__hash = hash;\n    list.__altered = false;\n    return list;\n  }\n\n  var EMPTY_LIST;\n  function emptyList() {\n    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));\n  }\n\n  function updateList(list, index, value) {\n    index = wrapIndex(list, index);\n\n    if (index !== index) {\n      return list;\n    }\n\n    if (index >= list.size || index < 0) {\n      return list.withMutations(function (list) {\n        index < 0 ? setListBounds(list, index).set(0, value) : setListBounds(list, 0, index + 1).set(index, value);\n      });\n    }\n\n    index += list._origin;\n\n    var newTail = list._tail;\n    var newRoot = list._root;\n    var didAlter = MakeRef(DID_ALTER);\n    if (index >= getTailOffset(list._capacity)) {\n      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);\n    } else {\n      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);\n    }\n\n    if (!didAlter.value) {\n      return list;\n    }\n\n    if (list.__ownerID) {\n      list._root = newRoot;\n      list._tail = newTail;\n      list.__hash = undefined;\n      list.__altered = true;\n      return list;\n    }\n    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);\n  }\n\n  function updateVNode(node, ownerID, level, index, value, didAlter) {\n    var idx = index >>> level & MASK;\n    var nodeHas = node && idx < node.array.length;\n    if (!nodeHas && value === undefined) {\n      return node;\n    }\n\n    var newNode;\n\n    if (level > 0) {\n      var lowerNode = node && node.array[idx];\n      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);\n      if (newLowerNode === lowerNode) {\n        return node;\n      }\n      newNode = editableVNode(node, ownerID);\n      newNode.array[idx] = newLowerNode;\n      return newNode;\n    }\n\n    if (nodeHas && node.array[idx] === value) {\n      return node;\n    }\n\n    SetRef(didAlter);\n\n    newNode = editableVNode(node, ownerID);\n    if (value === undefined && idx === newNode.array.length - 1) {\n      newNode.array.pop();\n    } else {\n      newNode.array[idx] = value;\n    }\n    return newNode;\n  }\n\n  function editableVNode(node, ownerID) {\n    if (ownerID && node && ownerID === node.ownerID) {\n      return node;\n    }\n    return new VNode(node ? node.array.slice() : [], ownerID);\n  }\n\n  function listNodeFor(list, rawIndex) {\n    if (rawIndex >= getTailOffset(list._capacity)) {\n      return list._tail;\n    }\n    if (rawIndex < 1 << list._level + SHIFT) {\n      var node = list._root;\n      var level = list._level;\n      while (node && level > 0) {\n        node = node.array[rawIndex >>> level & MASK];\n        level -= SHIFT;\n      }\n      return node;\n    }\n  }\n\n  function setListBounds(list, begin, end) {\n    // Sanitize begin & end using this shorthand for ToInt32(argument)\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n    if (begin !== undefined) {\n      begin = begin | 0;\n    }\n    if (end !== undefined) {\n      end = end | 0;\n    }\n    var owner = list.__ownerID || new OwnerID();\n    var oldOrigin = list._origin;\n    var oldCapacity = list._capacity;\n    var newOrigin = oldOrigin + begin;\n    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;\n    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {\n      return list;\n    }\n\n    // If it's going to end after it starts, it's empty.\n    if (newOrigin >= newCapacity) {\n      return list.clear();\n    }\n\n    var newLevel = list._level;\n    var newRoot = list._root;\n\n    // New origin might need creating a higher root.\n    var offsetShift = 0;\n    while (newOrigin + offsetShift < 0) {\n      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);\n      newLevel += SHIFT;\n      offsetShift += 1 << newLevel;\n    }\n    if (offsetShift) {\n      newOrigin += offsetShift;\n      oldOrigin += offsetShift;\n      newCapacity += offsetShift;\n      oldCapacity += offsetShift;\n    }\n\n    var oldTailOffset = getTailOffset(oldCapacity);\n    var newTailOffset = getTailOffset(newCapacity);\n\n    // New size might need creating a higher root.\n    while (newTailOffset >= 1 << newLevel + SHIFT) {\n      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);\n      newLevel += SHIFT;\n    }\n\n    // Locate or create the new tail.\n    var oldTail = list._tail;\n    var newTail = newTailOffset < oldTailOffset ? listNodeFor(list, newCapacity - 1) : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;\n\n    // Merge Tail into tree.\n    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {\n      newRoot = editableVNode(newRoot, owner);\n      var node = newRoot;\n      for (var level = newLevel; level > SHIFT; level -= SHIFT) {\n        var idx = oldTailOffset >>> level & MASK;\n        node = node.array[idx] = editableVNode(node.array[idx], owner);\n      }\n      node.array[oldTailOffset >>> SHIFT & MASK] = oldTail;\n    }\n\n    // If the size has been reduced, there's a chance the tail needs to be trimmed.\n    if (newCapacity < oldCapacity) {\n      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);\n    }\n\n    // If the new origin is within the tail, then we do not need a root.\n    if (newOrigin >= newTailOffset) {\n      newOrigin -= newTailOffset;\n      newCapacity -= newTailOffset;\n      newLevel = SHIFT;\n      newRoot = null;\n      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);\n\n      // Otherwise, if the root has been trimmed, garbage collect.\n    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {\n      offsetShift = 0;\n\n      // Identify the new top root node of the subtree of the old root.\n      while (newRoot) {\n        var beginIndex = newOrigin >>> newLevel & MASK;\n        if (beginIndex !== newTailOffset >>> newLevel & MASK) {\n          break;\n        }\n        if (beginIndex) {\n          offsetShift += (1 << newLevel) * beginIndex;\n        }\n        newLevel -= SHIFT;\n        newRoot = newRoot.array[beginIndex];\n      }\n\n      // Trim the new sides of the new root.\n      if (newRoot && newOrigin > oldOrigin) {\n        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);\n      }\n      if (newRoot && newTailOffset < oldTailOffset) {\n        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);\n      }\n      if (offsetShift) {\n        newOrigin -= offsetShift;\n        newCapacity -= offsetShift;\n      }\n    }\n\n    if (list.__ownerID) {\n      list.size = newCapacity - newOrigin;\n      list._origin = newOrigin;\n      list._capacity = newCapacity;\n      list._level = newLevel;\n      list._root = newRoot;\n      list._tail = newTail;\n      list.__hash = undefined;\n      list.__altered = true;\n      return list;\n    }\n    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);\n  }\n\n  function mergeIntoListWith(list, merger, iterables) {\n    var iters = [];\n    var maxSize = 0;\n    for (var ii = 0; ii < iterables.length; ii++) {\n      var value = iterables[ii];\n      var iter = IndexedIterable(value);\n      if (iter.size > maxSize) {\n        maxSize = iter.size;\n      }\n      if (!isIterable(value)) {\n        iter = iter.map(function (v) {\n          return fromJS(v);\n        });\n      }\n      iters.push(iter);\n    }\n    if (maxSize > list.size) {\n      list = list.setSize(maxSize);\n    }\n    return mergeIntoCollectionWith(list, merger, iters);\n  }\n\n  function getTailOffset(size) {\n    return size < SIZE ? 0 : size - 1 >>> SHIFT << SHIFT;\n  }\n\n  createClass(OrderedMap, Map);\n\n  // @pragma Construction\n\n  function OrderedMap(value) {\n    return value === null || value === undefined ? emptyOrderedMap() : isOrderedMap(value) ? value : emptyOrderedMap().withMutations(function (map) {\n      var iter = KeyedIterable(value);\n      assertNotInfinite(iter.size);\n      iter.forEach(function (v, k) {\n        return map.set(k, v);\n      });\n    });\n  }\n\n  OrderedMap.of = function () /*...values*/{\n    return this(arguments);\n  };\n\n  OrderedMap.prototype.toString = function () {\n    return this.__toString('OrderedMap {', '}');\n  };\n\n  // @pragma Access\n\n  OrderedMap.prototype.get = function (k, notSetValue) {\n    var index = this._map.get(k);\n    return index !== undefined ? this._list.get(index)[1] : notSetValue;\n  };\n\n  // @pragma Modification\n\n  OrderedMap.prototype.clear = function () {\n    if (this.size === 0) {\n      return this;\n    }\n    if (this.__ownerID) {\n      this.size = 0;\n      this._map.clear();\n      this._list.clear();\n      return this;\n    }\n    return emptyOrderedMap();\n  };\n\n  OrderedMap.prototype.set = function (k, v) {\n    return updateOrderedMap(this, k, v);\n  };\n\n  OrderedMap.prototype.remove = function (k) {\n    return updateOrderedMap(this, k, NOT_SET);\n  };\n\n  OrderedMap.prototype.wasAltered = function () {\n    return this._map.wasAltered() || this._list.wasAltered();\n  };\n\n  OrderedMap.prototype.__iterate = function (fn, reverse) {\n    var this$0 = this;\n    return this._list.__iterate(function (entry) {\n      return entry && fn(entry[1], entry[0], this$0);\n    }, reverse);\n  };\n\n  OrderedMap.prototype.__iterator = function (type, reverse) {\n    return this._list.fromEntrySeq().__iterator(type, reverse);\n  };\n\n  OrderedMap.prototype.__ensureOwner = function (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    var newMap = this._map.__ensureOwner(ownerID);\n    var newList = this._list.__ensureOwner(ownerID);\n    if (!ownerID) {\n      this.__ownerID = ownerID;\n      this._map = newMap;\n      this._list = newList;\n      return this;\n    }\n    return makeOrderedMap(newMap, newList, ownerID, this.__hash);\n  };\n\n  function isOrderedMap(maybeOrderedMap) {\n    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);\n  }\n\n  OrderedMap.isOrderedMap = isOrderedMap;\n\n  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;\n  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;\n\n  function makeOrderedMap(map, list, ownerID, hash) {\n    var omap = Object.create(OrderedMap.prototype);\n    omap.size = map ? map.size : 0;\n    omap._map = map;\n    omap._list = list;\n    omap.__ownerID = ownerID;\n    omap.__hash = hash;\n    return omap;\n  }\n\n  var EMPTY_ORDERED_MAP;\n  function emptyOrderedMap() {\n    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));\n  }\n\n  function updateOrderedMap(omap, k, v) {\n    var map = omap._map;\n    var list = omap._list;\n    var i = map.get(k);\n    var has = i !== undefined;\n    var newMap;\n    var newList;\n    if (v === NOT_SET) {\n      // removed\n      if (!has) {\n        return omap;\n      }\n      if (list.size >= SIZE && list.size >= map.size * 2) {\n        newList = list.filter(function (entry, idx) {\n          return entry !== undefined && i !== idx;\n        });\n        newMap = newList.toKeyedSeq().map(function (entry) {\n          return entry[0];\n        }).flip().toMap();\n        if (omap.__ownerID) {\n          newMap.__ownerID = newList.__ownerID = omap.__ownerID;\n        }\n      } else {\n        newMap = map.remove(k);\n        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);\n      }\n    } else {\n      if (has) {\n        if (v === list.get(i)[1]) {\n          return omap;\n        }\n        newMap = map;\n        newList = list.set(i, [k, v]);\n      } else {\n        newMap = map.set(k, list.size);\n        newList = list.set(list.size, [k, v]);\n      }\n    }\n    if (omap.__ownerID) {\n      omap.size = newMap.size;\n      omap._map = newMap;\n      omap._list = newList;\n      omap.__hash = undefined;\n      return omap;\n    }\n    return makeOrderedMap(newMap, newList);\n  }\n\n  createClass(ToKeyedSequence, KeyedSeq);\n  function ToKeyedSequence(indexed, useKeys) {\n    this._iter = indexed;\n    this._useKeys = useKeys;\n    this.size = indexed.size;\n  }\n\n  ToKeyedSequence.prototype.get = function (key, notSetValue) {\n    return this._iter.get(key, notSetValue);\n  };\n\n  ToKeyedSequence.prototype.has = function (key) {\n    return this._iter.has(key);\n  };\n\n  ToKeyedSequence.prototype.valueSeq = function () {\n    return this._iter.valueSeq();\n  };\n\n  ToKeyedSequence.prototype.reverse = function () {\n    var this$0 = this;\n    var reversedSequence = reverseFactory(this, true);\n    if (!this._useKeys) {\n      reversedSequence.valueSeq = function () {\n        return this$0._iter.toSeq().reverse();\n      };\n    }\n    return reversedSequence;\n  };\n\n  ToKeyedSequence.prototype.map = function (mapper, context) {\n    var this$0 = this;\n    var mappedSequence = mapFactory(this, mapper, context);\n    if (!this._useKeys) {\n      mappedSequence.valueSeq = function () {\n        return this$0._iter.toSeq().map(mapper, context);\n      };\n    }\n    return mappedSequence;\n  };\n\n  ToKeyedSequence.prototype.__iterate = function (fn, reverse) {\n    var this$0 = this;\n    var ii;\n    return this._iter.__iterate(this._useKeys ? function (v, k) {\n      return fn(v, k, this$0);\n    } : (ii = reverse ? resolveSize(this) : 0, function (v) {\n      return fn(v, reverse ? --ii : ii++, this$0);\n    }), reverse);\n  };\n\n  ToKeyedSequence.prototype.__iterator = function (type, reverse) {\n    if (this._useKeys) {\n      return this._iter.__iterator(type, reverse);\n    }\n    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n    var ii = reverse ? resolveSize(this) : 0;\n    return new Iterator(function () {\n      var step = iterator.next();\n      return step.done ? step : iteratorValue(type, reverse ? --ii : ii++, step.value, step);\n    });\n  };\n\n  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;\n\n  createClass(ToIndexedSequence, IndexedSeq);\n  function ToIndexedSequence(iter) {\n    this._iter = iter;\n    this.size = iter.size;\n  }\n\n  ToIndexedSequence.prototype.includes = function (value) {\n    return this._iter.includes(value);\n  };\n\n  ToIndexedSequence.prototype.__iterate = function (fn, reverse) {\n    var this$0 = this;\n    var iterations = 0;\n    return this._iter.__iterate(function (v) {\n      return fn(v, iterations++, this$0);\n    }, reverse);\n  };\n\n  ToIndexedSequence.prototype.__iterator = function (type, reverse) {\n    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n    var iterations = 0;\n    return new Iterator(function () {\n      var step = iterator.next();\n      return step.done ? step : iteratorValue(type, iterations++, step.value, step);\n    });\n  };\n\n  createClass(ToSetSequence, SetSeq);\n  function ToSetSequence(iter) {\n    this._iter = iter;\n    this.size = iter.size;\n  }\n\n  ToSetSequence.prototype.has = function (key) {\n    return this._iter.includes(key);\n  };\n\n  ToSetSequence.prototype.__iterate = function (fn, reverse) {\n    var this$0 = this;\n    return this._iter.__iterate(function (v) {\n      return fn(v, v, this$0);\n    }, reverse);\n  };\n\n  ToSetSequence.prototype.__iterator = function (type, reverse) {\n    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n    return new Iterator(function () {\n      var step = iterator.next();\n      return step.done ? step : iteratorValue(type, step.value, step.value, step);\n    });\n  };\n\n  createClass(FromEntriesSequence, KeyedSeq);\n  function FromEntriesSequence(entries) {\n    this._iter = entries;\n    this.size = entries.size;\n  }\n\n  FromEntriesSequence.prototype.entrySeq = function () {\n    return this._iter.toSeq();\n  };\n\n  FromEntriesSequence.prototype.__iterate = function (fn, reverse) {\n    var this$0 = this;\n    return this._iter.__iterate(function (entry) {\n      // Check if entry exists first so array access doesn't throw for holes\n      // in the parent iteration.\n      if (entry) {\n        validateEntry(entry);\n        var indexedIterable = isIterable(entry);\n        return fn(indexedIterable ? entry.get(1) : entry[1], indexedIterable ? entry.get(0) : entry[0], this$0);\n      }\n    }, reverse);\n  };\n\n  FromEntriesSequence.prototype.__iterator = function (type, reverse) {\n    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n    return new Iterator(function () {\n      while (true) {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        // Check if entry exists first so array access doesn't throw for holes\n        // in the parent iteration.\n        if (entry) {\n          validateEntry(entry);\n          var indexedIterable = isIterable(entry);\n          return iteratorValue(type, indexedIterable ? entry.get(0) : entry[0], indexedIterable ? entry.get(1) : entry[1], step);\n        }\n      }\n    });\n  };\n\n  ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;\n\n  function flipFactory(iterable) {\n    var flipSequence = makeSequence(iterable);\n    flipSequence._iter = iterable;\n    flipSequence.size = iterable.size;\n    flipSequence.flip = function () {\n      return iterable;\n    };\n    flipSequence.reverse = function () {\n      var reversedSequence = iterable.reverse.apply(this); // super.reverse()\n      reversedSequence.flip = function () {\n        return iterable.reverse();\n      };\n      return reversedSequence;\n    };\n    flipSequence.has = function (key) {\n      return iterable.includes(key);\n    };\n    flipSequence.includes = function (key) {\n      return iterable.has(key);\n    };\n    flipSequence.cacheResult = cacheResultThrough;\n    flipSequence.__iterateUncached = function (fn, reverse) {\n      var this$0 = this;\n      return iterable.__iterate(function (v, k) {\n        return fn(k, v, this$0) !== false;\n      }, reverse);\n    };\n    flipSequence.__iteratorUncached = function (type, reverse) {\n      if (type === ITERATE_ENTRIES) {\n        var iterator = iterable.__iterator(type, reverse);\n        return new Iterator(function () {\n          var step = iterator.next();\n          if (!step.done) {\n            var k = step.value[0];\n            step.value[0] = step.value[1];\n            step.value[1] = k;\n          }\n          return step;\n        });\n      }\n      return iterable.__iterator(type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES, reverse);\n    };\n    return flipSequence;\n  }\n\n  function mapFactory(iterable, mapper, context) {\n    var mappedSequence = makeSequence(iterable);\n    mappedSequence.size = iterable.size;\n    mappedSequence.has = function (key) {\n      return iterable.has(key);\n    };\n    mappedSequence.get = function (key, notSetValue) {\n      var v = iterable.get(key, NOT_SET);\n      return v === NOT_SET ? notSetValue : mapper.call(context, v, key, iterable);\n    };\n    mappedSequence.__iterateUncached = function (fn, reverse) {\n      var this$0 = this;\n      return iterable.__iterate(function (v, k, c) {\n        return fn(mapper.call(context, v, k, c), k, this$0) !== false;\n      }, reverse);\n    };\n    mappedSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      return new Iterator(function () {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var key = entry[0];\n        return iteratorValue(type, key, mapper.call(context, entry[1], key, iterable), step);\n      });\n    };\n    return mappedSequence;\n  }\n\n  function reverseFactory(iterable, useKeys) {\n    var reversedSequence = makeSequence(iterable);\n    reversedSequence._iter = iterable;\n    reversedSequence.size = iterable.size;\n    reversedSequence.reverse = function () {\n      return iterable;\n    };\n    if (iterable.flip) {\n      reversedSequence.flip = function () {\n        var flipSequence = flipFactory(iterable);\n        flipSequence.reverse = function () {\n          return iterable.flip();\n        };\n        return flipSequence;\n      };\n    }\n    reversedSequence.get = function (key, notSetValue) {\n      return iterable.get(useKeys ? key : -1 - key, notSetValue);\n    };\n    reversedSequence.has = function (key) {\n      return iterable.has(useKeys ? key : -1 - key);\n    };\n    reversedSequence.includes = function (value) {\n      return iterable.includes(value);\n    };\n    reversedSequence.cacheResult = cacheResultThrough;\n    reversedSequence.__iterate = function (fn, reverse) {\n      var this$0 = this;\n      return iterable.__iterate(function (v, k) {\n        return fn(v, k, this$0);\n      }, !reverse);\n    };\n    reversedSequence.__iterator = function (type, reverse) {\n      return iterable.__iterator(type, !reverse);\n    };\n    return reversedSequence;\n  }\n\n  function filterFactory(iterable, predicate, context, useKeys) {\n    var filterSequence = makeSequence(iterable);\n    if (useKeys) {\n      filterSequence.has = function (key) {\n        var v = iterable.get(key, NOT_SET);\n        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);\n      };\n      filterSequence.get = function (key, notSetValue) {\n        var v = iterable.get(key, NOT_SET);\n        return v !== NOT_SET && predicate.call(context, v, key, iterable) ? v : notSetValue;\n      };\n    }\n    filterSequence.__iterateUncached = function (fn, reverse) {\n      var this$0 = this;\n      var iterations = 0;\n      iterable.__iterate(function (v, k, c) {\n        if (predicate.call(context, v, k, c)) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$0);\n        }\n      }, reverse);\n      return iterations;\n    };\n    filterSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      var iterations = 0;\n      return new Iterator(function () {\n        while (true) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          var entry = step.value;\n          var key = entry[0];\n          var value = entry[1];\n          if (predicate.call(context, value, key, iterable)) {\n            return iteratorValue(type, useKeys ? key : iterations++, value, step);\n          }\n        }\n      });\n    };\n    return filterSequence;\n  }\n\n  function countByFactory(iterable, grouper, context) {\n    var groups = Map().asMutable();\n    iterable.__iterate(function (v, k) {\n      groups.update(grouper.call(context, v, k, iterable), 0, function (a) {\n        return a + 1;\n      });\n    });\n    return groups.asImmutable();\n  }\n\n  function groupByFactory(iterable, grouper, context) {\n    var isKeyedIter = isKeyed(iterable);\n    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();\n    iterable.__iterate(function (v, k) {\n      groups.update(grouper.call(context, v, k, iterable), function (a) {\n        return a = a || [], a.push(isKeyedIter ? [k, v] : v), a;\n      });\n    });\n    var coerce = iterableClass(iterable);\n    return groups.map(function (arr) {\n      return reify(iterable, coerce(arr));\n    });\n  }\n\n  function sliceFactory(iterable, begin, end, useKeys) {\n    var originalSize = iterable.size;\n\n    // Sanitize begin & end using this shorthand for ToInt32(argument)\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n    if (begin !== undefined) {\n      begin = begin | 0;\n    }\n    if (end !== undefined) {\n      if (end === Infinity) {\n        end = originalSize;\n      } else {\n        end = end | 0;\n      }\n    }\n\n    if (wholeSlice(begin, end, originalSize)) {\n      return iterable;\n    }\n\n    var resolvedBegin = resolveBegin(begin, originalSize);\n    var resolvedEnd = resolveEnd(end, originalSize);\n\n    // begin or end will be NaN if they were provided as negative numbers and\n    // this iterable's size is unknown. In that case, cache first so there is\n    // a known size and these do not resolve to NaN.\n    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {\n      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);\n    }\n\n    // Note: resolvedEnd is undefined when the original sequence's length is\n    // unknown and this slice did not supply an end and should contain all\n    // elements after resolvedBegin.\n    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.\n    var resolvedSize = resolvedEnd - resolvedBegin;\n    var sliceSize;\n    if (resolvedSize === resolvedSize) {\n      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;\n    }\n\n    var sliceSeq = makeSequence(iterable);\n\n    // If iterable.size is undefined, the size of the realized sliceSeq is\n    // unknown at this point unless the number of items to slice is 0\n    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;\n\n    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {\n      sliceSeq.get = function (index, notSetValue) {\n        index = wrapIndex(this, index);\n        return index >= 0 && index < sliceSize ? iterable.get(index + resolvedBegin, notSetValue) : notSetValue;\n      };\n    }\n\n    sliceSeq.__iterateUncached = function (fn, reverse) {\n      var this$0 = this;\n      if (sliceSize === 0) {\n        return 0;\n      }\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var skipped = 0;\n      var isSkipping = true;\n      var iterations = 0;\n      iterable.__iterate(function (v, k) {\n        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$0) !== false && iterations !== sliceSize;\n        }\n      });\n      return iterations;\n    };\n\n    sliceSeq.__iteratorUncached = function (type, reverse) {\n      if (sliceSize !== 0 && reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      // Don't bother instantiating parent iterator if taking 0.\n      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);\n      var skipped = 0;\n      var iterations = 0;\n      return new Iterator(function () {\n        while (skipped++ < resolvedBegin) {\n          iterator.next();\n        }\n        if (++iterations > sliceSize) {\n          return iteratorDone();\n        }\n        var step = iterator.next();\n        if (useKeys || type === ITERATE_VALUES) {\n          return step;\n        } else if (type === ITERATE_KEYS) {\n          return iteratorValue(type, iterations - 1, undefined, step);\n        } else {\n          return iteratorValue(type, iterations - 1, step.value[1], step);\n        }\n      });\n    };\n\n    return sliceSeq;\n  }\n\n  function takeWhileFactory(iterable, predicate, context) {\n    var takeSequence = makeSequence(iterable);\n    takeSequence.__iterateUncached = function (fn, reverse) {\n      var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterations = 0;\n      iterable.__iterate(function (v, k, c) {\n        return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0);\n      });\n      return iterations;\n    };\n    takeSequence.__iteratorUncached = function (type, reverse) {\n      var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      var iterating = true;\n      return new Iterator(function () {\n        if (!iterating) {\n          return iteratorDone();\n        }\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var k = entry[0];\n        var v = entry[1];\n        if (!predicate.call(context, v, k, this$0)) {\n          iterating = false;\n          return iteratorDone();\n        }\n        return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);\n      });\n    };\n    return takeSequence;\n  }\n\n  function skipWhileFactory(iterable, predicate, context, useKeys) {\n    var skipSequence = makeSequence(iterable);\n    skipSequence.__iterateUncached = function (fn, reverse) {\n      var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var isSkipping = true;\n      var iterations = 0;\n      iterable.__iterate(function (v, k, c) {\n        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$0);\n        }\n      });\n      return iterations;\n    };\n    skipSequence.__iteratorUncached = function (type, reverse) {\n      var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      var skipping = true;\n      var iterations = 0;\n      return new Iterator(function () {\n        var step, k, v;\n        do {\n          step = iterator.next();\n          if (step.done) {\n            if (useKeys || type === ITERATE_VALUES) {\n              return step;\n            } else if (type === ITERATE_KEYS) {\n              return iteratorValue(type, iterations++, undefined, step);\n            } else {\n              return iteratorValue(type, iterations++, step.value[1], step);\n            }\n          }\n          var entry = step.value;\n          k = entry[0];\n          v = entry[1];\n          skipping && (skipping = predicate.call(context, v, k, this$0));\n        } while (skipping);\n        return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);\n      });\n    };\n    return skipSequence;\n  }\n\n  function concatFactory(iterable, values) {\n    var isKeyedIterable = isKeyed(iterable);\n    var iters = [iterable].concat(values).map(function (v) {\n      if (!isIterable(v)) {\n        v = isKeyedIterable ? keyedSeqFromValue(v) : indexedSeqFromValue(Array.isArray(v) ? v : [v]);\n      } else if (isKeyedIterable) {\n        v = KeyedIterable(v);\n      }\n      return v;\n    }).filter(function (v) {\n      return v.size !== 0;\n    });\n\n    if (iters.length === 0) {\n      return iterable;\n    }\n\n    if (iters.length === 1) {\n      var singleton = iters[0];\n      if (singleton === iterable || isKeyedIterable && isKeyed(singleton) || isIndexed(iterable) && isIndexed(singleton)) {\n        return singleton;\n      }\n    }\n\n    var concatSeq = new ArraySeq(iters);\n    if (isKeyedIterable) {\n      concatSeq = concatSeq.toKeyedSeq();\n    } else if (!isIndexed(iterable)) {\n      concatSeq = concatSeq.toSetSeq();\n    }\n    concatSeq = concatSeq.flatten(true);\n    concatSeq.size = iters.reduce(function (sum, seq) {\n      if (sum !== undefined) {\n        var size = seq.size;\n        if (size !== undefined) {\n          return sum + size;\n        }\n      }\n    }, 0);\n    return concatSeq;\n  }\n\n  function flattenFactory(iterable, depth, useKeys) {\n    var flatSequence = makeSequence(iterable);\n    flatSequence.__iterateUncached = function (fn, reverse) {\n      var iterations = 0;\n      var stopped = false;\n      function flatDeep(iter, currentDepth) {\n        var this$0 = this;\n        iter.__iterate(function (v, k) {\n          if ((!depth || currentDepth < depth) && isIterable(v)) {\n            flatDeep(v, currentDepth + 1);\n          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {\n            stopped = true;\n          }\n          return !stopped;\n        }, reverse);\n      }\n      flatDeep(iterable, 0);\n      return iterations;\n    };\n    flatSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = iterable.__iterator(type, reverse);\n      var stack = [];\n      var iterations = 0;\n      return new Iterator(function () {\n        while (iterator) {\n          var step = iterator.next();\n          if (step.done !== false) {\n            iterator = stack.pop();\n            continue;\n          }\n          var v = step.value;\n          if (type === ITERATE_ENTRIES) {\n            v = v[1];\n          }\n          if ((!depth || stack.length < depth) && isIterable(v)) {\n            stack.push(iterator);\n            iterator = v.__iterator(type, reverse);\n          } else {\n            return useKeys ? step : iteratorValue(type, iterations++, v, step);\n          }\n        }\n        return iteratorDone();\n      });\n    };\n    return flatSequence;\n  }\n\n  function flatMapFactory(iterable, mapper, context) {\n    var coerce = iterableClass(iterable);\n    return iterable.toSeq().map(function (v, k) {\n      return coerce(mapper.call(context, v, k, iterable));\n    }).flatten(true);\n  }\n\n  function interposeFactory(iterable, separator) {\n    var interposedSequence = makeSequence(iterable);\n    interposedSequence.size = iterable.size && iterable.size * 2 - 1;\n    interposedSequence.__iterateUncached = function (fn, reverse) {\n      var this$0 = this;\n      var iterations = 0;\n      iterable.__iterate(function (v, k) {\n        return (!iterations || fn(separator, iterations++, this$0) !== false) && fn(v, iterations++, this$0) !== false;\n      }, reverse);\n      return iterations;\n    };\n    interposedSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);\n      var iterations = 0;\n      var step;\n      return new Iterator(function () {\n        if (!step || iterations % 2) {\n          step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n        }\n        return iterations % 2 ? iteratorValue(type, iterations++, separator) : iteratorValue(type, iterations++, step.value, step);\n      });\n    };\n    return interposedSequence;\n  }\n\n  function sortFactory(iterable, comparator, mapper) {\n    if (!comparator) {\n      comparator = defaultComparator;\n    }\n    var isKeyedIterable = isKeyed(iterable);\n    var index = 0;\n    var entries = iterable.toSeq().map(function (v, k) {\n      return [k, v, index++, mapper ? mapper(v, k, iterable) : v];\n    }).toArray();\n    entries.sort(function (a, b) {\n      return comparator(a[3], b[3]) || a[2] - b[2];\n    }).forEach(isKeyedIterable ? function (v, i) {\n      entries[i].length = 2;\n    } : function (v, i) {\n      entries[i] = v[1];\n    });\n    return isKeyedIterable ? KeyedSeq(entries) : isIndexed(iterable) ? IndexedSeq(entries) : SetSeq(entries);\n  }\n\n  function maxFactory(iterable, comparator, mapper) {\n    if (!comparator) {\n      comparator = defaultComparator;\n    }\n    if (mapper) {\n      var entry = iterable.toSeq().map(function (v, k) {\n        return [v, mapper(v, k, iterable)];\n      }).reduce(function (a, b) {\n        return maxCompare(comparator, a[1], b[1]) ? b : a;\n      });\n      return entry && entry[0];\n    } else {\n      return iterable.reduce(function (a, b) {\n        return maxCompare(comparator, a, b) ? b : a;\n      });\n    }\n  }\n\n  function maxCompare(comparator, a, b) {\n    var comp = comparator(b, a);\n    // b is considered the new max if the comparator declares them equal, but\n    // they are not equal and b is in fact a nullish value.\n    return comp === 0 && b !== a && (b === undefined || b === null || b !== b) || comp > 0;\n  }\n\n  function zipWithFactory(keyIter, zipper, iters) {\n    var zipSequence = makeSequence(keyIter);\n    zipSequence.size = new ArraySeq(iters).map(function (i) {\n      return i.size;\n    }).min();\n    // Note: this a generic base implementation of __iterate in terms of\n    // __iterator which may be more generically useful in the future.\n    zipSequence.__iterate = function (fn, reverse) {\n      /* generic:\n      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);\n      var step;\n      var iterations = 0;\n      while (!(step = iterator.next()).done) {\n        iterations++;\n        if (fn(step.value[1], step.value[0], this) === false) {\n          break;\n        }\n      }\n      return iterations;\n      */\n      // indexed:\n      var iterator = this.__iterator(ITERATE_VALUES, reverse);\n      var step;\n      var iterations = 0;\n      while (!(step = iterator.next()).done) {\n        if (fn(step.value, iterations++, this) === false) {\n          break;\n        }\n      }\n      return iterations;\n    };\n    zipSequence.__iteratorUncached = function (type, reverse) {\n      var iterators = iters.map(function (i) {\n        return i = Iterable(i), getIterator(reverse ? i.reverse() : i);\n      });\n      var iterations = 0;\n      var isDone = false;\n      return new Iterator(function () {\n        var steps;\n        if (!isDone) {\n          steps = iterators.map(function (i) {\n            return i.next();\n          });\n          isDone = steps.some(function (s) {\n            return s.done;\n          });\n        }\n        if (isDone) {\n          return iteratorDone();\n        }\n        return iteratorValue(type, iterations++, zipper.apply(null, steps.map(function (s) {\n          return s.value;\n        })));\n      });\n    };\n    return zipSequence;\n  }\n\n  // #pragma Helper Functions\n\n  function reify(iter, seq) {\n    return isSeq(iter) ? seq : iter.constructor(seq);\n  }\n\n  function validateEntry(entry) {\n    if (entry !== Object(entry)) {\n      throw new TypeError('Expected [K, V] tuple: ' + entry);\n    }\n  }\n\n  function resolveSize(iter) {\n    assertNotInfinite(iter.size);\n    return ensureSize(iter);\n  }\n\n  function iterableClass(iterable) {\n    return isKeyed(iterable) ? KeyedIterable : isIndexed(iterable) ? IndexedIterable : SetIterable;\n  }\n\n  function makeSequence(iterable) {\n    return Object.create((isKeyed(iterable) ? KeyedSeq : isIndexed(iterable) ? IndexedSeq : SetSeq).prototype);\n  }\n\n  function cacheResultThrough() {\n    if (this._iter.cacheResult) {\n      this._iter.cacheResult();\n      this.size = this._iter.size;\n      return this;\n    } else {\n      return Seq.prototype.cacheResult.call(this);\n    }\n  }\n\n  function defaultComparator(a, b) {\n    return a > b ? 1 : a < b ? -1 : 0;\n  }\n\n  function forceIterator(keyPath) {\n    var iter = getIterator(keyPath);\n    if (!iter) {\n      // Array might not be iterable in this environment, so we need a fallback\n      // to our wrapped type.\n      if (!isArrayLike(keyPath)) {\n        throw new TypeError('Expected iterable or array-like: ' + keyPath);\n      }\n      iter = getIterator(Iterable(keyPath));\n    }\n    return iter;\n  }\n\n  createClass(Record, KeyedCollection);\n\n  function Record(defaultValues, name) {\n    var hasInitialized;\n\n    var RecordType = function Record(values) {\n      if (values instanceof RecordType) {\n        return values;\n      }\n      if (!(this instanceof RecordType)) {\n        return new RecordType(values);\n      }\n      if (!hasInitialized) {\n        hasInitialized = true;\n        var keys = Object.keys(defaultValues);\n        setProps(RecordTypePrototype, keys);\n        RecordTypePrototype.size = keys.length;\n        RecordTypePrototype._name = name;\n        RecordTypePrototype._keys = keys;\n        RecordTypePrototype._defaultValues = defaultValues;\n      }\n      this._map = Map(values);\n    };\n\n    var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);\n    RecordTypePrototype.constructor = RecordType;\n\n    return RecordType;\n  }\n\n  Record.prototype.toString = function () {\n    return this.__toString(recordName(this) + ' {', '}');\n  };\n\n  // @pragma Access\n\n  Record.prototype.has = function (k) {\n    return this._defaultValues.hasOwnProperty(k);\n  };\n\n  Record.prototype.get = function (k, notSetValue) {\n    if (!this.has(k)) {\n      return notSetValue;\n    }\n    var defaultVal = this._defaultValues[k];\n    return this._map ? this._map.get(k, defaultVal) : defaultVal;\n  };\n\n  // @pragma Modification\n\n  Record.prototype.clear = function () {\n    if (this.__ownerID) {\n      this._map && this._map.clear();\n      return this;\n    }\n    var RecordType = this.constructor;\n    return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));\n  };\n\n  Record.prototype.set = function (k, v) {\n    if (!this.has(k)) {\n      throw new Error('Cannot set unknown key \"' + k + '\" on ' + recordName(this));\n    }\n    if (this._map && !this._map.has(k)) {\n      var defaultVal = this._defaultValues[k];\n      if (v === defaultVal) {\n        return this;\n      }\n    }\n    var newMap = this._map && this._map.set(k, v);\n    if (this.__ownerID || newMap === this._map) {\n      return this;\n    }\n    return makeRecord(this, newMap);\n  };\n\n  Record.prototype.remove = function (k) {\n    if (!this.has(k)) {\n      return this;\n    }\n    var newMap = this._map && this._map.remove(k);\n    if (this.__ownerID || newMap === this._map) {\n      return this;\n    }\n    return makeRecord(this, newMap);\n  };\n\n  Record.prototype.wasAltered = function () {\n    return this._map.wasAltered();\n  };\n\n  Record.prototype.__iterator = function (type, reverse) {\n    var this$0 = this;\n    return KeyedIterable(this._defaultValues).map(function (_, k) {\n      return this$0.get(k);\n    }).__iterator(type, reverse);\n  };\n\n  Record.prototype.__iterate = function (fn, reverse) {\n    var this$0 = this;\n    return KeyedIterable(this._defaultValues).map(function (_, k) {\n      return this$0.get(k);\n    }).__iterate(fn, reverse);\n  };\n\n  Record.prototype.__ensureOwner = function (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    var newMap = this._map && this._map.__ensureOwner(ownerID);\n    if (!ownerID) {\n      this.__ownerID = ownerID;\n      this._map = newMap;\n      return this;\n    }\n    return makeRecord(this, newMap, ownerID);\n  };\n\n  var RecordPrototype = Record.prototype;\n  RecordPrototype[DELETE] = RecordPrototype.remove;\n  RecordPrototype.deleteIn = RecordPrototype.removeIn = MapPrototype.removeIn;\n  RecordPrototype.merge = MapPrototype.merge;\n  RecordPrototype.mergeWith = MapPrototype.mergeWith;\n  RecordPrototype.mergeIn = MapPrototype.mergeIn;\n  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;\n  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;\n  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n  RecordPrototype.setIn = MapPrototype.setIn;\n  RecordPrototype.update = MapPrototype.update;\n  RecordPrototype.updateIn = MapPrototype.updateIn;\n  RecordPrototype.withMutations = MapPrototype.withMutations;\n  RecordPrototype.asMutable = MapPrototype.asMutable;\n  RecordPrototype.asImmutable = MapPrototype.asImmutable;\n\n  function makeRecord(likeRecord, map, ownerID) {\n    var record = Object.create(Object.getPrototypeOf(likeRecord));\n    record._map = map;\n    record.__ownerID = ownerID;\n    return record;\n  }\n\n  function recordName(record) {\n    return record._name || record.constructor.name || 'Record';\n  }\n\n  function setProps(prototype, names) {\n    try {\n      names.forEach(setProp.bind(undefined, prototype));\n    } catch (error) {\n      // Object.defineProperty failed. Probably IE8.\n    }\n  }\n\n  function setProp(prototype, name) {\n    Object.defineProperty(prototype, name, {\n      get: function get() {\n        return this.get(name);\n      },\n      set: function set(value) {\n        invariant(this.__ownerID, 'Cannot set on an immutable record.');\n        this.set(name, value);\n      }\n    });\n  }\n\n  createClass(Set, SetCollection);\n\n  // @pragma Construction\n\n  function Set(value) {\n    return value === null || value === undefined ? emptySet() : isSet(value) && !isOrdered(value) ? value : emptySet().withMutations(function (set) {\n      var iter = SetIterable(value);\n      assertNotInfinite(iter.size);\n      iter.forEach(function (v) {\n        return set.add(v);\n      });\n    });\n  }\n\n  Set.of = function () /*...values*/{\n    return this(arguments);\n  };\n\n  Set.fromKeys = function (value) {\n    return this(KeyedIterable(value).keySeq());\n  };\n\n  Set.prototype.toString = function () {\n    return this.__toString('Set {', '}');\n  };\n\n  // @pragma Access\n\n  Set.prototype.has = function (value) {\n    return this._map.has(value);\n  };\n\n  // @pragma Modification\n\n  Set.prototype.add = function (value) {\n    return updateSet(this, this._map.set(value, true));\n  };\n\n  Set.prototype.remove = function (value) {\n    return updateSet(this, this._map.remove(value));\n  };\n\n  Set.prototype.clear = function () {\n    return updateSet(this, this._map.clear());\n  };\n\n  // @pragma Composition\n\n  Set.prototype.union = function () {\n    var iters = SLICE$0.call(arguments, 0);\n    iters = iters.filter(function (x) {\n      return x.size !== 0;\n    });\n    if (iters.length === 0) {\n      return this;\n    }\n    if (this.size === 0 && !this.__ownerID && iters.length === 1) {\n      return this.constructor(iters[0]);\n    }\n    return this.withMutations(function (set) {\n      for (var ii = 0; ii < iters.length; ii++) {\n        SetIterable(iters[ii]).forEach(function (value) {\n          return set.add(value);\n        });\n      }\n    });\n  };\n\n  Set.prototype.intersect = function () {\n    var iters = SLICE$0.call(arguments, 0);\n    if (iters.length === 0) {\n      return this;\n    }\n    iters = iters.map(function (iter) {\n      return SetIterable(iter);\n    });\n    var originalSet = this;\n    return this.withMutations(function (set) {\n      originalSet.forEach(function (value) {\n        if (!iters.every(function (iter) {\n          return iter.includes(value);\n        })) {\n          set.remove(value);\n        }\n      });\n    });\n  };\n\n  Set.prototype.subtract = function () {\n    var iters = SLICE$0.call(arguments, 0);\n    if (iters.length === 0) {\n      return this;\n    }\n    iters = iters.map(function (iter) {\n      return SetIterable(iter);\n    });\n    var originalSet = this;\n    return this.withMutations(function (set) {\n      originalSet.forEach(function (value) {\n        if (iters.some(function (iter) {\n          return iter.includes(value);\n        })) {\n          set.remove(value);\n        }\n      });\n    });\n  };\n\n  Set.prototype.merge = function () {\n    return this.union.apply(this, arguments);\n  };\n\n  Set.prototype.mergeWith = function (merger) {\n    var iters = SLICE$0.call(arguments, 1);\n    return this.union.apply(this, iters);\n  };\n\n  Set.prototype.sort = function (comparator) {\n    // Late binding\n    return OrderedSet(sortFactory(this, comparator));\n  };\n\n  Set.prototype.sortBy = function (mapper, comparator) {\n    // Late binding\n    return OrderedSet(sortFactory(this, comparator, mapper));\n  };\n\n  Set.prototype.wasAltered = function () {\n    return this._map.wasAltered();\n  };\n\n  Set.prototype.__iterate = function (fn, reverse) {\n    var this$0 = this;\n    return this._map.__iterate(function (_, k) {\n      return fn(k, k, this$0);\n    }, reverse);\n  };\n\n  Set.prototype.__iterator = function (type, reverse) {\n    return this._map.map(function (_, k) {\n      return k;\n    }).__iterator(type, reverse);\n  };\n\n  Set.prototype.__ensureOwner = function (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    var newMap = this._map.__ensureOwner(ownerID);\n    if (!ownerID) {\n      this.__ownerID = ownerID;\n      this._map = newMap;\n      return this;\n    }\n    return this.__make(newMap, ownerID);\n  };\n\n  function isSet(maybeSet) {\n    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);\n  }\n\n  Set.isSet = isSet;\n\n  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';\n\n  var SetPrototype = Set.prototype;\n  SetPrototype[IS_SET_SENTINEL] = true;\n  SetPrototype[DELETE] = SetPrototype.remove;\n  SetPrototype.mergeDeep = SetPrototype.merge;\n  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;\n  SetPrototype.withMutations = MapPrototype.withMutations;\n  SetPrototype.asMutable = MapPrototype.asMutable;\n  SetPrototype.asImmutable = MapPrototype.asImmutable;\n\n  SetPrototype.__empty = emptySet;\n  SetPrototype.__make = makeSet;\n\n  function updateSet(set, newMap) {\n    if (set.__ownerID) {\n      set.size = newMap.size;\n      set._map = newMap;\n      return set;\n    }\n    return newMap === set._map ? set : newMap.size === 0 ? set.__empty() : set.__make(newMap);\n  }\n\n  function makeSet(map, ownerID) {\n    var set = Object.create(SetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n  }\n\n  var EMPTY_SET;\n  function emptySet() {\n    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));\n  }\n\n  createClass(OrderedSet, Set);\n\n  // @pragma Construction\n\n  function OrderedSet(value) {\n    return value === null || value === undefined ? emptyOrderedSet() : isOrderedSet(value) ? value : emptyOrderedSet().withMutations(function (set) {\n      var iter = SetIterable(value);\n      assertNotInfinite(iter.size);\n      iter.forEach(function (v) {\n        return set.add(v);\n      });\n    });\n  }\n\n  OrderedSet.of = function () /*...values*/{\n    return this(arguments);\n  };\n\n  OrderedSet.fromKeys = function (value) {\n    return this(KeyedIterable(value).keySeq());\n  };\n\n  OrderedSet.prototype.toString = function () {\n    return this.__toString('OrderedSet {', '}');\n  };\n\n  function isOrderedSet(maybeOrderedSet) {\n    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);\n  }\n\n  OrderedSet.isOrderedSet = isOrderedSet;\n\n  var OrderedSetPrototype = OrderedSet.prototype;\n  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;\n\n  OrderedSetPrototype.__empty = emptyOrderedSet;\n  OrderedSetPrototype.__make = makeOrderedSet;\n\n  function makeOrderedSet(map, ownerID) {\n    var set = Object.create(OrderedSetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n  }\n\n  var EMPTY_ORDERED_SET;\n  function emptyOrderedSet() {\n    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));\n  }\n\n  createClass(Stack, IndexedCollection);\n\n  // @pragma Construction\n\n  function Stack(value) {\n    return value === null || value === undefined ? emptyStack() : isStack(value) ? value : emptyStack().unshiftAll(value);\n  }\n\n  Stack.of = function () /*...values*/{\n    return this(arguments);\n  };\n\n  Stack.prototype.toString = function () {\n    return this.__toString('Stack [', ']');\n  };\n\n  // @pragma Access\n\n  Stack.prototype.get = function (index, notSetValue) {\n    var head = this._head;\n    index = wrapIndex(this, index);\n    while (head && index--) {\n      head = head.next;\n    }\n    return head ? head.value : notSetValue;\n  };\n\n  Stack.prototype.peek = function () {\n    return this._head && this._head.value;\n  };\n\n  // @pragma Modification\n\n  Stack.prototype.push = function () /*...values*/{\n    if (arguments.length === 0) {\n      return this;\n    }\n    var newSize = this.size + arguments.length;\n    var head = this._head;\n    for (var ii = arguments.length - 1; ii >= 0; ii--) {\n      head = {\n        value: arguments[ii],\n        next: head\n      };\n    }\n    if (this.__ownerID) {\n      this.size = newSize;\n      this._head = head;\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return makeStack(newSize, head);\n  };\n\n  Stack.prototype.pushAll = function (iter) {\n    iter = IndexedIterable(iter);\n    if (iter.size === 0) {\n      return this;\n    }\n    assertNotInfinite(iter.size);\n    var newSize = this.size;\n    var head = this._head;\n    iter.reverse().forEach(function (value) {\n      newSize++;\n      head = {\n        value: value,\n        next: head\n      };\n    });\n    if (this.__ownerID) {\n      this.size = newSize;\n      this._head = head;\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return makeStack(newSize, head);\n  };\n\n  Stack.prototype.pop = function () {\n    return this.slice(1);\n  };\n\n  Stack.prototype.unshift = function () /*...values*/{\n    return this.push.apply(this, arguments);\n  };\n\n  Stack.prototype.unshiftAll = function (iter) {\n    return this.pushAll(iter);\n  };\n\n  Stack.prototype.shift = function () {\n    return this.pop.apply(this, arguments);\n  };\n\n  Stack.prototype.clear = function () {\n    if (this.size === 0) {\n      return this;\n    }\n    if (this.__ownerID) {\n      this.size = 0;\n      this._head = undefined;\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return emptyStack();\n  };\n\n  Stack.prototype.slice = function (begin, end) {\n    if (wholeSlice(begin, end, this.size)) {\n      return this;\n    }\n    var resolvedBegin = resolveBegin(begin, this.size);\n    var resolvedEnd = resolveEnd(end, this.size);\n    if (resolvedEnd !== this.size) {\n      // super.slice(begin, end);\n      return IndexedCollection.prototype.slice.call(this, begin, end);\n    }\n    var newSize = this.size - resolvedBegin;\n    var head = this._head;\n    while (resolvedBegin--) {\n      head = head.next;\n    }\n    if (this.__ownerID) {\n      this.size = newSize;\n      this._head = head;\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return makeStack(newSize, head);\n  };\n\n  // @pragma Mutability\n\n  Stack.prototype.__ensureOwner = function (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    if (!ownerID) {\n      this.__ownerID = ownerID;\n      this.__altered = false;\n      return this;\n    }\n    return makeStack(this.size, this._head, ownerID, this.__hash);\n  };\n\n  // @pragma Iteration\n\n  Stack.prototype.__iterate = function (fn, reverse) {\n    if (reverse) {\n      return this.reverse().__iterate(fn);\n    }\n    var iterations = 0;\n    var node = this._head;\n    while (node) {\n      if (fn(node.value, iterations++, this) === false) {\n        break;\n      }\n      node = node.next;\n    }\n    return iterations;\n  };\n\n  Stack.prototype.__iterator = function (type, reverse) {\n    if (reverse) {\n      return this.reverse().__iterator(type);\n    }\n    var iterations = 0;\n    var node = this._head;\n    return new Iterator(function () {\n      if (node) {\n        var value = node.value;\n        node = node.next;\n        return iteratorValue(type, iterations++, value);\n      }\n      return iteratorDone();\n    });\n  };\n\n  function isStack(maybeStack) {\n    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);\n  }\n\n  Stack.isStack = isStack;\n\n  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';\n\n  var StackPrototype = Stack.prototype;\n  StackPrototype[IS_STACK_SENTINEL] = true;\n  StackPrototype.withMutations = MapPrototype.withMutations;\n  StackPrototype.asMutable = MapPrototype.asMutable;\n  StackPrototype.asImmutable = MapPrototype.asImmutable;\n  StackPrototype.wasAltered = MapPrototype.wasAltered;\n\n  function makeStack(size, head, ownerID, hash) {\n    var map = Object.create(StackPrototype);\n    map.size = size;\n    map._head = head;\n    map.__ownerID = ownerID;\n    map.__hash = hash;\n    map.__altered = false;\n    return map;\n  }\n\n  var EMPTY_STACK;\n  function emptyStack() {\n    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));\n  }\n\n  /**\n   * Contributes additional methods to a constructor\n   */\n  function mixin(ctor, methods) {\n    var keyCopier = function keyCopier(key) {\n      ctor.prototype[key] = methods[key];\n    };\n    Object.keys(methods).forEach(keyCopier);\n    Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(methods).forEach(keyCopier);\n    return ctor;\n  }\n\n  Iterable.Iterator = Iterator;\n\n  mixin(Iterable, {\n\n    // ### Conversion to other types\n\n    toArray: function toArray() {\n      assertNotInfinite(this.size);\n      var array = new Array(this.size || 0);\n      this.valueSeq().__iterate(function (v, i) {\n        array[i] = v;\n      });\n      return array;\n    },\n\n    toIndexedSeq: function toIndexedSeq() {\n      return new ToIndexedSequence(this);\n    },\n\n    toJS: function toJS() {\n      return this.toSeq().map(function (value) {\n        return value && typeof value.toJS === 'function' ? value.toJS() : value;\n      }).__toJS();\n    },\n\n    toJSON: function toJSON() {\n      return this.toSeq().map(function (value) {\n        return value && typeof value.toJSON === 'function' ? value.toJSON() : value;\n      }).__toJS();\n    },\n\n    toKeyedSeq: function toKeyedSeq() {\n      return new ToKeyedSequence(this, true);\n    },\n\n    toMap: function toMap() {\n      // Use Late Binding here to solve the circular dependency.\n      return Map(this.toKeyedSeq());\n    },\n\n    toObject: function toObject() {\n      assertNotInfinite(this.size);\n      var object = {};\n      this.__iterate(function (v, k) {\n        object[k] = v;\n      });\n      return object;\n    },\n\n    toOrderedMap: function toOrderedMap() {\n      // Use Late Binding here to solve the circular dependency.\n      return OrderedMap(this.toKeyedSeq());\n    },\n\n    toOrderedSet: function toOrderedSet() {\n      // Use Late Binding here to solve the circular dependency.\n      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toSet: function toSet() {\n      // Use Late Binding here to solve the circular dependency.\n      return Set(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toSetSeq: function toSetSeq() {\n      return new ToSetSequence(this);\n    },\n\n    toSeq: function toSeq() {\n      return isIndexed(this) ? this.toIndexedSeq() : isKeyed(this) ? this.toKeyedSeq() : this.toSetSeq();\n    },\n\n    toStack: function toStack() {\n      // Use Late Binding here to solve the circular dependency.\n      return Stack(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toList: function toList() {\n      // Use Late Binding here to solve the circular dependency.\n      return List(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    // ### Common JavaScript methods and properties\n\n    toString: function toString() {\n      return '[Iterable]';\n    },\n\n    __toString: function __toString(head, tail) {\n      if (this.size === 0) {\n        return head + tail;\n      }\n      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;\n    },\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    concat: function concat() {\n      var values = SLICE$0.call(arguments, 0);\n      return reify(this, concatFactory(this, values));\n    },\n\n    includes: function includes(searchValue) {\n      return this.some(function (value) {\n        return is(value, searchValue);\n      });\n    },\n\n    entries: function entries() {\n      return this.__iterator(ITERATE_ENTRIES);\n    },\n\n    every: function every(predicate, context) {\n      assertNotInfinite(this.size);\n      var returnValue = true;\n      this.__iterate(function (v, k, c) {\n        if (!predicate.call(context, v, k, c)) {\n          returnValue = false;\n          return false;\n        }\n      });\n      return returnValue;\n    },\n\n    filter: function filter(predicate, context) {\n      return reify(this, filterFactory(this, predicate, context, true));\n    },\n\n    find: function find(predicate, context, notSetValue) {\n      var entry = this.findEntry(predicate, context);\n      return entry ? entry[1] : notSetValue;\n    },\n\n    forEach: function forEach(sideEffect, context) {\n      assertNotInfinite(this.size);\n      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);\n    },\n\n    join: function join(separator) {\n      assertNotInfinite(this.size);\n      separator = separator !== undefined ? '' + separator : ',';\n      var joined = '';\n      var isFirst = true;\n      this.__iterate(function (v) {\n        isFirst ? isFirst = false : joined += separator;\n        joined += v !== null && v !== undefined ? v.toString() : '';\n      });\n      return joined;\n    },\n\n    keys: function keys() {\n      return this.__iterator(ITERATE_KEYS);\n    },\n\n    map: function map(mapper, context) {\n      return reify(this, mapFactory(this, mapper, context));\n    },\n\n    reduce: function reduce(reducer, initialReduction, context) {\n      assertNotInfinite(this.size);\n      var reduction;\n      var useFirst;\n      if (arguments.length < 2) {\n        useFirst = true;\n      } else {\n        reduction = initialReduction;\n      }\n      this.__iterate(function (v, k, c) {\n        if (useFirst) {\n          useFirst = false;\n          reduction = v;\n        } else {\n          reduction = reducer.call(context, reduction, v, k, c);\n        }\n      });\n      return reduction;\n    },\n\n    reduceRight: function reduceRight(reducer, initialReduction, context) {\n      var reversed = this.toKeyedSeq().reverse();\n      return reversed.reduce.apply(reversed, arguments);\n    },\n\n    reverse: function reverse() {\n      return reify(this, reverseFactory(this, true));\n    },\n\n    slice: function slice(begin, end) {\n      return reify(this, sliceFactory(this, begin, end, true));\n    },\n\n    some: function some(predicate, context) {\n      return !this.every(not(predicate), context);\n    },\n\n    sort: function sort(comparator) {\n      return reify(this, sortFactory(this, comparator));\n    },\n\n    values: function values() {\n      return this.__iterator(ITERATE_VALUES);\n    },\n\n    // ### More sequential methods\n\n    butLast: function butLast() {\n      return this.slice(0, -1);\n    },\n\n    isEmpty: function isEmpty() {\n      return this.size !== undefined ? this.size === 0 : !this.some(function () {\n        return true;\n      });\n    },\n\n    count: function count(predicate, context) {\n      return ensureSize(predicate ? this.toSeq().filter(predicate, context) : this);\n    },\n\n    countBy: function countBy(grouper, context) {\n      return countByFactory(this, grouper, context);\n    },\n\n    equals: function equals(other) {\n      return deepEqual(this, other);\n    },\n\n    entrySeq: function entrySeq() {\n      var iterable = this;\n      if (iterable._cache) {\n        // We cache as an entries array, so we can just return the cache!\n        return new ArraySeq(iterable._cache);\n      }\n      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();\n      entriesSequence.fromEntrySeq = function () {\n        return iterable.toSeq();\n      };\n      return entriesSequence;\n    },\n\n    filterNot: function filterNot(predicate, context) {\n      return this.filter(not(predicate), context);\n    },\n\n    findEntry: function findEntry(predicate, context, notSetValue) {\n      var found = notSetValue;\n      this.__iterate(function (v, k, c) {\n        if (predicate.call(context, v, k, c)) {\n          found = [k, v];\n          return false;\n        }\n      });\n      return found;\n    },\n\n    findKey: function findKey(predicate, context) {\n      var entry = this.findEntry(predicate, context);\n      return entry && entry[0];\n    },\n\n    findLast: function findLast(predicate, context, notSetValue) {\n      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);\n    },\n\n    findLastEntry: function findLastEntry(predicate, context, notSetValue) {\n      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);\n    },\n\n    findLastKey: function findLastKey(predicate, context) {\n      return this.toKeyedSeq().reverse().findKey(predicate, context);\n    },\n\n    first: function first() {\n      return this.find(returnTrue);\n    },\n\n    flatMap: function flatMap(mapper, context) {\n      return reify(this, flatMapFactory(this, mapper, context));\n    },\n\n    flatten: function flatten(depth) {\n      return reify(this, flattenFactory(this, depth, true));\n    },\n\n    fromEntrySeq: function fromEntrySeq() {\n      return new FromEntriesSequence(this);\n    },\n\n    get: function get(searchKey, notSetValue) {\n      return this.find(function (_, key) {\n        return is(key, searchKey);\n      }, undefined, notSetValue);\n    },\n\n    getIn: function getIn(searchKeyPath, notSetValue) {\n      var nested = this;\n      // Note: in an ES6 environment, we would prefer:\n      // for (var key of searchKeyPath) {\n      var iter = forceIterator(searchKeyPath);\n      var step;\n      while (!(step = iter.next()).done) {\n        var key = step.value;\n        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;\n        if (nested === NOT_SET) {\n          return notSetValue;\n        }\n      }\n      return nested;\n    },\n\n    groupBy: function groupBy(grouper, context) {\n      return groupByFactory(this, grouper, context);\n    },\n\n    has: function has(searchKey) {\n      return this.get(searchKey, NOT_SET) !== NOT_SET;\n    },\n\n    hasIn: function hasIn(searchKeyPath) {\n      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;\n    },\n\n    isSubset: function isSubset(iter) {\n      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);\n      return this.every(function (value) {\n        return iter.includes(value);\n      });\n    },\n\n    isSuperset: function isSuperset(iter) {\n      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);\n      return iter.isSubset(this);\n    },\n\n    keyOf: function keyOf(searchValue) {\n      return this.findKey(function (value) {\n        return is(value, searchValue);\n      });\n    },\n\n    keySeq: function keySeq() {\n      return this.toSeq().map(keyMapper).toIndexedSeq();\n    },\n\n    last: function last() {\n      return this.toSeq().reverse().first();\n    },\n\n    lastKeyOf: function lastKeyOf(searchValue) {\n      return this.toKeyedSeq().reverse().keyOf(searchValue);\n    },\n\n    max: function max(comparator) {\n      return maxFactory(this, comparator);\n    },\n\n    maxBy: function maxBy(mapper, comparator) {\n      return maxFactory(this, comparator, mapper);\n    },\n\n    min: function min(comparator) {\n      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);\n    },\n\n    minBy: function minBy(mapper, comparator) {\n      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);\n    },\n\n    rest: function rest() {\n      return this.slice(1);\n    },\n\n    skip: function skip(amount) {\n      return this.slice(Math.max(0, amount));\n    },\n\n    skipLast: function skipLast(amount) {\n      return reify(this, this.toSeq().reverse().skip(amount).reverse());\n    },\n\n    skipWhile: function skipWhile(predicate, context) {\n      return reify(this, skipWhileFactory(this, predicate, context, true));\n    },\n\n    skipUntil: function skipUntil(predicate, context) {\n      return this.skipWhile(not(predicate), context);\n    },\n\n    sortBy: function sortBy(mapper, comparator) {\n      return reify(this, sortFactory(this, comparator, mapper));\n    },\n\n    take: function take(amount) {\n      return this.slice(0, Math.max(0, amount));\n    },\n\n    takeLast: function takeLast(amount) {\n      return reify(this, this.toSeq().reverse().take(amount).reverse());\n    },\n\n    takeWhile: function takeWhile(predicate, context) {\n      return reify(this, takeWhileFactory(this, predicate, context));\n    },\n\n    takeUntil: function takeUntil(predicate, context) {\n      return this.takeWhile(not(predicate), context);\n    },\n\n    valueSeq: function valueSeq() {\n      return this.toIndexedSeq();\n    },\n\n    // ### Hashable Object\n\n    hashCode: function hashCode() {\n      return this.__hash || (this.__hash = hashIterable(this));\n    }\n\n    // ### Internal\n\n    // abstract __iterate(fn, reverse)\n\n    // abstract __iterator(type, reverse)\n  });\n\n  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\n  var IterablePrototype = Iterable.prototype;\n  IterablePrototype[IS_ITERABLE_SENTINEL] = true;\n  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;\n  IterablePrototype.__toJS = IterablePrototype.toArray;\n  IterablePrototype.__toStringMapper = quoteString;\n  IterablePrototype.inspect = IterablePrototype.toSource = function () {\n    return this.toString();\n  };\n  IterablePrototype.chain = IterablePrototype.flatMap;\n  IterablePrototype.contains = IterablePrototype.includes;\n\n  mixin(KeyedIterable, {\n\n    // ### More sequential methods\n\n    flip: function flip() {\n      return reify(this, flipFactory(this));\n    },\n\n    mapEntries: function mapEntries(mapper, context) {\n      var this$0 = this;\n      var iterations = 0;\n      return reify(this, this.toSeq().map(function (v, k) {\n        return mapper.call(context, [k, v], iterations++, this$0);\n      }).fromEntrySeq());\n    },\n\n    mapKeys: function mapKeys(mapper, context) {\n      var this$0 = this;\n      return reify(this, this.toSeq().flip().map(function (k, v) {\n        return mapper.call(context, k, v, this$0);\n      }).flip());\n    }\n\n  });\n\n  var KeyedIterablePrototype = KeyedIterable.prototype;\n  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;\n  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;\n  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;\n  KeyedIterablePrototype.__toStringMapper = function (v, k) {\n    return JSON.stringify(k) + ': ' + quoteString(v);\n  };\n\n  mixin(IndexedIterable, {\n\n    // ### Conversion to other types\n\n    toKeyedSeq: function toKeyedSeq() {\n      return new ToKeyedSequence(this, false);\n    },\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    filter: function filter(predicate, context) {\n      return reify(this, filterFactory(this, predicate, context, false));\n    },\n\n    findIndex: function findIndex(predicate, context) {\n      var entry = this.findEntry(predicate, context);\n      return entry ? entry[0] : -1;\n    },\n\n    indexOf: function indexOf(searchValue) {\n      var key = this.keyOf(searchValue);\n      return key === undefined ? -1 : key;\n    },\n\n    lastIndexOf: function lastIndexOf(searchValue) {\n      var key = this.lastKeyOf(searchValue);\n      return key === undefined ? -1 : key;\n    },\n\n    reverse: function reverse() {\n      return reify(this, reverseFactory(this, false));\n    },\n\n    slice: function slice(begin, end) {\n      return reify(this, sliceFactory(this, begin, end, false));\n    },\n\n    splice: function splice(index, removeNum /*, ...values*/) {\n      var numArgs = arguments.length;\n      removeNum = Math.max(removeNum | 0, 0);\n      if (numArgs === 0 || numArgs === 2 && !removeNum) {\n        return this;\n      }\n      // If index is negative, it should resolve relative to the size of the\n      // collection. However size may be expensive to compute if not cached, so\n      // only call count() if the number is in fact negative.\n      index = resolveBegin(index, index < 0 ? this.count() : this.size);\n      var spliced = this.slice(0, index);\n      return reify(this, numArgs === 1 ? spliced : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum)));\n    },\n\n    // ### More collection methods\n\n    findLastIndex: function findLastIndex(predicate, context) {\n      var entry = this.findLastEntry(predicate, context);\n      return entry ? entry[0] : -1;\n    },\n\n    first: function first() {\n      return this.get(0);\n    },\n\n    flatten: function flatten(depth) {\n      return reify(this, flattenFactory(this, depth, false));\n    },\n\n    get: function get(index, notSetValue) {\n      index = wrapIndex(this, index);\n      return index < 0 || this.size === Infinity || this.size !== undefined && index > this.size ? notSetValue : this.find(function (_, key) {\n        return key === index;\n      }, undefined, notSetValue);\n    },\n\n    has: function has(index) {\n      index = wrapIndex(this, index);\n      return index >= 0 && (this.size !== undefined ? this.size === Infinity || index < this.size : this.indexOf(index) !== -1);\n    },\n\n    interpose: function interpose(separator) {\n      return reify(this, interposeFactory(this, separator));\n    },\n\n    interleave: function interleave() /*...iterables*/{\n      var iterables = [this].concat(arrCopy(arguments));\n      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);\n      var interleaved = zipped.flatten(true);\n      if (zipped.size) {\n        interleaved.size = zipped.size * iterables.length;\n      }\n      return reify(this, interleaved);\n    },\n\n    keySeq: function keySeq() {\n      return Range(0, this.size);\n    },\n\n    last: function last() {\n      return this.get(-1);\n    },\n\n    skipWhile: function skipWhile(predicate, context) {\n      return reify(this, skipWhileFactory(this, predicate, context, false));\n    },\n\n    zip: function zip() /*, ...iterables */{\n      var iterables = [this].concat(arrCopy(arguments));\n      return reify(this, zipWithFactory(this, defaultZipper, iterables));\n    },\n\n    zipWith: function zipWith(zipper /*, ...iterables */) {\n      var iterables = arrCopy(arguments);\n      iterables[0] = this;\n      return reify(this, zipWithFactory(this, zipper, iterables));\n    }\n\n  });\n\n  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;\n  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;\n\n  mixin(SetIterable, {\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    get: function get(value, notSetValue) {\n      return this.has(value) ? value : notSetValue;\n    },\n\n    includes: function includes(value) {\n      return this.has(value);\n    },\n\n    // ### More sequential methods\n\n    keySeq: function keySeq() {\n      return this.valueSeq();\n    }\n\n  });\n\n  SetIterable.prototype.has = IterablePrototype.includes;\n  SetIterable.prototype.contains = SetIterable.prototype.includes;\n\n  // Mixin subclasses\n\n  mixin(KeyedSeq, KeyedIterable.prototype);\n  mixin(IndexedSeq, IndexedIterable.prototype);\n  mixin(SetSeq, SetIterable.prototype);\n\n  mixin(KeyedCollection, KeyedIterable.prototype);\n  mixin(IndexedCollection, IndexedIterable.prototype);\n  mixin(SetCollection, SetIterable.prototype);\n\n  // #pragma Helper functions\n\n  function keyMapper(v, k) {\n    return k;\n  }\n\n  function entryMapper(v, k) {\n    return [k, v];\n  }\n\n  function not(predicate) {\n    return function () {\n      return !predicate.apply(this, arguments);\n    };\n  }\n\n  function neg(predicate) {\n    return function () {\n      return -predicate.apply(this, arguments);\n    };\n  }\n\n  function quoteString(value) {\n    return typeof value === 'string' ? JSON.stringify(value) : String(value);\n  }\n\n  function defaultZipper() {\n    return arrCopy(arguments);\n  }\n\n  function defaultNegComparator(a, b) {\n    return a < b ? 1 : a > b ? -1 : 0;\n  }\n\n  function hashIterable(iterable) {\n    if (iterable.size === Infinity) {\n      return 0;\n    }\n    var ordered = isOrdered(iterable);\n    var keyed = isKeyed(iterable);\n    var h = ordered ? 1 : 0;\n    var size = iterable.__iterate(keyed ? ordered ? function (v, k) {\n      h = 31 * h + hashMerge(hash(v), hash(k)) | 0;\n    } : function (v, k) {\n      h = h + hashMerge(hash(v), hash(k)) | 0;\n    } : ordered ? function (v) {\n      h = 31 * h + hash(v) | 0;\n    } : function (v) {\n      h = h + hash(v) | 0;\n    });\n    return murmurHashOfSize(size, h);\n  }\n\n  function murmurHashOfSize(size, h) {\n    h = imul(h, 0xCC9E2D51);\n    h = imul(h << 15 | h >>> -15, 0x1B873593);\n    h = imul(h << 13 | h >>> -13, 5);\n    h = (h + 0xE6546B64 | 0) ^ size;\n    h = imul(h ^ h >>> 16, 0x85EBCA6B);\n    h = imul(h ^ h >>> 13, 0xC2B2AE35);\n    h = smi(h ^ h >>> 16);\n    return h;\n  }\n\n  function hashMerge(a, b) {\n    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int\n  }\n\n  var Immutable = {\n\n    Iterable: Iterable,\n\n    Seq: Seq,\n    Collection: Collection,\n    Map: Map,\n    OrderedMap: OrderedMap,\n    List: List,\n    Stack: Stack,\n    Set: Set,\n    OrderedSet: OrderedSet,\n\n    Record: Record,\n    Range: Range,\n    Repeat: Repeat,\n\n    is: is,\n    fromJS: fromJS\n\n  };\n\n  return Immutable;\n});\n\n/***/ }),\n\n/***/ \"cRy3\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Stringify/parse functions that don't operate\n * recursively, so they avoid call stack exceeded\n * errors.\n */\n\nexports.stringify = function stringify(input) {\n  var queue = [];\n  queue.push({ obj: input });\n\n  var res = '';\n  var next, obj, prefix, val, i, arrayPrefix, keys, k, key, value, objPrefix;\n  while (next = queue.pop()) {\n    obj = next.obj;\n    prefix = next.prefix || '';\n    val = next.val || '';\n    res += prefix;\n    if (val) {\n      res += val;\n    } else if (typeof obj !== 'object') {\n      res += typeof obj === 'undefined' ? null : JSON.stringify(obj);\n    } else if (obj === null) {\n      res += 'null';\n    } else if (Array.isArray(obj)) {\n      queue.push({ val: ']' });\n      for (i = obj.length - 1; i >= 0; i--) {\n        arrayPrefix = i === 0 ? '' : ',';\n        queue.push({ obj: obj[i], prefix: arrayPrefix });\n      }\n      queue.push({ val: '[' });\n    } else {\n      // object\n      keys = [];\n      for (k in obj) {\n        if (obj.hasOwnProperty(k)) {\n          keys.push(k);\n        }\n      }\n      queue.push({ val: '}' });\n      for (i = keys.length - 1; i >= 0; i--) {\n        key = keys[i];\n        value = obj[key];\n        objPrefix = i > 0 ? ',' : '';\n        objPrefix += JSON.stringify(key) + ':';\n        queue.push({ obj: value, prefix: objPrefix });\n      }\n      queue.push({ val: '{' });\n    }\n  }\n  return res;\n};\n\n// Convenience function for the parse function.\n// This pop function is basically copied from\n// pouchCollate.parseIndexableString\nfunction pop(obj, stack, metaStack) {\n  var lastMetaElement = metaStack[metaStack.length - 1];\n  if (obj === lastMetaElement.element) {\n    // popping a meta-element, e.g. an object whose value is another object\n    metaStack.pop();\n    lastMetaElement = metaStack[metaStack.length - 1];\n  }\n  var element = lastMetaElement.element;\n  var lastElementIndex = lastMetaElement.index;\n  if (Array.isArray(element)) {\n    element.push(obj);\n  } else if (lastElementIndex === stack.length - 2) {\n    // obj with key+value\n    var key = stack.pop();\n    element[key] = obj;\n  } else {\n    stack.push(obj); // obj with key only\n  }\n}\n\nexports.parse = function (str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n  var collationIndex, parsedNum, numChar;\n  var parsedString, lastCh, numConsecutiveSlashes, ch;\n  var arrayElement, objElement;\n  while (true) {\n    collationIndex = str[i++];\n    if (collationIndex === '}' || collationIndex === ']' || typeof collationIndex === 'undefined') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack.pop(), stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case ' ':\n      case '\\t':\n      case '\\n':\n      case ':':\n      case ',':\n        break;\n      case 'n':\n        i += 3; // 'ull'\n        pop(null, stack, metaStack);\n        break;\n      case 't':\n        i += 3; // 'rue'\n        pop(true, stack, metaStack);\n        break;\n      case 'f':\n        i += 4; // 'alse'\n        pop(false, stack, metaStack);\n        break;\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n      case '-':\n        parsedNum = '';\n        i--;\n        while (true) {\n          numChar = str[i++];\n          if (/[\\d\\.\\-e\\+]/.test(numChar)) {\n            parsedNum += numChar;\n          } else {\n            i--;\n            break;\n          }\n        }\n        pop(parseFloat(parsedNum), stack, metaStack);\n        break;\n      case '\"':\n        parsedString = '';\n        lastCh = void 0;\n        numConsecutiveSlashes = 0;\n        while (true) {\n          ch = str[i++];\n          if (ch !== '\"' || lastCh === '\\\\' && numConsecutiveSlashes % 2 === 1) {\n            parsedString += ch;\n            lastCh = ch;\n            if (lastCh === '\\\\') {\n              numConsecutiveSlashes++;\n            } else {\n              numConsecutiveSlashes = 0;\n            }\n          } else {\n            break;\n          }\n        }\n        pop(JSON.parse('\"' + parsedString + '\"'), stack, metaStack);\n        break;\n      case '[':\n        arrayElement = { element: [], index: stack.length };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '{':\n        objElement = { element: {}, index: stack.length };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      default:\n        throw new Error('unexpectedly reached end of input: ' + collationIndex);\n    }\n  }\n};\n\n/***/ }),\n\n/***/ \"d18E\":\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n *  Copyright (c) 2014-2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n(function (global, factory) {\n   true ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : factory(global.Immutable = global.Immutable || {});\n})(this, function (exports) {\n  'use strict';\n\n  // Used for setting prototype methods that IE8 chokes on.\n\n  var DELETE = 'delete';\n\n  // Constants describing the size of trie nodes.\n  var SHIFT = 5; // Resulted in best performance after ______?\n  var SIZE = 1 << SHIFT;\n  var MASK = SIZE - 1;\n\n  // A consistent shared value representing \"not set\" which equals nothing other\n  // than itself, and nothing that could be provided externally.\n  var NOT_SET = {};\n\n  // Boolean references, Rough equivalent of `bool &`.\n  var CHANGE_LENGTH = { value: false };\n  var DID_ALTER = { value: false };\n\n  function MakeRef(ref) {\n    ref.value = false;\n    return ref;\n  }\n\n  function SetRef(ref) {\n    ref && (ref.value = true);\n  }\n\n  // A function which returns a value representing an \"owner\" for transient writes\n  // to tries. The return value will only ever equal itself, and will not equal\n  // the return of any subsequent call of this function.\n  function OwnerID() {}\n\n  // http://jsperf.com/copy-array-inline\n  function arrCopy(arr, offset) {\n    offset = offset || 0;\n    var len = Math.max(0, arr.length - offset);\n    var newArr = new Array(len);\n    for (var ii = 0; ii < len; ii++) {\n      newArr[ii] = arr[ii + offset];\n    }\n    return newArr;\n  }\n\n  function ensureSize(iter) {\n    if (iter.size === undefined) {\n      iter.size = iter.__iterate(returnTrue);\n    }\n    return iter.size;\n  }\n\n  function wrapIndex(iter, index) {\n    // This implements \"is array index\" which the ECMAString spec defines as:\n    //\n    //     A String property name P is an array index if and only if\n    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal\n    //     to 2^32−1.\n    //\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects\n    if (typeof index !== 'number') {\n      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32\n      if ('' + uint32Index !== index || uint32Index === 4294967295) {\n        return NaN;\n      }\n      index = uint32Index;\n    }\n    return index < 0 ? ensureSize(iter) + index : index;\n  }\n\n  function returnTrue() {\n    return true;\n  }\n\n  function wholeSlice(begin, end, size) {\n    return (begin === 0 || size !== undefined && begin <= -size) && (end === undefined || size !== undefined && end >= size);\n  }\n\n  function resolveBegin(begin, size) {\n    return resolveIndex(begin, size, 0);\n  }\n\n  function resolveEnd(end, size) {\n    return resolveIndex(end, size, size);\n  }\n\n  function resolveIndex(index, size, defaultIndex) {\n    // Sanitize indices using this shorthand for ToInt32(argument)\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n    return index === undefined ? defaultIndex : index < 0 ? size === Infinity ? size : Math.max(0, size + index) | 0 : size === undefined || size === index ? index : Math.min(size, index) | 0;\n  }\n\n  function isImmutable(maybeImmutable) {\n    return (isCollection(maybeImmutable) || isRecord(maybeImmutable)) && !maybeImmutable.__ownerID;\n  }\n\n  function isCollection(maybeCollection) {\n    return !!(maybeCollection && maybeCollection[IS_ITERABLE_SENTINEL]);\n  }\n\n  function isKeyed(maybeKeyed) {\n    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);\n  }\n\n  function isIndexed(maybeIndexed) {\n    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);\n  }\n\n  function isAssociative(maybeAssociative) {\n    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);\n  }\n\n  function isOrdered(maybeOrdered) {\n    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);\n  }\n\n  function isRecord(maybeRecord) {\n    return !!(maybeRecord && maybeRecord[IS_RECORD_SENTINEL]);\n  }\n\n  function isValueObject(maybeValue) {\n    return !!(maybeValue && typeof maybeValue.equals === 'function' && typeof maybeValue.hashCode === 'function');\n  }\n\n  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n  var IS_RECORD_SENTINEL = '@@__IMMUTABLE_RECORD__@@';\n\n  var Collection = function Collection(value) {\n    return isCollection(value) ? value : Seq(value);\n  };\n\n  var KeyedCollection = function (Collection) {\n    function KeyedCollection(value) {\n      return isKeyed(value) ? value : KeyedSeq(value);\n    }\n\n    if (Collection) KeyedCollection.__proto__ = Collection;\n    KeyedCollection.prototype = Object.create(Collection && Collection.prototype);\n    KeyedCollection.prototype.constructor = KeyedCollection;\n\n    return KeyedCollection;\n  }(Collection);\n\n  var IndexedCollection = function (Collection) {\n    function IndexedCollection(value) {\n      return isIndexed(value) ? value : IndexedSeq(value);\n    }\n\n    if (Collection) IndexedCollection.__proto__ = Collection;\n    IndexedCollection.prototype = Object.create(Collection && Collection.prototype);\n    IndexedCollection.prototype.constructor = IndexedCollection;\n\n    return IndexedCollection;\n  }(Collection);\n\n  var SetCollection = function (Collection) {\n    function SetCollection(value) {\n      return isCollection(value) && !isAssociative(value) ? value : SetSeq(value);\n    }\n\n    if (Collection) SetCollection.__proto__ = Collection;\n    SetCollection.prototype = Object.create(Collection && Collection.prototype);\n    SetCollection.prototype.constructor = SetCollection;\n\n    return SetCollection;\n  }(Collection);\n\n  Collection.Keyed = KeyedCollection;\n  Collection.Indexed = IndexedCollection;\n  Collection.Set = SetCollection;\n\n  var ITERATE_KEYS = 0;\n  var ITERATE_VALUES = 1;\n  var ITERATE_ENTRIES = 2;\n\n  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator';\n\n  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;\n\n  var Iterator = function Iterator(next) {\n    this.next = next;\n  };\n\n  Iterator.prototype.toString = function toString() {\n    return '[Iterator]';\n  };\n\n  Iterator.KEYS = ITERATE_KEYS;\n  Iterator.VALUES = ITERATE_VALUES;\n  Iterator.ENTRIES = ITERATE_ENTRIES;\n\n  Iterator.prototype.inspect = Iterator.prototype.toSource = function () {\n    return this.toString();\n  };\n  Iterator.prototype[ITERATOR_SYMBOL] = function () {\n    return this;\n  };\n\n  function iteratorValue(type, k, v, iteratorResult) {\n    var value = type === 0 ? k : type === 1 ? v : [k, v];\n    iteratorResult ? iteratorResult.value = value : iteratorResult = {\n      value: value,\n      done: false\n    };\n    return iteratorResult;\n  }\n\n  function iteratorDone() {\n    return { value: undefined, done: true };\n  }\n\n  function hasIterator(maybeIterable) {\n    return !!getIteratorFn(maybeIterable);\n  }\n\n  function isIterator(maybeIterator) {\n    return maybeIterator && typeof maybeIterator.next === 'function';\n  }\n\n  function getIterator(iterable) {\n    var iteratorFn = getIteratorFn(iterable);\n    return iteratorFn && iteratorFn.call(iterable);\n  }\n\n  function getIteratorFn(iterable) {\n    var iteratorFn = iterable && (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL] || iterable[FAUX_ITERATOR_SYMBOL]);\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  function isArrayLike(value) {\n    return value && typeof value.length === 'number';\n  }\n\n  var Seq = function (Collection$$1) {\n    function Seq(value) {\n      return value === null || value === undefined ? emptySequence() : isCollection(value) || isRecord(value) ? value.toSeq() : seqFromValue(value);\n    }\n\n    if (Collection$$1) Seq.__proto__ = Collection$$1;\n    Seq.prototype = Object.create(Collection$$1 && Collection$$1.prototype);\n    Seq.prototype.constructor = Seq;\n\n    Seq.of = function of() /*...values*/{\n      return Seq(arguments);\n    };\n\n    Seq.prototype.toSeq = function toSeq() {\n      return this;\n    };\n\n    Seq.prototype.toString = function toString() {\n      return this.__toString('Seq {', '}');\n    };\n\n    Seq.prototype.cacheResult = function cacheResult() {\n      if (!this._cache && this.__iterateUncached) {\n        this._cache = this.entrySeq().toArray();\n        this.size = this._cache.length;\n      }\n      return this;\n    };\n\n    // abstract __iterateUncached(fn, reverse)\n\n    Seq.prototype.__iterate = function __iterate(fn, reverse) {\n      var this$1 = this;\n\n      var cache = this._cache;\n      if (cache) {\n        var size = cache.length;\n        var i = 0;\n        while (i !== size) {\n          var entry = cache[reverse ? size - ++i : i++];\n          if (fn(entry[1], entry[0], this$1) === false) {\n            break;\n          }\n        }\n        return i;\n      }\n      return this.__iterateUncached(fn, reverse);\n    };\n\n    // abstract __iteratorUncached(type, reverse)\n\n    Seq.prototype.__iterator = function __iterator(type, reverse) {\n      var cache = this._cache;\n      if (cache) {\n        var size = cache.length;\n        var i = 0;\n        return new Iterator(function () {\n          if (i === size) {\n            return iteratorDone();\n          }\n          var entry = cache[reverse ? size - ++i : i++];\n          return iteratorValue(type, entry[0], entry[1]);\n        });\n      }\n      return this.__iteratorUncached(type, reverse);\n    };\n\n    return Seq;\n  }(Collection);\n\n  var KeyedSeq = function (Seq) {\n    function KeyedSeq(value) {\n      return value === null || value === undefined ? emptySequence().toKeyedSeq() : isCollection(value) ? isKeyed(value) ? value.toSeq() : value.fromEntrySeq() : isRecord(value) ? value.toSeq() : keyedSeqFromValue(value);\n    }\n\n    if (Seq) KeyedSeq.__proto__ = Seq;\n    KeyedSeq.prototype = Object.create(Seq && Seq.prototype);\n    KeyedSeq.prototype.constructor = KeyedSeq;\n\n    KeyedSeq.prototype.toKeyedSeq = function toKeyedSeq() {\n      return this;\n    };\n\n    return KeyedSeq;\n  }(Seq);\n\n  var IndexedSeq = function (Seq) {\n    function IndexedSeq(value) {\n      return value === null || value === undefined ? emptySequence() : isCollection(value) ? isKeyed(value) ? value.entrySeq() : value.toIndexedSeq() : isRecord(value) ? value.toSeq().entrySeq() : indexedSeqFromValue(value);\n    }\n\n    if (Seq) IndexedSeq.__proto__ = Seq;\n    IndexedSeq.prototype = Object.create(Seq && Seq.prototype);\n    IndexedSeq.prototype.constructor = IndexedSeq;\n\n    IndexedSeq.of = function of() /*...values*/{\n      return IndexedSeq(arguments);\n    };\n\n    IndexedSeq.prototype.toIndexedSeq = function toIndexedSeq() {\n      return this;\n    };\n\n    IndexedSeq.prototype.toString = function toString() {\n      return this.__toString('Seq [', ']');\n    };\n\n    return IndexedSeq;\n  }(Seq);\n\n  var SetSeq = function (Seq) {\n    function SetSeq(value) {\n      return (isCollection(value) && !isAssociative(value) ? value : IndexedSeq(value)).toSetSeq();\n    }\n\n    if (Seq) SetSeq.__proto__ = Seq;\n    SetSeq.prototype = Object.create(Seq && Seq.prototype);\n    SetSeq.prototype.constructor = SetSeq;\n\n    SetSeq.of = function of() /*...values*/{\n      return SetSeq(arguments);\n    };\n\n    SetSeq.prototype.toSetSeq = function toSetSeq() {\n      return this;\n    };\n\n    return SetSeq;\n  }(Seq);\n\n  Seq.isSeq = isSeq;\n  Seq.Keyed = KeyedSeq;\n  Seq.Set = SetSeq;\n  Seq.Indexed = IndexedSeq;\n\n  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';\n\n  Seq.prototype[IS_SEQ_SENTINEL] = true;\n\n  // #pragma Root Sequences\n\n  var ArraySeq = function (IndexedSeq) {\n    function ArraySeq(array) {\n      this._array = array;\n      this.size = array.length;\n    }\n\n    if (IndexedSeq) ArraySeq.__proto__ = IndexedSeq;\n    ArraySeq.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);\n    ArraySeq.prototype.constructor = ArraySeq;\n\n    ArraySeq.prototype.get = function get(index, notSetValue) {\n      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;\n    };\n\n    ArraySeq.prototype.__iterate = function __iterate(fn, reverse) {\n      var this$1 = this;\n\n      var array = this._array;\n      var size = array.length;\n      var i = 0;\n      while (i !== size) {\n        var ii = reverse ? size - ++i : i++;\n        if (fn(array[ii], ii, this$1) === false) {\n          break;\n        }\n      }\n      return i;\n    };\n\n    ArraySeq.prototype.__iterator = function __iterator(type, reverse) {\n      var array = this._array;\n      var size = array.length;\n      var i = 0;\n      return new Iterator(function () {\n        if (i === size) {\n          return iteratorDone();\n        }\n        var ii = reverse ? size - ++i : i++;\n        return iteratorValue(type, ii, array[ii]);\n      });\n    };\n\n    return ArraySeq;\n  }(IndexedSeq);\n\n  var ObjectSeq = function (KeyedSeq) {\n    function ObjectSeq(object) {\n      var keys = Object.keys(object);\n      this._object = object;\n      this._keys = keys;\n      this.size = keys.length;\n    }\n\n    if (KeyedSeq) ObjectSeq.__proto__ = KeyedSeq;\n    ObjectSeq.prototype = Object.create(KeyedSeq && KeyedSeq.prototype);\n    ObjectSeq.prototype.constructor = ObjectSeq;\n\n    ObjectSeq.prototype.get = function get(key, notSetValue) {\n      if (notSetValue !== undefined && !this.has(key)) {\n        return notSetValue;\n      }\n      return this._object[key];\n    };\n\n    ObjectSeq.prototype.has = function has(key) {\n      return this._object.hasOwnProperty(key);\n    };\n\n    ObjectSeq.prototype.__iterate = function __iterate(fn, reverse) {\n      var this$1 = this;\n\n      var object = this._object;\n      var keys = this._keys;\n      var size = keys.length;\n      var i = 0;\n      while (i !== size) {\n        var key = keys[reverse ? size - ++i : i++];\n        if (fn(object[key], key, this$1) === false) {\n          break;\n        }\n      }\n      return i;\n    };\n\n    ObjectSeq.prototype.__iterator = function __iterator(type, reverse) {\n      var object = this._object;\n      var keys = this._keys;\n      var size = keys.length;\n      var i = 0;\n      return new Iterator(function () {\n        if (i === size) {\n          return iteratorDone();\n        }\n        var key = keys[reverse ? size - ++i : i++];\n        return iteratorValue(type, key, object[key]);\n      });\n    };\n\n    return ObjectSeq;\n  }(KeyedSeq);\n  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;\n\n  var CollectionSeq = function (IndexedSeq) {\n    function CollectionSeq(collection) {\n      this._collection = collection;\n      this.size = collection.length || collection.size;\n    }\n\n    if (IndexedSeq) CollectionSeq.__proto__ = IndexedSeq;\n    CollectionSeq.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);\n    CollectionSeq.prototype.constructor = CollectionSeq;\n\n    CollectionSeq.prototype.__iterateUncached = function __iterateUncached(fn, reverse) {\n      var this$1 = this;\n\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var collection = this._collection;\n      var iterator = getIterator(collection);\n      var iterations = 0;\n      if (isIterator(iterator)) {\n        var step;\n        while (!(step = iterator.next()).done) {\n          if (fn(step.value, iterations++, this$1) === false) {\n            break;\n          }\n        }\n      }\n      return iterations;\n    };\n\n    CollectionSeq.prototype.__iteratorUncached = function __iteratorUncached(type, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var collection = this._collection;\n      var iterator = getIterator(collection);\n      if (!isIterator(iterator)) {\n        return new Iterator(iteratorDone);\n      }\n      var iterations = 0;\n      return new Iterator(function () {\n        var step = iterator.next();\n        return step.done ? step : iteratorValue(type, iterations++, step.value);\n      });\n    };\n\n    return CollectionSeq;\n  }(IndexedSeq);\n\n  var IteratorSeq = function (IndexedSeq) {\n    function IteratorSeq(iterator) {\n      this._iterator = iterator;\n      this._iteratorCache = [];\n    }\n\n    if (IndexedSeq) IteratorSeq.__proto__ = IndexedSeq;\n    IteratorSeq.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);\n    IteratorSeq.prototype.constructor = IteratorSeq;\n\n    IteratorSeq.prototype.__iterateUncached = function __iterateUncached(fn, reverse) {\n      var this$1 = this;\n\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterator = this._iterator;\n      var cache = this._iteratorCache;\n      var iterations = 0;\n      while (iterations < cache.length) {\n        if (fn(cache[iterations], iterations++, this$1) === false) {\n          return iterations;\n        }\n      }\n      var step;\n      while (!(step = iterator.next()).done) {\n        var val = step.value;\n        cache[iterations] = val;\n        if (fn(val, iterations++, this$1) === false) {\n          break;\n        }\n      }\n      return iterations;\n    };\n\n    IteratorSeq.prototype.__iteratorUncached = function __iteratorUncached(type, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = this._iterator;\n      var cache = this._iteratorCache;\n      var iterations = 0;\n      return new Iterator(function () {\n        if (iterations >= cache.length) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          cache[iterations] = step.value;\n        }\n        return iteratorValue(type, iterations, cache[iterations++]);\n      });\n    };\n\n    return IteratorSeq;\n  }(IndexedSeq);\n\n  // # pragma Helper functions\n\n  function isSeq(maybeSeq) {\n    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);\n  }\n\n  var EMPTY_SEQ;\n\n  function emptySequence() {\n    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));\n  }\n\n  function keyedSeqFromValue(value) {\n    var seq = Array.isArray(value) ? new ArraySeq(value) : isIterator(value) ? new IteratorSeq(value) : hasIterator(value) ? new CollectionSeq(value) : undefined;\n    if (seq) {\n      return seq.fromEntrySeq();\n    }\n    if (typeof value === 'object') {\n      return new ObjectSeq(value);\n    }\n    throw new TypeError('Expected Array or collection object of [k, v] entries, or keyed object: ' + value);\n  }\n\n  function indexedSeqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value);\n    if (seq) {\n      return seq;\n    }\n    throw new TypeError('Expected Array or collection object of values: ' + value);\n  }\n\n  function seqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value);\n    if (seq) {\n      return seq;\n    }\n    if (typeof value === 'object') {\n      return new ObjectSeq(value);\n    }\n    throw new TypeError('Expected Array or collection object of values, or keyed object: ' + value);\n  }\n\n  function maybeIndexedSeqFromValue(value) {\n    return isArrayLike(value) ? new ArraySeq(value) : isIterator(value) ? new IteratorSeq(value) : hasIterator(value) ? new CollectionSeq(value) : undefined;\n  }\n\n  /**\n   * An extension of the \"same-value\" algorithm as [described for use by ES6 Map\n   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)\n   *\n   * NaN is considered the same as NaN, however -0 and 0 are considered the same\n   * value, which is different from the algorithm described by\n   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n   *\n   * This is extended further to allow Objects to describe the values they\n   * represent, by way of `valueOf` or `equals` (and `hashCode`).\n   *\n   * Note: because of this extension, the key equality of Immutable.Map and the\n   * value equality of Immutable.Set will differ from ES6 Map and Set.\n   *\n   * ### Defining custom values\n   *\n   * The easiest way to describe the value an object represents is by implementing\n   * `valueOf`. For example, `Date` represents a value by returning a unix\n   * timestamp for `valueOf`:\n   *\n   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...\n   *     var date2 = new Date(1234567890000);\n   *     date1.valueOf(); // 1234567890000\n   *     assert( date1 !== date2 );\n   *     assert( Immutable.is( date1, date2 ) );\n   *\n   * Note: overriding `valueOf` may have other implications if you use this object\n   * where JavaScript expects a primitive, such as implicit string coercion.\n   *\n   * For more complex types, especially collections, implementing `valueOf` may\n   * not be performant. An alternative is to implement `equals` and `hashCode`.\n   *\n   * `equals` takes another object, presumably of similar type, and returns true\n   * if it is equal. Equality is symmetrical, so the same result should be\n   * returned if this and the argument are flipped.\n   *\n   *     assert( a.equals(b) === b.equals(a) );\n   *\n   * `hashCode` returns a 32bit integer number representing the object which will\n   * be used to determine how to store the value object in a Map or Set. You must\n   * provide both or neither methods, one must not exist without the other.\n   *\n   * Also, an important relationship between these methods must be upheld: if two\n   * values are equal, they *must* return the same hashCode. If the values are not\n   * equal, they might have the same hashCode; this is called a hash collision,\n   * and while undesirable for performance reasons, it is acceptable.\n   *\n   *     if (a.equals(b)) {\n   *       assert( a.hashCode() === b.hashCode() );\n   *     }\n   *\n   * All Immutable collections are Value Objects: they implement `equals()`\n   * and `hashCode()`.\n   */\n  function is(valueA, valueB) {\n    if (valueA === valueB || valueA !== valueA && valueB !== valueB) {\n      return true;\n    }\n    if (!valueA || !valueB) {\n      return false;\n    }\n    if (typeof valueA.valueOf === 'function' && typeof valueB.valueOf === 'function') {\n      valueA = valueA.valueOf();\n      valueB = valueB.valueOf();\n      if (valueA === valueB || valueA !== valueA && valueB !== valueB) {\n        return true;\n      }\n      if (!valueA || !valueB) {\n        return false;\n      }\n    }\n    return !!(isValueObject(valueA) && isValueObject(valueB) && valueA.equals(valueB));\n  }\n\n  function fromJS(value, converter) {\n    return fromJSWith([], converter || defaultConverter, value, '', converter && converter.length > 2 ? [] : undefined, { '': value });\n  }\n\n  function fromJSWith(stack, converter, value, key, keyPath, parentValue) {\n    var toSeq = Array.isArray(value) ? IndexedSeq : isPlainObj(value) ? KeyedSeq : null;\n    if (toSeq) {\n      if (~stack.indexOf(value)) {\n        throw new TypeError('Cannot convert circular structure to Immutable');\n      }\n      stack.push(value);\n      keyPath && key !== '' && keyPath.push(key);\n      var converted = converter.call(parentValue, key, toSeq(value).map(function (v, k) {\n        return fromJSWith(stack, converter, v, k, keyPath, value);\n      }), keyPath && keyPath.slice());\n      stack.pop();\n      keyPath && keyPath.pop();\n      return converted;\n    }\n    return value;\n  }\n\n  function defaultConverter(k, v) {\n    return isKeyed(v) ? v.toMap() : v.toList();\n  }\n\n  function isPlainObj(value) {\n    return value && (value.constructor === Object || value.constructor === undefined);\n  }\n\n  var imul = typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ? Math.imul : function imul(a, b) {\n    a |= 0; // int\n    b |= 0; // int\n    var c = a & 0xffff;\n    var d = b & 0xffff;\n    // Shift by 0 fixes the sign on the high part.\n    return c * d + ((a >>> 16) * d + c * (b >>> 16) << 16 >>> 0) | 0; // int\n  };\n\n  // v8 has an optimization for storing 31-bit signed numbers.\n  // Values which have either 00 or 11 as the high order bits qualify.\n  // This function drops the highest order bit in a signed number, maintaining\n  // the sign bit.\n  function smi(i32) {\n    return i32 >>> 1 & 0x40000000 | i32 & 0xbfffffff;\n  }\n\n  function hash(o) {\n    if (o === false || o === null || o === undefined) {\n      return 0;\n    }\n    if (typeof o.valueOf === 'function') {\n      o = o.valueOf();\n      if (o === false || o === null || o === undefined) {\n        return 0;\n      }\n    }\n    if (o === true) {\n      return 1;\n    }\n    var type = typeof o;\n    if (type === 'number') {\n      if (o !== o || o === Infinity) {\n        return 0;\n      }\n      var h = o | 0;\n      if (h !== o) {\n        h ^= o * 0xffffffff;\n      }\n      while (o > 0xffffffff) {\n        o /= 0xffffffff;\n        h ^= o;\n      }\n      return smi(h);\n    }\n    if (type === 'string') {\n      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);\n    }\n    if (typeof o.hashCode === 'function') {\n      return o.hashCode();\n    }\n    if (type === 'object') {\n      return hashJSObj(o);\n    }\n    if (typeof o.toString === 'function') {\n      return hashString(o.toString());\n    }\n    throw new Error('Value type ' + type + ' cannot be hashed.');\n  }\n\n  function cachedHashString(string) {\n    var hash = stringHashCache[string];\n    if (hash === undefined) {\n      hash = hashString(string);\n      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {\n        STRING_HASH_CACHE_SIZE = 0;\n        stringHashCache = {};\n      }\n      STRING_HASH_CACHE_SIZE++;\n      stringHashCache[string] = hash;\n    }\n    return hash;\n  }\n\n  // http://jsperf.com/hashing-strings\n  function hashString(string) {\n    // This is the hash from JVM\n    // The hash code for a string is computed as\n    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\n    // where s[i] is the ith character of the string and n is the length of\n    // the string. We \"mod\" the result to make it between 0 (inclusive) and 2^31\n    // (exclusive) by dropping high bits.\n    var hash = 0;\n    for (var ii = 0; ii < string.length; ii++) {\n      hash = 31 * hash + string.charCodeAt(ii) | 0;\n    }\n    return smi(hash);\n  }\n\n  function hashJSObj(obj) {\n    var hash;\n    if (usingWeakMap) {\n      hash = weakMap.get(obj);\n      if (hash !== undefined) {\n        return hash;\n      }\n    }\n\n    hash = obj[UID_HASH_KEY];\n    if (hash !== undefined) {\n      return hash;\n    }\n\n    if (!canDefineProperty) {\n      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];\n      if (hash !== undefined) {\n        return hash;\n      }\n\n      hash = getIENodeHash(obj);\n      if (hash !== undefined) {\n        return hash;\n      }\n    }\n\n    hash = ++objHashUID;\n    if (objHashUID & 0x40000000) {\n      objHashUID = 0;\n    }\n\n    if (usingWeakMap) {\n      weakMap.set(obj, hash);\n    } else if (isExtensible !== undefined && isExtensible(obj) === false) {\n      throw new Error('Non-extensible objects are not allowed as keys.');\n    } else if (canDefineProperty) {\n      Object.defineProperty(obj, UID_HASH_KEY, {\n        enumerable: false,\n        configurable: false,\n        writable: false,\n        value: hash\n      });\n    } else if (obj.propertyIsEnumerable !== undefined && obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {\n      // Since we can't define a non-enumerable property on the object\n      // we'll hijack one of the less-used non-enumerable properties to\n      // save our hash on it. Since this is a function it will not show up in\n      // `JSON.stringify` which is what we want.\n      obj.propertyIsEnumerable = function () {\n        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);\n      };\n      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;\n    } else if (obj.nodeType !== undefined) {\n      // At this point we couldn't get the IE `uniqueID` to use as a hash\n      // and we couldn't use a non-enumerable property to exploit the\n      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node\n      // itself.\n      obj[UID_HASH_KEY] = hash;\n    } else {\n      throw new Error('Unable to set a non-enumerable property on object.');\n    }\n\n    return hash;\n  }\n\n  // Get references to ES5 object methods.\n  var isExtensible = Object.isExtensible;\n\n  // True if Object.defineProperty works as expected. IE8 fails this test.\n  var canDefineProperty = function () {\n    try {\n      Object.defineProperty({}, '@', {});\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }();\n\n  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it\n  // and avoid memory leaks from the IE cloneNode bug.\n  function getIENodeHash(node) {\n    if (node && node.nodeType > 0) {\n      switch (node.nodeType) {\n        case 1:\n          // Element\n          return node.uniqueID;\n        case 9:\n          // Document\n          return node.documentElement && node.documentElement.uniqueID;\n      }\n    }\n  }\n\n  // If possible, use a WeakMap.\n  var usingWeakMap = typeof WeakMap === 'function';\n  var weakMap;\n  if (usingWeakMap) {\n    weakMap = new WeakMap();\n  }\n\n  var objHashUID = 0;\n\n  var UID_HASH_KEY = '__immutablehash__';\n  if (typeof Symbol === 'function') {\n    UID_HASH_KEY = Symbol(UID_HASH_KEY);\n  }\n\n  var STRING_HASH_CACHE_MIN_STRLEN = 16;\n  var STRING_HASH_CACHE_MAX_SIZE = 255;\n  var STRING_HASH_CACHE_SIZE = 0;\n  var stringHashCache = {};\n\n  var ToKeyedSequence = function (KeyedSeq$$1) {\n    function ToKeyedSequence(indexed, useKeys) {\n      this._iter = indexed;\n      this._useKeys = useKeys;\n      this.size = indexed.size;\n    }\n\n    if (KeyedSeq$$1) ToKeyedSequence.__proto__ = KeyedSeq$$1;\n    ToKeyedSequence.prototype = Object.create(KeyedSeq$$1 && KeyedSeq$$1.prototype);\n    ToKeyedSequence.prototype.constructor = ToKeyedSequence;\n\n    ToKeyedSequence.prototype.get = function get(key, notSetValue) {\n      return this._iter.get(key, notSetValue);\n    };\n\n    ToKeyedSequence.prototype.has = function has(key) {\n      return this._iter.has(key);\n    };\n\n    ToKeyedSequence.prototype.valueSeq = function valueSeq() {\n      return this._iter.valueSeq();\n    };\n\n    ToKeyedSequence.prototype.reverse = function reverse() {\n      var this$1 = this;\n\n      var reversedSequence = reverseFactory(this, true);\n      if (!this._useKeys) {\n        reversedSequence.valueSeq = function () {\n          return this$1._iter.toSeq().reverse();\n        };\n      }\n      return reversedSequence;\n    };\n\n    ToKeyedSequence.prototype.map = function map(mapper, context) {\n      var this$1 = this;\n\n      var mappedSequence = mapFactory(this, mapper, context);\n      if (!this._useKeys) {\n        mappedSequence.valueSeq = function () {\n          return this$1._iter.toSeq().map(mapper, context);\n        };\n      }\n      return mappedSequence;\n    };\n\n    ToKeyedSequence.prototype.__iterate = function __iterate(fn, reverse) {\n      var this$1 = this;\n\n      return this._iter.__iterate(function (v, k) {\n        return fn(v, k, this$1);\n      }, reverse);\n    };\n\n    ToKeyedSequence.prototype.__iterator = function __iterator(type, reverse) {\n      return this._iter.__iterator(type, reverse);\n    };\n\n    return ToKeyedSequence;\n  }(KeyedSeq);\n  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;\n\n  var ToIndexedSequence = function (IndexedSeq$$1) {\n    function ToIndexedSequence(iter) {\n      this._iter = iter;\n      this.size = iter.size;\n    }\n\n    if (IndexedSeq$$1) ToIndexedSequence.__proto__ = IndexedSeq$$1;\n    ToIndexedSequence.prototype = Object.create(IndexedSeq$$1 && IndexedSeq$$1.prototype);\n    ToIndexedSequence.prototype.constructor = ToIndexedSequence;\n\n    ToIndexedSequence.prototype.includes = function includes(value) {\n      return this._iter.includes(value);\n    };\n\n    ToIndexedSequence.prototype.__iterate = function __iterate(fn, reverse) {\n      var this$1 = this;\n\n      var i = 0;\n      reverse && ensureSize(this);\n      return this._iter.__iterate(function (v) {\n        return fn(v, reverse ? this$1.size - ++i : i++, this$1);\n      }, reverse);\n    };\n\n    ToIndexedSequence.prototype.__iterator = function __iterator(type, reverse) {\n      var this$1 = this;\n\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      var i = 0;\n      reverse && ensureSize(this);\n      return new Iterator(function () {\n        var step = iterator.next();\n        return step.done ? step : iteratorValue(type, reverse ? this$1.size - ++i : i++, step.value, step);\n      });\n    };\n\n    return ToIndexedSequence;\n  }(IndexedSeq);\n\n  var ToSetSequence = function (SetSeq$$1) {\n    function ToSetSequence(iter) {\n      this._iter = iter;\n      this.size = iter.size;\n    }\n\n    if (SetSeq$$1) ToSetSequence.__proto__ = SetSeq$$1;\n    ToSetSequence.prototype = Object.create(SetSeq$$1 && SetSeq$$1.prototype);\n    ToSetSequence.prototype.constructor = ToSetSequence;\n\n    ToSetSequence.prototype.has = function has(key) {\n      return this._iter.includes(key);\n    };\n\n    ToSetSequence.prototype.__iterate = function __iterate(fn, reverse) {\n      var this$1 = this;\n\n      return this._iter.__iterate(function (v) {\n        return fn(v, v, this$1);\n      }, reverse);\n    };\n\n    ToSetSequence.prototype.__iterator = function __iterator(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      return new Iterator(function () {\n        var step = iterator.next();\n        return step.done ? step : iteratorValue(type, step.value, step.value, step);\n      });\n    };\n\n    return ToSetSequence;\n  }(SetSeq);\n\n  var FromEntriesSequence = function (KeyedSeq$$1) {\n    function FromEntriesSequence(entries) {\n      this._iter = entries;\n      this.size = entries.size;\n    }\n\n    if (KeyedSeq$$1) FromEntriesSequence.__proto__ = KeyedSeq$$1;\n    FromEntriesSequence.prototype = Object.create(KeyedSeq$$1 && KeyedSeq$$1.prototype);\n    FromEntriesSequence.prototype.constructor = FromEntriesSequence;\n\n    FromEntriesSequence.prototype.entrySeq = function entrySeq() {\n      return this._iter.toSeq();\n    };\n\n    FromEntriesSequence.prototype.__iterate = function __iterate(fn, reverse) {\n      var this$1 = this;\n\n      return this._iter.__iterate(function (entry) {\n        // Check if entry exists first so array access doesn't throw for holes\n        // in the parent iteration.\n        if (entry) {\n          validateEntry(entry);\n          var indexedCollection = isCollection(entry);\n          return fn(indexedCollection ? entry.get(1) : entry[1], indexedCollection ? entry.get(0) : entry[0], this$1);\n        }\n      }, reverse);\n    };\n\n    FromEntriesSequence.prototype.__iterator = function __iterator(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      return new Iterator(function () {\n        while (true) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          var entry = step.value;\n          // Check if entry exists first so array access doesn't throw for holes\n          // in the parent iteration.\n          if (entry) {\n            validateEntry(entry);\n            var indexedCollection = isCollection(entry);\n            return iteratorValue(type, indexedCollection ? entry.get(0) : entry[0], indexedCollection ? entry.get(1) : entry[1], step);\n          }\n        }\n      });\n    };\n\n    return FromEntriesSequence;\n  }(KeyedSeq);\n\n  ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;\n\n  function flipFactory(collection) {\n    var flipSequence = makeSequence(collection);\n    flipSequence._iter = collection;\n    flipSequence.size = collection.size;\n    flipSequence.flip = function () {\n      return collection;\n    };\n    flipSequence.reverse = function () {\n      var reversedSequence = collection.reverse.apply(this); // super.reverse()\n      reversedSequence.flip = function () {\n        return collection.reverse();\n      };\n      return reversedSequence;\n    };\n    flipSequence.has = function (key) {\n      return collection.includes(key);\n    };\n    flipSequence.includes = function (key) {\n      return collection.has(key);\n    };\n    flipSequence.cacheResult = cacheResultThrough;\n    flipSequence.__iterateUncached = function (fn, reverse) {\n      var this$1 = this;\n\n      return collection.__iterate(function (v, k) {\n        return fn(k, v, this$1) !== false;\n      }, reverse);\n    };\n    flipSequence.__iteratorUncached = function (type, reverse) {\n      if (type === ITERATE_ENTRIES) {\n        var iterator = collection.__iterator(type, reverse);\n        return new Iterator(function () {\n          var step = iterator.next();\n          if (!step.done) {\n            var k = step.value[0];\n            step.value[0] = step.value[1];\n            step.value[1] = k;\n          }\n          return step;\n        });\n      }\n      return collection.__iterator(type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES, reverse);\n    };\n    return flipSequence;\n  }\n\n  function mapFactory(collection, mapper, context) {\n    var mappedSequence = makeSequence(collection);\n    mappedSequence.size = collection.size;\n    mappedSequence.has = function (key) {\n      return collection.has(key);\n    };\n    mappedSequence.get = function (key, notSetValue) {\n      var v = collection.get(key, NOT_SET);\n      return v === NOT_SET ? notSetValue : mapper.call(context, v, key, collection);\n    };\n    mappedSequence.__iterateUncached = function (fn, reverse) {\n      var this$1 = this;\n\n      return collection.__iterate(function (v, k, c) {\n        return fn(mapper.call(context, v, k, c), k, this$1) !== false;\n      }, reverse);\n    };\n    mappedSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n      return new Iterator(function () {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var key = entry[0];\n        return iteratorValue(type, key, mapper.call(context, entry[1], key, collection), step);\n      });\n    };\n    return mappedSequence;\n  }\n\n  function reverseFactory(collection, useKeys) {\n    var this$1 = this;\n\n    var reversedSequence = makeSequence(collection);\n    reversedSequence._iter = collection;\n    reversedSequence.size = collection.size;\n    reversedSequence.reverse = function () {\n      return collection;\n    };\n    if (collection.flip) {\n      reversedSequence.flip = function () {\n        var flipSequence = flipFactory(collection);\n        flipSequence.reverse = function () {\n          return collection.flip();\n        };\n        return flipSequence;\n      };\n    }\n    reversedSequence.get = function (key, notSetValue) {\n      return collection.get(useKeys ? key : -1 - key, notSetValue);\n    };\n    reversedSequence.has = function (key) {\n      return collection.has(useKeys ? key : -1 - key);\n    };\n    reversedSequence.includes = function (value) {\n      return collection.includes(value);\n    };\n    reversedSequence.cacheResult = cacheResultThrough;\n    reversedSequence.__iterate = function (fn, reverse) {\n      var this$1 = this;\n\n      var i = 0;\n      reverse && ensureSize(collection);\n      return collection.__iterate(function (v, k) {\n        return fn(v, useKeys ? k : reverse ? this$1.size - ++i : i++, this$1);\n      }, !reverse);\n    };\n    reversedSequence.__iterator = function (type, reverse) {\n      var i = 0;\n      reverse && ensureSize(collection);\n      var iterator = collection.__iterator(ITERATE_ENTRIES, !reverse);\n      return new Iterator(function () {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        return iteratorValue(type, useKeys ? entry[0] : reverse ? this$1.size - ++i : i++, entry[1], step);\n      });\n    };\n    return reversedSequence;\n  }\n\n  function filterFactory(collection, predicate, context, useKeys) {\n    var filterSequence = makeSequence(collection);\n    if (useKeys) {\n      filterSequence.has = function (key) {\n        var v = collection.get(key, NOT_SET);\n        return v !== NOT_SET && !!predicate.call(context, v, key, collection);\n      };\n      filterSequence.get = function (key, notSetValue) {\n        var v = collection.get(key, NOT_SET);\n        return v !== NOT_SET && predicate.call(context, v, key, collection) ? v : notSetValue;\n      };\n    }\n    filterSequence.__iterateUncached = function (fn, reverse) {\n      var this$1 = this;\n\n      var iterations = 0;\n      collection.__iterate(function (v, k, c) {\n        if (predicate.call(context, v, k, c)) {\n          return fn(v, useKeys ? k : iterations++, this$1);\n        }\n      }, reverse);\n      return iterations;\n    };\n    filterSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n      var iterations = 0;\n      return new Iterator(function () {\n        while (true) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          var entry = step.value;\n          var key = entry[0];\n          var value = entry[1];\n          if (predicate.call(context, value, key, collection)) {\n            return iteratorValue(type, useKeys ? key : iterations++, value, step);\n          }\n        }\n      });\n    };\n    return filterSequence;\n  }\n\n  function countByFactory(collection, grouper, context) {\n    var groups = Map().asMutable();\n    collection.__iterate(function (v, k) {\n      groups.update(grouper.call(context, v, k, collection), 0, function (a) {\n        return a + 1;\n      });\n    });\n    return groups.asImmutable();\n  }\n\n  function groupByFactory(collection, grouper, context) {\n    var isKeyedIter = isKeyed(collection);\n    var groups = (isOrdered(collection) ? OrderedMap() : Map()).asMutable();\n    collection.__iterate(function (v, k) {\n      groups.update(grouper.call(context, v, k, collection), function (a) {\n        return a = a || [], a.push(isKeyedIter ? [k, v] : v), a;\n      });\n    });\n    var coerce = collectionClass(collection);\n    return groups.map(function (arr) {\n      return reify(collection, coerce(arr));\n    });\n  }\n\n  function sliceFactory(collection, begin, end, useKeys) {\n    var originalSize = collection.size;\n\n    if (wholeSlice(begin, end, originalSize)) {\n      return collection;\n    }\n\n    var resolvedBegin = resolveBegin(begin, originalSize);\n    var resolvedEnd = resolveEnd(end, originalSize);\n\n    // begin or end will be NaN if they were provided as negative numbers and\n    // this collection's size is unknown. In that case, cache first so there is\n    // a known size and these do not resolve to NaN.\n    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {\n      return sliceFactory(collection.toSeq().cacheResult(), begin, end, useKeys);\n    }\n\n    // Note: resolvedEnd is undefined when the original sequence's length is\n    // unknown and this slice did not supply an end and should contain all\n    // elements after resolvedBegin.\n    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.\n    var resolvedSize = resolvedEnd - resolvedBegin;\n    var sliceSize;\n    if (resolvedSize === resolvedSize) {\n      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;\n    }\n\n    var sliceSeq = makeSequence(collection);\n\n    // If collection.size is undefined, the size of the realized sliceSeq is\n    // unknown at this point unless the number of items to slice is 0\n    sliceSeq.size = sliceSize === 0 ? sliceSize : collection.size && sliceSize || undefined;\n\n    if (!useKeys && isSeq(collection) && sliceSize >= 0) {\n      sliceSeq.get = function (index, notSetValue) {\n        index = wrapIndex(this, index);\n        return index >= 0 && index < sliceSize ? collection.get(index + resolvedBegin, notSetValue) : notSetValue;\n      };\n    }\n\n    sliceSeq.__iterateUncached = function (fn, reverse) {\n      var this$1 = this;\n\n      if (sliceSize === 0) {\n        return 0;\n      }\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var skipped = 0;\n      var isSkipping = true;\n      var iterations = 0;\n      collection.__iterate(function (v, k) {\n        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$1) !== false && iterations !== sliceSize;\n        }\n      });\n      return iterations;\n    };\n\n    sliceSeq.__iteratorUncached = function (type, reverse) {\n      if (sliceSize !== 0 && reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      // Don't bother instantiating parent iterator if taking 0.\n      var iterator = sliceSize !== 0 && collection.__iterator(type, reverse);\n      var skipped = 0;\n      var iterations = 0;\n      return new Iterator(function () {\n        while (skipped++ < resolvedBegin) {\n          iterator.next();\n        }\n        if (++iterations > sliceSize) {\n          return iteratorDone();\n        }\n        var step = iterator.next();\n        if (useKeys || type === ITERATE_VALUES) {\n          return step;\n        }\n        if (type === ITERATE_KEYS) {\n          return iteratorValue(type, iterations - 1, undefined, step);\n        }\n        return iteratorValue(type, iterations - 1, step.value[1], step);\n      });\n    };\n\n    return sliceSeq;\n  }\n\n  function takeWhileFactory(collection, predicate, context) {\n    var takeSequence = makeSequence(collection);\n    takeSequence.__iterateUncached = function (fn, reverse) {\n      var this$1 = this;\n\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterations = 0;\n      collection.__iterate(function (v, k, c) {\n        return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$1);\n      });\n      return iterations;\n    };\n    takeSequence.__iteratorUncached = function (type, reverse) {\n      var this$1 = this;\n\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n      var iterating = true;\n      return new Iterator(function () {\n        if (!iterating) {\n          return iteratorDone();\n        }\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var k = entry[0];\n        var v = entry[1];\n        if (!predicate.call(context, v, k, this$1)) {\n          iterating = false;\n          return iteratorDone();\n        }\n        return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);\n      });\n    };\n    return takeSequence;\n  }\n\n  function skipWhileFactory(collection, predicate, context, useKeys) {\n    var skipSequence = makeSequence(collection);\n    skipSequence.__iterateUncached = function (fn, reverse) {\n      var this$1 = this;\n\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var isSkipping = true;\n      var iterations = 0;\n      collection.__iterate(function (v, k, c) {\n        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$1);\n        }\n      });\n      return iterations;\n    };\n    skipSequence.__iteratorUncached = function (type, reverse) {\n      var this$1 = this;\n\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n      var skipping = true;\n      var iterations = 0;\n      return new Iterator(function () {\n        var step;\n        var k;\n        var v;\n        do {\n          step = iterator.next();\n          if (step.done) {\n            if (useKeys || type === ITERATE_VALUES) {\n              return step;\n            }\n            if (type === ITERATE_KEYS) {\n              return iteratorValue(type, iterations++, undefined, step);\n            }\n            return iteratorValue(type, iterations++, step.value[1], step);\n          }\n          var entry = step.value;\n          k = entry[0];\n          v = entry[1];\n          skipping && (skipping = predicate.call(context, v, k, this$1));\n        } while (skipping);\n        return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);\n      });\n    };\n    return skipSequence;\n  }\n\n  function concatFactory(collection, values) {\n    var isKeyedCollection = isKeyed(collection);\n    var iters = [collection].concat(values).map(function (v) {\n      if (!isCollection(v)) {\n        v = isKeyedCollection ? keyedSeqFromValue(v) : indexedSeqFromValue(Array.isArray(v) ? v : [v]);\n      } else if (isKeyedCollection) {\n        v = KeyedCollection(v);\n      }\n      return v;\n    }).filter(function (v) {\n      return v.size !== 0;\n    });\n\n    if (iters.length === 0) {\n      return collection;\n    }\n\n    if (iters.length === 1) {\n      var singleton = iters[0];\n      if (singleton === collection || isKeyedCollection && isKeyed(singleton) || isIndexed(collection) && isIndexed(singleton)) {\n        return singleton;\n      }\n    }\n\n    var concatSeq = new ArraySeq(iters);\n    if (isKeyedCollection) {\n      concatSeq = concatSeq.toKeyedSeq();\n    } else if (!isIndexed(collection)) {\n      concatSeq = concatSeq.toSetSeq();\n    }\n    concatSeq = concatSeq.flatten(true);\n    concatSeq.size = iters.reduce(function (sum, seq) {\n      if (sum !== undefined) {\n        var size = seq.size;\n        if (size !== undefined) {\n          return sum + size;\n        }\n      }\n    }, 0);\n    return concatSeq;\n  }\n\n  function flattenFactory(collection, depth, useKeys) {\n    var flatSequence = makeSequence(collection);\n    flatSequence.__iterateUncached = function (fn, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterations = 0;\n      var stopped = false;\n      function flatDeep(iter, currentDepth) {\n        iter.__iterate(function (v, k) {\n          if ((!depth || currentDepth < depth) && isCollection(v)) {\n            flatDeep(v, currentDepth + 1);\n          } else if (fn(v, useKeys ? k : iterations++, flatSequence) === false) {\n            stopped = true;\n          }\n          return !stopped;\n        }, reverse);\n      }\n      flatDeep(collection, 0);\n      return iterations;\n    };\n    flatSequence.__iteratorUncached = function (type, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = collection.__iterator(type, reverse);\n      var stack = [];\n      var iterations = 0;\n      return new Iterator(function () {\n        while (iterator) {\n          var step = iterator.next();\n          if (step.done !== false) {\n            iterator = stack.pop();\n            continue;\n          }\n          var v = step.value;\n          if (type === ITERATE_ENTRIES) {\n            v = v[1];\n          }\n          if ((!depth || stack.length < depth) && isCollection(v)) {\n            stack.push(iterator);\n            iterator = v.__iterator(type, reverse);\n          } else {\n            return useKeys ? step : iteratorValue(type, iterations++, v, step);\n          }\n        }\n        return iteratorDone();\n      });\n    };\n    return flatSequence;\n  }\n\n  function flatMapFactory(collection, mapper, context) {\n    var coerce = collectionClass(collection);\n    return collection.toSeq().map(function (v, k) {\n      return coerce(mapper.call(context, v, k, collection));\n    }).flatten(true);\n  }\n\n  function interposeFactory(collection, separator) {\n    var interposedSequence = makeSequence(collection);\n    interposedSequence.size = collection.size && collection.size * 2 - 1;\n    interposedSequence.__iterateUncached = function (fn, reverse) {\n      var this$1 = this;\n\n      var iterations = 0;\n      collection.__iterate(function (v) {\n        return (!iterations || fn(separator, iterations++, this$1) !== false) && fn(v, iterations++, this$1) !== false;\n      }, reverse);\n      return iterations;\n    };\n    interposedSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = collection.__iterator(ITERATE_VALUES, reverse);\n      var iterations = 0;\n      var step;\n      return new Iterator(function () {\n        if (!step || iterations % 2) {\n          step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n        }\n        return iterations % 2 ? iteratorValue(type, iterations++, separator) : iteratorValue(type, iterations++, step.value, step);\n      });\n    };\n    return interposedSequence;\n  }\n\n  function sortFactory(collection, comparator, mapper) {\n    if (!comparator) {\n      comparator = defaultComparator;\n    }\n    var isKeyedCollection = isKeyed(collection);\n    var index = 0;\n    var entries = collection.toSeq().map(function (v, k) {\n      return [k, v, index++, mapper ? mapper(v, k, collection) : v];\n    }).toArray();\n    entries.sort(function (a, b) {\n      return comparator(a[3], b[3]) || a[2] - b[2];\n    }).forEach(isKeyedCollection ? function (v, i) {\n      entries[i].length = 2;\n    } : function (v, i) {\n      entries[i] = v[1];\n    });\n    return isKeyedCollection ? KeyedSeq(entries) : isIndexed(collection) ? IndexedSeq(entries) : SetSeq(entries);\n  }\n\n  function maxFactory(collection, comparator, mapper) {\n    if (!comparator) {\n      comparator = defaultComparator;\n    }\n    if (mapper) {\n      var entry = collection.toSeq().map(function (v, k) {\n        return [v, mapper(v, k, collection)];\n      }).reduce(function (a, b) {\n        return maxCompare(comparator, a[1], b[1]) ? b : a;\n      });\n      return entry && entry[0];\n    }\n    return collection.reduce(function (a, b) {\n      return maxCompare(comparator, a, b) ? b : a;\n    });\n  }\n\n  function maxCompare(comparator, a, b) {\n    var comp = comparator(b, a);\n    // b is considered the new max if the comparator declares them equal, but\n    // they are not equal and b is in fact a nullish value.\n    return comp === 0 && b !== a && (b === undefined || b === null || b !== b) || comp > 0;\n  }\n\n  function zipWithFactory(keyIter, zipper, iters) {\n    var zipSequence = makeSequence(keyIter);\n    zipSequence.size = new ArraySeq(iters).map(function (i) {\n      return i.size;\n    }).min();\n    // Note: this a generic base implementation of __iterate in terms of\n    // __iterator which may be more generically useful in the future.\n    zipSequence.__iterate = function (fn, reverse) {\n      var this$1 = this;\n\n      /* generic:\n      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);\n      var step;\n      var iterations = 0;\n      while (!(step = iterator.next()).done) {\n        iterations++;\n        if (fn(step.value[1], step.value[0], this) === false) {\n          break;\n        }\n      }\n      return iterations;\n      */\n      // indexed:\n      var iterator = this.__iterator(ITERATE_VALUES, reverse);\n      var step;\n      var iterations = 0;\n      while (!(step = iterator.next()).done) {\n        if (fn(step.value, iterations++, this$1) === false) {\n          break;\n        }\n      }\n      return iterations;\n    };\n    zipSequence.__iteratorUncached = function (type, reverse) {\n      var iterators = iters.map(function (i) {\n        return i = Collection(i), getIterator(reverse ? i.reverse() : i);\n      });\n      var iterations = 0;\n      var isDone = false;\n      return new Iterator(function () {\n        var steps;\n        if (!isDone) {\n          steps = iterators.map(function (i) {\n            return i.next();\n          });\n          isDone = steps.some(function (s) {\n            return s.done;\n          });\n        }\n        if (isDone) {\n          return iteratorDone();\n        }\n        return iteratorValue(type, iterations++, zipper.apply(null, steps.map(function (s) {\n          return s.value;\n        })));\n      });\n    };\n    return zipSequence;\n  }\n\n  // #pragma Helper Functions\n\n  function reify(iter, seq) {\n    return iter === seq ? iter : isSeq(iter) ? seq : iter.constructor(seq);\n  }\n\n  function validateEntry(entry) {\n    if (entry !== Object(entry)) {\n      throw new TypeError('Expected [K, V] tuple: ' + entry);\n    }\n  }\n\n  function collectionClass(collection) {\n    return isKeyed(collection) ? KeyedCollection : isIndexed(collection) ? IndexedCollection : SetCollection;\n  }\n\n  function makeSequence(collection) {\n    return Object.create((isKeyed(collection) ? KeyedSeq : isIndexed(collection) ? IndexedSeq : SetSeq).prototype);\n  }\n\n  function cacheResultThrough() {\n    if (this._iter.cacheResult) {\n      this._iter.cacheResult();\n      this.size = this._iter.size;\n      return this;\n    }\n    return Seq.prototype.cacheResult.call(this);\n  }\n\n  function defaultComparator(a, b) {\n    if (a === undefined && b === undefined) {\n      return 0;\n    }\n\n    if (a === undefined) {\n      return 1;\n    }\n\n    if (b === undefined) {\n      return -1;\n    }\n\n    return a > b ? 1 : a < b ? -1 : 0;\n  }\n\n  function coerceKeyPath(keyPath) {\n    if (isArrayLike(keyPath) && typeof keyPath !== 'string') {\n      return keyPath;\n    }\n    if (isOrdered(keyPath)) {\n      return keyPath.toArray();\n    }\n    throw new TypeError('Invalid keyPath: expected Ordered Collection or Array: ' + keyPath);\n  }\n\n  function invariant(condition, error) {\n    if (!condition) {\n      throw new Error(error);\n    }\n  }\n\n  function assertNotInfinite(size) {\n    invariant(size !== Infinity, 'Cannot perform this action with an infinite size.');\n  }\n\n  /**\n   * Converts a value to a string, adding quotes if a string was provided.\n   */\n  function quoteString(value) {\n    return typeof value === 'string' ? JSON.stringify(value) : String(value);\n  }\n\n  var Map = function (KeyedCollection$$1) {\n    function Map(value) {\n      return value === null || value === undefined ? emptyMap() : isMap(value) && !isOrdered(value) ? value : emptyMap().withMutations(function (map) {\n        var iter = KeyedCollection$$1(value);\n        assertNotInfinite(iter.size);\n        iter.forEach(function (v, k) {\n          return map.set(k, v);\n        });\n      });\n    }\n\n    if (KeyedCollection$$1) Map.__proto__ = KeyedCollection$$1;\n    Map.prototype = Object.create(KeyedCollection$$1 && KeyedCollection$$1.prototype);\n    Map.prototype.constructor = Map;\n\n    Map.of = function of() {\n      var keyValues = [],\n          len = arguments.length;\n      while (len--) {\n        keyValues[len] = arguments[len];\n      }return emptyMap().withMutations(function (map) {\n        for (var i = 0; i < keyValues.length; i += 2) {\n          if (i + 1 >= keyValues.length) {\n            throw new Error('Missing value for key: ' + keyValues[i]);\n          }\n          map.set(keyValues[i], keyValues[i + 1]);\n        }\n      });\n    };\n\n    Map.prototype.toString = function toString() {\n      return this.__toString('Map {', '}');\n    };\n\n    // @pragma Access\n\n    Map.prototype.get = function get(k, notSetValue) {\n      return this._root ? this._root.get(0, undefined, k, notSetValue) : notSetValue;\n    };\n\n    // @pragma Modification\n\n    Map.prototype.set = function set(k, v) {\n      return updateMap(this, k, v);\n    };\n\n    Map.prototype.setIn = function setIn(keyPath, v) {\n      return this.updateIn(keyPath, NOT_SET, function () {\n        return v;\n      });\n    };\n\n    Map.prototype.remove = function remove(k) {\n      return updateMap(this, k, NOT_SET);\n    };\n\n    Map.prototype.deleteIn = function deleteIn(keyPath) {\n      keyPath = [].concat(coerceKeyPath(keyPath));\n      if (keyPath.length) {\n        var lastKey = keyPath.pop();\n        return this.updateIn(keyPath, function (c) {\n          return c && c.remove(lastKey);\n        });\n      }\n    };\n\n    Map.prototype.deleteAll = function deleteAll(keys) {\n      var collection = Collection(keys);\n\n      if (collection.size === 0) {\n        return this;\n      }\n\n      return this.withMutations(function (map) {\n        collection.forEach(function (key) {\n          return map.remove(key);\n        });\n      });\n    };\n\n    Map.prototype.update = function update(k, notSetValue, updater) {\n      return arguments.length === 1 ? k(this) : this.updateIn([k], notSetValue, updater);\n    };\n\n    Map.prototype.updateIn = function updateIn(keyPath, notSetValue, updater) {\n      if (!updater) {\n        updater = notSetValue;\n        notSetValue = undefined;\n      }\n      var updatedValue = updateInDeepMap(this, coerceKeyPath(keyPath), 0, notSetValue, updater);\n      return updatedValue === NOT_SET ? notSetValue : updatedValue;\n    };\n\n    Map.prototype.clear = function clear() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._root = null;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyMap();\n    };\n\n    // @pragma Composition\n\n    Map.prototype.merge = function merge() /*...iters*/{\n      return mergeIntoMapWith(this, undefined, arguments);\n    };\n\n    Map.prototype.mergeWith = function mergeWith(merger) {\n      var iters = [],\n          len = arguments.length - 1;\n      while (len-- > 0) {\n        iters[len] = arguments[len + 1];\n      }return mergeIntoMapWith(this, merger, iters);\n    };\n\n    Map.prototype.mergeIn = function mergeIn(keyPath) {\n      var iters = [],\n          len = arguments.length - 1;\n      while (len-- > 0) {\n        iters[len] = arguments[len + 1];\n      }return this.updateIn(keyPath, emptyMap(), function (m) {\n        return typeof m.merge === 'function' ? m.merge.apply(m, iters) : iters[iters.length - 1];\n      });\n    };\n\n    Map.prototype.mergeDeep = function mergeDeep() /*...iters*/{\n      return mergeIntoMapWith(this, deepMerger, arguments);\n    };\n\n    Map.prototype.mergeDeepWith = function mergeDeepWith(merger) {\n      var iters = [],\n          len = arguments.length - 1;\n      while (len-- > 0) {\n        iters[len] = arguments[len + 1];\n      }return mergeIntoMapWith(this, deepMergerWith(merger), iters);\n    };\n\n    Map.prototype.mergeDeepIn = function mergeDeepIn(keyPath) {\n      var iters = [],\n          len = arguments.length - 1;\n      while (len-- > 0) {\n        iters[len] = arguments[len + 1];\n      }return this.updateIn(keyPath, emptyMap(), function (m) {\n        return typeof m.mergeDeep === 'function' ? m.mergeDeep.apply(m, iters) : iters[iters.length - 1];\n      });\n    };\n\n    Map.prototype.sort = function sort(comparator) {\n      // Late binding\n      return OrderedMap(sortFactory(this, comparator));\n    };\n\n    Map.prototype.sortBy = function sortBy(mapper, comparator) {\n      // Late binding\n      return OrderedMap(sortFactory(this, comparator, mapper));\n    };\n\n    // @pragma Mutability\n\n    Map.prototype.withMutations = function withMutations(fn) {\n      var mutable = this.asMutable();\n      fn(mutable);\n      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;\n    };\n\n    Map.prototype.asMutable = function asMutable() {\n      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());\n    };\n\n    Map.prototype.asImmutable = function asImmutable() {\n      return this.__ensureOwner();\n    };\n\n    Map.prototype.wasAltered = function wasAltered() {\n      return this.__altered;\n    };\n\n    Map.prototype.__iterator = function __iterator(type, reverse) {\n      return new MapIterator(this, type, reverse);\n    };\n\n    Map.prototype.__iterate = function __iterate(fn, reverse) {\n      var this$1 = this;\n\n      var iterations = 0;\n      this._root && this._root.iterate(function (entry) {\n        iterations++;\n        return fn(entry[1], entry[0], this$1);\n      }, reverse);\n      return iterations;\n    };\n\n    Map.prototype.__ensureOwner = function __ensureOwner(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        if (this.size === 0) {\n          return emptyMap();\n        }\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeMap(this.size, this._root, ownerID, this.__hash);\n    };\n\n    return Map;\n  }(KeyedCollection);\n\n  function isMap(maybeMap) {\n    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);\n  }\n\n  Map.isMap = isMap;\n\n  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';\n\n  var MapPrototype = Map.prototype;\n  MapPrototype[IS_MAP_SENTINEL] = true;\n  MapPrototype[DELETE] = MapPrototype.remove;\n  MapPrototype.removeIn = MapPrototype.deleteIn;\n  MapPrototype.removeAll = MapPrototype.deleteAll;\n\n  // #pragma Trie Nodes\n\n  var ArrayMapNode = function ArrayMapNode(ownerID, entries) {\n    this.ownerID = ownerID;\n    this.entries = entries;\n  };\n\n  ArrayMapNode.prototype.get = function get(shift, keyHash, key, notSetValue) {\n    var entries = this.entries;\n    for (var ii = 0, len = entries.length; ii < len; ii++) {\n      if (is(key, entries[ii][0])) {\n        return entries[ii][1];\n      }\n    }\n    return notSetValue;\n  };\n\n  ArrayMapNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    var removed = value === NOT_SET;\n\n    var entries = this.entries;\n    var idx = 0;\n    var len = entries.length;\n    for (; idx < len; idx++) {\n      if (is(key, entries[idx][0])) {\n        break;\n      }\n    }\n    var exists = idx < len;\n\n    if (exists ? entries[idx][1] === value : removed) {\n      return this;\n    }\n\n    SetRef(didAlter);\n    (removed || !exists) && SetRef(didChangeSize);\n\n    if (removed && entries.length === 1) {\n      return; // undefined\n    }\n\n    if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {\n      return createNodes(ownerID, entries, key, value);\n    }\n\n    var isEditable = ownerID && ownerID === this.ownerID;\n    var newEntries = isEditable ? entries : arrCopy(entries);\n\n    if (exists) {\n      if (removed) {\n        idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();\n      } else {\n        newEntries[idx] = [key, value];\n      }\n    } else {\n      newEntries.push([key, value]);\n    }\n\n    if (isEditable) {\n      this.entries = newEntries;\n      return this;\n    }\n\n    return new ArrayMapNode(ownerID, newEntries);\n  };\n\n  var BitmapIndexedNode = function BitmapIndexedNode(ownerID, bitmap, nodes) {\n    this.ownerID = ownerID;\n    this.bitmap = bitmap;\n    this.nodes = nodes;\n  };\n\n  BitmapIndexedNode.prototype.get = function get(shift, keyHash, key, notSetValue) {\n    if (keyHash === undefined) {\n      keyHash = hash(key);\n    }\n    var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);\n    var bitmap = this.bitmap;\n    return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & bit - 1)].get(shift + SHIFT, keyHash, key, notSetValue);\n  };\n\n  BitmapIndexedNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (keyHash === undefined) {\n      keyHash = hash(key);\n    }\n    var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n    var bit = 1 << keyHashFrag;\n    var bitmap = this.bitmap;\n    var exists = (bitmap & bit) !== 0;\n\n    if (!exists && value === NOT_SET) {\n      return this;\n    }\n\n    var idx = popCount(bitmap & bit - 1);\n    var nodes = this.nodes;\n    var node = exists ? nodes[idx] : undefined;\n    var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n\n    if (newNode === node) {\n      return this;\n    }\n\n    if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {\n      return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);\n    }\n\n    if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {\n      return nodes[idx ^ 1];\n    }\n\n    if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {\n      return newNode;\n    }\n\n    var isEditable = ownerID && ownerID === this.ownerID;\n    var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;\n    var newNodes = exists ? newNode ? setIn(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);\n\n    if (isEditable) {\n      this.bitmap = newBitmap;\n      this.nodes = newNodes;\n      return this;\n    }\n\n    return new BitmapIndexedNode(ownerID, newBitmap, newNodes);\n  };\n\n  var HashArrayMapNode = function HashArrayMapNode(ownerID, count, nodes) {\n    this.ownerID = ownerID;\n    this.count = count;\n    this.nodes = nodes;\n  };\n\n  HashArrayMapNode.prototype.get = function get(shift, keyHash, key, notSetValue) {\n    if (keyHash === undefined) {\n      keyHash = hash(key);\n    }\n    var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n    var node = this.nodes[idx];\n    return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;\n  };\n\n  HashArrayMapNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (keyHash === undefined) {\n      keyHash = hash(key);\n    }\n    var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n    var removed = value === NOT_SET;\n    var nodes = this.nodes;\n    var node = nodes[idx];\n\n    if (removed && !node) {\n      return this;\n    }\n\n    var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n    if (newNode === node) {\n      return this;\n    }\n\n    var newCount = this.count;\n    if (!node) {\n      newCount++;\n    } else if (!newNode) {\n      newCount--;\n      if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {\n        return packNodes(ownerID, nodes, newCount, idx);\n      }\n    }\n\n    var isEditable = ownerID && ownerID === this.ownerID;\n    var newNodes = setIn(nodes, idx, newNode, isEditable);\n\n    if (isEditable) {\n      this.count = newCount;\n      this.nodes = newNodes;\n      return this;\n    }\n\n    return new HashArrayMapNode(ownerID, newCount, newNodes);\n  };\n\n  var HashCollisionNode = function HashCollisionNode(ownerID, keyHash, entries) {\n    this.ownerID = ownerID;\n    this.keyHash = keyHash;\n    this.entries = entries;\n  };\n\n  HashCollisionNode.prototype.get = function get(shift, keyHash, key, notSetValue) {\n    var entries = this.entries;\n    for (var ii = 0, len = entries.length; ii < len; ii++) {\n      if (is(key, entries[ii][0])) {\n        return entries[ii][1];\n      }\n    }\n    return notSetValue;\n  };\n\n  HashCollisionNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (keyHash === undefined) {\n      keyHash = hash(key);\n    }\n\n    var removed = value === NOT_SET;\n\n    if (keyHash !== this.keyHash) {\n      if (removed) {\n        return this;\n      }\n      SetRef(didAlter);\n      SetRef(didChangeSize);\n      return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);\n    }\n\n    var entries = this.entries;\n    var idx = 0;\n    var len = entries.length;\n    for (; idx < len; idx++) {\n      if (is(key, entries[idx][0])) {\n        break;\n      }\n    }\n    var exists = idx < len;\n\n    if (exists ? entries[idx][1] === value : removed) {\n      return this;\n    }\n\n    SetRef(didAlter);\n    (removed || !exists) && SetRef(didChangeSize);\n\n    if (removed && len === 2) {\n      return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);\n    }\n\n    var isEditable = ownerID && ownerID === this.ownerID;\n    var newEntries = isEditable ? entries : arrCopy(entries);\n\n    if (exists) {\n      if (removed) {\n        idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();\n      } else {\n        newEntries[idx] = [key, value];\n      }\n    } else {\n      newEntries.push([key, value]);\n    }\n\n    if (isEditable) {\n      this.entries = newEntries;\n      return this;\n    }\n\n    return new HashCollisionNode(ownerID, this.keyHash, newEntries);\n  };\n\n  var ValueNode = function ValueNode(ownerID, keyHash, entry) {\n    this.ownerID = ownerID;\n    this.keyHash = keyHash;\n    this.entry = entry;\n  };\n\n  ValueNode.prototype.get = function get(shift, keyHash, key, notSetValue) {\n    return is(key, this.entry[0]) ? this.entry[1] : notSetValue;\n  };\n\n  ValueNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    var removed = value === NOT_SET;\n    var keyMatch = is(key, this.entry[0]);\n    if (keyMatch ? value === this.entry[1] : removed) {\n      return this;\n    }\n\n    SetRef(didAlter);\n\n    if (removed) {\n      SetRef(didChangeSize);\n      return; // undefined\n    }\n\n    if (keyMatch) {\n      if (ownerID && ownerID === this.ownerID) {\n        this.entry[1] = value;\n        return this;\n      }\n      return new ValueNode(ownerID, this.keyHash, [key, value]);\n    }\n\n    SetRef(didChangeSize);\n    return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);\n  };\n\n  // #pragma Iterators\n\n  ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function (fn, reverse) {\n    var entries = this.entries;\n    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {\n      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {\n        return false;\n      }\n    }\n  };\n\n  BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function (fn, reverse) {\n    var nodes = this.nodes;\n    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {\n      var node = nodes[reverse ? maxIndex - ii : ii];\n      if (node && node.iterate(fn, reverse) === false) {\n        return false;\n      }\n    }\n  };\n\n  // eslint-disable-next-line no-unused-vars\n  ValueNode.prototype.iterate = function (fn, reverse) {\n    return fn(this.entry);\n  };\n\n  var MapIterator = function (Iterator$$1) {\n    function MapIterator(map, type, reverse) {\n      this._type = type;\n      this._reverse = reverse;\n      this._stack = map._root && mapIteratorFrame(map._root);\n    }\n\n    if (Iterator$$1) MapIterator.__proto__ = Iterator$$1;\n    MapIterator.prototype = Object.create(Iterator$$1 && Iterator$$1.prototype);\n    MapIterator.prototype.constructor = MapIterator;\n\n    MapIterator.prototype.next = function next() {\n      var this$1 = this;\n\n      var type = this._type;\n      var stack = this._stack;\n      while (stack) {\n        var node = stack.node;\n        var index = stack.index++;\n        var maxIndex = void 0;\n        if (node.entry) {\n          if (index === 0) {\n            return mapIteratorValue(type, node.entry);\n          }\n        } else if (node.entries) {\n          maxIndex = node.entries.length - 1;\n          if (index <= maxIndex) {\n            return mapIteratorValue(type, node.entries[this$1._reverse ? maxIndex - index : index]);\n          }\n        } else {\n          maxIndex = node.nodes.length - 1;\n          if (index <= maxIndex) {\n            var subNode = node.nodes[this$1._reverse ? maxIndex - index : index];\n            if (subNode) {\n              if (subNode.entry) {\n                return mapIteratorValue(type, subNode.entry);\n              }\n              stack = this$1._stack = mapIteratorFrame(subNode, stack);\n            }\n            continue;\n          }\n        }\n        stack = this$1._stack = this$1._stack.__prev;\n      }\n      return iteratorDone();\n    };\n\n    return MapIterator;\n  }(Iterator);\n\n  function mapIteratorValue(type, entry) {\n    return iteratorValue(type, entry[0], entry[1]);\n  }\n\n  function mapIteratorFrame(node, prev) {\n    return {\n      node: node,\n      index: 0,\n      __prev: prev\n    };\n  }\n\n  function makeMap(size, root, ownerID, hash$$1) {\n    var map = Object.create(MapPrototype);\n    map.size = size;\n    map._root = root;\n    map.__ownerID = ownerID;\n    map.__hash = hash$$1;\n    map.__altered = false;\n    return map;\n  }\n\n  var EMPTY_MAP;\n  function emptyMap() {\n    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));\n  }\n\n  function updateMap(map, k, v) {\n    var newRoot;\n    var newSize;\n    if (!map._root) {\n      if (v === NOT_SET) {\n        return map;\n      }\n      newSize = 1;\n      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);\n    } else {\n      var didChangeSize = MakeRef(CHANGE_LENGTH);\n      var didAlter = MakeRef(DID_ALTER);\n      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);\n      if (!didAlter.value) {\n        return map;\n      }\n      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);\n    }\n    if (map.__ownerID) {\n      map.size = newSize;\n      map._root = newRoot;\n      map.__hash = undefined;\n      map.__altered = true;\n      return map;\n    }\n    return newRoot ? makeMap(newSize, newRoot) : emptyMap();\n  }\n\n  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (!node) {\n      if (value === NOT_SET) {\n        return node;\n      }\n      SetRef(didAlter);\n      SetRef(didChangeSize);\n      return new ValueNode(ownerID, keyHash, [key, value]);\n    }\n    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);\n  }\n\n  function isLeafNode(node) {\n    return node.constructor === ValueNode || node.constructor === HashCollisionNode;\n  }\n\n  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {\n    if (node.keyHash === keyHash) {\n      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);\n    }\n\n    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;\n    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\n    var newNode;\n    var nodes = idx1 === idx2 ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] : (newNode = new ValueNode(ownerID, keyHash, entry), idx1 < idx2 ? [node, newNode] : [newNode, node]);\n\n    return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);\n  }\n\n  function createNodes(ownerID, entries, key, value) {\n    if (!ownerID) {\n      ownerID = new OwnerID();\n    }\n    var node = new ValueNode(ownerID, hash(key), [key, value]);\n    for (var ii = 0; ii < entries.length; ii++) {\n      var entry = entries[ii];\n      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);\n    }\n    return node;\n  }\n\n  function packNodes(ownerID, nodes, count, excluding) {\n    var bitmap = 0;\n    var packedII = 0;\n    var packedNodes = new Array(count);\n    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {\n      var node = nodes[ii];\n      if (node !== undefined && ii !== excluding) {\n        bitmap |= bit;\n        packedNodes[packedII++] = node;\n      }\n    }\n    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);\n  }\n\n  function expandNodes(ownerID, nodes, bitmap, including, node) {\n    var count = 0;\n    var expandedNodes = new Array(SIZE);\n    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {\n      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;\n    }\n    expandedNodes[including] = node;\n    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);\n  }\n\n  function mergeIntoMapWith(map, merger, collections) {\n    var iters = [];\n    for (var ii = 0; ii < collections.length; ii++) {\n      var value = collections[ii];\n      var iter = KeyedCollection(value);\n      if (!isCollection(value)) {\n        iter = iter.map(function (v) {\n          return fromJS(v);\n        });\n      }\n      iters.push(iter);\n    }\n    return mergeIntoCollectionWith(map, merger, iters);\n  }\n\n  function deepMerger(oldVal, newVal) {\n    return oldVal && oldVal.mergeDeep && isCollection(newVal) ? oldVal.mergeDeep(newVal) : is(oldVal, newVal) ? oldVal : newVal;\n  }\n\n  function deepMergerWith(merger) {\n    return function (oldVal, newVal, key) {\n      if (oldVal && oldVal.mergeDeepWith && isCollection(newVal)) {\n        return oldVal.mergeDeepWith(merger, newVal);\n      }\n      var nextValue = merger(oldVal, newVal, key);\n      return is(oldVal, nextValue) ? oldVal : nextValue;\n    };\n  }\n\n  function mergeIntoCollectionWith(collection, merger, iters) {\n    iters = iters.filter(function (x) {\n      return x.size !== 0;\n    });\n    if (iters.length === 0) {\n      return collection;\n    }\n    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {\n      return collection.constructor(iters[0]);\n    }\n    return collection.withMutations(function (collection) {\n      var mergeIntoMap = merger ? function (value, key) {\n        collection.update(key, NOT_SET, function (oldVal) {\n          return oldVal === NOT_SET ? value : merger(oldVal, value, key);\n        });\n      } : function (value, key) {\n        collection.set(key, value);\n      };\n      for (var ii = 0; ii < iters.length; ii++) {\n        iters[ii].forEach(mergeIntoMap);\n      }\n    });\n  }\n\n  function updateInDeepMap(existing, keyPath, i, notSetValue, updater) {\n    var isNotSet = existing === NOT_SET;\n    if (i === keyPath.length) {\n      var existingValue = isNotSet ? notSetValue : existing;\n      var newValue = updater(existingValue);\n      return newValue === existingValue ? existing : newValue;\n    }\n    if (!(isNotSet || existing && existing.set)) {\n      throw new TypeError('Invalid keyPath: Value at [' + keyPath.slice(0, i).map(quoteString) + '] does not have a .set() method and cannot be updated: ' + existing);\n    }\n    var key = keyPath[i];\n    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);\n    var nextUpdated = updateInDeepMap(nextExisting, keyPath, i + 1, notSetValue, updater);\n    return nextUpdated === nextExisting ? existing : nextUpdated === NOT_SET ? existing.remove(key) : (isNotSet ? emptyMap() : existing).set(key, nextUpdated);\n  }\n\n  function popCount(x) {\n    x -= x >> 1 & 0x55555555;\n    x = (x & 0x33333333) + (x >> 2 & 0x33333333);\n    x = x + (x >> 4) & 0x0f0f0f0f;\n    x += x >> 8;\n    x += x >> 16;\n    return x & 0x7f;\n  }\n\n  function setIn(array, idx, val, canEdit) {\n    var newArray = canEdit ? array : arrCopy(array);\n    newArray[idx] = val;\n    return newArray;\n  }\n\n  function spliceIn(array, idx, val, canEdit) {\n    var newLen = array.length + 1;\n    if (canEdit && idx + 1 === newLen) {\n      array[idx] = val;\n      return array;\n    }\n    var newArray = new Array(newLen);\n    var after = 0;\n    for (var ii = 0; ii < newLen; ii++) {\n      if (ii === idx) {\n        newArray[ii] = val;\n        after = -1;\n      } else {\n        newArray[ii] = array[ii + after];\n      }\n    }\n    return newArray;\n  }\n\n  function spliceOut(array, idx, canEdit) {\n    var newLen = array.length - 1;\n    if (canEdit && idx === newLen) {\n      array.pop();\n      return array;\n    }\n    var newArray = new Array(newLen);\n    var after = 0;\n    for (var ii = 0; ii < newLen; ii++) {\n      if (ii === idx) {\n        after = 1;\n      }\n      newArray[ii] = array[ii + after];\n    }\n    return newArray;\n  }\n\n  var MAX_ARRAY_MAP_SIZE = SIZE / 4;\n  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;\n  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;\n\n  var List = function (IndexedCollection$$1) {\n    function List(value) {\n      var empty = emptyList();\n      if (value === null || value === undefined) {\n        return empty;\n      }\n      if (isList(value)) {\n        return value;\n      }\n      var iter = IndexedCollection$$1(value);\n      var size = iter.size;\n      if (size === 0) {\n        return empty;\n      }\n      assertNotInfinite(size);\n      if (size > 0 && size < SIZE) {\n        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));\n      }\n      return empty.withMutations(function (list) {\n        list.setSize(size);\n        iter.forEach(function (v, i) {\n          return list.set(i, v);\n        });\n      });\n    }\n\n    if (IndexedCollection$$1) List.__proto__ = IndexedCollection$$1;\n    List.prototype = Object.create(IndexedCollection$$1 && IndexedCollection$$1.prototype);\n    List.prototype.constructor = List;\n\n    List.of = function of() /*...values*/{\n      return this(arguments);\n    };\n\n    List.prototype.toString = function toString() {\n      return this.__toString('List [', ']');\n    };\n\n    // @pragma Access\n\n    List.prototype.get = function get(index, notSetValue) {\n      index = wrapIndex(this, index);\n      if (index >= 0 && index < this.size) {\n        index += this._origin;\n        var node = listNodeFor(this, index);\n        return node && node.array[index & MASK];\n      }\n      return notSetValue;\n    };\n\n    // @pragma Modification\n\n    List.prototype.set = function set(index, value) {\n      return updateList(this, index, value);\n    };\n\n    List.prototype.remove = function remove(index) {\n      return !this.has(index) ? this : index === 0 ? this.shift() : index === this.size - 1 ? this.pop() : this.splice(index, 1);\n    };\n\n    List.prototype.insert = function insert(index, value) {\n      return this.splice(index, 0, value);\n    };\n\n    List.prototype.clear = function clear() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = this._origin = this._capacity = 0;\n        this._level = SHIFT;\n        this._root = this._tail = null;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyList();\n    };\n\n    List.prototype.push = function push() /*...values*/{\n      var values = arguments;\n      var oldSize = this.size;\n      return this.withMutations(function (list) {\n        setListBounds(list, 0, oldSize + values.length);\n        for (var ii = 0; ii < values.length; ii++) {\n          list.set(oldSize + ii, values[ii]);\n        }\n      });\n    };\n\n    List.prototype.pop = function pop() {\n      return setListBounds(this, 0, -1);\n    };\n\n    List.prototype.unshift = function unshift() /*...values*/{\n      var values = arguments;\n      return this.withMutations(function (list) {\n        setListBounds(list, -values.length);\n        for (var ii = 0; ii < values.length; ii++) {\n          list.set(ii, values[ii]);\n        }\n      });\n    };\n\n    List.prototype.shift = function shift() {\n      return setListBounds(this, 1);\n    };\n\n    // @pragma Composition\n\n    List.prototype.merge = function merge() /*...iters*/{\n      return mergeIntoListWith(this, undefined, arguments);\n    };\n\n    List.prototype.mergeWith = function mergeWith(merger) {\n      var iters = [],\n          len = arguments.length - 1;\n      while (len-- > 0) {\n        iters[len] = arguments[len + 1];\n      }return mergeIntoListWith(this, merger, iters);\n    };\n\n    List.prototype.mergeDeep = function mergeDeep() /*...iters*/{\n      return mergeIntoListWith(this, deepMerger, arguments);\n    };\n\n    List.prototype.mergeDeepWith = function mergeDeepWith(merger) {\n      var iters = [],\n          len = arguments.length - 1;\n      while (len-- > 0) {\n        iters[len] = arguments[len + 1];\n      }return mergeIntoListWith(this, deepMergerWith(merger), iters);\n    };\n\n    List.prototype.setSize = function setSize(size) {\n      return setListBounds(this, 0, size);\n    };\n\n    // @pragma Iteration\n\n    List.prototype.slice = function slice(begin, end) {\n      var size = this.size;\n      if (wholeSlice(begin, end, size)) {\n        return this;\n      }\n      return setListBounds(this, resolveBegin(begin, size), resolveEnd(end, size));\n    };\n\n    List.prototype.__iterator = function __iterator(type, reverse) {\n      var index = reverse ? this.size : 0;\n      var values = iterateList(this, reverse);\n      return new Iterator(function () {\n        var value = values();\n        return value === DONE ? iteratorDone() : iteratorValue(type, reverse ? --index : index++, value);\n      });\n    };\n\n    List.prototype.__iterate = function __iterate(fn, reverse) {\n      var this$1 = this;\n\n      var index = reverse ? this.size : 0;\n      var values = iterateList(this, reverse);\n      var value;\n      while ((value = values()) !== DONE) {\n        if (fn(value, reverse ? --index : index++, this$1) === false) {\n          break;\n        }\n      }\n      return index;\n    };\n\n    List.prototype.__ensureOwner = function __ensureOwner(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        if (this.size === 0) {\n          return emptyList();\n        }\n        this.__ownerID = ownerID;\n        return this;\n      }\n      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);\n    };\n\n    return List;\n  }(IndexedCollection);\n\n  function isList(maybeList) {\n    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);\n  }\n\n  List.isList = isList;\n\n  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';\n\n  var ListPrototype = List.prototype;\n  ListPrototype[IS_LIST_SENTINEL] = true;\n  ListPrototype[DELETE] = ListPrototype.remove;\n  ListPrototype.setIn = MapPrototype.setIn;\n  ListPrototype.deleteIn = ListPrototype.removeIn = MapPrototype.removeIn;\n  ListPrototype.update = MapPrototype.update;\n  ListPrototype.updateIn = MapPrototype.updateIn;\n  ListPrototype.mergeIn = MapPrototype.mergeIn;\n  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n  ListPrototype.withMutations = MapPrototype.withMutations;\n  ListPrototype.asMutable = MapPrototype.asMutable;\n  ListPrototype.asImmutable = MapPrototype.asImmutable;\n  ListPrototype.wasAltered = MapPrototype.wasAltered;\n\n  var VNode = function VNode(array, ownerID) {\n    this.array = array;\n    this.ownerID = ownerID;\n  };\n\n  // TODO: seems like these methods are very similar\n\n  VNode.prototype.removeBefore = function removeBefore(ownerID, level, index) {\n    if (index === level ? 1 << level : 0 || this.array.length === 0) {\n      return this;\n    }\n    var originIndex = index >>> level & MASK;\n    if (originIndex >= this.array.length) {\n      return new VNode([], ownerID);\n    }\n    var removingFirst = originIndex === 0;\n    var newChild;\n    if (level > 0) {\n      var oldChild = this.array[originIndex];\n      newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);\n      if (newChild === oldChild && removingFirst) {\n        return this;\n      }\n    }\n    if (removingFirst && !newChild) {\n      return this;\n    }\n    var editable = editableVNode(this, ownerID);\n    if (!removingFirst) {\n      for (var ii = 0; ii < originIndex; ii++) {\n        editable.array[ii] = undefined;\n      }\n    }\n    if (newChild) {\n      editable.array[originIndex] = newChild;\n    }\n    return editable;\n  };\n\n  VNode.prototype.removeAfter = function removeAfter(ownerID, level, index) {\n    if (index === (level ? 1 << level : 0) || this.array.length === 0) {\n      return this;\n    }\n    var sizeIndex = index - 1 >>> level & MASK;\n    if (sizeIndex >= this.array.length) {\n      return this;\n    }\n\n    var newChild;\n    if (level > 0) {\n      var oldChild = this.array[sizeIndex];\n      newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);\n      if (newChild === oldChild && sizeIndex === this.array.length - 1) {\n        return this;\n      }\n    }\n\n    var editable = editableVNode(this, ownerID);\n    editable.array.splice(sizeIndex + 1);\n    if (newChild) {\n      editable.array[sizeIndex] = newChild;\n    }\n    return editable;\n  };\n\n  var DONE = {};\n\n  function iterateList(list, reverse) {\n    var left = list._origin;\n    var right = list._capacity;\n    var tailPos = getTailOffset(right);\n    var tail = list._tail;\n\n    return iterateNodeOrLeaf(list._root, list._level, 0);\n\n    function iterateNodeOrLeaf(node, level, offset) {\n      return level === 0 ? iterateLeaf(node, offset) : iterateNode(node, level, offset);\n    }\n\n    function iterateLeaf(node, offset) {\n      var array = offset === tailPos ? tail && tail.array : node && node.array;\n      var from = offset > left ? 0 : left - offset;\n      var to = right - offset;\n      if (to > SIZE) {\n        to = SIZE;\n      }\n      return function () {\n        if (from === to) {\n          return DONE;\n        }\n        var idx = reverse ? --to : from++;\n        return array && array[idx];\n      };\n    }\n\n    function iterateNode(node, level, offset) {\n      var values;\n      var array = node && node.array;\n      var from = offset > left ? 0 : left - offset >> level;\n      var to = (right - offset >> level) + 1;\n      if (to > SIZE) {\n        to = SIZE;\n      }\n      return function () {\n        while (true) {\n          if (values) {\n            var value = values();\n            if (value !== DONE) {\n              return value;\n            }\n            values = null;\n          }\n          if (from === to) {\n            return DONE;\n          }\n          var idx = reverse ? --to : from++;\n          values = iterateNodeOrLeaf(array && array[idx], level - SHIFT, offset + (idx << level));\n        }\n      };\n    }\n  }\n\n  function makeList(origin, capacity, level, root, tail, ownerID, hash) {\n    var list = Object.create(ListPrototype);\n    list.size = capacity - origin;\n    list._origin = origin;\n    list._capacity = capacity;\n    list._level = level;\n    list._root = root;\n    list._tail = tail;\n    list.__ownerID = ownerID;\n    list.__hash = hash;\n    list.__altered = false;\n    return list;\n  }\n\n  var EMPTY_LIST;\n  function emptyList() {\n    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));\n  }\n\n  function updateList(list, index, value) {\n    index = wrapIndex(list, index);\n\n    if (index !== index) {\n      return list;\n    }\n\n    if (index >= list.size || index < 0) {\n      return list.withMutations(function (list) {\n        index < 0 ? setListBounds(list, index).set(0, value) : setListBounds(list, 0, index + 1).set(index, value);\n      });\n    }\n\n    index += list._origin;\n\n    var newTail = list._tail;\n    var newRoot = list._root;\n    var didAlter = MakeRef(DID_ALTER);\n    if (index >= getTailOffset(list._capacity)) {\n      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);\n    } else {\n      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);\n    }\n\n    if (!didAlter.value) {\n      return list;\n    }\n\n    if (list.__ownerID) {\n      list._root = newRoot;\n      list._tail = newTail;\n      list.__hash = undefined;\n      list.__altered = true;\n      return list;\n    }\n    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);\n  }\n\n  function updateVNode(node, ownerID, level, index, value, didAlter) {\n    var idx = index >>> level & MASK;\n    var nodeHas = node && idx < node.array.length;\n    if (!nodeHas && value === undefined) {\n      return node;\n    }\n\n    var newNode;\n\n    if (level > 0) {\n      var lowerNode = node && node.array[idx];\n      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);\n      if (newLowerNode === lowerNode) {\n        return node;\n      }\n      newNode = editableVNode(node, ownerID);\n      newNode.array[idx] = newLowerNode;\n      return newNode;\n    }\n\n    if (nodeHas && node.array[idx] === value) {\n      return node;\n    }\n\n    SetRef(didAlter);\n\n    newNode = editableVNode(node, ownerID);\n    if (value === undefined && idx === newNode.array.length - 1) {\n      newNode.array.pop();\n    } else {\n      newNode.array[idx] = value;\n    }\n    return newNode;\n  }\n\n  function editableVNode(node, ownerID) {\n    if (ownerID && node && ownerID === node.ownerID) {\n      return node;\n    }\n    return new VNode(node ? node.array.slice() : [], ownerID);\n  }\n\n  function listNodeFor(list, rawIndex) {\n    if (rawIndex >= getTailOffset(list._capacity)) {\n      return list._tail;\n    }\n    if (rawIndex < 1 << list._level + SHIFT) {\n      var node = list._root;\n      var level = list._level;\n      while (node && level > 0) {\n        node = node.array[rawIndex >>> level & MASK];\n        level -= SHIFT;\n      }\n      return node;\n    }\n  }\n\n  function setListBounds(list, begin, end) {\n    // Sanitize begin & end using this shorthand for ToInt32(argument)\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n    if (begin !== undefined) {\n      begin |= 0;\n    }\n    if (end !== undefined) {\n      end |= 0;\n    }\n    var owner = list.__ownerID || new OwnerID();\n    var oldOrigin = list._origin;\n    var oldCapacity = list._capacity;\n    var newOrigin = oldOrigin + begin;\n    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;\n    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {\n      return list;\n    }\n\n    // If it's going to end after it starts, it's empty.\n    if (newOrigin >= newCapacity) {\n      return list.clear();\n    }\n\n    var newLevel = list._level;\n    var newRoot = list._root;\n\n    // New origin might need creating a higher root.\n    var offsetShift = 0;\n    while (newOrigin + offsetShift < 0) {\n      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);\n      newLevel += SHIFT;\n      offsetShift += 1 << newLevel;\n    }\n    if (offsetShift) {\n      newOrigin += offsetShift;\n      oldOrigin += offsetShift;\n      newCapacity += offsetShift;\n      oldCapacity += offsetShift;\n    }\n\n    var oldTailOffset = getTailOffset(oldCapacity);\n    var newTailOffset = getTailOffset(newCapacity);\n\n    // New size might need creating a higher root.\n    while (newTailOffset >= 1 << newLevel + SHIFT) {\n      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);\n      newLevel += SHIFT;\n    }\n\n    // Locate or create the new tail.\n    var oldTail = list._tail;\n    var newTail = newTailOffset < oldTailOffset ? listNodeFor(list, newCapacity - 1) : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;\n\n    // Merge Tail into tree.\n    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {\n      newRoot = editableVNode(newRoot, owner);\n      var node = newRoot;\n      for (var level = newLevel; level > SHIFT; level -= SHIFT) {\n        var idx = oldTailOffset >>> level & MASK;\n        node = node.array[idx] = editableVNode(node.array[idx], owner);\n      }\n      node.array[oldTailOffset >>> SHIFT & MASK] = oldTail;\n    }\n\n    // If the size has been reduced, there's a chance the tail needs to be trimmed.\n    if (newCapacity < oldCapacity) {\n      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);\n    }\n\n    // If the new origin is within the tail, then we do not need a root.\n    if (newOrigin >= newTailOffset) {\n      newOrigin -= newTailOffset;\n      newCapacity -= newTailOffset;\n      newLevel = SHIFT;\n      newRoot = null;\n      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);\n\n      // Otherwise, if the root has been trimmed, garbage collect.\n    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {\n      offsetShift = 0;\n\n      // Identify the new top root node of the subtree of the old root.\n      while (newRoot) {\n        var beginIndex = newOrigin >>> newLevel & MASK;\n        if (beginIndex !== newTailOffset >>> newLevel & MASK) {\n          break;\n        }\n        if (beginIndex) {\n          offsetShift += (1 << newLevel) * beginIndex;\n        }\n        newLevel -= SHIFT;\n        newRoot = newRoot.array[beginIndex];\n      }\n\n      // Trim the new sides of the new root.\n      if (newRoot && newOrigin > oldOrigin) {\n        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);\n      }\n      if (newRoot && newTailOffset < oldTailOffset) {\n        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);\n      }\n      if (offsetShift) {\n        newOrigin -= offsetShift;\n        newCapacity -= offsetShift;\n      }\n    }\n\n    if (list.__ownerID) {\n      list.size = newCapacity - newOrigin;\n      list._origin = newOrigin;\n      list._capacity = newCapacity;\n      list._level = newLevel;\n      list._root = newRoot;\n      list._tail = newTail;\n      list.__hash = undefined;\n      list.__altered = true;\n      return list;\n    }\n    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);\n  }\n\n  function mergeIntoListWith(list, merger, collections) {\n    var iters = [];\n    var maxSize = 0;\n    for (var ii = 0; ii < collections.length; ii++) {\n      var value = collections[ii];\n      var iter = IndexedCollection(value);\n      if (iter.size > maxSize) {\n        maxSize = iter.size;\n      }\n      if (!isCollection(value)) {\n        iter = iter.map(function (v) {\n          return fromJS(v);\n        });\n      }\n      iters.push(iter);\n    }\n    if (maxSize > list.size) {\n      list = list.setSize(maxSize);\n    }\n    return mergeIntoCollectionWith(list, merger, iters);\n  }\n\n  function getTailOffset(size) {\n    return size < SIZE ? 0 : size - 1 >>> SHIFT << SHIFT;\n  }\n\n  var OrderedMap = function (Map$$1) {\n    function OrderedMap(value) {\n      return value === null || value === undefined ? emptyOrderedMap() : isOrderedMap(value) ? value : emptyOrderedMap().withMutations(function (map) {\n        var iter = KeyedCollection(value);\n        assertNotInfinite(iter.size);\n        iter.forEach(function (v, k) {\n          return map.set(k, v);\n        });\n      });\n    }\n\n    if (Map$$1) OrderedMap.__proto__ = Map$$1;\n    OrderedMap.prototype = Object.create(Map$$1 && Map$$1.prototype);\n    OrderedMap.prototype.constructor = OrderedMap;\n\n    OrderedMap.of = function of() /*...values*/{\n      return this(arguments);\n    };\n\n    OrderedMap.prototype.toString = function toString() {\n      return this.__toString('OrderedMap {', '}');\n    };\n\n    // @pragma Access\n\n    OrderedMap.prototype.get = function get(k, notSetValue) {\n      var index = this._map.get(k);\n      return index !== undefined ? this._list.get(index)[1] : notSetValue;\n    };\n\n    // @pragma Modification\n\n    OrderedMap.prototype.clear = function clear() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._map.clear();\n        this._list.clear();\n        return this;\n      }\n      return emptyOrderedMap();\n    };\n\n    OrderedMap.prototype.set = function set(k, v) {\n      return updateOrderedMap(this, k, v);\n    };\n\n    OrderedMap.prototype.remove = function remove(k) {\n      return updateOrderedMap(this, k, NOT_SET);\n    };\n\n    OrderedMap.prototype.wasAltered = function wasAltered() {\n      return this._map.wasAltered() || this._list.wasAltered();\n    };\n\n    OrderedMap.prototype.__iterate = function __iterate(fn, reverse) {\n      var this$1 = this;\n\n      return this._list.__iterate(function (entry) {\n        return entry && fn(entry[1], entry[0], this$1);\n      }, reverse);\n    };\n\n    OrderedMap.prototype.__iterator = function __iterator(type, reverse) {\n      return this._list.fromEntrySeq().__iterator(type, reverse);\n    };\n\n    OrderedMap.prototype.__ensureOwner = function __ensureOwner(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map.__ensureOwner(ownerID);\n      var newList = this._list.__ensureOwner(ownerID);\n      if (!ownerID) {\n        if (this.size === 0) {\n          return emptyOrderedMap();\n        }\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        this._list = newList;\n        return this;\n      }\n      return makeOrderedMap(newMap, newList, ownerID, this.__hash);\n    };\n\n    return OrderedMap;\n  }(Map);\n\n  function isOrderedMap(maybeOrderedMap) {\n    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);\n  }\n\n  OrderedMap.isOrderedMap = isOrderedMap;\n\n  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;\n  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;\n\n  function makeOrderedMap(map, list, ownerID, hash) {\n    var omap = Object.create(OrderedMap.prototype);\n    omap.size = map ? map.size : 0;\n    omap._map = map;\n    omap._list = list;\n    omap.__ownerID = ownerID;\n    omap.__hash = hash;\n    return omap;\n  }\n\n  var EMPTY_ORDERED_MAP;\n  function emptyOrderedMap() {\n    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));\n  }\n\n  function updateOrderedMap(omap, k, v) {\n    var map = omap._map;\n    var list = omap._list;\n    var i = map.get(k);\n    var has = i !== undefined;\n    var newMap;\n    var newList;\n    if (v === NOT_SET) {\n      // removed\n      if (!has) {\n        return omap;\n      }\n      if (list.size >= SIZE && list.size >= map.size * 2) {\n        newList = list.filter(function (entry, idx) {\n          return entry !== undefined && i !== idx;\n        });\n        newMap = newList.toKeyedSeq().map(function (entry) {\n          return entry[0];\n        }).flip().toMap();\n        if (omap.__ownerID) {\n          newMap.__ownerID = newList.__ownerID = omap.__ownerID;\n        }\n      } else {\n        newMap = map.remove(k);\n        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);\n      }\n    } else if (has) {\n      if (v === list.get(i)[1]) {\n        return omap;\n      }\n      newMap = map;\n      newList = list.set(i, [k, v]);\n    } else {\n      newMap = map.set(k, list.size);\n      newList = list.set(list.size, [k, v]);\n    }\n    if (omap.__ownerID) {\n      omap.size = newMap.size;\n      omap._map = newMap;\n      omap._list = newList;\n      omap.__hash = undefined;\n      return omap;\n    }\n    return makeOrderedMap(newMap, newList);\n  }\n\n  var Stack = function (IndexedCollection$$1) {\n    function Stack(value) {\n      return value === null || value === undefined ? emptyStack() : isStack(value) ? value : emptyStack().pushAll(value);\n    }\n\n    if (IndexedCollection$$1) Stack.__proto__ = IndexedCollection$$1;\n    Stack.prototype = Object.create(IndexedCollection$$1 && IndexedCollection$$1.prototype);\n    Stack.prototype.constructor = Stack;\n\n    Stack.of = function of() /*...values*/{\n      return this(arguments);\n    };\n\n    Stack.prototype.toString = function toString() {\n      return this.__toString('Stack [', ']');\n    };\n\n    // @pragma Access\n\n    Stack.prototype.get = function get(index, notSetValue) {\n      var head = this._head;\n      index = wrapIndex(this, index);\n      while (head && index--) {\n        head = head.next;\n      }\n      return head ? head.value : notSetValue;\n    };\n\n    Stack.prototype.peek = function peek() {\n      return this._head && this._head.value;\n    };\n\n    // @pragma Modification\n\n    Stack.prototype.push = function push() /*...values*/{\n      var arguments$1 = arguments;\n\n      if (arguments.length === 0) {\n        return this;\n      }\n      var newSize = this.size + arguments.length;\n      var head = this._head;\n      for (var ii = arguments.length - 1; ii >= 0; ii--) {\n        head = {\n          value: arguments$1[ii],\n          next: head\n        };\n      }\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    Stack.prototype.pushAll = function pushAll(iter) {\n      iter = IndexedCollection$$1(iter);\n      if (iter.size === 0) {\n        return this;\n      }\n      if (this.size === 0 && isStack(iter)) {\n        return iter;\n      }\n      assertNotInfinite(iter.size);\n      var newSize = this.size;\n      var head = this._head;\n      iter.__iterate(function (value) {\n        newSize++;\n        head = {\n          value: value,\n          next: head\n        };\n      },\n      /* reverse */true);\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    Stack.prototype.pop = function pop() {\n      return this.slice(1);\n    };\n\n    Stack.prototype.clear = function clear() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._head = undefined;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyStack();\n    };\n\n    Stack.prototype.slice = function slice(begin, end) {\n      if (wholeSlice(begin, end, this.size)) {\n        return this;\n      }\n      var resolvedBegin = resolveBegin(begin, this.size);\n      var resolvedEnd = resolveEnd(end, this.size);\n      if (resolvedEnd !== this.size) {\n        // super.slice(begin, end);\n        return IndexedCollection$$1.prototype.slice.call(this, begin, end);\n      }\n      var newSize = this.size - resolvedBegin;\n      var head = this._head;\n      while (resolvedBegin--) {\n        head = head.next;\n      }\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    // @pragma Mutability\n\n    Stack.prototype.__ensureOwner = function __ensureOwner(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        if (this.size === 0) {\n          return emptyStack();\n        }\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeStack(this.size, this._head, ownerID, this.__hash);\n    };\n\n    // @pragma Iteration\n\n    Stack.prototype.__iterate = function __iterate(fn, reverse) {\n      var this$1 = this;\n\n      if (reverse) {\n        return new ArraySeq(this.toArray()).__iterate(function (v, k) {\n          return fn(v, k, this$1);\n        }, reverse);\n      }\n      var iterations = 0;\n      var node = this._head;\n      while (node) {\n        if (fn(node.value, iterations++, this$1) === false) {\n          break;\n        }\n        node = node.next;\n      }\n      return iterations;\n    };\n\n    Stack.prototype.__iterator = function __iterator(type, reverse) {\n      if (reverse) {\n        return new ArraySeq(this.toArray()).__iterator(type, reverse);\n      }\n      var iterations = 0;\n      var node = this._head;\n      return new Iterator(function () {\n        if (node) {\n          var value = node.value;\n          node = node.next;\n          return iteratorValue(type, iterations++, value);\n        }\n        return iteratorDone();\n      });\n    };\n\n    return Stack;\n  }(IndexedCollection);\n\n  function isStack(maybeStack) {\n    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);\n  }\n\n  Stack.isStack = isStack;\n\n  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';\n\n  var StackPrototype = Stack.prototype;\n  StackPrototype[IS_STACK_SENTINEL] = true;\n  StackPrototype.withMutations = MapPrototype.withMutations;\n  StackPrototype.asMutable = MapPrototype.asMutable;\n  StackPrototype.asImmutable = MapPrototype.asImmutable;\n  StackPrototype.wasAltered = MapPrototype.wasAltered;\n  StackPrototype.shift = StackPrototype.pop;\n  StackPrototype.unshift = StackPrototype.push;\n  StackPrototype.unshiftAll = StackPrototype.pushAll;\n\n  function makeStack(size, head, ownerID, hash) {\n    var map = Object.create(StackPrototype);\n    map.size = size;\n    map._head = head;\n    map.__ownerID = ownerID;\n    map.__hash = hash;\n    map.__altered = false;\n    return map;\n  }\n\n  var EMPTY_STACK;\n  function emptyStack() {\n    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));\n  }\n\n  function deepEqual(a, b) {\n    if (a === b) {\n      return true;\n    }\n\n    if (!isCollection(b) || a.size !== undefined && b.size !== undefined && a.size !== b.size || a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash || isKeyed(a) !== isKeyed(b) || isIndexed(a) !== isIndexed(b) || isOrdered(a) !== isOrdered(b)) {\n      return false;\n    }\n\n    if (a.size === 0 && b.size === 0) {\n      return true;\n    }\n\n    var notAssociative = !isAssociative(a);\n\n    if (isOrdered(a)) {\n      var entries = a.entries();\n      return b.every(function (v, k) {\n        var entry = entries.next().value;\n        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));\n      }) && entries.next().done;\n    }\n\n    var flipped = false;\n\n    if (a.size === undefined) {\n      if (b.size === undefined) {\n        if (typeof a.cacheResult === 'function') {\n          a.cacheResult();\n        }\n      } else {\n        flipped = true;\n        var _ = a;\n        a = b;\n        b = _;\n      }\n    }\n\n    var allEqual = true;\n    var bSize = b.__iterate(function (v, k) {\n      if (notAssociative ? !a.has(v) : flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {\n        allEqual = false;\n        return false;\n      }\n    });\n\n    return allEqual && a.size === bSize;\n  }\n\n  /**\n   * Contributes additional methods to a constructor\n   */\n  function mixin(ctor, methods) {\n    var keyCopier = function keyCopier(key) {\n      ctor.prototype[key] = methods[key];\n    };\n    Object.keys(methods).forEach(keyCopier);\n    Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(methods).forEach(keyCopier);\n    return ctor;\n  }\n\n  var Set = function (SetCollection$$1) {\n    function Set(value) {\n      return value === null || value === undefined ? emptySet() : isSet(value) && !isOrdered(value) ? value : emptySet().withMutations(function (set) {\n        var iter = SetCollection$$1(value);\n        assertNotInfinite(iter.size);\n        iter.forEach(function (v) {\n          return set.add(v);\n        });\n      });\n    }\n\n    if (SetCollection$$1) Set.__proto__ = SetCollection$$1;\n    Set.prototype = Object.create(SetCollection$$1 && SetCollection$$1.prototype);\n    Set.prototype.constructor = Set;\n\n    Set.of = function of() /*...values*/{\n      return this(arguments);\n    };\n\n    Set.fromKeys = function fromKeys(value) {\n      return this(KeyedCollection(value).keySeq());\n    };\n\n    Set.intersect = function intersect(sets) {\n      sets = Collection(sets).toArray();\n      return sets.length ? SetPrototype.intersect.apply(Set(sets.pop()), sets) : emptySet();\n    };\n\n    Set.union = function union(sets) {\n      sets = Collection(sets).toArray();\n      return sets.length ? SetPrototype.union.apply(Set(sets.pop()), sets) : emptySet();\n    };\n\n    Set.prototype.toString = function toString() {\n      return this.__toString('Set {', '}');\n    };\n\n    // @pragma Access\n\n    Set.prototype.has = function has(value) {\n      return this._map.has(value);\n    };\n\n    // @pragma Modification\n\n    Set.prototype.add = function add(value) {\n      return updateSet(this, this._map.set(value, true));\n    };\n\n    Set.prototype.remove = function remove(value) {\n      return updateSet(this, this._map.remove(value));\n    };\n\n    Set.prototype.clear = function clear() {\n      return updateSet(this, this._map.clear());\n    };\n\n    // @pragma Composition\n\n    Set.prototype.union = function union() {\n      var iters = [],\n          len = arguments.length;\n      while (len--) {\n        iters[len] = arguments[len];\n      }iters = iters.filter(function (x) {\n        return x.size !== 0;\n      });\n      if (iters.length === 0) {\n        return this;\n      }\n      if (this.size === 0 && !this.__ownerID && iters.length === 1) {\n        return this.constructor(iters[0]);\n      }\n      return this.withMutations(function (set) {\n        for (var ii = 0; ii < iters.length; ii++) {\n          SetCollection$$1(iters[ii]).forEach(function (value) {\n            return set.add(value);\n          });\n        }\n      });\n    };\n\n    Set.prototype.intersect = function intersect() {\n      var iters = [],\n          len = arguments.length;\n      while (len--) {\n        iters[len] = arguments[len];\n      }if (iters.length === 0) {\n        return this;\n      }\n      iters = iters.map(function (iter) {\n        return SetCollection$$1(iter);\n      });\n      var toRemove = [];\n      this.forEach(function (value) {\n        if (!iters.every(function (iter) {\n          return iter.includes(value);\n        })) {\n          toRemove.push(value);\n        }\n      });\n      return this.withMutations(function (set) {\n        toRemove.forEach(function (value) {\n          set.remove(value);\n        });\n      });\n    };\n\n    Set.prototype.subtract = function subtract() {\n      var iters = [],\n          len = arguments.length;\n      while (len--) {\n        iters[len] = arguments[len];\n      }if (iters.length === 0) {\n        return this;\n      }\n      var toRemove = [];\n      this.forEach(function (value) {\n        if (iters.some(function (iter) {\n          return iter.includes(value);\n        })) {\n          toRemove.push(value);\n        }\n      });\n      return this.withMutations(function (set) {\n        toRemove.forEach(function (value) {\n          set.remove(value);\n        });\n      });\n    };\n\n    Set.prototype.merge = function merge() {\n      return this.union.apply(this, arguments);\n    };\n\n    Set.prototype.mergeWith = function mergeWith(merger) {\n      var iters = [],\n          len = arguments.length - 1;\n      while (len-- > 0) {\n        iters[len] = arguments[len + 1];\n      }return this.union.apply(this, iters);\n    };\n\n    Set.prototype.sort = function sort(comparator) {\n      // Late binding\n      return OrderedSet(sortFactory(this, comparator));\n    };\n\n    Set.prototype.sortBy = function sortBy(mapper, comparator) {\n      // Late binding\n      return OrderedSet(sortFactory(this, comparator, mapper));\n    };\n\n    Set.prototype.wasAltered = function wasAltered() {\n      return this._map.wasAltered();\n    };\n\n    Set.prototype.__iterate = function __iterate(fn, reverse) {\n      var this$1 = this;\n\n      return this._map.__iterate(function (_, k) {\n        return fn(k, k, this$1);\n      }, reverse);\n    };\n\n    Set.prototype.__iterator = function __iterator(type, reverse) {\n      return this._map.map(function (_, k) {\n        return k;\n      }).__iterator(type, reverse);\n    };\n\n    Set.prototype.__ensureOwner = function __ensureOwner(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map.__ensureOwner(ownerID);\n      if (!ownerID) {\n        if (this.size === 0) {\n          return emptySet();\n        }\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        return this;\n      }\n      return this.__make(newMap, ownerID);\n    };\n\n    return Set;\n  }(SetCollection);\n\n  function isSet(maybeSet) {\n    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);\n  }\n\n  Set.isSet = isSet;\n\n  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';\n\n  var SetPrototype = Set.prototype;\n  SetPrototype[IS_SET_SENTINEL] = true;\n  SetPrototype[DELETE] = SetPrototype.remove;\n  SetPrototype.mergeDeep = SetPrototype.merge;\n  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;\n  SetPrototype.withMutations = MapPrototype.withMutations;\n  SetPrototype.asMutable = MapPrototype.asMutable;\n  SetPrototype.asImmutable = MapPrototype.asImmutable;\n\n  SetPrototype.__empty = emptySet;\n  SetPrototype.__make = makeSet;\n\n  function updateSet(set, newMap) {\n    if (set.__ownerID) {\n      set.size = newMap.size;\n      set._map = newMap;\n      return set;\n    }\n    return newMap === set._map ? set : newMap.size === 0 ? set.__empty() : set.__make(newMap);\n  }\n\n  function makeSet(map, ownerID) {\n    var set = Object.create(SetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n  }\n\n  var EMPTY_SET;\n  function emptySet() {\n    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));\n  }\n\n  /**\n   * Returns a lazy seq of nums from start (inclusive) to end\n   * (exclusive), by step, where start defaults to 0, step to 1, and end to\n   * infinity. When start is equal to end, returns empty list.\n   */\n  var Range = function (IndexedSeq$$1) {\n    function Range(start, end, step) {\n      if (!(this instanceof Range)) {\n        return new Range(start, end, step);\n      }\n      invariant(step !== 0, 'Cannot step a Range by 0');\n      start = start || 0;\n      if (end === undefined) {\n        end = Infinity;\n      }\n      step = step === undefined ? 1 : Math.abs(step);\n      if (end < start) {\n        step = -step;\n      }\n      this._start = start;\n      this._end = end;\n      this._step = step;\n      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);\n      if (this.size === 0) {\n        if (EMPTY_RANGE) {\n          return EMPTY_RANGE;\n        }\n        EMPTY_RANGE = this;\n      }\n    }\n\n    if (IndexedSeq$$1) Range.__proto__ = IndexedSeq$$1;\n    Range.prototype = Object.create(IndexedSeq$$1 && IndexedSeq$$1.prototype);\n    Range.prototype.constructor = Range;\n\n    Range.prototype.toString = function toString() {\n      if (this.size === 0) {\n        return 'Range []';\n      }\n      return 'Range [ ' + this._start + '...' + this._end + (this._step !== 1 ? ' by ' + this._step : '') + ' ]';\n    };\n\n    Range.prototype.get = function get(index, notSetValue) {\n      return this.has(index) ? this._start + wrapIndex(this, index) * this._step : notSetValue;\n    };\n\n    Range.prototype.includes = function includes(searchValue) {\n      var possibleIndex = (searchValue - this._start) / this._step;\n      return possibleIndex >= 0 && possibleIndex < this.size && possibleIndex === Math.floor(possibleIndex);\n    };\n\n    Range.prototype.slice = function slice(begin, end) {\n      if (wholeSlice(begin, end, this.size)) {\n        return this;\n      }\n      begin = resolveBegin(begin, this.size);\n      end = resolveEnd(end, this.size);\n      if (end <= begin) {\n        return new Range(0, 0);\n      }\n      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);\n    };\n\n    Range.prototype.indexOf = function indexOf(searchValue) {\n      var offsetValue = searchValue - this._start;\n      if (offsetValue % this._step === 0) {\n        var index = offsetValue / this._step;\n        if (index >= 0 && index < this.size) {\n          return index;\n        }\n      }\n      return -1;\n    };\n\n    Range.prototype.lastIndexOf = function lastIndexOf(searchValue) {\n      return this.indexOf(searchValue);\n    };\n\n    Range.prototype.__iterate = function __iterate(fn, reverse) {\n      var this$1 = this;\n\n      var size = this.size;\n      var step = this._step;\n      var value = reverse ? this._start + (size - 1) * step : this._start;\n      var i = 0;\n      while (i !== size) {\n        if (fn(value, reverse ? size - ++i : i++, this$1) === false) {\n          break;\n        }\n        value += reverse ? -step : step;\n      }\n      return i;\n    };\n\n    Range.prototype.__iterator = function __iterator(type, reverse) {\n      var size = this.size;\n      var step = this._step;\n      var value = reverse ? this._start + (size - 1) * step : this._start;\n      var i = 0;\n      return new Iterator(function () {\n        if (i === size) {\n          return iteratorDone();\n        }\n        var v = value;\n        value += reverse ? -step : step;\n        return iteratorValue(type, reverse ? size - ++i : i++, v);\n      });\n    };\n\n    Range.prototype.equals = function equals(other) {\n      return other instanceof Range ? this._start === other._start && this._end === other._end && this._step === other._step : deepEqual(this, other);\n    };\n\n    return Range;\n  }(IndexedSeq);\n\n  var EMPTY_RANGE;\n\n  // Note: all of these methods are deprecated.\n  Collection.isIterable = isCollection;\n  Collection.isKeyed = isKeyed;\n  Collection.isIndexed = isIndexed;\n  Collection.isAssociative = isAssociative;\n  Collection.isOrdered = isOrdered;\n\n  Collection.Iterator = Iterator;\n\n  mixin(Collection, {\n    // ### Conversion to other types\n\n    toArray: function toArray() {\n      assertNotInfinite(this.size);\n      var array = new Array(this.size || 0);\n      this.valueSeq().__iterate(function (v, i) {\n        array[i] = v;\n      });\n      return array;\n    },\n\n    toIndexedSeq: function toIndexedSeq() {\n      return new ToIndexedSequence(this);\n    },\n\n    toJS: function toJS$1() {\n      return this.toSeq().map(toJS).toJSON();\n    },\n\n    toKeyedSeq: function toKeyedSeq() {\n      return new ToKeyedSequence(this, true);\n    },\n\n    toMap: function toMap() {\n      // Use Late Binding here to solve the circular dependency.\n      return Map(this.toKeyedSeq());\n    },\n\n    toObject: function toObject() {\n      assertNotInfinite(this.size);\n      var object = {};\n      this.__iterate(function (v, k) {\n        object[k] = v;\n      });\n      return object;\n    },\n\n    toOrderedMap: function toOrderedMap() {\n      // Use Late Binding here to solve the circular dependency.\n      return OrderedMap(this.toKeyedSeq());\n    },\n\n    toOrderedSet: function toOrderedSet() {\n      // Use Late Binding here to solve the circular dependency.\n      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toSet: function toSet() {\n      // Use Late Binding here to solve the circular dependency.\n      return Set(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toSetSeq: function toSetSeq() {\n      return new ToSetSequence(this);\n    },\n\n    toSeq: function toSeq() {\n      return isIndexed(this) ? this.toIndexedSeq() : isKeyed(this) ? this.toKeyedSeq() : this.toSetSeq();\n    },\n\n    toStack: function toStack() {\n      // Use Late Binding here to solve the circular dependency.\n      return Stack(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toList: function toList() {\n      // Use Late Binding here to solve the circular dependency.\n      return List(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    // ### Common JavaScript methods and properties\n\n    toString: function toString() {\n      return '[Collection]';\n    },\n\n    __toString: function __toString(head, tail) {\n      if (this.size === 0) {\n        return head + tail;\n      }\n      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;\n    },\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    concat: function concat() {\n      var values = [],\n          len = arguments.length;\n      while (len--) {\n        values[len] = arguments[len];\n      }return reify(this, concatFactory(this, values));\n    },\n\n    includes: function includes(searchValue) {\n      return this.some(function (value) {\n        return is(value, searchValue);\n      });\n    },\n\n    entries: function entries() {\n      return this.__iterator(ITERATE_ENTRIES);\n    },\n\n    every: function every(predicate, context) {\n      assertNotInfinite(this.size);\n      var returnValue = true;\n      this.__iterate(function (v, k, c) {\n        if (!predicate.call(context, v, k, c)) {\n          returnValue = false;\n          return false;\n        }\n      });\n      return returnValue;\n    },\n\n    filter: function filter(predicate, context) {\n      return reify(this, filterFactory(this, predicate, context, true));\n    },\n\n    find: function find(predicate, context, notSetValue) {\n      var entry = this.findEntry(predicate, context);\n      return entry ? entry[1] : notSetValue;\n    },\n\n    forEach: function forEach(sideEffect, context) {\n      assertNotInfinite(this.size);\n      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);\n    },\n\n    join: function join(separator) {\n      assertNotInfinite(this.size);\n      separator = separator !== undefined ? '' + separator : ',';\n      var joined = '';\n      var isFirst = true;\n      this.__iterate(function (v) {\n        isFirst ? isFirst = false : joined += separator;\n        joined += v !== null && v !== undefined ? v.toString() : '';\n      });\n      return joined;\n    },\n\n    keys: function keys() {\n      return this.__iterator(ITERATE_KEYS);\n    },\n\n    map: function map(mapper, context) {\n      return reify(this, mapFactory(this, mapper, context));\n    },\n\n    reduce: function reduce$1(reducer, initialReduction, context) {\n      return reduce(this, reducer, initialReduction, context, arguments.length < 2, false);\n    },\n\n    reduceRight: function reduceRight(reducer, initialReduction, context) {\n      return reduce(this, reducer, initialReduction, context, arguments.length < 2, true);\n    },\n\n    reverse: function reverse() {\n      return reify(this, reverseFactory(this, true));\n    },\n\n    slice: function slice(begin, end) {\n      return reify(this, sliceFactory(this, begin, end, true));\n    },\n\n    some: function some(predicate, context) {\n      return !this.every(not(predicate), context);\n    },\n\n    sort: function sort(comparator) {\n      return reify(this, sortFactory(this, comparator));\n    },\n\n    values: function values() {\n      return this.__iterator(ITERATE_VALUES);\n    },\n\n    // ### More sequential methods\n\n    butLast: function butLast() {\n      return this.slice(0, -1);\n    },\n\n    isEmpty: function isEmpty() {\n      return this.size !== undefined ? this.size === 0 : !this.some(function () {\n        return true;\n      });\n    },\n\n    count: function count(predicate, context) {\n      return ensureSize(predicate ? this.toSeq().filter(predicate, context) : this);\n    },\n\n    countBy: function countBy(grouper, context) {\n      return countByFactory(this, grouper, context);\n    },\n\n    equals: function equals(other) {\n      return deepEqual(this, other);\n    },\n\n    entrySeq: function entrySeq() {\n      var collection = this;\n      if (collection._cache) {\n        // We cache as an entries array, so we can just return the cache!\n        return new ArraySeq(collection._cache);\n      }\n      var entriesSequence = collection.toSeq().map(entryMapper).toIndexedSeq();\n      entriesSequence.fromEntrySeq = function () {\n        return collection.toSeq();\n      };\n\n      // Entries are plain Array, which do not define toJS, so it must\n      // manually converts keys and values before conversion.\n      entriesSequence.toJS = function () {\n        return this.map(function (entry) {\n          return [toJS(entry[0]), toJS(entry[1])];\n        }).toJSON();\n      };\n\n      return entriesSequence;\n    },\n\n    filterNot: function filterNot(predicate, context) {\n      return this.filter(not(predicate), context);\n    },\n\n    findEntry: function findEntry(predicate, context, notSetValue) {\n      var found = notSetValue;\n      this.__iterate(function (v, k, c) {\n        if (predicate.call(context, v, k, c)) {\n          found = [k, v];\n          return false;\n        }\n      });\n      return found;\n    },\n\n    findKey: function findKey(predicate, context) {\n      var entry = this.findEntry(predicate, context);\n      return entry && entry[0];\n    },\n\n    findLast: function findLast(predicate, context, notSetValue) {\n      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);\n    },\n\n    findLastEntry: function findLastEntry(predicate, context, notSetValue) {\n      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);\n    },\n\n    findLastKey: function findLastKey(predicate, context) {\n      return this.toKeyedSeq().reverse().findKey(predicate, context);\n    },\n\n    first: function first() {\n      return this.find(returnTrue);\n    },\n\n    flatMap: function flatMap(mapper, context) {\n      return reify(this, flatMapFactory(this, mapper, context));\n    },\n\n    flatten: function flatten(depth) {\n      return reify(this, flattenFactory(this, depth, true));\n    },\n\n    fromEntrySeq: function fromEntrySeq() {\n      return new FromEntriesSequence(this);\n    },\n\n    get: function get(searchKey, notSetValue) {\n      return this.find(function (_, key) {\n        return is(key, searchKey);\n      }, undefined, notSetValue);\n    },\n\n    getIn: function getIn(searchKeyPath, notSetValue) {\n      var nested = this;\n      var keyPath = coerceKeyPath(searchKeyPath);\n      var i = 0;\n      while (i !== keyPath.length) {\n        if (!nested || !nested.get) {\n          throw new TypeError('Invalid keyPath: Value at [' + keyPath.slice(0, i).map(quoteString) + '] does not have a .get() method: ' + nested);\n        }\n        nested = nested.get(keyPath[i++], NOT_SET);\n        if (nested === NOT_SET) {\n          return notSetValue;\n        }\n      }\n      return nested;\n      // var step;\n      // while (!(step = iter.next()).done) {\n      //   var key = step.value;\n      //   nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;\n      //   if (nested === NOT_SET) {\n      //     return notSetValue;\n      //   }\n      // }\n      // return nested;\n    },\n\n    groupBy: function groupBy(grouper, context) {\n      return groupByFactory(this, grouper, context);\n    },\n\n    has: function has(searchKey) {\n      return this.get(searchKey, NOT_SET) !== NOT_SET;\n    },\n\n    hasIn: function hasIn(searchKeyPath) {\n      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;\n    },\n\n    isSubset: function isSubset(iter) {\n      iter = typeof iter.includes === 'function' ? iter : Collection(iter);\n      return this.every(function (value) {\n        return iter.includes(value);\n      });\n    },\n\n    isSuperset: function isSuperset(iter) {\n      iter = typeof iter.isSubset === 'function' ? iter : Collection(iter);\n      return iter.isSubset(this);\n    },\n\n    keyOf: function keyOf(searchValue) {\n      return this.findKey(function (value) {\n        return is(value, searchValue);\n      });\n    },\n\n    keySeq: function keySeq() {\n      return this.toSeq().map(keyMapper).toIndexedSeq();\n    },\n\n    last: function last() {\n      return this.toSeq().reverse().first();\n    },\n\n    lastKeyOf: function lastKeyOf(searchValue) {\n      return this.toKeyedSeq().reverse().keyOf(searchValue);\n    },\n\n    max: function max(comparator) {\n      return maxFactory(this, comparator);\n    },\n\n    maxBy: function maxBy(mapper, comparator) {\n      return maxFactory(this, comparator, mapper);\n    },\n\n    min: function min(comparator) {\n      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);\n    },\n\n    minBy: function minBy(mapper, comparator) {\n      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);\n    },\n\n    rest: function rest() {\n      return this.slice(1);\n    },\n\n    skip: function skip(amount) {\n      return amount === 0 ? this : this.slice(Math.max(0, amount));\n    },\n\n    skipLast: function skipLast(amount) {\n      return amount === 0 ? this : this.slice(0, -Math.max(0, amount));\n    },\n\n    skipWhile: function skipWhile(predicate, context) {\n      return reify(this, skipWhileFactory(this, predicate, context, true));\n    },\n\n    skipUntil: function skipUntil(predicate, context) {\n      return this.skipWhile(not(predicate), context);\n    },\n\n    sortBy: function sortBy(mapper, comparator) {\n      return reify(this, sortFactory(this, comparator, mapper));\n    },\n\n    take: function take(amount) {\n      return this.slice(0, Math.max(0, amount));\n    },\n\n    takeLast: function takeLast(amount) {\n      return this.slice(-Math.max(0, amount));\n    },\n\n    takeWhile: function takeWhile(predicate, context) {\n      return reify(this, takeWhileFactory(this, predicate, context));\n    },\n\n    takeUntil: function takeUntil(predicate, context) {\n      return this.takeWhile(not(predicate), context);\n    },\n\n    update: function update(fn) {\n      return fn(this);\n    },\n\n    valueSeq: function valueSeq() {\n      return this.toIndexedSeq();\n    },\n\n    // ### Hashable Object\n\n    hashCode: function hashCode() {\n      return this.__hash || (this.__hash = hashCollection(this));\n    }\n\n    // ### Internal\n\n    // abstract __iterate(fn, reverse)\n\n    // abstract __iterator(type, reverse)\n  });\n\n  var CollectionPrototype = Collection.prototype;\n  CollectionPrototype[IS_ITERABLE_SENTINEL] = true;\n  CollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.values;\n  CollectionPrototype.toJSON = CollectionPrototype.toArray;\n  CollectionPrototype.__toStringMapper = quoteString;\n  CollectionPrototype.inspect = CollectionPrototype.toSource = function () {\n    return this.toString();\n  };\n  CollectionPrototype.chain = CollectionPrototype.flatMap;\n  CollectionPrototype.contains = CollectionPrototype.includes;\n\n  mixin(KeyedCollection, {\n    // ### More sequential methods\n\n    flip: function flip() {\n      return reify(this, flipFactory(this));\n    },\n\n    mapEntries: function mapEntries(mapper, context) {\n      var this$1 = this;\n\n      var iterations = 0;\n      return reify(this, this.toSeq().map(function (v, k) {\n        return mapper.call(context, [k, v], iterations++, this$1);\n      }).fromEntrySeq());\n    },\n\n    mapKeys: function mapKeys(mapper, context) {\n      var this$1 = this;\n\n      return reify(this, this.toSeq().flip().map(function (k, v) {\n        return mapper.call(context, k, v, this$1);\n      }).flip());\n    }\n  });\n\n  var KeyedCollectionPrototype = KeyedCollection.prototype;\n  KeyedCollectionPrototype[IS_KEYED_SENTINEL] = true;\n  KeyedCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;\n  KeyedCollectionPrototype.toJSON = CollectionPrototype.toObject;\n  KeyedCollectionPrototype.__toStringMapper = function (v, k) {\n    return quoteString(k) + ': ' + quoteString(v);\n  };\n\n  mixin(IndexedCollection, {\n    // ### Conversion to other types\n\n    toKeyedSeq: function toKeyedSeq() {\n      return new ToKeyedSequence(this, false);\n    },\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    filter: function filter(predicate, context) {\n      return reify(this, filterFactory(this, predicate, context, false));\n    },\n\n    findIndex: function findIndex(predicate, context) {\n      var entry = this.findEntry(predicate, context);\n      return entry ? entry[0] : -1;\n    },\n\n    indexOf: function indexOf(searchValue) {\n      var key = this.keyOf(searchValue);\n      return key === undefined ? -1 : key;\n    },\n\n    lastIndexOf: function lastIndexOf(searchValue) {\n      var key = this.lastKeyOf(searchValue);\n      return key === undefined ? -1 : key;\n    },\n\n    reverse: function reverse() {\n      return reify(this, reverseFactory(this, false));\n    },\n\n    slice: function slice(begin, end) {\n      return reify(this, sliceFactory(this, begin, end, false));\n    },\n\n    splice: function splice(index, removeNum /*, ...values*/) {\n      var numArgs = arguments.length;\n      removeNum = Math.max(removeNum || 0, 0);\n      if (numArgs === 0 || numArgs === 2 && !removeNum) {\n        return this;\n      }\n      // If index is negative, it should resolve relative to the size of the\n      // collection. However size may be expensive to compute if not cached, so\n      // only call count() if the number is in fact negative.\n      index = resolveBegin(index, index < 0 ? this.count() : this.size);\n      var spliced = this.slice(0, index);\n      return reify(this, numArgs === 1 ? spliced : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum)));\n    },\n\n    // ### More collection methods\n\n    findLastIndex: function findLastIndex(predicate, context) {\n      var entry = this.findLastEntry(predicate, context);\n      return entry ? entry[0] : -1;\n    },\n\n    first: function first() {\n      return this.get(0);\n    },\n\n    flatten: function flatten(depth) {\n      return reify(this, flattenFactory(this, depth, false));\n    },\n\n    get: function get(index, notSetValue) {\n      index = wrapIndex(this, index);\n      return index < 0 || this.size === Infinity || this.size !== undefined && index > this.size ? notSetValue : this.find(function (_, key) {\n        return key === index;\n      }, undefined, notSetValue);\n    },\n\n    has: function has(index) {\n      index = wrapIndex(this, index);\n      return index >= 0 && (this.size !== undefined ? this.size === Infinity || index < this.size : this.indexOf(index) !== -1);\n    },\n\n    interpose: function interpose(separator) {\n      return reify(this, interposeFactory(this, separator));\n    },\n\n    interleave: function interleave() /*...collections*/{\n      var collections = [this].concat(arrCopy(arguments));\n      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, collections);\n      var interleaved = zipped.flatten(true);\n      if (zipped.size) {\n        interleaved.size = zipped.size * collections.length;\n      }\n      return reify(this, interleaved);\n    },\n\n    keySeq: function keySeq() {\n      return Range(0, this.size);\n    },\n\n    last: function last() {\n      return this.get(-1);\n    },\n\n    skipWhile: function skipWhile(predicate, context) {\n      return reify(this, skipWhileFactory(this, predicate, context, false));\n    },\n\n    zip: function zip() /*, ...collections */{\n      var collections = [this].concat(arrCopy(arguments));\n      return reify(this, zipWithFactory(this, defaultZipper, collections));\n    },\n\n    zipWith: function zipWith(zipper /*, ...collections */) {\n      var collections = arrCopy(arguments);\n      collections[0] = this;\n      return reify(this, zipWithFactory(this, zipper, collections));\n    }\n  });\n\n  var IndexedCollectionPrototype = IndexedCollection.prototype;\n  IndexedCollectionPrototype[IS_INDEXED_SENTINEL] = true;\n  IndexedCollectionPrototype[IS_ORDERED_SENTINEL] = true;\n\n  mixin(SetCollection, {\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    get: function get(value, notSetValue) {\n      return this.has(value) ? value : notSetValue;\n    },\n\n    includes: function includes(value) {\n      return this.has(value);\n    },\n\n    // ### More sequential methods\n\n    keySeq: function keySeq() {\n      return this.valueSeq();\n    }\n  });\n\n  SetCollection.prototype.has = CollectionPrototype.includes;\n  SetCollection.prototype.contains = SetCollection.prototype.includes;\n\n  // Mixin subclasses\n\n  mixin(KeyedSeq, KeyedCollection.prototype);\n  mixin(IndexedSeq, IndexedCollection.prototype);\n  mixin(SetSeq, SetCollection.prototype);\n\n  // #pragma Helper functions\n\n  function reduce(collection, reducer, reduction, context, useFirst, reverse) {\n    assertNotInfinite(collection.size);\n    collection.__iterate(function (v, k, c) {\n      if (useFirst) {\n        useFirst = false;\n        reduction = v;\n      } else {\n        reduction = reducer.call(context, reduction, v, k, c);\n      }\n    }, reverse);\n    return reduction;\n  }\n\n  function keyMapper(v, k) {\n    return k;\n  }\n\n  function entryMapper(v, k) {\n    return [k, v];\n  }\n\n  function toJS(value) {\n    return value && typeof value.toJS === 'function' ? value.toJS() : value;\n  }\n\n  function not(predicate) {\n    return function () {\n      return !predicate.apply(this, arguments);\n    };\n  }\n\n  function neg(predicate) {\n    return function () {\n      return -predicate.apply(this, arguments);\n    };\n  }\n\n  function defaultZipper() {\n    return arrCopy(arguments);\n  }\n\n  function defaultNegComparator(a, b) {\n    return a < b ? 1 : a > b ? -1 : 0;\n  }\n\n  function hashCollection(collection) {\n    if (collection.size === Infinity) {\n      return 0;\n    }\n    var ordered = isOrdered(collection);\n    var keyed = isKeyed(collection);\n    var h = ordered ? 1 : 0;\n    var size = collection.__iterate(keyed ? ordered ? function (v, k) {\n      h = 31 * h + hashMerge(hash(v), hash(k)) | 0;\n    } : function (v, k) {\n      h = h + hashMerge(hash(v), hash(k)) | 0;\n    } : ordered ? function (v) {\n      h = 31 * h + hash(v) | 0;\n    } : function (v) {\n      h = h + hash(v) | 0;\n    });\n    return murmurHashOfSize(size, h);\n  }\n\n  function murmurHashOfSize(size, h) {\n    h = imul(h, 0xcc9e2d51);\n    h = imul(h << 15 | h >>> -15, 0x1b873593);\n    h = imul(h << 13 | h >>> -13, 5);\n    h = (h + 0xe6546b64 | 0) ^ size;\n    h = imul(h ^ h >>> 16, 0x85ebca6b);\n    h = imul(h ^ h >>> 13, 0xc2b2ae35);\n    h = smi(h ^ h >>> 16);\n    return h;\n  }\n\n  function hashMerge(a, b) {\n    return a ^ b + 0x9e3779b9 + (a << 6) + (a >> 2) | 0; // int\n  }\n\n  var OrderedSet = function (Set$$1) {\n    function OrderedSet(value) {\n      return value === null || value === undefined ? emptyOrderedSet() : isOrderedSet(value) ? value : emptyOrderedSet().withMutations(function (set) {\n        var iter = SetCollection(value);\n        assertNotInfinite(iter.size);\n        iter.forEach(function (v) {\n          return set.add(v);\n        });\n      });\n    }\n\n    if (Set$$1) OrderedSet.__proto__ = Set$$1;\n    OrderedSet.prototype = Object.create(Set$$1 && Set$$1.prototype);\n    OrderedSet.prototype.constructor = OrderedSet;\n\n    OrderedSet.of = function of() /*...values*/{\n      return this(arguments);\n    };\n\n    OrderedSet.fromKeys = function fromKeys(value) {\n      return this(KeyedCollection(value).keySeq());\n    };\n\n    OrderedSet.prototype.toString = function toString() {\n      return this.__toString('OrderedSet {', '}');\n    };\n\n    return OrderedSet;\n  }(Set);\n\n  function isOrderedSet(maybeOrderedSet) {\n    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);\n  }\n\n  OrderedSet.isOrderedSet = isOrderedSet;\n\n  var OrderedSetPrototype = OrderedSet.prototype;\n  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;\n  OrderedSetPrototype.zip = IndexedCollectionPrototype.zip;\n  OrderedSetPrototype.zipWith = IndexedCollectionPrototype.zipWith;\n\n  OrderedSetPrototype.__empty = emptyOrderedSet;\n  OrderedSetPrototype.__make = makeOrderedSet;\n\n  function makeOrderedSet(map, ownerID) {\n    var set = Object.create(OrderedSetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n  }\n\n  var EMPTY_ORDERED_SET;\n  function emptyOrderedSet() {\n    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));\n  }\n\n  var Record = function Record(defaultValues, name) {\n    var hasInitialized;\n\n    var RecordType = function Record(values) {\n      var this$1 = this;\n\n      if (values instanceof RecordType) {\n        return values;\n      }\n      if (!(this instanceof RecordType)) {\n        return new RecordType(values);\n      }\n      if (!hasInitialized) {\n        hasInitialized = true;\n        var keys = Object.keys(defaultValues);\n        var indices = RecordTypePrototype._indices = {};\n        RecordTypePrototype._name = name;\n        RecordTypePrototype._keys = keys;\n        RecordTypePrototype._defaultValues = defaultValues;\n        for (var i = 0; i < keys.length; i++) {\n          var propName = keys[i];\n          indices[propName] = i;\n          if (RecordTypePrototype[propName]) {\n            /* eslint-disable no-console */\n            typeof console === 'object' && console.warn && console.warn('Cannot define ' + recordName(this$1) + ' with property \"' + propName + '\" since that property name is part of the Record API.');\n            /* eslint-enable no-console */\n          } else {\n            setProp(RecordTypePrototype, propName);\n          }\n        }\n      }\n      this.__ownerID = undefined;\n      this._values = List().withMutations(function (l) {\n        l.setSize(this$1._keys.length);\n        KeyedCollection(values).forEach(function (v, k) {\n          l.set(this$1._indices[k], v === this$1._defaultValues[k] ? undefined : v);\n        });\n      });\n    };\n\n    var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);\n    RecordTypePrototype.constructor = RecordType;\n\n    return RecordType;\n  };\n\n  Record.prototype.toString = function toString() {\n    var this$1 = this;\n\n    var str = recordName(this) + ' { ';\n    var keys = this._keys;\n    var k;\n    for (var i = 0, l = keys.length; i !== l; i++) {\n      k = keys[i];\n      str += (i ? ', ' : '') + k + ': ' + quoteString(this$1.get(k));\n    }\n    return str + ' }';\n  };\n\n  Record.prototype.equals = function equals(other) {\n    return this === other || this._keys === other._keys && recordSeq(this).equals(recordSeq(other));\n  };\n\n  Record.prototype.hashCode = function hashCode() {\n    return recordSeq(this).hashCode();\n  };\n\n  // @pragma Access\n\n  Record.prototype.has = function has(k) {\n    return this._indices.hasOwnProperty(k);\n  };\n\n  Record.prototype.get = function get(k, notSetValue) {\n    if (!this.has(k)) {\n      return notSetValue;\n    }\n    var index = this._indices[k];\n    var value = this._values.get(index);\n    return value === undefined ? this._defaultValues[k] : value;\n  };\n\n  // @pragma Modification\n\n  Record.prototype.set = function set(k, v) {\n    if (this.has(k)) {\n      var newValues = this._values.set(this._indices[k], v === this._defaultValues[k] ? undefined : v);\n      if (newValues !== this._values && !this.__ownerID) {\n        return makeRecord(this, newValues);\n      }\n    }\n    return this;\n  };\n\n  Record.prototype.remove = function remove(k) {\n    return this.set(k);\n  };\n\n  Record.prototype.clear = function clear() {\n    var newValues = this._values.clear().setSize(this._keys.length);\n    return this.__ownerID ? this : makeRecord(this, newValues);\n  };\n\n  Record.prototype.wasAltered = function wasAltered() {\n    return this._values.wasAltered();\n  };\n\n  Record.prototype.toSeq = function toSeq() {\n    return recordSeq(this);\n  };\n\n  Record.prototype.toJS = function toJS() {\n    return recordSeq(this).toJS();\n  };\n\n  Record.prototype.__iterator = function __iterator(type, reverse) {\n    return recordSeq(this).__iterator(type, reverse);\n  };\n\n  Record.prototype.__iterate = function __iterate(fn, reverse) {\n    return recordSeq(this).__iterate(fn, reverse);\n  };\n\n  Record.prototype.__ensureOwner = function __ensureOwner(ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    var newValues = this._values.__ensureOwner(ownerID);\n    if (!ownerID) {\n      this.__ownerID = ownerID;\n      this._values = newValues;\n      return this;\n    }\n    return makeRecord(this, newValues, ownerID);\n  };\n\n  Record.isRecord = isRecord;\n  Record.getDescriptiveName = recordName;\n  var RecordPrototype = Record.prototype;\n  RecordPrototype[IS_RECORD_SENTINEL] = true;\n  RecordPrototype[DELETE] = RecordPrototype.remove;\n  RecordPrototype.getIn = CollectionPrototype.getIn;\n  RecordPrototype.hasIn = CollectionPrototype.hasIn;\n  RecordPrototype.merge = MapPrototype.merge;\n  RecordPrototype.mergeWith = MapPrototype.mergeWith;\n  RecordPrototype.mergeIn = MapPrototype.mergeIn;\n  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;\n  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;\n  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n  RecordPrototype.setIn = MapPrototype.setIn;\n  RecordPrototype.update = MapPrototype.update;\n  RecordPrototype.updateIn = MapPrototype.updateIn;\n  RecordPrototype.withMutations = MapPrototype.withMutations;\n  RecordPrototype.asMutable = MapPrototype.asMutable;\n  RecordPrototype.asImmutable = MapPrototype.asImmutable;\n  RecordPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;\n  RecordPrototype.toJSON = RecordPrototype.toObject = CollectionPrototype.toObject;\n  RecordPrototype.inspect = RecordPrototype.toSource = CollectionPrototype.toSource;\n\n  function makeRecord(likeRecord, values, ownerID) {\n    var record = Object.create(Object.getPrototypeOf(likeRecord));\n    record._values = values;\n    record.__ownerID = ownerID;\n    return record;\n  }\n\n  function recordName(record) {\n    return record._name || record.constructor.name || 'Record';\n  }\n\n  function recordSeq(record) {\n    return keyedSeqFromValue(record._keys.map(function (k) {\n      return [k, record.get(k)];\n    }));\n  }\n\n  function setProp(prototype, name) {\n    try {\n      Object.defineProperty(prototype, name, {\n        get: function get() {\n          return this.get(name);\n        },\n        set: function set(value) {\n          invariant(this.__ownerID, 'Cannot set on an immutable record.');\n          this.set(name, value);\n        }\n      });\n    } catch (error) {\n      // Object.defineProperty failed. Probably IE8.\n    }\n  }\n\n  /**\n   * Returns a lazy Seq of `value` repeated `times` times. When `times` is\n   * undefined, returns an infinite sequence of `value`.\n   */\n  var Repeat = function (IndexedSeq$$1) {\n    function Repeat(value, times) {\n      if (!(this instanceof Repeat)) {\n        return new Repeat(value, times);\n      }\n      this._value = value;\n      this.size = times === undefined ? Infinity : Math.max(0, times);\n      if (this.size === 0) {\n        if (EMPTY_REPEAT) {\n          return EMPTY_REPEAT;\n        }\n        EMPTY_REPEAT = this;\n      }\n    }\n\n    if (IndexedSeq$$1) Repeat.__proto__ = IndexedSeq$$1;\n    Repeat.prototype = Object.create(IndexedSeq$$1 && IndexedSeq$$1.prototype);\n    Repeat.prototype.constructor = Repeat;\n\n    Repeat.prototype.toString = function toString() {\n      if (this.size === 0) {\n        return 'Repeat []';\n      }\n      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';\n    };\n\n    Repeat.prototype.get = function get(index, notSetValue) {\n      return this.has(index) ? this._value : notSetValue;\n    };\n\n    Repeat.prototype.includes = function includes(searchValue) {\n      return is(this._value, searchValue);\n    };\n\n    Repeat.prototype.slice = function slice(begin, end) {\n      var size = this.size;\n      return wholeSlice(begin, end, size) ? this : new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));\n    };\n\n    Repeat.prototype.reverse = function reverse() {\n      return this;\n    };\n\n    Repeat.prototype.indexOf = function indexOf(searchValue) {\n      if (is(this._value, searchValue)) {\n        return 0;\n      }\n      return -1;\n    };\n\n    Repeat.prototype.lastIndexOf = function lastIndexOf(searchValue) {\n      if (is(this._value, searchValue)) {\n        return this.size;\n      }\n      return -1;\n    };\n\n    Repeat.prototype.__iterate = function __iterate(fn, reverse) {\n      var this$1 = this;\n\n      var size = this.size;\n      var i = 0;\n      while (i !== size) {\n        if (fn(this$1._value, reverse ? size - ++i : i++, this$1) === false) {\n          break;\n        }\n      }\n      return i;\n    };\n\n    Repeat.prototype.__iterator = function __iterator(type, reverse) {\n      var this$1 = this;\n\n      var size = this.size;\n      var i = 0;\n      return new Iterator(function () {\n        return i === size ? iteratorDone() : iteratorValue(type, reverse ? size - ++i : i++, this$1._value);\n      });\n    };\n\n    Repeat.prototype.equals = function equals(other) {\n      return other instanceof Repeat ? is(this._value, other._value) : deepEqual(other);\n    };\n\n    return Repeat;\n  }(IndexedSeq);\n\n  var EMPTY_REPEAT;\n\n  var Immutable = {\n    Collection: Collection,\n    // Note: Iterable is deprecated\n    Iterable: Collection,\n\n    Seq: Seq,\n    Map: Map,\n    OrderedMap: OrderedMap,\n    List: List,\n    Stack: Stack,\n    Set: Set,\n    OrderedSet: OrderedSet,\n\n    Record: Record,\n    Range: Range,\n    Repeat: Repeat,\n\n    is: is,\n    fromJS: fromJS,\n    hash: hash,\n\n    isImmutable: isImmutable,\n    isCollection: isCollection,\n    isKeyed: isKeyed,\n    isIndexed: isIndexed,\n    isAssociative: isAssociative,\n    isOrdered: isOrdered,\n    isValueObject: isValueObject\n  };\n\n  // Note: Iterable is deprecated\n  var Iterable = Collection;\n\n  exports['default'] = Immutable;\n  exports.Collection = Collection;\n  exports.Iterable = Iterable;\n  exports.Seq = Seq;\n  exports.Map = Map;\n  exports.OrderedMap = OrderedMap;\n  exports.List = List;\n  exports.Stack = Stack;\n  exports.Set = Set;\n  exports.OrderedSet = OrderedSet;\n  exports.Record = Record;\n  exports.Range = Range;\n  exports.Repeat = Repeat;\n  exports.is = is;\n  exports.fromJS = fromJS;\n  exports.hash = hash;\n  exports.isImmutable = isImmutable;\n  exports.isCollection = isCollection;\n  exports.isKeyed = isKeyed;\n  exports.isIndexed = isIndexed;\n  exports.isAssociative = isAssociative;\n  exports.isOrdered = isOrdered;\n  exports.isValueObject = isValueObject;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n});\n\n/***/ }),\n\n/***/ \"dAjQ\":\n/***/ (function(module, exports) {\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  return bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]];\n}\n\nmodule.exports = bytesToUuid;\n\n/***/ }),\n\n/***/ \"f+DB\":\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\nvar rng;\n\nvar crypto = global.crypto || global.msCrypto; // for IE 11\nif (crypto && crypto.getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n  rng = function whatwgRNG() {\n    crypto.getRandomValues(rnds8);\n    return rnds8;\n  };\n}\n\nif (!rng) {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n  rng = function rng() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n\nmodule.exports = rng;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(\"h4f+\")))\n\n/***/ }),\n\n/***/ \"gUuJ\":\n/***/ (function(module, exports) {\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function (n) {\n  if (!isNumber(n) || n < 0 || isNaN(n)) throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function (type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events) this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler)) return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++) {\n      listeners[i].apply(this, args);\n    }\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function (type, listener) {\n  var m;\n\n  if (!isFunction(listener)) throw TypeError('listener must be a function');\n\n  if (!this._events) this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener) this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function (type, listener) {\n  if (!isFunction(listener)) throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function (type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener)) throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type]) return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener || isFunction(list.listener) && list.listener === listener) {\n    delete this._events[type];\n    if (this._events.removeListener) this.emit('removeListener', type, listener);\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener || list[i].listener && list[i].listener === listener) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0) return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener) this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function (type) {\n  var key, listeners;\n\n  if (!this._events) return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0) this._events = {};else if (this._events[type]) delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length) {\n      this.removeListener(type, listeners[listeners.length - 1]);\n    }\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function (type) {\n  var ret;\n  if (!this._events || !this._events[type]) ret = [];else if (isFunction(this._events[type])) ret = [this._events[type]];else ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function (type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener)) return 1;else if (evlistener) return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function (emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n/***/ }),\n\n/***/ \"h4f+\":\n/***/ (function(module, exports) {\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n/***/ }),\n\n/***/ \"hVVj\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar rng = __webpack_require__(\"f+DB\");\nvar bytesToUuid = __webpack_require__(\"dAjQ\");\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\n// random #'s we need to init node and clockseq\nvar _seedBytes = rng();\n\n// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\nvar _nodeId = [_seedBytes[0] | 0x01, _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]];\n\n// Per 4.2.2, randomize (14 bit) clockseq\nvar _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n// Previous uuid creation time\nvar _lastMSecs = 0,\n    _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  var node = options.node || _nodeId;\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;\n\n/***/ }),\n\n/***/ \"hYHi\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar rng = __webpack_require__(\"f+DB\");\nvar bytesToUuid = __webpack_require__(\"dAjQ\");\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof options == 'string') {\n    buf = options == 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n\n/***/ }),\n\n/***/ \"jcLW\":\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(process) {/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(\"y5CM\");\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window && typeof window.process !== 'undefined' && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return typeof document !== 'undefined' && document && 'WebkitAppearance' in document.documentElement.style ||\n  // is firebug? http://stackoverflow.com/a/398120/376773\n  typeof window !== 'undefined' && window && window.console && (console.firebug || console.exception && console.table) ||\n  // is firefox >= v31?\n  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n  typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||\n  // double check webkit in userAgent just in case we are in a worker\n  typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function (v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit');\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function (match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch (e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch (e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(\"xdep\")))\n\n/***/ }),\n\n/***/ \"mY35\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export adapterFun */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return assign$1; });\n/* unused harmony export bulkGetShim */\n/* unused harmony export changesHandler */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return clone; });\n/* unused harmony export defaultBackOff */\n/* unused harmony export explainError */\n/* unused harmony export filterChange */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return flatten; });\n/* unused harmony export functionName */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return guardedConsole; });\n/* unused harmony export hasLocalStorage */\n/* unused harmony export invalidIdError */\n/* unused harmony export isChromeApp */\n/* unused harmony export isCordova */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return isRemote; });\n/* unused harmony export listenerCount */\n/* unused harmony export normalizeDdocFunctionName */\n/* unused harmony export once */\n/* unused harmony export parseDdocFunctionName */\n/* unused harmony export parseUri */\n/* unused harmony export pick */\n/* unused harmony export rev */\n/* unused harmony export scopeEval */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return toPromise; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return upsert; });\n/* unused harmony export uuid */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_uuid__ = __webpack_require__(\"qQO4\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_uuid___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_uuid__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_pouchdb_promise__ = __webpack_require__(\"5euN\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_argsarray__ = __webpack_require__(\"38I5\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_argsarray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_argsarray__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_pouchdb_collections__ = __webpack_require__(\"qpbW\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_events__ = __webpack_require__(\"gUuJ\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_events___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_events__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_inherits__ = __webpack_require__(\"4Bm0\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_inherits__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_immediate__ = __webpack_require__(\"uUPe\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_immediate___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_immediate__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_pouchdb_errors__ = __webpack_require__(\"qncM\");\n/* harmony reexport (default from non-hamory) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return __WEBPACK_IMPORTED_MODULE_6_immediate___default.a; });\n\n\n\n\n\n\n\n\n\nfunction isBinaryObject(object) {\n  return typeof ArrayBuffer !== 'undefined' && object instanceof ArrayBuffer || typeof Blob !== 'undefined' && object instanceof Blob;\n}\n\nfunction cloneArrayBuffer(buff) {\n  if (typeof buff.slice === 'function') {\n    return buff.slice(0);\n  }\n  // IE10-11 slice() polyfill\n  var target = new ArrayBuffer(buff.byteLength);\n  var targetArray = new Uint8Array(target);\n  var sourceArray = new Uint8Array(buff);\n  targetArray.set(sourceArray);\n  return target;\n}\n\nfunction cloneBinaryObject(object) {\n  if (object instanceof ArrayBuffer) {\n    return cloneArrayBuffer(object);\n  }\n  var size = object.size;\n  var type = object.type;\n  // Blob\n  if (typeof object.slice === 'function') {\n    return object.slice(0, size, type);\n  }\n  // PhantomJS slice() replacement\n  return object.webkitSlice(0, size, type);\n}\n\n// most of this is borrowed from lodash.isPlainObject:\n// https://github.com/fis-components/lodash.isplainobject/\n// blob/29c358140a74f252aeb08c9eb28bef86f2217d4a/index.js\n\nvar funcToString = Function.prototype.toString;\nvar objectCtorString = funcToString.call(Object);\n\nfunction isPlainObject(value) {\n  var proto = Object.getPrototypeOf(value);\n  /* istanbul ignore if */\n  if (proto === null) {\n    // not sure when this happens, but I guess it can\n    return true;\n  }\n  var Ctor = proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;\n}\n\nfunction clone(object) {\n  var newObject;\n  var i;\n  var len;\n\n  if (!object || typeof object !== 'object') {\n    return object;\n  }\n\n  if (Array.isArray(object)) {\n    newObject = [];\n    for (i = 0, len = object.length; i < len; i++) {\n      newObject[i] = clone(object[i]);\n    }\n    return newObject;\n  }\n\n  // special case: to avoid inconsistencies between IndexedDB\n  // and other backends, we automatically stringify Dates\n  if (object instanceof Date) {\n    return object.toISOString();\n  }\n\n  if (isBinaryObject(object)) {\n    return cloneBinaryObject(object);\n  }\n\n  if (!isPlainObject(object)) {\n    return object; // don't clone objects like Workers\n  }\n\n  newObject = {};\n  for (i in object) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(object, i)) {\n      var value = clone(object[i]);\n      if (typeof value !== 'undefined') {\n        newObject[i] = value;\n      }\n    }\n  }\n  return newObject;\n}\n\nfunction once(fun) {\n  var called = false;\n  return __WEBPACK_IMPORTED_MODULE_2_argsarray___default()(function (args) {\n    /* istanbul ignore if */\n    if (called) {\n      // this is a smoke test and should never actually happen\n      throw new Error('once called more than once');\n    } else {\n      called = true;\n      fun.apply(this, args);\n    }\n  });\n}\n\nfunction toPromise(func) {\n  //create the function we will be returning\n  return __WEBPACK_IMPORTED_MODULE_2_argsarray___default()(function (args) {\n    // Clone arguments\n    args = clone(args);\n    var self = this;\n    // if the last argument is a function, assume its a callback\n    var usedCB = typeof args[args.length - 1] === 'function' ? args.pop() : false;\n    var promise = new __WEBPACK_IMPORTED_MODULE_1_pouchdb_promise__[\"a\" /* default */](function (fulfill, reject) {\n      var resp;\n      try {\n        var callback = once(function (err, mesg) {\n          if (err) {\n            reject(err);\n          } else {\n            fulfill(mesg);\n          }\n        });\n        // create a callback for this invocation\n        // apply the function in the orig context\n        args.push(callback);\n        resp = func.apply(self, args);\n        if (resp && typeof resp.then === 'function') {\n          fulfill(resp);\n        }\n      } catch (e) {\n        reject(e);\n      }\n    });\n    // if there is a callback, call it back\n    if (usedCB) {\n      promise.then(function (result) {\n        usedCB(null, result);\n      }, usedCB);\n    }\n    return promise;\n  });\n}\n\nfunction logApiCall(self, name, args) {\n  /* istanbul ignore if */\n  if (self.constructor.listeners('debug').length) {\n    var logArgs = ['api', self.name, name];\n    for (var i = 0; i < args.length - 1; i++) {\n      logArgs.push(args[i]);\n    }\n    self.constructor.emit('debug', logArgs);\n\n    // override the callback itself to log the response\n    var origCallback = args[args.length - 1];\n    args[args.length - 1] = function (err, res) {\n      var responseArgs = ['api', self.name, name];\n      responseArgs = responseArgs.concat(err ? ['error', err] : ['success', res]);\n      self.constructor.emit('debug', responseArgs);\n      origCallback(err, res);\n    };\n  }\n}\n\nfunction adapterFun(name, callback) {\n  return toPromise(__WEBPACK_IMPORTED_MODULE_2_argsarray___default()(function (args) {\n    if (this._closed) {\n      return __WEBPACK_IMPORTED_MODULE_1_pouchdb_promise__[\"a\" /* default */].reject(new Error('database is closed'));\n    }\n    if (this._destroyed) {\n      return __WEBPACK_IMPORTED_MODULE_1_pouchdb_promise__[\"a\" /* default */].reject(new Error('database is destroyed'));\n    }\n    var self = this;\n    logApiCall(self, name, args);\n    if (!this.taskqueue.isReady) {\n      return new __WEBPACK_IMPORTED_MODULE_1_pouchdb_promise__[\"a\" /* default */](function (fulfill, reject) {\n        self.taskqueue.addTask(function (failed) {\n          if (failed) {\n            reject(failed);\n          } else {\n            fulfill(self[name].apply(self, args));\n          }\n        });\n      });\n    }\n    return callback.apply(this, args);\n  }));\n}\n\n// like underscore/lodash _.pick()\nfunction pick(obj, arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var prop = arr[i];\n    if (prop in obj) {\n      res[prop] = obj[prop];\n    }\n  }\n  return res;\n}\n\n// Most browsers throttle concurrent requests at 6, so it's silly\n// to shim _bulk_get by trying to launch potentially hundreds of requests\n// and then letting the majority time out. We can handle this ourselves.\nvar MAX_NUM_CONCURRENT_REQUESTS = 6;\n\nfunction identityFunction(x) {\n  return x;\n}\n\nfunction formatResultForOpenRevsGet(result) {\n  return [{\n    ok: result\n  }];\n}\n\n// shim for P/CouchDB adapters that don't directly implement _bulk_get\nfunction bulkGet(db, opts, callback) {\n  var requests = opts.docs;\n\n  // consolidate into one request per doc if possible\n  var requestsById = new __WEBPACK_IMPORTED_MODULE_3_pouchdb_collections__[\"a\" /* Map */]();\n  requests.forEach(function (request) {\n    if (requestsById.has(request.id)) {\n      requestsById.get(request.id).push(request);\n    } else {\n      requestsById.set(request.id, [request]);\n    }\n  });\n\n  var numDocs = requestsById.size;\n  var numDone = 0;\n  var perDocResults = new Array(numDocs);\n\n  function collapseResultsAndFinish() {\n    var results = [];\n    perDocResults.forEach(function (res) {\n      res.docs.forEach(function (info) {\n        results.push({\n          id: res.id,\n          docs: [info]\n        });\n      });\n    });\n    callback(null, { results: results });\n  }\n\n  function checkDone() {\n    if (++numDone === numDocs) {\n      collapseResultsAndFinish();\n    }\n  }\n\n  function gotResult(docIndex, id, docs) {\n    perDocResults[docIndex] = { id: id, docs: docs };\n    checkDone();\n  }\n\n  var allRequests = [];\n  requestsById.forEach(function (value, key) {\n    allRequests.push(key);\n  });\n\n  var i = 0;\n\n  function nextBatch() {\n\n    if (i >= allRequests.length) {\n      return;\n    }\n\n    var upTo = Math.min(i + MAX_NUM_CONCURRENT_REQUESTS, allRequests.length);\n    var batch = allRequests.slice(i, upTo);\n    processBatch(batch, i);\n    i += batch.length;\n  }\n\n  function processBatch(batch, offset) {\n    batch.forEach(function (docId, j) {\n      var docIdx = offset + j;\n      var docRequests = requestsById.get(docId);\n\n      // just use the first request as the \"template\"\n      // TODO: The _bulk_get API allows for more subtle use cases than this,\n      // but for now it is unlikely that there will be a mix of different\n      // \"atts_since\" or \"attachments\" in the same request, since it's just\n      // replicate.js that is using this for the moment.\n      // Also, atts_since is aspirational, since we don't support it yet.\n      var docOpts = pick(docRequests[0], ['atts_since', 'attachments']);\n      docOpts.open_revs = docRequests.map(function (request) {\n        // rev is optional, open_revs disallowed\n        return request.rev;\n      });\n\n      // remove falsey / undefined revisions\n      docOpts.open_revs = docOpts.open_revs.filter(identityFunction);\n\n      var formatResult = identityFunction;\n\n      if (docOpts.open_revs.length === 0) {\n        delete docOpts.open_revs;\n\n        // when fetching only the \"winning\" leaf,\n        // transform the result so it looks like an open_revs\n        // request\n        formatResult = formatResultForOpenRevsGet;\n      }\n\n      // globally-supplied options\n      ['revs', 'attachments', 'binary', 'ajax', 'latest'].forEach(function (param) {\n        if (param in opts) {\n          docOpts[param] = opts[param];\n        }\n      });\n      db.get(docId, docOpts, function (err, res) {\n        var result;\n        /* istanbul ignore if */\n        if (err) {\n          result = [{ error: err }];\n        } else {\n          result = formatResult(res);\n        }\n        gotResult(docIdx, docId, result);\n        nextBatch();\n      });\n    });\n  }\n\n  nextBatch();\n}\n\nfunction isChromeApp() {\n  return typeof chrome !== \"undefined\" && typeof chrome.storage !== \"undefined\" && typeof chrome.storage.local !== \"undefined\";\n}\n\nvar hasLocal;\n\nif (isChromeApp()) {\n  hasLocal = false;\n} else {\n  try {\n    localStorage.setItem('_pouch_check_localstorage', 1);\n    hasLocal = !!localStorage.getItem('_pouch_check_localstorage');\n  } catch (e) {\n    hasLocal = false;\n  }\n}\n\nfunction hasLocalStorage() {\n  return hasLocal;\n}\n\n// Custom nextTick() shim for browsers. In node, this will just be process.nextTick(). We\n// avoid using process.nextTick() directly because the polyfill is very large and we don't\n// need all of it (see: https://github.com/defunctzombie/node-process).\n// \"immediate\" 3.0.8 is used by lie, and it's a smaller version of the latest \"immediate\"\n// package, so it's the one we use.\n// When we use nextTick() in our codebase, we only care about not releasing Zalgo\n// (see: http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony).\n// Microtask vs macrotask doesn't matter to us. So we're free to use the fastest\n// (least latency) option, which is \"immediate\" due to use of microtasks.\n// All of our nextTicks are isolated to this one function so we can easily swap out one\n// implementation for another.\n\n__WEBPACK_IMPORTED_MODULE_5_inherits___default()(Changes, __WEBPACK_IMPORTED_MODULE_4_events__[\"EventEmitter\"]);\n\n/* istanbul ignore next */\nfunction attachBrowserEvents(self) {\n  if (isChromeApp()) {\n    chrome.storage.onChanged.addListener(function (e) {\n      // make sure it's event addressed to us\n      if (e.db_name != null) {\n        //object only has oldValue, newValue members\n        self.emit(e.dbName.newValue);\n      }\n    });\n  } else if (hasLocalStorage()) {\n    if (typeof addEventListener !== 'undefined') {\n      addEventListener(\"storage\", function (e) {\n        self.emit(e.key);\n      });\n    } else {\n      // old IE\n      window.attachEvent(\"storage\", function (e) {\n        self.emit(e.key);\n      });\n    }\n  }\n}\n\nfunction Changes() {\n  __WEBPACK_IMPORTED_MODULE_4_events__[\"EventEmitter\"].call(this);\n  this._listeners = {};\n\n  attachBrowserEvents(this);\n}\nChanges.prototype.addListener = function (dbName, id, db, opts) {\n  /* istanbul ignore if */\n  if (this._listeners[id]) {\n    return;\n  }\n  var self = this;\n  var inprogress = false;\n  function eventFunction() {\n    /* istanbul ignore if */\n    if (!self._listeners[id]) {\n      return;\n    }\n    if (inprogress) {\n      inprogress = 'waiting';\n      return;\n    }\n    inprogress = true;\n    var changesOpts = pick(opts, ['style', 'include_docs', 'attachments', 'conflicts', 'filter', 'doc_ids', 'view', 'since', 'query_params', 'binary']);\n\n    /* istanbul ignore next */\n    function onError() {\n      inprogress = false;\n    }\n\n    db.changes(changesOpts).on('change', function (c) {\n      if (c.seq > opts.since && !opts.cancelled) {\n        opts.since = c.seq;\n        opts.onChange(c);\n      }\n    }).on('complete', function () {\n      if (inprogress === 'waiting') {\n        __WEBPACK_IMPORTED_MODULE_6_immediate___default()(eventFunction);\n      }\n      inprogress = false;\n    }).on('error', onError);\n  }\n  this._listeners[id] = eventFunction;\n  this.on(dbName, eventFunction);\n};\n\nChanges.prototype.removeListener = function (dbName, id) {\n  /* istanbul ignore if */\n  if (!(id in this._listeners)) {\n    return;\n  }\n  __WEBPACK_IMPORTED_MODULE_4_events__[\"EventEmitter\"].prototype.removeListener.call(this, dbName, this._listeners[id]);\n  delete this._listeners[id];\n};\n\n/* istanbul ignore next */\nChanges.prototype.notifyLocalWindows = function (dbName) {\n  //do a useless change on a storage thing\n  //in order to get other windows's listeners to activate\n  if (isChromeApp()) {\n    chrome.storage.local.set({ dbName: dbName });\n  } else if (hasLocalStorage()) {\n    localStorage[dbName] = localStorage[dbName] === \"a\" ? \"b\" : \"a\";\n  }\n};\n\nChanges.prototype.notify = function (dbName) {\n  this.emit(dbName);\n  this.notifyLocalWindows(dbName);\n};\n\nfunction guardedConsole(method) {\n  /* istanbul ignore else */\n  if (console !== 'undefined' && method in console) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    console[method].apply(console, args);\n  }\n}\n\nfunction randomNumber(min, max) {\n  var maxTimeout = 600000; // Hard-coded default of 10 minutes\n  min = parseInt(min, 10) || 0;\n  max = parseInt(max, 10);\n  if (max !== max || max <= min) {\n    max = (min || 1) << 1; //doubling\n  } else {\n    max = max + 1;\n  }\n  // In order to not exceed maxTimeout, pick a random value between half of maxTimeout and maxTimeout\n  if (max > maxTimeout) {\n    min = maxTimeout >> 1; // divide by two\n    max = maxTimeout;\n  }\n  var ratio = Math.random();\n  var range = max - min;\n\n  return ~~(range * ratio + min); // ~~ coerces to an int, but fast.\n}\n\nfunction defaultBackOff(min) {\n  var max = 0;\n  if (!min) {\n    max = 2000;\n  }\n  return randomNumber(min, max);\n}\n\n// designed to give info to browser users, who are disturbed\n// when they see http errors in the console\nfunction explainError(status, str) {\n  guardedConsole('info', 'The above ' + status + ' is totally normal. ' + str);\n}\n\nvar assign;\n{\n  if (typeof Object.assign === 'function') {\n    assign = Object.assign;\n  } else {\n    // lite Object.assign polyfill based on\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n    assign = function assign(target) {\n      var to = Object(target);\n\n      for (var index = 1; index < arguments.length; index++) {\n        var nextSource = arguments[index];\n\n        if (nextSource != null) {\n          // Skip over if undefined or null\n          for (var nextKey in nextSource) {\n            // Avoid bugs when hasOwnProperty is shadowed\n            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n              to[nextKey] = nextSource[nextKey];\n            }\n          }\n        }\n      }\n      return to;\n    };\n  }\n}\n\nvar assign$1 = assign;\n\nfunction tryFilter(filter, doc, req) {\n  try {\n    return !filter(doc, req);\n  } catch (err) {\n    var msg = 'Filter function threw: ' + err.toString();\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_pouchdb_errors__[\"a\" /* createError */])(__WEBPACK_IMPORTED_MODULE_7_pouchdb_errors__[\"b\" /* BAD_REQUEST */], msg);\n  }\n}\n\nfunction filterChange(opts) {\n  var req = {};\n  var hasFilter = opts.filter && typeof opts.filter === 'function';\n  req.query = opts.query_params;\n\n  return function filter(change) {\n    if (!change.doc) {\n      // CSG sends events on the changes feed that don't have documents,\n      // this hack makes a whole lot of existing code robust.\n      change.doc = {};\n    }\n\n    var filterReturn = hasFilter && tryFilter(opts.filter, change.doc, req);\n\n    if (typeof filterReturn === 'object') {\n      return filterReturn;\n    }\n\n    if (filterReturn) {\n      return false;\n    }\n\n    if (!opts.include_docs) {\n      delete change.doc;\n    } else if (!opts.attachments) {\n      for (var att in change.doc._attachments) {\n        /* istanbul ignore else */\n        if (change.doc._attachments.hasOwnProperty(att)) {\n          change.doc._attachments[att].stub = true;\n        }\n      }\n    }\n    return true;\n  };\n}\n\nfunction flatten(arrs) {\n  var res = [];\n  for (var i = 0, len = arrs.length; i < len; i++) {\n    res = res.concat(arrs[i]);\n  }\n  return res;\n}\n\n// shim for Function.prototype.name,\n// for browsers that don't support it like IE\n\n/* istanbul ignore next */\nfunction f() {}\n\nvar hasName = f.name;\nvar res;\n\n// We dont run coverage in IE\n/* istanbul ignore else */\nif (hasName) {\n  res = function res(fun) {\n    return fun.name;\n  };\n} else {\n  res = function res(fun) {\n    return fun.toString().match(/^\\s*function\\s*(\\S*)\\s*\\(/)[1];\n  };\n}\n\nvar res$1 = res;\n\n// Determine id an ID is valid\n//   - invalid IDs begin with an underescore that does not begin '_design' or\n//     '_local'\n//   - any other string value is a valid id\n// Returns the specific error object for each case\nfunction invalidIdError(id) {\n  var err;\n  if (!id) {\n    err = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_pouchdb_errors__[\"a\" /* createError */])(__WEBPACK_IMPORTED_MODULE_7_pouchdb_errors__[\"c\" /* MISSING_ID */]);\n  } else if (typeof id !== 'string') {\n    err = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_pouchdb_errors__[\"a\" /* createError */])(__WEBPACK_IMPORTED_MODULE_7_pouchdb_errors__[\"d\" /* INVALID_ID */]);\n  } else if (/^_/.test(id) && !/^_(design|local)/.test(id)) {\n    err = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_pouchdb_errors__[\"a\" /* createError */])(__WEBPACK_IMPORTED_MODULE_7_pouchdb_errors__[\"e\" /* RESERVED_ID */]);\n  }\n  if (err) {\n    throw err;\n  }\n}\n\nfunction isCordova() {\n  return typeof cordova !== \"undefined\" || typeof PhoneGap !== \"undefined\" || typeof phonegap !== \"undefined\";\n}\n\n// Checks if a PouchDB object is \"remote\" or not. This is\n// designed to opt-in to certain optimizations, such as\n// avoiding checks for \"dependentDbs\" and other things that\n// we know only apply to local databases. In general, \"remote\"\n// should be true for the http adapter, and for third-party\n// adapters with similar expensive boundaries to cross for\n// every API call, such as socket-pouch and worker-pouch.\n// Previously, this was handled via db.type() === 'http'\n// which is now deprecated.\n\nfunction isRemote(db) {\n  if (typeof db._remote === 'boolean') {\n    return db._remote;\n  }\n  /* istanbul ignore next */\n  if (typeof db.type === 'function') {\n    guardedConsole('warn', 'db.type() is deprecated and will be removed in ' + 'a future version of PouchDB');\n    return db.type() === 'http';\n  }\n  /* istanbul ignore next */\n  return false;\n}\n\nfunction listenerCount(ee, type) {\n  return 'listenerCount' in ee ? ee.listenerCount(type) : __WEBPACK_IMPORTED_MODULE_4_events__[\"EventEmitter\"].listenerCount(ee, type);\n}\n\nfunction parseDesignDocFunctionName(s) {\n  if (!s) {\n    return null;\n  }\n  var parts = s.split('/');\n  if (parts.length === 2) {\n    return parts;\n  }\n  if (parts.length === 1) {\n    return [s, s];\n  }\n  return null;\n}\n\nfunction normalizeDesignDocFunctionName(s) {\n  var normalized = parseDesignDocFunctionName(s);\n  return normalized ? normalized.join('/') : null;\n}\n\n// originally parseUri 1.2.2, now patched by us\n// (c) Steven Levithan <stevenlevithan.com>\n// MIT License\nvar keys = [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\", \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"];\nvar qName = \"queryKey\";\nvar qParser = /(?:^|&)([^&=]*)=?([^&]*)/g;\n\n// use the \"loose\" parser\n/* eslint maxlen: 0, no-useless-escape: 0 */\nvar parser = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\nfunction parseUri(str) {\n  var m = parser.exec(str);\n  var uri = {};\n  var i = 14;\n\n  while (i--) {\n    var key = keys[i];\n    var value = m[i] || \"\";\n    var encoded = ['user', 'password'].indexOf(key) !== -1;\n    uri[key] = encoded ? decodeURIComponent(value) : value;\n  }\n\n  uri[qName] = {};\n  uri[keys[12]].replace(qParser, function ($0, $1, $2) {\n    if ($1) {\n      uri[qName][$1] = $2;\n    }\n  });\n\n  return uri;\n}\n\n// Based on https://github.com/alexdavid/scope-eval v0.0.3\n// (source: https://unpkg.com/scope-eval@0.0.3/scope_eval.js)\n// This is basically just a wrapper around new Function()\n\nfunction scopeEval(source, scope) {\n  var keys = [];\n  var values = [];\n  for (var key in scope) {\n    if (scope.hasOwnProperty(key)) {\n      keys.push(key);\n      values.push(scope[key]);\n    }\n  }\n  keys.push(source);\n  return Function.apply(null, keys).apply(null, values);\n}\n\n// this is essentially the \"update sugar\" function from daleharvey/pouchdb#1388\n// the diffFun tells us what delta to apply to the doc.  it either returns\n// the doc, or false if it doesn't need to do an update after all\nfunction upsert(db, docId, diffFun) {\n  return new __WEBPACK_IMPORTED_MODULE_1_pouchdb_promise__[\"a\" /* default */](function (fulfill, reject) {\n    db.get(docId, function (err, doc) {\n      if (err) {\n        /* istanbul ignore next */\n        if (err.status !== 404) {\n          return reject(err);\n        }\n        doc = {};\n      }\n\n      // the user might change the _rev, so save it for posterity\n      var docRev = doc._rev;\n      var newDoc = diffFun(doc);\n\n      if (!newDoc) {\n        // if the diffFun returns falsy, we short-circuit as\n        // an optimization\n        return fulfill({ updated: false, rev: docRev });\n      }\n\n      // users aren't allowed to modify these values,\n      // so reset them here\n      newDoc._id = docId;\n      newDoc._rev = docRev;\n      fulfill(tryAndPut(db, newDoc, diffFun));\n    });\n  });\n}\n\nfunction tryAndPut(db, doc, diffFun) {\n  return db.put(doc).then(function (res) {\n    return {\n      updated: true,\n      rev: res.rev\n    };\n  }, function (err) {\n    /* istanbul ignore next */\n    if (err.status !== 409) {\n      throw err;\n    }\n    return upsert(db, doc._id, diffFun);\n  });\n}\n\nfunction rev() {\n  return __WEBPACK_IMPORTED_MODULE_0_uuid___default.a.v4().replace(/-/g, '').toLowerCase();\n}\n\nvar uuid = __WEBPACK_IMPORTED_MODULE_0_uuid___default.a.v4;\n\n\n\n/***/ }),\n\n/***/ \"osyQ\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _preact = __webpack_require__(\"KM04\");\n\nif (false) {\n\trequire('preact/devtools');\n} else if ('serviceWorker' in navigator && location.protocol === 'https:') {\n\tnavigator.serviceWorker.register('/sw.js');\n}\n\nvar interopDefault = function interopDefault(m) {\n\treturn m && m.default || m;\n};\n\nvar app = interopDefault(__webpack_require__(\"JkW7\"));\n\nif (typeof app === 'function') {\n\tvar root = document.body.firstElementChild;\n\n\tvar init = function init() {\n\t\tvar app = interopDefault(__webpack_require__(\"JkW7\"));\n\t\troot = (0, _preact.render)((0, _preact.h)(app), document.body, root);\n\t};\n\n\tif (false) module.hot.accept('preact-cli-entrypoint', init);\n\n\tinit();\n}\n\n/***/ }),\n\n/***/ \"qQO4\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar v1 = __webpack_require__(\"hVVj\");\nvar v4 = __webpack_require__(\"hYHi\");\n\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\n\nmodule.exports = uuid;\n\n/***/ }),\n\n/***/ \"qncM\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export UNAUTHORIZED */\n/* unused harmony export MISSING_BULK_DOCS */\n/* unused harmony export MISSING_DOC */\n/* unused harmony export REV_CONFLICT */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return INVALID_ID; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return MISSING_ID; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return RESERVED_ID; });\n/* unused harmony export NOT_OPEN */\n/* unused harmony export UNKNOWN_ERROR */\n/* unused harmony export BAD_ARG */\n/* unused harmony export INVALID_REQUEST */\n/* unused harmony export QUERY_PARSE_ERROR */\n/* unused harmony export DOC_VALIDATION */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return BAD_REQUEST; });\n/* unused harmony export NOT_AN_OBJECT */\n/* unused harmony export DB_MISSING */\n/* unused harmony export WSQ_ERROR */\n/* unused harmony export LDB_ERROR */\n/* unused harmony export FORBIDDEN */\n/* unused harmony export INVALID_REV */\n/* unused harmony export FILE_EXISTS */\n/* unused harmony export MISSING_STUB */\n/* unused harmony export IDB_ERROR */\n/* unused harmony export INVALID_URL */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return createError; });\n/* unused harmony export generateErrorFromResponse */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_inherits__ = __webpack_require__(\"4Bm0\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_inherits__);\n\n\n__WEBPACK_IMPORTED_MODULE_0_inherits___default()(PouchError, Error);\n\nfunction PouchError(status, error, reason) {\n  Error.call(this, reason);\n  this.status = status;\n  this.name = error;\n  this.message = reason;\n  this.error = true;\n}\n\nPouchError.prototype.toString = function () {\n  return JSON.stringify({\n    status: this.status,\n    name: this.name,\n    message: this.message,\n    reason: this.reason\n  });\n};\n\nvar UNAUTHORIZED = new PouchError(401, 'unauthorized', \"Name or password is incorrect.\");\nvar MISSING_BULK_DOCS = new PouchError(400, 'bad_request', \"Missing JSON list of 'docs'\");\nvar MISSING_DOC = new PouchError(404, 'not_found', 'missing');\nvar REV_CONFLICT = new PouchError(409, 'conflict', 'Document update conflict');\nvar INVALID_ID = new PouchError(400, 'bad_request', '_id field must contain a string');\nvar MISSING_ID = new PouchError(412, 'missing_id', '_id is required for puts');\nvar RESERVED_ID = new PouchError(400, 'bad_request', 'Only reserved document ids may start with underscore.');\nvar NOT_OPEN = new PouchError(412, 'precondition_failed', 'Database not open');\nvar UNKNOWN_ERROR = new PouchError(500, 'unknown_error', 'Database encountered an unknown error');\nvar BAD_ARG = new PouchError(500, 'badarg', 'Some query argument is invalid');\nvar INVALID_REQUEST = new PouchError(400, 'invalid_request', 'Request was invalid');\nvar QUERY_PARSE_ERROR = new PouchError(400, 'query_parse_error', 'Some query parameter is invalid');\nvar DOC_VALIDATION = new PouchError(500, 'doc_validation', 'Bad special document member');\nvar BAD_REQUEST = new PouchError(400, 'bad_request', 'Something wrong with the request');\nvar NOT_AN_OBJECT = new PouchError(400, 'bad_request', 'Document must be a JSON object');\nvar DB_MISSING = new PouchError(404, 'not_found', 'Database not found');\nvar IDB_ERROR = new PouchError(500, 'indexed_db_went_bad', 'unknown');\nvar WSQ_ERROR = new PouchError(500, 'web_sql_went_bad', 'unknown');\nvar LDB_ERROR = new PouchError(500, 'levelDB_went_went_bad', 'unknown');\nvar FORBIDDEN = new PouchError(403, 'forbidden', 'Forbidden by design doc validate_doc_update function');\nvar INVALID_REV = new PouchError(400, 'bad_request', 'Invalid rev format');\nvar FILE_EXISTS = new PouchError(412, 'file_exists', 'The database could not be created, the file already exists.');\nvar MISSING_STUB = new PouchError(412, 'missing_stub', 'A pre-existing attachment stub wasn\\'t found');\nvar INVALID_URL = new PouchError(413, 'invalid_url', 'Provided URL is invalid');\n\nfunction createError(error, reason) {\n  function CustomPouchError(reason) {\n    // inherit error properties from our parent error manually\n    // so as to allow proper JSON parsing.\n    /* jshint ignore:start */\n    for (var p in error) {\n      if (typeof error[p] !== 'function') {\n        this[p] = error[p];\n      }\n    }\n    /* jshint ignore:end */\n    if (reason !== undefined) {\n      this.reason = reason;\n    }\n  }\n  CustomPouchError.prototype = PouchError.prototype;\n  return new CustomPouchError(reason);\n}\n\nfunction generateErrorFromResponse(err) {\n\n  if (typeof err !== 'object') {\n    var data = err;\n    err = UNKNOWN_ERROR;\n    err.data = data;\n  }\n\n  if ('error' in err && err.error === 'conflict') {\n    err.name = 'conflict';\n    err.status = 409;\n  }\n\n  if (!('name' in err)) {\n    err.name = err.error || 'unknown';\n  }\n\n  if (!('status' in err)) {\n    err.status = 500;\n  }\n\n  if (!('message' in err)) {\n    err.message = err.message || err.reason;\n  }\n\n  return err;\n}\n\n\n\n/***/ }),\n\n/***/ \"qove\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_pouchdb_promise__ = __webpack_require__(\"5euN\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_pouchdb_collections__ = __webpack_require__(\"qpbW\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_pouchdb_utils__ = __webpack_require__(\"mY35\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_pouchdb_binary_utils__ = __webpack_require__(\"8/Wf\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_pouchdb_collate__ = __webpack_require__(\"1XVU\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_pouchdb_md5__ = __webpack_require__(\"ZfEw\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_pouchdb_mapreduce_utils__ = __webpack_require__(\"T/c0\");\n\n\n\n\n\n\n\n\n/*\n * Simple task queue to sequentialize actions. Assumes\n * callbacks will eventually fire (once).\n */\n\nfunction TaskQueue() {\n  this.promise = new __WEBPACK_IMPORTED_MODULE_0_pouchdb_promise__[\"a\" /* default */](function (fulfill) {\n    fulfill();\n  });\n}\nTaskQueue.prototype.add = function (promiseFactory) {\n  this.promise = this.promise.catch(function () {\n    // just recover\n  }).then(function () {\n    return promiseFactory();\n  });\n  return this.promise;\n};\nTaskQueue.prototype.finish = function () {\n  return this.promise;\n};\n\nfunction stringify(input) {\n  if (!input) {\n    return 'undefined'; // backwards compat for empty reduce\n  }\n  // for backwards compat with mapreduce, functions/strings are stringified\n  // as-is. everything else is JSON-stringified.\n  switch (typeof input) {\n    case 'function':\n      // e.g. a mapreduce map\n      return input.toString();\n    case 'string':\n      // e.g. a mapreduce built-in _reduce function\n      return input.toString();\n    default:\n      // e.g. a JSON object in the case of mango queries\n      return JSON.stringify(input);\n  }\n}\n\n/* create a string signature for a view so we can cache it and uniq it */\nfunction createViewSignature(mapFun, reduceFun) {\n  // the \"undefined\" part is for backwards compatibility\n  return stringify(mapFun) + stringify(reduceFun) + 'undefined';\n}\n\nfunction createView(sourceDB, viewName, mapFun, reduceFun, temporary, localDocName) {\n  var viewSignature = createViewSignature(mapFun, reduceFun);\n\n  var cachedViews;\n  if (!temporary) {\n    // cache this to ensure we don't try to update the same view twice\n    cachedViews = sourceDB._cachedViews = sourceDB._cachedViews || {};\n    if (cachedViews[viewSignature]) {\n      return cachedViews[viewSignature];\n    }\n  }\n\n  var promiseForView = sourceDB.info().then(function (info) {\n\n    var depDbName = info.db_name + '-mrview-' + (temporary ? 'temp' : __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5_pouchdb_md5__[\"a\" /* stringMd5 */])(viewSignature));\n\n    // save the view name in the source db so it can be cleaned up if necessary\n    // (e.g. when the _design doc is deleted, remove all associated view data)\n    function diffFunction(doc) {\n      doc.views = doc.views || {};\n      var fullViewName = viewName;\n      if (fullViewName.indexOf('/') === -1) {\n        fullViewName = viewName + '/' + viewName;\n      }\n      var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};\n      /* istanbul ignore if */\n      if (depDbs[depDbName]) {\n        return; // no update necessary\n      }\n      depDbs[depDbName] = true;\n      return doc;\n    }\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_pouchdb_utils__[\"c\" /* upsert */])(sourceDB, '_local/' + localDocName, diffFunction).then(function () {\n      return sourceDB.registerDependentDatabase(depDbName).then(function (res) {\n        var db = res.db;\n        db.auto_compaction = true;\n        var view = {\n          name: depDbName,\n          db: db,\n          sourceDB: sourceDB,\n          adapter: sourceDB.adapter,\n          mapFun: mapFun,\n          reduceFun: reduceFun\n        };\n        return view.db.get('_local/lastSeq').catch(function (err) {\n          /* istanbul ignore if */\n          if (err.status !== 404) {\n            throw err;\n          }\n        }).then(function (lastSeqDoc) {\n          view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;\n          if (cachedViews) {\n            view.db.once('destroyed', function () {\n              delete cachedViews[viewSignature];\n            });\n          }\n          return view;\n        });\n      });\n    });\n  });\n\n  if (cachedViews) {\n    cachedViews[viewSignature] = promiseForView;\n  }\n  return promiseForView;\n}\n\nvar persistentQueues = {};\nvar tempViewQueue = new TaskQueue();\nvar CHANGES_BATCH_SIZE = 50;\n\nfunction parseViewName(name) {\n  // can be either 'ddocname/viewname' or just 'viewname'\n  // (where the ddoc name is the same)\n  return name.indexOf('/') === -1 ? [name, name] : name.split('/');\n}\n\nfunction isGenOne(changes) {\n  // only return true if the current change is 1-\n  // and there are no other leafs\n  return changes.length === 1 && /^1-/.test(changes[0].rev);\n}\n\nfunction emitError(db, e) {\n  try {\n    db.emit('error', e);\n  } catch (err) {\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_pouchdb_utils__[\"f\" /* guardedConsole */])('error', 'The user\\'s map/reduce function threw an uncaught error.\\n' + 'You can debug this error by doing:\\n' + 'myDatabase.on(\\'error\\', function (err) { debugger; });\\n' + 'Please double-check your map/reduce function.');\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_pouchdb_utils__[\"f\" /* guardedConsole */])('error', e);\n  }\n}\n\n/**\n * Returns an \"abstract\" mapreduce object of the form:\n *\n *   {\n *     query: queryFun,\n *     viewCleanup: viewCleanupFun\n *   }\n *\n * Arguments are:\n *\n * localDoc: string\n *   This is for the local doc that gets saved in order to track the\n *   \"dependent\" DBs and clean them up for viewCleanup. It should be\n *   unique, so that indexer plugins don't collide with each other.\n * mapper: function (mapFunDef, emit)\n *   Returns a map function based on the mapFunDef, which in the case of\n *   normal map/reduce is just the de-stringified function, but may be\n *   something else, such as an object in the case of pouchdb-find.\n * reducer: function (reduceFunDef)\n *   Ditto, but for reducing. Modules don't have to support reducing\n *   (e.g. pouchdb-find).\n * ddocValidator: function (ddoc, viewName)\n *   Throws an error if the ddoc or viewName is not valid.\n *   This could be a way to communicate to the user that the configuration for the\n *   indexer is invalid.\n */\nfunction createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator) {\n\n  function tryMap(db, fun, doc) {\n    // emit an event if there was an error thrown by a map function.\n    // putting try/catches in a single function also avoids deoptimizations.\n    try {\n      fun(doc);\n    } catch (e) {\n      emitError(db, e);\n    }\n  }\n\n  function tryReduce(db, fun, keys, values, rereduce) {\n    // same as above, but returning the result or an error. there are two separate\n    // functions to avoid extra memory allocations since the tryCode() case is used\n    // for custom map functions (common) vs this function, which is only used for\n    // custom reduce functions (rare)\n    try {\n      return { output: fun(keys, values, rereduce) };\n    } catch (e) {\n      emitError(db, e);\n      return { error: e };\n    }\n  }\n\n  function sortByKeyThenValue(x, y) {\n    var keyCompare = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_pouchdb_collate__[\"a\" /* collate */])(x.key, y.key);\n    return keyCompare !== 0 ? keyCompare : __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_pouchdb_collate__[\"a\" /* collate */])(x.value, y.value);\n  }\n\n  function sliceResults(results, limit, skip) {\n    skip = skip || 0;\n    if (typeof limit === 'number') {\n      return results.slice(skip, limit + skip);\n    } else if (skip > 0) {\n      return results.slice(skip);\n    }\n    return results;\n  }\n\n  function rowToDocId(row) {\n    var val = row.value;\n    // Users can explicitly specify a joined doc _id, or it\n    // defaults to the doc _id that emitted the key/value.\n    var docId = val && typeof val === 'object' && val._id || row.id;\n    return docId;\n  }\n\n  function readAttachmentsAsBlobOrBuffer(res) {\n    res.rows.forEach(function (row) {\n      var atts = row.doc && row.doc._attachments;\n      if (!atts) {\n        return;\n      }\n      Object.keys(atts).forEach(function (filename) {\n        var att = atts[filename];\n        atts[filename].data = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3_pouchdb_binary_utils__[\"c\" /* base64StringToBlobOrBuffer */])(att.data, att.content_type);\n      });\n    });\n  }\n\n  function postprocessAttachments(opts) {\n    return function (res) {\n      if (opts.include_docs && opts.attachments && opts.binary) {\n        readAttachmentsAsBlobOrBuffer(res);\n      }\n      return res;\n    };\n  }\n\n  function addHttpParam(paramName, opts, params, asJson) {\n    // add an http param from opts to params, optionally json-encoded\n    var val = opts[paramName];\n    if (typeof val !== 'undefined') {\n      if (asJson) {\n        val = encodeURIComponent(JSON.stringify(val));\n      }\n      params.push(paramName + '=' + val);\n    }\n  }\n\n  function coerceInteger(integerCandidate) {\n    if (typeof integerCandidate !== 'undefined') {\n      var asNumber = Number(integerCandidate);\n      // prevents e.g. '1foo' or '1.1' being coerced to 1\n      if (!isNaN(asNumber) && asNumber === parseInt(integerCandidate, 10)) {\n        return asNumber;\n      } else {\n        return integerCandidate;\n      }\n    }\n  }\n\n  function coerceOptions(opts) {\n    opts.group_level = coerceInteger(opts.group_level);\n    opts.limit = coerceInteger(opts.limit);\n    opts.skip = coerceInteger(opts.skip);\n    return opts;\n  }\n\n  function checkPositiveInteger(number) {\n    if (number) {\n      if (typeof number !== 'number') {\n        return new __WEBPACK_IMPORTED_MODULE_6_pouchdb_mapreduce_utils__[\"a\" /* QueryParseError */]('Invalid value for integer: \"' + number + '\"');\n      }\n      if (number < 0) {\n        return new __WEBPACK_IMPORTED_MODULE_6_pouchdb_mapreduce_utils__[\"a\" /* QueryParseError */]('Invalid value for positive integer: ' + '\"' + number + '\"');\n      }\n    }\n  }\n\n  function checkQueryParseError(options, fun) {\n    var startkeyName = options.descending ? 'endkey' : 'startkey';\n    var endkeyName = options.descending ? 'startkey' : 'endkey';\n\n    if (typeof options[startkeyName] !== 'undefined' && typeof options[endkeyName] !== 'undefined' && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_pouchdb_collate__[\"a\" /* collate */])(options[startkeyName], options[endkeyName]) > 0) {\n      throw new __WEBPACK_IMPORTED_MODULE_6_pouchdb_mapreduce_utils__[\"a\" /* QueryParseError */]('No rows can match your key range, ' + 'reverse your start_key and end_key or set {descending : true}');\n    } else if (fun.reduce && options.reduce !== false) {\n      if (options.include_docs) {\n        throw new __WEBPACK_IMPORTED_MODULE_6_pouchdb_mapreduce_utils__[\"a\" /* QueryParseError */]('{include_docs:true} is invalid for reduce');\n      } else if (options.keys && options.keys.length > 1 && !options.group && !options.group_level) {\n        throw new __WEBPACK_IMPORTED_MODULE_6_pouchdb_mapreduce_utils__[\"a\" /* QueryParseError */]('Multi-key fetches for reduce views must use ' + '{group: true}');\n      }\n    }\n    ['group_level', 'limit', 'skip'].forEach(function (optionName) {\n      var error = checkPositiveInteger(options[optionName]);\n      if (error) {\n        throw error;\n      }\n    });\n  }\n\n  function httpQuery(db, fun, opts) {\n    // List of parameters to add to the PUT request\n    var params = [];\n    var body;\n    var method = 'GET';\n\n    // If opts.reduce exists and is defined, then add it to the list\n    // of parameters.\n    // If reduce=false then the results are that of only the map function\n    // not the final result of map and reduce.\n    addHttpParam('reduce', opts, params);\n    addHttpParam('include_docs', opts, params);\n    addHttpParam('attachments', opts, params);\n    addHttpParam('limit', opts, params);\n    addHttpParam('descending', opts, params);\n    addHttpParam('group', opts, params);\n    addHttpParam('group_level', opts, params);\n    addHttpParam('skip', opts, params);\n    addHttpParam('stale', opts, params);\n    addHttpParam('conflicts', opts, params);\n    addHttpParam('startkey', opts, params, true);\n    addHttpParam('start_key', opts, params, true);\n    addHttpParam('endkey', opts, params, true);\n    addHttpParam('end_key', opts, params, true);\n    addHttpParam('inclusive_end', opts, params);\n    addHttpParam('key', opts, params, true);\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    params = params === '' ? '' : '?' + params;\n\n    // If keys are supplied, issue a POST to circumvent GET query string limits\n    // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\n    if (typeof opts.keys !== 'undefined') {\n      var MAX_URL_LENGTH = 2000;\n      // according to http://stackoverflow.com/a/417184/680742,\n      // the de facto URL length limit is 2000 characters\n\n      var keysAsString = 'keys=' + encodeURIComponent(JSON.stringify(opts.keys));\n      if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {\n        // If the keys are short enough, do a GET. we do this to work around\n        // Safari not understanding 304s on POSTs (see pouchdb/pouchdb#1239)\n        params += (params[0] === '?' ? '&' : '?') + keysAsString;\n      } else {\n        method = 'POST';\n        if (typeof fun === 'string') {\n          body = { keys: opts.keys };\n        } else {\n          // fun is {map : mapfun}, so append to this\n          fun.keys = opts.keys;\n        }\n      }\n    }\n\n    // We are referencing a query defined in the design doc\n    if (typeof fun === 'string') {\n      var parts = parseViewName(fun);\n      return db.request({\n        method: method,\n        url: '_design/' + parts[0] + '/_view/' + parts[1] + params,\n        body: body\n      }).then(\n      /* istanbul ignore next */\n      function (result) {\n        // fail the entire request if the result contains an error\n        result.rows.forEach(function (row) {\n          if (row.value && row.value.error && row.value.error === \"builtin_reduce_error\") {\n            throw new Error(row.reason);\n          }\n        });\n\n        return result;\n      }).then(postprocessAttachments(opts));\n    }\n\n    // We are using a temporary view, terrible for performance, good for testing\n    body = body || {};\n    Object.keys(fun).forEach(function (key) {\n      if (Array.isArray(fun[key])) {\n        body[key] = fun[key];\n      } else {\n        body[key] = fun[key].toString();\n      }\n    });\n    return db.request({\n      method: 'POST',\n      url: '_temp_view' + params,\n      body: body\n    }).then(postprocessAttachments(opts));\n  }\n\n  // custom adapters can define their own api._query\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customQuery(db, fun, opts) {\n    return new __WEBPACK_IMPORTED_MODULE_0_pouchdb_promise__[\"a\" /* default */](function (resolve, reject) {\n      db._query(fun, opts, function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  // custom adapters can define their own api._viewCleanup\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customViewCleanup(db) {\n    return new __WEBPACK_IMPORTED_MODULE_0_pouchdb_promise__[\"a\" /* default */](function (resolve, reject) {\n      db._viewCleanup(function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  function defaultsTo(value) {\n    return function (reason) {\n      /* istanbul ignore else */\n      if (reason.status === 404) {\n        return value;\n      } else {\n        throw reason;\n      }\n    };\n  }\n\n  // returns a promise for a list of docs to update, based on the input docId.\n  // the order doesn't matter, because post-3.2.0, bulkDocs\n  // is an atomic operation in all three adapters.\n  function getDocsToPersist(docId, view, docIdsToChangesAndEmits) {\n    var metaDocId = '_local/doc_' + docId;\n    var defaultMetaDoc = { _id: metaDocId, keys: [] };\n    var docData = docIdsToChangesAndEmits.get(docId);\n    var indexableKeysToKeyValues = docData[0];\n    var changes = docData[1];\n\n    function getMetaDoc() {\n      if (isGenOne(changes)) {\n        // generation 1, so we can safely assume initial state\n        // for performance reasons (avoids unnecessary GETs)\n        return __WEBPACK_IMPORTED_MODULE_0_pouchdb_promise__[\"a\" /* default */].resolve(defaultMetaDoc);\n      }\n      return view.db.get(metaDocId).catch(defaultsTo(defaultMetaDoc));\n    }\n\n    function getKeyValueDocs(metaDoc) {\n      if (!metaDoc.keys.length) {\n        // no keys, no need for a lookup\n        return __WEBPACK_IMPORTED_MODULE_0_pouchdb_promise__[\"a\" /* default */].resolve({ rows: [] });\n      }\n      return view.db.allDocs({\n        keys: metaDoc.keys,\n        include_docs: true\n      });\n    }\n\n    function processKeyValueDocs(metaDoc, kvDocsRes) {\n      var kvDocs = [];\n      var oldKeys = new __WEBPACK_IMPORTED_MODULE_1_pouchdb_collections__[\"b\" /* Set */]();\n\n      for (var i = 0, len = kvDocsRes.rows.length; i < len; i++) {\n        var row = kvDocsRes.rows[i];\n        var doc = row.doc;\n        if (!doc) {\n          // deleted\n          continue;\n        }\n        kvDocs.push(doc);\n        oldKeys.add(doc._id);\n        doc._deleted = !indexableKeysToKeyValues.has(doc._id);\n        if (!doc._deleted) {\n          var keyValue = indexableKeysToKeyValues.get(doc._id);\n          if ('value' in keyValue) {\n            doc.value = keyValue.value;\n          }\n        }\n      }\n      var newKeys = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_pouchdb_mapreduce_utils__[\"b\" /* mapToKeysArray */])(indexableKeysToKeyValues);\n      newKeys.forEach(function (key) {\n        if (!oldKeys.has(key)) {\n          // new doc\n          var kvDoc = {\n            _id: key\n          };\n          var keyValue = indexableKeysToKeyValues.get(key);\n          if ('value' in keyValue) {\n            kvDoc.value = keyValue.value;\n          }\n          kvDocs.push(kvDoc);\n        }\n      });\n      metaDoc.keys = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_pouchdb_mapreduce_utils__[\"c\" /* uniq */])(newKeys.concat(metaDoc.keys));\n      kvDocs.push(metaDoc);\n\n      return kvDocs;\n    }\n\n    return getMetaDoc().then(function (metaDoc) {\n      return getKeyValueDocs(metaDoc).then(function (kvDocsRes) {\n        return processKeyValueDocs(metaDoc, kvDocsRes);\n      });\n    });\n  }\n\n  // updates all emitted key/value docs and metaDocs in the mrview database\n  // for the given batch of documents from the source database\n  function saveKeyValues(view, docIdsToChangesAndEmits, seq) {\n    var seqDocId = '_local/lastSeq';\n    return view.db.get(seqDocId).catch(defaultsTo({ _id: seqDocId, seq: 0 })).then(function (lastSeqDoc) {\n      var docIds = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_pouchdb_mapreduce_utils__[\"b\" /* mapToKeysArray */])(docIdsToChangesAndEmits);\n      return __WEBPACK_IMPORTED_MODULE_0_pouchdb_promise__[\"a\" /* default */].all(docIds.map(function (docId) {\n        return getDocsToPersist(docId, view, docIdsToChangesAndEmits);\n      })).then(function (listOfDocsToPersist) {\n        var docsToPersist = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_pouchdb_utils__[\"g\" /* flatten */])(listOfDocsToPersist);\n        lastSeqDoc.seq = seq;\n        docsToPersist.push(lastSeqDoc);\n        // write all docs in a single operation, update the seq once\n        return view.db.bulkDocs({ docs: docsToPersist });\n      });\n    });\n  }\n\n  function getQueue(view) {\n    var viewName = typeof view === 'string' ? view : view.name;\n    var queue = persistentQueues[viewName];\n    if (!queue) {\n      queue = persistentQueues[viewName] = new TaskQueue();\n    }\n    return queue;\n  }\n\n  function updateView(view) {\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_pouchdb_mapreduce_utils__[\"d\" /* sequentialize */])(getQueue(view), function () {\n      return updateViewInQueue(view);\n    })();\n  }\n\n  function updateViewInQueue(view) {\n    // bind the emit function once\n    var mapResults;\n    var doc;\n\n    function emit(key, value) {\n      var output = { id: doc._id, key: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_pouchdb_collate__[\"b\" /* normalizeKey */])(key) };\n      // Don't explicitly store the value unless it's defined and non-null.\n      // This saves on storage space, because often people don't use it.\n      if (typeof value !== 'undefined' && value !== null) {\n        output.value = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_pouchdb_collate__[\"b\" /* normalizeKey */])(value);\n      }\n      mapResults.push(output);\n    }\n\n    var mapFun = mapper(view.mapFun, emit);\n\n    var currentSeq = view.seq || 0;\n\n    function processChange(docIdsToChangesAndEmits, seq) {\n      return function () {\n        return saveKeyValues(view, docIdsToChangesAndEmits, seq);\n      };\n    }\n\n    var queue = new TaskQueue();\n\n    function processNextBatch() {\n      return view.sourceDB.changes({\n        conflicts: true,\n        include_docs: true,\n        style: 'all_docs',\n        since: currentSeq,\n        limit: CHANGES_BATCH_SIZE\n      }).then(processBatch);\n    }\n\n    function processBatch(response) {\n      var results = response.results;\n      if (!results.length) {\n        return;\n      }\n      var docIdsToChangesAndEmits = createDocIdsToChangesAndEmits(results);\n      queue.add(processChange(docIdsToChangesAndEmits, currentSeq));\n      if (results.length < CHANGES_BATCH_SIZE) {\n        return;\n      }\n      return processNextBatch();\n    }\n\n    function createDocIdsToChangesAndEmits(results) {\n      var docIdsToChangesAndEmits = new __WEBPACK_IMPORTED_MODULE_1_pouchdb_collections__[\"a\" /* Map */]();\n      for (var i = 0, len = results.length; i < len; i++) {\n        var change = results[i];\n        if (change.doc._id[0] !== '_') {\n          mapResults = [];\n          doc = change.doc;\n\n          if (!doc._deleted) {\n            tryMap(view.sourceDB, mapFun, doc);\n          }\n          mapResults.sort(sortByKeyThenValue);\n\n          var indexableKeysToKeyValues = createIndexableKeysToKeyValues(mapResults);\n          docIdsToChangesAndEmits.set(change.doc._id, [indexableKeysToKeyValues, change.changes]);\n        }\n        currentSeq = change.seq;\n      }\n      return docIdsToChangesAndEmits;\n    }\n\n    function createIndexableKeysToKeyValues(mapResults) {\n      var indexableKeysToKeyValues = new __WEBPACK_IMPORTED_MODULE_1_pouchdb_collections__[\"a\" /* Map */]();\n      var lastKey;\n      for (var i = 0, len = mapResults.length; i < len; i++) {\n        var emittedKeyValue = mapResults[i];\n        var complexKey = [emittedKeyValue.key, emittedKeyValue.id];\n        if (i > 0 && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_pouchdb_collate__[\"a\" /* collate */])(emittedKeyValue.key, lastKey) === 0) {\n          complexKey.push(i); // dup key+id, so make it unique\n        }\n        indexableKeysToKeyValues.set(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_pouchdb_collate__[\"c\" /* toIndexableString */])(complexKey), emittedKeyValue);\n        lastKey = emittedKeyValue.key;\n      }\n      return indexableKeysToKeyValues;\n    }\n\n    return processNextBatch().then(function () {\n      return queue.finish();\n    }).then(function () {\n      view.seq = currentSeq;\n    });\n  }\n\n  function reduceView(view, results, options) {\n    if (options.group_level === 0) {\n      delete options.group_level;\n    }\n\n    var shouldGroup = options.group || options.group_level;\n\n    var reduceFun = reducer(view.reduceFun);\n\n    var groups = [];\n    var lvl = isNaN(options.group_level) ? Number.POSITIVE_INFINITY : options.group_level;\n    results.forEach(function (e) {\n      var last = groups[groups.length - 1];\n      var groupKey = shouldGroup ? e.key : null;\n\n      // only set group_level for array keys\n      if (shouldGroup && Array.isArray(groupKey)) {\n        groupKey = groupKey.slice(0, lvl);\n      }\n\n      if (last && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_pouchdb_collate__[\"a\" /* collate */])(last.groupKey, groupKey) === 0) {\n        last.keys.push([e.key, e.id]);\n        last.values.push(e.value);\n        return;\n      }\n      groups.push({\n        keys: [[e.key, e.id]],\n        values: [e.value],\n        groupKey: groupKey\n      });\n    });\n    results = [];\n    for (var i = 0, len = groups.length; i < len; i++) {\n      var e = groups[i];\n      var reduceTry = tryReduce(view.sourceDB, reduceFun, e.keys, e.values, false);\n      if (reduceTry.error && reduceTry.error instanceof __WEBPACK_IMPORTED_MODULE_6_pouchdb_mapreduce_utils__[\"e\" /* BuiltInError */]) {\n        // CouchDB returns an error if a built-in errors out\n        throw reduceTry.error;\n      }\n      results.push({\n        // CouchDB just sets the value to null if a non-built-in errors out\n        value: reduceTry.error ? null : reduceTry.output,\n        key: e.groupKey\n      });\n    }\n    // no total_rows/offset when reducing\n    return { rows: sliceResults(results, options.limit, options.skip) };\n  }\n\n  function queryView(view, opts) {\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_pouchdb_mapreduce_utils__[\"d\" /* sequentialize */])(getQueue(view), function () {\n      return queryViewInQueue(view, opts);\n    })();\n  }\n\n  function queryViewInQueue(view, opts) {\n    var totalRows;\n    var shouldReduce = view.reduceFun && opts.reduce !== false;\n    var skip = opts.skip || 0;\n    if (typeof opts.keys !== 'undefined' && !opts.keys.length) {\n      // equivalent query\n      opts.limit = 0;\n      delete opts.keys;\n    }\n\n    function fetchFromView(viewOpts) {\n      viewOpts.include_docs = true;\n      return view.db.allDocs(viewOpts).then(function (res) {\n        totalRows = res.total_rows;\n        return res.rows.map(function (result) {\n\n          // implicit migration - in older versions of PouchDB,\n          // we explicitly stored the doc as {id: ..., key: ..., value: ...}\n          // this is tested in a migration test\n          /* istanbul ignore next */\n          if ('value' in result.doc && typeof result.doc.value === 'object' && result.doc.value !== null) {\n            var keys = Object.keys(result.doc.value).sort();\n            // this detection method is not perfect, but it's unlikely the user\n            // emitted a value which was an object with these 3 exact keys\n            var expectedKeys = ['id', 'key', 'value'];\n            if (!(keys < expectedKeys || keys > expectedKeys)) {\n              return result.doc.value;\n            }\n          }\n\n          var parsedKeyAndDocId = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_pouchdb_collate__[\"d\" /* parseIndexableString */])(result.doc._id);\n          return {\n            key: parsedKeyAndDocId[0],\n            id: parsedKeyAndDocId[1],\n            value: 'value' in result.doc ? result.doc.value : null\n          };\n        });\n      });\n    }\n\n    function onMapResultsReady(rows) {\n      var finalResults;\n      if (shouldReduce) {\n        finalResults = reduceView(view, rows, opts);\n      } else {\n        finalResults = {\n          total_rows: totalRows,\n          offset: skip,\n          rows: rows\n        };\n      }\n      if (opts.include_docs) {\n        var docIds = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_pouchdb_mapreduce_utils__[\"c\" /* uniq */])(rows.map(rowToDocId));\n\n        return view.sourceDB.allDocs({\n          keys: docIds,\n          include_docs: true,\n          conflicts: opts.conflicts,\n          attachments: opts.attachments,\n          binary: opts.binary\n        }).then(function (allDocsRes) {\n          var docIdsToDocs = new __WEBPACK_IMPORTED_MODULE_1_pouchdb_collections__[\"a\" /* Map */]();\n          allDocsRes.rows.forEach(function (row) {\n            docIdsToDocs.set(row.id, row.doc);\n          });\n          rows.forEach(function (row) {\n            var docId = rowToDocId(row);\n            var doc = docIdsToDocs.get(docId);\n            if (doc) {\n              row.doc = doc;\n            }\n          });\n          return finalResults;\n        });\n      } else {\n        return finalResults;\n      }\n    }\n\n    if (typeof opts.keys !== 'undefined') {\n      var keys = opts.keys;\n      var fetchPromises = keys.map(function (key) {\n        var viewOpts = {\n          startkey: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_pouchdb_collate__[\"c\" /* toIndexableString */])([key]),\n          endkey: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_pouchdb_collate__[\"c\" /* toIndexableString */])([key, {}])\n        };\n        return fetchFromView(viewOpts);\n      });\n      return __WEBPACK_IMPORTED_MODULE_0_pouchdb_promise__[\"a\" /* default */].all(fetchPromises).then(__WEBPACK_IMPORTED_MODULE_2_pouchdb_utils__[\"g\" /* flatten */]).then(onMapResultsReady);\n    } else {\n      // normal query, no 'keys'\n      var viewOpts = {\n        descending: opts.descending\n      };\n      var startkey;\n      var endkey;\n      if ('start_key' in opts) {\n        startkey = opts.start_key;\n      }\n      if ('startkey' in opts) {\n        startkey = opts.startkey;\n      }\n      if ('end_key' in opts) {\n        endkey = opts.end_key;\n      }\n      if ('endkey' in opts) {\n        endkey = opts.endkey;\n      }\n      if (typeof startkey !== 'undefined') {\n        viewOpts.startkey = opts.descending ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_pouchdb_collate__[\"c\" /* toIndexableString */])([startkey, {}]) : __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_pouchdb_collate__[\"c\" /* toIndexableString */])([startkey]);\n      }\n      if (typeof endkey !== 'undefined') {\n        var inclusiveEnd = opts.inclusive_end !== false;\n        if (opts.descending) {\n          inclusiveEnd = !inclusiveEnd;\n        }\n\n        viewOpts.endkey = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_pouchdb_collate__[\"c\" /* toIndexableString */])(inclusiveEnd ? [endkey, {}] : [endkey]);\n      }\n      if (typeof opts.key !== 'undefined') {\n        var keyStart = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_pouchdb_collate__[\"c\" /* toIndexableString */])([opts.key]);\n        var keyEnd = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_pouchdb_collate__[\"c\" /* toIndexableString */])([opts.key, {}]);\n        if (viewOpts.descending) {\n          viewOpts.endkey = keyStart;\n          viewOpts.startkey = keyEnd;\n        } else {\n          viewOpts.startkey = keyStart;\n          viewOpts.endkey = keyEnd;\n        }\n      }\n      if (!shouldReduce) {\n        if (typeof opts.limit === 'number') {\n          viewOpts.limit = opts.limit;\n        }\n        viewOpts.skip = skip;\n      }\n      return fetchFromView(viewOpts).then(onMapResultsReady);\n    }\n  }\n\n  function httpViewCleanup(db) {\n    return db.request({\n      method: 'POST',\n      url: '_view_cleanup'\n    });\n  }\n\n  function localViewCleanup(db) {\n    return db.get('_local/' + localDocName).then(function (metaDoc) {\n      var docsToViews = new __WEBPACK_IMPORTED_MODULE_1_pouchdb_collections__[\"a\" /* Map */]();\n      Object.keys(metaDoc.views).forEach(function (fullViewName) {\n        var parts = parseViewName(fullViewName);\n        var designDocName = '_design/' + parts[0];\n        var viewName = parts[1];\n        var views = docsToViews.get(designDocName);\n        if (!views) {\n          views = new __WEBPACK_IMPORTED_MODULE_1_pouchdb_collections__[\"b\" /* Set */]();\n          docsToViews.set(designDocName, views);\n        }\n        views.add(viewName);\n      });\n      var opts = {\n        keys: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_pouchdb_mapreduce_utils__[\"b\" /* mapToKeysArray */])(docsToViews),\n        include_docs: true\n      };\n      return db.allDocs(opts).then(function (res) {\n        var viewsToStatus = {};\n        res.rows.forEach(function (row) {\n          var ddocName = row.key.substring(8); // cuts off '_design/'\n          docsToViews.get(row.key).forEach(function (viewName) {\n            var fullViewName = ddocName + '/' + viewName;\n            /* istanbul ignore if */\n            if (!metaDoc.views[fullViewName]) {\n              // new format, without slashes, to support PouchDB 2.2.0\n              // migration test in pouchdb's browser.migration.js verifies this\n              fullViewName = viewName;\n            }\n            var viewDBNames = Object.keys(metaDoc.views[fullViewName]);\n            // design doc deleted, or view function nonexistent\n            var statusIsGood = row.doc && row.doc.views && row.doc.views[viewName];\n            viewDBNames.forEach(function (viewDBName) {\n              viewsToStatus[viewDBName] = viewsToStatus[viewDBName] || statusIsGood;\n            });\n          });\n        });\n        var dbsToDelete = Object.keys(viewsToStatus).filter(function (viewDBName) {\n          return !viewsToStatus[viewDBName];\n        });\n        var destroyPromises = dbsToDelete.map(function (viewDBName) {\n          return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_pouchdb_mapreduce_utils__[\"d\" /* sequentialize */])(getQueue(viewDBName), function () {\n            return new db.constructor(viewDBName, db.__opts).destroy();\n          })();\n        });\n        return __WEBPACK_IMPORTED_MODULE_0_pouchdb_promise__[\"a\" /* default */].all(destroyPromises).then(function () {\n          return { ok: true };\n        });\n      });\n    }, defaultsTo({ ok: true }));\n  }\n\n  function queryPromised(db, fun, opts) {\n    /* istanbul ignore next */\n    if (typeof db._query === 'function') {\n      return customQuery(db, fun, opts);\n    }\n    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_pouchdb_utils__[\"e\" /* isRemote */])(db)) {\n      return httpQuery(db, fun, opts);\n    }\n\n    if (typeof fun !== 'string') {\n      // temp_view\n      checkQueryParseError(opts, fun);\n\n      tempViewQueue.add(function () {\n        var createViewPromise = createView(\n        /* sourceDB */db,\n        /* viewName */'temp_view/temp_view',\n        /* mapFun */fun.map,\n        /* reduceFun */fun.reduce,\n        /* temporary */true,\n        /* localDocName */localDocName);\n        return createViewPromise.then(function (view) {\n          return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_pouchdb_mapreduce_utils__[\"f\" /* fin */])(updateView(view).then(function () {\n            return queryView(view, opts);\n          }), function () {\n            return view.db.destroy();\n          });\n        });\n      });\n      return tempViewQueue.finish();\n    } else {\n      // persistent view\n      var fullViewName = fun;\n      var parts = parseViewName(fullViewName);\n      var designDocName = parts[0];\n      var viewName = parts[1];\n      return db.get('_design/' + designDocName).then(function (doc) {\n        var fun = doc.views && doc.views[viewName];\n\n        if (!fun) {\n          // basic validator; it's assumed that every subclass would want this\n          throw new __WEBPACK_IMPORTED_MODULE_6_pouchdb_mapreduce_utils__[\"g\" /* NotFoundError */]('ddoc ' + doc._id + ' has no view named ' + viewName);\n        }\n\n        ddocValidator(doc, viewName);\n        checkQueryParseError(opts, fun);\n\n        var createViewPromise = createView(\n        /* sourceDB */db,\n        /* viewName */fullViewName,\n        /* mapFun */fun.map,\n        /* reduceFun */fun.reduce,\n        /* temporary */false,\n        /* localDocName */localDocName);\n        return createViewPromise.then(function (view) {\n          if (opts.stale === 'ok' || opts.stale === 'update_after') {\n            if (opts.stale === 'update_after') {\n              __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_pouchdb_utils__[\"h\" /* nextTick */])(function () {\n                updateView(view);\n              });\n            }\n            return queryView(view, opts);\n          } else {\n            // stale not ok\n            return updateView(view).then(function () {\n              return queryView(view, opts);\n            });\n          }\n        });\n      });\n    }\n  }\n\n  function abstractQuery(fun, opts, callback) {\n    var db = this;\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = opts ? coerceOptions(opts) : {};\n\n    if (typeof fun === 'function') {\n      fun = { map: fun };\n    }\n\n    var promise = __WEBPACK_IMPORTED_MODULE_0_pouchdb_promise__[\"a\" /* default */].resolve().then(function () {\n      return queryPromised(db, fun, opts);\n    });\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_pouchdb_mapreduce_utils__[\"h\" /* promisedCallback */])(promise, callback);\n    return promise;\n  }\n\n  var abstractViewCleanup = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_pouchdb_mapreduce_utils__[\"i\" /* callbackify */])(function () {\n    var db = this;\n    /* istanbul ignore next */\n    if (typeof db._viewCleanup === 'function') {\n      return customViewCleanup(db);\n    }\n    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_pouchdb_utils__[\"e\" /* isRemote */])(db)) {\n      return httpViewCleanup(db);\n    }\n    return localViewCleanup(db);\n  });\n\n  return {\n    query: abstractQuery,\n    viewCleanup: abstractViewCleanup\n  };\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (createAbstractMapReduce);\n\n/***/ }),\n\n/***/ \"qpbW\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return ExportedSet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return ExportedMap; });\nfunction mangle(key) {\n  return '$' + key;\n}\nfunction unmangle(key) {\n  return key.substring(1);\n}\nfunction Map$1() {\n  this._store = {};\n}\nMap$1.prototype.get = function (key) {\n  var mangled = mangle(key);\n  return this._store[mangled];\n};\nMap$1.prototype.set = function (key, value) {\n  var mangled = mangle(key);\n  this._store[mangled] = value;\n  return true;\n};\nMap$1.prototype.has = function (key) {\n  var mangled = mangle(key);\n  return mangled in this._store;\n};\nMap$1.prototype.delete = function (key) {\n  var mangled = mangle(key);\n  var res = mangled in this._store;\n  delete this._store[mangled];\n  return res;\n};\nMap$1.prototype.forEach = function (cb) {\n  var keys = Object.keys(this._store);\n  for (var i = 0, len = keys.length; i < len; i++) {\n    var key = keys[i];\n    var value = this._store[key];\n    key = unmangle(key);\n    cb(value, key);\n  }\n};\nObject.defineProperty(Map$1.prototype, 'size', {\n  get: function get() {\n    return Object.keys(this._store).length;\n  }\n});\n\nfunction Set$1(array) {\n  this._store = new Map$1();\n\n  // init with an array\n  if (array && Array.isArray(array)) {\n    for (var i = 0, len = array.length; i < len; i++) {\n      this.add(array[i]);\n    }\n  }\n}\nSet$1.prototype.add = function (key) {\n  return this._store.set(key, true);\n};\nSet$1.prototype.has = function (key) {\n  return this._store.has(key);\n};\nSet$1.prototype.forEach = function (cb) {\n  this._store.forEach(function (value, key) {\n    cb(key);\n  });\n};\nObject.defineProperty(Set$1.prototype, 'size', {\n  get: function get() {\n    return this._store.size;\n  }\n});\n\n/* global Map,Set,Symbol */\n// Based on https://kangax.github.io/compat-table/es6/ we can sniff out\n// incomplete Map/Set implementations which would otherwise cause our tests to fail.\n// Notably they fail in IE11 and iOS 8.4, which this prevents.\nfunction supportsMapAndSet() {\n  if (typeof Symbol === 'undefined' || typeof Map === 'undefined' || typeof Set === 'undefined') {\n    return false;\n  }\n  var prop = Object.getOwnPropertyDescriptor(Map, Symbol.species);\n  return prop && 'get' in prop && Map[Symbol.species] === Map;\n}\n\n// based on https://github.com/montagejs/collections\n/* global Map,Set */\n\nvar ExportedSet;\nvar ExportedMap;\n\n{\n  if (supportsMapAndSet()) {\n    // prefer built-in Map/Set\n    ExportedSet = Set;\n    ExportedMap = Map;\n  } else {\n    // fall back to our polyfill\n    ExportedSet = Set$1;\n    ExportedMap = Map$1;\n  }\n}\n\n\n\n/***/ }),\n\n/***/ \"rsNZ\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(process) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_pouchdb_utils__ = __webpack_require__(\"mY35\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_pouchdb_promise__ = __webpack_require__(\"5euN\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_pouchdb_selector_core__ = __webpack_require__(\"C9XX\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_pouchdb_abstract_mapreduce__ = __webpack_require__(\"qove\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_pouchdb_collate__ = __webpack_require__(\"1XVU\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_pouchdb_md5__ = __webpack_require__(\"ZfEw\");\n\n\n\n\n\n\n\n// we restucture the supplied JSON considerably, because the official\n// Mango API is very particular about a lot of this stuff, but we like\n// to be liberal with what we accept in order to prevent mental\n// breakdowns in our users\nfunction massageCreateIndexRequest(requestDef) {\n  requestDef = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_pouchdb_utils__[\"a\" /* clone */])(requestDef);\n\n  if (!requestDef.index) {\n    requestDef.index = {};\n  }\n\n  ['type', 'name', 'ddoc'].forEach(function (key) {\n    if (requestDef.index[key]) {\n      requestDef[key] = requestDef.index[key];\n      delete requestDef.index[key];\n    }\n  });\n\n  if (requestDef.fields) {\n    requestDef.index.fields = requestDef.fields;\n    delete requestDef.fields;\n  }\n\n  if (!requestDef.type) {\n    requestDef.type = 'json';\n  }\n  return requestDef;\n}\n\nfunction createIndex(db, requestDef, callback) {\n  requestDef = massageCreateIndexRequest(requestDef);\n\n  db.request({\n    method: 'POST',\n    url: '_index',\n    body: requestDef\n  }, callback);\n}\n\nfunction find(db, requestDef, callback) {\n  db.request({\n    method: 'POST',\n    url: '_find',\n    body: requestDef\n  }, callback);\n}\n\nfunction explain(db, requestDef, callback) {\n  db.request({\n    method: 'POST',\n    url: '_explain',\n    body: requestDef\n  }, callback);\n}\n\nfunction getIndexes(db, callback) {\n  db.request({\n    method: 'GET',\n    url: '_index'\n  }, callback);\n}\n\nfunction deleteIndex(db, indexDef, callback) {\n\n  var ddoc = indexDef.ddoc;\n  var type = indexDef.type || 'json';\n  var name = indexDef.name;\n\n  if (!ddoc) {\n    return callback(new Error('you must provide an index\\'s ddoc'));\n  }\n\n  if (!name) {\n    return callback(new Error('you must provide an index\\'s name'));\n  }\n\n  var url = '_index/' + [ddoc, type, name].map(encodeURIComponent).join('/');\n\n  db.request({\n    method: 'DELETE',\n    url: url\n  }, callback);\n}\n\nfunction getArguments(fun) {\n  return function () {\n    var len = arguments.length;\n    var args = new Array(len);\n    var i = -1;\n    while (++i < len) {\n      args[i] = arguments[i];\n    }\n    return fun.call(this, args);\n  };\n}\nfunction callbackify(fun) {\n  return getArguments(function (args) {\n    var cb = args.pop();\n    var promise = fun.apply(this, args);\n    promisedCallback(promise, cb);\n    return promise;\n  });\n}\n\nfunction promisedCallback(promise, callback) {\n  promise.then(function (res) {\n    process.nextTick(function () {\n      callback(null, res);\n    });\n  }, function (reason) {\n    process.nextTick(function () {\n      callback(reason);\n    });\n  });\n  return promise;\n}\n\nvar flatten = getArguments(function (args) {\n  var res = [];\n  for (var i = 0, len = args.length; i < len; i++) {\n    var subArr = args[i];\n    if (Array.isArray(subArr)) {\n      res = res.concat(flatten.apply(null, subArr));\n    } else {\n      res.push(subArr);\n    }\n  }\n  return res;\n});\n\nfunction mergeObjects(arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    res = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_pouchdb_utils__[\"b\" /* assign */])(res, arr[i]);\n  }\n  return res;\n}\n\n// Selects a list of fields defined in dot notation from one doc\n// and copies them to a new doc. Like underscore _.pick but supports nesting.\nfunction pick(obj, arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var parsedField = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_pouchdb_selector_core__[\"a\" /* parseField */])(arr[i]);\n    var value = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_pouchdb_selector_core__[\"b\" /* getFieldFromDoc */])(obj, parsedField);\n    if (typeof value !== 'undefined') {\n      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_pouchdb_selector_core__[\"c\" /* setFieldInDoc */])(res, parsedField, value);\n    }\n  }\n  return res;\n}\n\n// e.g. ['a'], ['a', 'b'] is true, but ['b'], ['a', 'b'] is false\nfunction oneArrayIsSubArrayOfOther(left, right) {\n\n  for (var i = 0, len = Math.min(left.length, right.length); i < len; i++) {\n    if (left[i] !== right[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// e.g.['a', 'b', 'c'], ['a', 'b'] is false\nfunction oneArrayIsStrictSubArrayOfOther(left, right) {\n\n  if (left.length > right.length) {\n    return false;\n  }\n\n  return oneArrayIsSubArrayOfOther(left, right);\n}\n\n// same as above, but treat the left array as an unordered set\n// e.g. ['b', 'a'], ['a', 'b', 'c'] is true, but ['c'], ['a', 'b', 'c'] is false\nfunction oneSetIsSubArrayOfOther(left, right) {\n  left = left.slice();\n  for (var i = 0, len = right.length; i < len; i++) {\n    var field = right[i];\n    if (!left.length) {\n      break;\n    }\n    var leftIdx = left.indexOf(field);\n    if (leftIdx === -1) {\n      return false;\n    } else {\n      left.splice(leftIdx, 1);\n    }\n  }\n  return true;\n}\n\nfunction arrayToObject(arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    res[arr[i]] = true;\n  }\n  return res;\n}\n\nfunction max(arr, fun) {\n  var max = null;\n  var maxScore = -1;\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var element = arr[i];\n    var score = fun(element);\n    if (score > maxScore) {\n      maxScore = score;\n      max = element;\n    }\n  }\n  return max;\n}\n\nfunction arrayEquals(arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n  for (var i = 0, len = arr1.length; i < len; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction uniq(arr) {\n  var obj = {};\n  for (var i = 0; i < arr.length; i++) {\n    obj['$' + arr[i]] = true;\n  }\n  return Object.keys(obj).map(function (key) {\n    return key.substring(1);\n  });\n}\n\n//\n// One thing about these mappers:\n//\n// Per the advice of John-David Dalton (http://youtu.be/NthmeLEhDDM),\n// what you want to do in this case is optimize for the smallest possible\n// function, since that's the thing that gets run over and over again.\n//\n// This code would be a lot simpler if all the if/elses were inside\n// the function, but it would also be a lot less performant.\n//\n\n\nfunction createDeepMultiMapper(fields, emit) {\n  return function (doc) {\n    var toEmit = [];\n    for (var i = 0, iLen = fields.length; i < iLen; i++) {\n      var parsedField = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_pouchdb_selector_core__[\"a\" /* parseField */])(fields[i]);\n      var value = doc;\n      for (var j = 0, jLen = parsedField.length; j < jLen; j++) {\n        var key = parsedField[j];\n        value = value[key];\n        if (!value) {\n          return; // don't emit\n        }\n      }\n      toEmit.push(value);\n    }\n    emit(toEmit);\n  };\n}\n\nfunction createDeepSingleMapper(field, emit) {\n  var parsedField = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_pouchdb_selector_core__[\"a\" /* parseField */])(field);\n  return function (doc) {\n    var value = doc;\n    for (var i = 0, len = parsedField.length; i < len; i++) {\n      var key = parsedField[i];\n      value = value[key];\n      if (!value) {\n        return; // do nothing\n      }\n    }\n    emit(value);\n  };\n}\n\nfunction createShallowSingleMapper(field, emit) {\n  return function (doc) {\n    emit(doc[field]);\n  };\n}\n\nfunction createShallowMultiMapper(fields, emit) {\n  return function (doc) {\n    var toEmit = [];\n    for (var i = 0, len = fields.length; i < len; i++) {\n      toEmit.push(doc[fields[i]]);\n    }\n    emit(toEmit);\n  };\n}\n\nfunction checkShallow(fields) {\n  for (var i = 0, len = fields.length; i < len; i++) {\n    var field = fields[i];\n    if (field.indexOf('.') !== -1) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction createMapper(fields, emit) {\n  var isShallow = checkShallow(fields);\n  var isSingle = fields.length === 1;\n\n  // notice we try to optimize for the most common case,\n  // i.e. single shallow indexes\n  if (isShallow) {\n    if (isSingle) {\n      return createShallowSingleMapper(fields[0], emit);\n    } else {\n      // multi\n      return createShallowMultiMapper(fields, emit);\n    }\n  } else {\n    // deep\n    if (isSingle) {\n      return createDeepSingleMapper(fields[0], emit);\n    } else {\n      // multi\n      return createDeepMultiMapper(fields, emit);\n    }\n  }\n}\n\nfunction mapper(mapFunDef, emit) {\n  // mapFunDef is a list of fields\n\n  var fields = Object.keys(mapFunDef.fields);\n\n  return createMapper(fields, emit);\n}\n\n/* istanbul ignore next */\nfunction reducer() /*reduceFunDef*/{\n  throw new Error('reduce not supported');\n}\n\nfunction ddocValidator(ddoc, viewName) {\n  var view = ddoc.views[viewName];\n  // This doesn't actually need to be here apparently, but\n  // I feel safer keeping it.\n  /* istanbul ignore if */\n  if (!view.map || !view.map.fields) {\n    throw new Error('ddoc ' + ddoc._id + ' with view ' + viewName + ' doesn\\'t have map.fields defined. ' + 'maybe it wasn\\'t created by this plugin?');\n  }\n}\n\nvar abstractMapper = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3_pouchdb_abstract_mapreduce__[\"a\" /* default */])(\n/* localDocName */'indexes', mapper, reducer, ddocValidator);\n\n// normalize the \"sort\" value\nfunction massageSort(sort) {\n  if (!Array.isArray(sort)) {\n    throw new Error('invalid sort json - should be an array');\n  }\n  return sort.map(function (sorting) {\n    if (typeof sorting === 'string') {\n      var obj = {};\n      obj[sorting] = 'asc';\n      return obj;\n    } else {\n      return sorting;\n    }\n  });\n}\n\nfunction massageUseIndex(useIndex) {\n  var cleanedUseIndex = [];\n  if (typeof useIndex === 'string') {\n    cleanedUseIndex.push(useIndex);\n  } else {\n    cleanedUseIndex = useIndex;\n  }\n\n  return cleanedUseIndex.map(function (name) {\n    return name.replace('_design/', '');\n  });\n}\n\nfunction massageIndexDef(indexDef) {\n  indexDef.fields = indexDef.fields.map(function (field) {\n    if (typeof field === 'string') {\n      var obj = {};\n      obj[field] = 'asc';\n      return obj;\n    }\n    return field;\n  });\n  return indexDef;\n}\n\nfunction getKeyFromDoc(doc, index) {\n  var res = [];\n  for (var i = 0; i < index.def.fields.length; i++) {\n    var field = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_pouchdb_selector_core__[\"d\" /* getKey */])(index.def.fields[i]);\n    res.push(doc[field]);\n  }\n  return res;\n}\n\n// have to do this manually because REASONS. I don't know why\n// CouchDB didn't implement inclusive_start\nfunction filterInclusiveStart(rows, targetValue, index) {\n  var indexFields = index.def.fields;\n  for (var i = 0, len = rows.length; i < len; i++) {\n    var row = rows[i];\n\n    // shave off any docs at the beginning that are <= the\n    // target value\n\n    var docKey = getKeyFromDoc(row.doc, index);\n    if (indexFields.length === 1) {\n      docKey = docKey[0]; // only one field, not multi-field\n    } else {\n      // more than one field in index\n      // in the case where e.g. the user is searching {$gt: {a: 1}}\n      // but the index is [a, b], then we need to shorten the doc key\n      while (docKey.length > targetValue.length) {\n        docKey.pop();\n      }\n    }\n    //ABS as we just looking for values that don't match\n    if (Math.abs(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_pouchdb_collate__[\"a\" /* collate */])(docKey, targetValue)) > 0) {\n      // no need to filter any further; we're past the key\n      break;\n    }\n  }\n  return i > 0 ? rows.slice(i) : rows;\n}\n\nfunction reverseOptions(opts) {\n  var newOpts = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_pouchdb_utils__[\"a\" /* clone */])(opts);\n  delete newOpts.startkey;\n  delete newOpts.endkey;\n  delete newOpts.inclusive_start;\n  delete newOpts.inclusive_end;\n\n  if ('endkey' in opts) {\n    newOpts.startkey = opts.endkey;\n  }\n  if ('startkey' in opts) {\n    newOpts.endkey = opts.startkey;\n  }\n  if ('inclusive_start' in opts) {\n    newOpts.inclusive_end = opts.inclusive_start;\n  }\n  if ('inclusive_end' in opts) {\n    newOpts.inclusive_start = opts.inclusive_end;\n  }\n  return newOpts;\n}\n\nfunction validateIndex(index) {\n  var ascFields = index.fields.filter(function (field) {\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_pouchdb_selector_core__[\"e\" /* getValue */])(field) === 'asc';\n  });\n  if (ascFields.length !== 0 && ascFields.length !== index.fields.length) {\n    throw new Error('unsupported mixed sorting');\n  }\n}\n\nfunction validateSort(requestDef, index) {\n  if (index.defaultUsed && requestDef.sort) {\n    var noneIdSorts = requestDef.sort.filter(function (sortItem) {\n      return Object.keys(sortItem)[0] !== '_id';\n    }).map(function (sortItem) {\n      return Object.keys(sortItem)[0];\n    });\n\n    if (noneIdSorts.length > 0) {\n      throw new Error('Cannot sort on field(s) \"' + noneIdSorts.join(',') + '\" when using the default index');\n    }\n  }\n\n  if (index.defaultUsed) {\n    return;\n  }\n}\n\nfunction validateFindRequest(requestDef) {\n  if (typeof requestDef.selector !== 'object') {\n    throw new Error('you must provide a selector when you find()');\n  }\n\n  /*var selectors = requestDef.selector['$and'] || [requestDef.selector];\n  for (var i = 0; i < selectors.length; i++) {\n    var selector = selectors[i];\n    var keys = Object.keys(selector);\n    if (keys.length === 0) {\n      throw new Error('invalid empty selector');\n    }\n    //var selection = selector[keys[0]];\n    /*if (Object.keys(selection).length !== 1) {\n      throw new Error('invalid selector: ' + JSON.stringify(selection) +\n        ' - it must have exactly one key/value');\n    }\n  }*/\n}\n\n// determine the maximum number of fields\n// we're going to need to query, e.g. if the user\n// has selection ['a'] and sorting ['a', 'b'], then we\n// need to use the longer of the two: ['a', 'b']\nfunction getUserFields(selector, sort) {\n  var selectorFields = Object.keys(selector);\n  var sortFields = sort ? sort.map(__WEBPACK_IMPORTED_MODULE_2_pouchdb_selector_core__[\"d\" /* getKey */]) : [];\n  var userFields;\n  if (selectorFields.length >= sortFields.length) {\n    userFields = selectorFields;\n  } else {\n    userFields = sortFields;\n  }\n\n  if (sortFields.length === 0) {\n    return {\n      fields: userFields\n    };\n  }\n\n  // sort according to the user's preferred sorting\n  userFields = userFields.sort(function (left, right) {\n    var leftIdx = sortFields.indexOf(left);\n    if (leftIdx === -1) {\n      leftIdx = Number.MAX_VALUE;\n    }\n    var rightIdx = sortFields.indexOf(right);\n    if (rightIdx === -1) {\n      rightIdx = Number.MAX_VALUE;\n    }\n    return leftIdx < rightIdx ? -1 : leftIdx > rightIdx ? 1 : 0;\n  });\n\n  return {\n    fields: userFields,\n    sortOrder: sort.map(__WEBPACK_IMPORTED_MODULE_2_pouchdb_selector_core__[\"d\" /* getKey */])\n  };\n}\n\nfunction createIndex$1(db, requestDef) {\n  requestDef = massageCreateIndexRequest(requestDef);\n  var originalIndexDef = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_pouchdb_utils__[\"a\" /* clone */])(requestDef.index);\n  requestDef.index = massageIndexDef(requestDef.index);\n\n  validateIndex(requestDef.index);\n\n  // calculating md5 is expensive - memoize and only\n  // run if required\n  var md5;\n  function getMd5() {\n    return md5 || (md5 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5_pouchdb_md5__[\"a\" /* stringMd5 */])(JSON.stringify(requestDef)));\n  }\n\n  var viewName = requestDef.name || 'idx-' + getMd5();\n\n  var ddocName = requestDef.ddoc || 'idx-' + getMd5();\n  var ddocId = '_design/' + ddocName;\n\n  var hasInvalidLanguage = false;\n  var viewExists = false;\n\n  function updateDdoc(doc) {\n    if (doc._rev && doc.language !== 'query') {\n      hasInvalidLanguage = true;\n    }\n    doc.language = 'query';\n    doc.views = doc.views || {};\n\n    viewExists = !!doc.views[viewName];\n\n    if (viewExists) {\n      return false;\n    }\n\n    doc.views[viewName] = {\n      map: {\n        fields: mergeObjects(requestDef.index.fields)\n      },\n      reduce: '_count',\n      options: {\n        def: originalIndexDef\n      }\n    };\n\n    return doc;\n  }\n\n  db.constructor.emit('debug', ['find', 'creating index', ddocId]);\n\n  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_pouchdb_utils__[\"c\" /* upsert */])(db, ddocId, updateDdoc).then(function () {\n    if (hasInvalidLanguage) {\n      throw new Error('invalid language for ddoc with id \"' + ddocId + '\" (should be \"query\")');\n    }\n  }).then(function () {\n    // kick off a build\n    // TODO: abstract-pouchdb-mapreduce should support auto-updating\n    // TODO: should also use update_after, but pouchdb/pouchdb#3415 blocks me\n    var signature = ddocName + '/' + viewName;\n    return abstractMapper.query.call(db, signature, {\n      limit: 0,\n      reduce: false\n    }).then(function () {\n      return {\n        id: ddocId,\n        name: viewName,\n        result: viewExists ? 'exists' : 'created'\n      };\n    });\n  });\n}\n\nfunction getIndexes$1(db) {\n  // just search through all the design docs and filter in-memory.\n  // hopefully there aren't that many ddocs.\n  return db.allDocs({\n    startkey: '_design/',\n    endkey: '_design/\\uFFFF',\n    include_docs: true\n  }).then(function (allDocsRes) {\n    var res = {\n      indexes: [{\n        ddoc: null,\n        name: '_all_docs',\n        type: 'special',\n        def: {\n          fields: [{ _id: 'asc' }]\n        }\n      }]\n    };\n\n    res.indexes = flatten(res.indexes, allDocsRes.rows.filter(function (row) {\n      return row.doc.language === 'query';\n    }).map(function (row) {\n      var viewNames = row.doc.views !== undefined ? Object.keys(row.doc.views) : [];\n\n      return viewNames.map(function (viewName) {\n        var view = row.doc.views[viewName];\n        return {\n          ddoc: row.id,\n          name: viewName,\n          type: 'json',\n          def: massageIndexDef(view.options.def)\n        };\n      });\n    }));\n\n    // these are sorted by view name for some reason\n    res.indexes.sort(function (left, right) {\n      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_pouchdb_selector_core__[\"f\" /* compare */])(left.name, right.name);\n    });\n    res.total_rows = res.indexes.length;\n    return res;\n  });\n}\n\n// couchdb lowest collation value\nvar COLLATE_LO = null;\n\n// couchdb highest collation value (TODO: well not really, but close enough amirite)\nvar COLLATE_HI = { '\\uFFFF': {} };\n\n// couchdb second-lowest collation value\n\nfunction checkFieldInIndex(index, field) {\n  var indexFields = index.def.fields.map(__WEBPACK_IMPORTED_MODULE_2_pouchdb_selector_core__[\"d\" /* getKey */]);\n  for (var i = 0, len = indexFields.length; i < len; i++) {\n    var indexField = indexFields[i];\n    if (field === indexField) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// so when you do e.g. $eq/$eq, we can do it entirely in the database.\n// but when you do e.g. $gt/$eq, the first part can be done\n// in the database, but the second part has to be done in-memory,\n// because $gt has forced us to lose precision.\n// so that's what this determines\nfunction userOperatorLosesPrecision(selector, field) {\n  var matcher = selector[field];\n  var userOperator = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_pouchdb_selector_core__[\"d\" /* getKey */])(matcher);\n\n  return userOperator !== '$eq';\n}\n\n// sort the user fields by their position in the index,\n// if they're in the index\nfunction sortFieldsByIndex(userFields, index) {\n  var indexFields = index.def.fields.map(__WEBPACK_IMPORTED_MODULE_2_pouchdb_selector_core__[\"d\" /* getKey */]);\n\n  return userFields.slice().sort(function (a, b) {\n    var aIdx = indexFields.indexOf(a);\n    var bIdx = indexFields.indexOf(b);\n    if (aIdx === -1) {\n      aIdx = Number.MAX_VALUE;\n    }\n    if (bIdx === -1) {\n      bIdx = Number.MAX_VALUE;\n    }\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_pouchdb_selector_core__[\"f\" /* compare */])(aIdx, bIdx);\n  });\n}\n\n// first pass to try to find fields that will need to be sorted in-memory\nfunction getBasicInMemoryFields(index, selector, userFields) {\n\n  userFields = sortFieldsByIndex(userFields, index);\n\n  // check if any of the user selectors lose precision\n  var needToFilterInMemory = false;\n  for (var i = 0, len = userFields.length; i < len; i++) {\n    var field = userFields[i];\n    if (needToFilterInMemory || !checkFieldInIndex(index, field)) {\n      return userFields.slice(i);\n    }\n    if (i < len - 1 && userOperatorLosesPrecision(selector, field)) {\n      needToFilterInMemory = true;\n    }\n  }\n  return [];\n}\n\nfunction getInMemoryFieldsFromNe(selector) {\n  var fields = [];\n  Object.keys(selector).forEach(function (field) {\n    var matcher = selector[field];\n    Object.keys(matcher).forEach(function (operator) {\n      if (operator === '$ne') {\n        fields.push(field);\n      }\n    });\n  });\n  return fields;\n}\n\nfunction getInMemoryFields(coreInMemoryFields, index, selector, userFields) {\n  var result = flatten(\n  // in-memory fields reported as necessary by the query planner\n  coreInMemoryFields,\n  // combine with another pass that checks for any we may have missed\n  getBasicInMemoryFields(index, selector, userFields),\n  // combine with another pass that checks for $ne's\n  getInMemoryFieldsFromNe(selector));\n\n  return sortFieldsByIndex(uniq(result), index);\n}\n\n// check that at least one field in the user's query is represented\n// in the index. order matters in the case of sorts\nfunction checkIndexFieldsMatch(indexFields, sortOrder, fields) {\n  if (sortOrder) {\n    // array has to be a strict subarray of index array. furthermore,\n    // the sortOrder fields need to all be represented in the index\n    var sortMatches = oneArrayIsStrictSubArrayOfOther(sortOrder, indexFields);\n    var selectorMatches = oneArrayIsSubArrayOfOther(fields, indexFields);\n\n    return sortMatches && selectorMatches;\n  }\n\n  // all of the user's specified fields still need to be\n  // on the left side of the index array, although the order\n  // doesn't matter\n  return oneSetIsSubArrayOfOther(fields, indexFields);\n}\n\nvar logicalMatchers = ['$eq', '$gt', '$gte', '$lt', '$lte'];\nfunction isNonLogicalMatcher(matcher) {\n  return logicalMatchers.indexOf(matcher) === -1;\n}\n\n// check all the index fields for usages of '$ne'\n// e.g. if the user queries {foo: {$ne: 'foo'}, bar: {$eq: 'bar'}},\n// then we can neither use an index on ['foo'] nor an index on\n// ['foo', 'bar'], but we can use an index on ['bar'] or ['bar', 'foo']\nfunction checkFieldsLogicallySound(indexFields, selector) {\n  var firstField = indexFields[0];\n  var matcher = selector[firstField];\n\n  if (typeof matcher === 'undefined') {\n    return true;\n  }\n\n  var hasLogicalOperator = Object.keys(matcher).some(function (matcherKey) {\n    return !isNonLogicalMatcher(matcherKey);\n  });\n\n  if (!hasLogicalOperator) {\n    return false;\n  }\n\n  var isInvalidNe = Object.keys(matcher).length === 1 && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_pouchdb_selector_core__[\"d\" /* getKey */])(matcher) === '$ne';\n\n  return !isInvalidNe;\n}\n\nfunction checkIndexMatches(index, sortOrder, fields, selector) {\n\n  var indexFields = index.def.fields.map(__WEBPACK_IMPORTED_MODULE_2_pouchdb_selector_core__[\"d\" /* getKey */]);\n\n  var fieldsMatch = checkIndexFieldsMatch(indexFields, sortOrder, fields);\n\n  if (!fieldsMatch) {\n    return false;\n  }\n\n  return checkFieldsLogicallySound(indexFields, selector);\n}\n\n//\n// the algorithm is very simple:\n// take all the fields the user supplies, and if those fields\n// are a strict subset of the fields in some index,\n// then use that index\n//\n//\nfunction findMatchingIndexes(selector, userFields, sortOrder, indexes) {\n\n  return indexes.reduce(function (res, index) {\n    var indexMatches = checkIndexMatches(index, sortOrder, userFields, selector);\n    if (indexMatches) {\n      res.push(index);\n    }\n    return res;\n  }, []);\n}\n\n// find the best index, i.e. the one that matches the most fields\n// in the user's query\nfunction findBestMatchingIndex(selector, userFields, sortOrder, indexes, useIndex) {\n\n  var matchingIndexes = findMatchingIndexes(selector, userFields, sortOrder, indexes);\n\n  if (matchingIndexes.length === 0) {\n    if (useIndex) {\n      throw {\n        error: \"no_usable_index\",\n        message: \"There is no index available for this selector.\"\n      };\n    }\n    //return `all_docs` as a default index;\n    //I'm assuming that _all_docs is always first\n    var defaultIndex = indexes[0];\n    defaultIndex.defaultUsed = true;\n    return defaultIndex;\n  }\n  if (matchingIndexes.length === 1 && !useIndex) {\n    return matchingIndexes[0];\n  }\n\n  var userFieldsMap = arrayToObject(userFields);\n\n  function scoreIndex(index) {\n    var indexFields = index.def.fields.map(__WEBPACK_IMPORTED_MODULE_2_pouchdb_selector_core__[\"d\" /* getKey */]);\n    var score = 0;\n    for (var i = 0, len = indexFields.length; i < len; i++) {\n      var indexField = indexFields[i];\n      if (userFieldsMap[indexField]) {\n        score++;\n      }\n    }\n    return score;\n  }\n\n  if (useIndex) {\n    var useIndexDdoc = '_design/' + useIndex[0];\n    var useIndexName = useIndex.length === 2 ? useIndex[1] : false;\n    var index = matchingIndexes.find(function (index) {\n      if (useIndexName && index.ddoc === useIndexDdoc && useIndexName === index.name) {\n        return true;\n      }\n\n      if (index.ddoc === useIndexDdoc) {\n        return true;\n      }\n\n      return false;\n    });\n\n    if (!index) {\n      throw {\n        error: \"unknown_error\",\n        message: \"Could not find that index or could not use that index for the query\"\n      };\n    }\n    return index;\n  }\n\n  return max(matchingIndexes, scoreIndex);\n}\n\nfunction getSingleFieldQueryOptsFor(userOperator, userValue) {\n  switch (userOperator) {\n    case '$eq':\n      return { key: userValue };\n    case '$lte':\n      return { endkey: userValue };\n    case '$gte':\n      return { startkey: userValue };\n    case '$lt':\n      return {\n        endkey: userValue,\n        inclusive_end: false\n      };\n    case '$gt':\n      return {\n        startkey: userValue,\n        inclusive_start: false\n      };\n  }\n}\n\nfunction getSingleFieldCoreQueryPlan(selector, index) {\n  var field = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_pouchdb_selector_core__[\"d\" /* getKey */])(index.def.fields[0]);\n  //ignoring this because the test to exercise the branch is skipped at the moment\n  /* istanbul ignore next */\n  var matcher = selector[field] || {};\n  var inMemoryFields = [];\n\n  var userOperators = Object.keys(matcher);\n\n  var combinedOpts;\n\n  userOperators.forEach(function (userOperator) {\n\n    if (isNonLogicalMatcher(userOperator)) {\n      inMemoryFields.push(field);\n      return;\n    }\n\n    var userValue = matcher[userOperator];\n\n    var newQueryOpts = getSingleFieldQueryOptsFor(userOperator, userValue);\n\n    if (combinedOpts) {\n      combinedOpts = mergeObjects([combinedOpts, newQueryOpts]);\n    } else {\n      combinedOpts = newQueryOpts;\n    }\n  });\n\n  return {\n    queryOpts: combinedOpts,\n    inMemoryFields: inMemoryFields\n  };\n}\n\nfunction getMultiFieldCoreQueryPlan(userOperator, userValue) {\n  switch (userOperator) {\n    case '$eq':\n      return {\n        startkey: userValue,\n        endkey: userValue\n      };\n    case '$lte':\n      return {\n        endkey: userValue\n      };\n    case '$gte':\n      return {\n        startkey: userValue\n      };\n    case '$lt':\n      return {\n        endkey: userValue,\n        inclusive_end: false\n      };\n    case '$gt':\n      return {\n        startkey: userValue,\n        inclusive_start: false\n      };\n  }\n}\n\nfunction getMultiFieldQueryOpts(selector, index) {\n\n  var indexFields = index.def.fields.map(__WEBPACK_IMPORTED_MODULE_2_pouchdb_selector_core__[\"d\" /* getKey */]);\n\n  var inMemoryFields = [];\n  var startkey = [];\n  var endkey = [];\n  var inclusiveStart;\n  var inclusiveEnd;\n\n  function finish(i) {\n\n    if (inclusiveStart !== false) {\n      startkey.push(COLLATE_LO);\n    }\n    if (inclusiveEnd !== false) {\n      endkey.push(COLLATE_HI);\n    }\n    // keep track of the fields where we lost specificity,\n    // and therefore need to filter in-memory\n    inMemoryFields = indexFields.slice(i);\n  }\n\n  for (var i = 0, len = indexFields.length; i < len; i++) {\n    var indexField = indexFields[i];\n\n    var matcher = selector[indexField];\n\n    if (!matcher || !Object.keys(matcher).length) {\n      // fewer fields in user query than in index\n      finish(i);\n      break;\n    } else if (i > 0) {\n      if (Object.keys(matcher).some(isNonLogicalMatcher)) {\n        // non-logical are ignored\n        finish(i);\n        break;\n      }\n      var usingGtlt = '$gt' in matcher || '$gte' in matcher || '$lt' in matcher || '$lte' in matcher;\n      var previousKeys = Object.keys(selector[indexFields[i - 1]]);\n      var previousWasEq = arrayEquals(previousKeys, ['$eq']);\n      var previousWasSame = arrayEquals(previousKeys, Object.keys(matcher));\n      var gtltLostSpecificity = usingGtlt && !previousWasEq && !previousWasSame;\n      if (gtltLostSpecificity) {\n        finish(i);\n        break;\n      }\n    }\n\n    var userOperators = Object.keys(matcher);\n\n    var combinedOpts = null;\n\n    for (var j = 0; j < userOperators.length; j++) {\n      var userOperator = userOperators[j];\n      var userValue = matcher[userOperator];\n\n      var newOpts = getMultiFieldCoreQueryPlan(userOperator, userValue);\n\n      if (combinedOpts) {\n        combinedOpts = mergeObjects([combinedOpts, newOpts]);\n      } else {\n        combinedOpts = newOpts;\n      }\n    }\n\n    startkey.push('startkey' in combinedOpts ? combinedOpts.startkey : COLLATE_LO);\n    endkey.push('endkey' in combinedOpts ? combinedOpts.endkey : COLLATE_HI);\n    if ('inclusive_start' in combinedOpts) {\n      inclusiveStart = combinedOpts.inclusive_start;\n    }\n    if ('inclusive_end' in combinedOpts) {\n      inclusiveEnd = combinedOpts.inclusive_end;\n    }\n  }\n\n  var res = {\n    startkey: startkey,\n    endkey: endkey\n  };\n\n  if (typeof inclusiveStart !== 'undefined') {\n    res.inclusive_start = inclusiveStart;\n  }\n  if (typeof inclusiveEnd !== 'undefined') {\n    res.inclusive_end = inclusiveEnd;\n  }\n\n  return {\n    queryOpts: res,\n    inMemoryFields: inMemoryFields\n  };\n}\n\nfunction getDefaultQueryPlan(selector) {\n  //using default index, so all fields need to be done in memory\n  return {\n    queryOpts: { startkey: null },\n    inMemoryFields: [Object.keys(selector)]\n  };\n}\n\nfunction getCoreQueryPlan(selector, index) {\n  if (index.defaultUsed) {\n    return getDefaultQueryPlan(selector, index);\n  }\n\n  if (index.def.fields.length === 1) {\n    // one field in index, so the value was indexed as a singleton\n    return getSingleFieldCoreQueryPlan(selector, index);\n  }\n  // else index has multiple fields, so the value was indexed as an array\n  return getMultiFieldQueryOpts(selector, index);\n}\n\nfunction planQuery(request, indexes) {\n\n  var selector = request.selector;\n  var sort = request.sort;\n\n  var userFieldsRes = getUserFields(selector, sort);\n\n  var userFields = userFieldsRes.fields;\n  var sortOrder = userFieldsRes.sortOrder;\n  var index = findBestMatchingIndex(selector, userFields, sortOrder, indexes, request.use_index);\n\n  var coreQueryPlan = getCoreQueryPlan(selector, index);\n  var queryOpts = coreQueryPlan.queryOpts;\n  var coreInMemoryFields = coreQueryPlan.inMemoryFields;\n\n  var inMemoryFields = getInMemoryFields(coreInMemoryFields, index, selector, userFields);\n\n  var res = {\n    queryOpts: queryOpts,\n    index: index,\n    inMemoryFields: inMemoryFields\n  };\n  return res;\n}\n\nfunction indexToSignature(index) {\n  // remove '_design/'\n  return index.ddoc.substring(8) + '/' + index.name;\n}\n\nfunction doAllDocs(db, originalOpts) {\n  var opts = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_pouchdb_utils__[\"a\" /* clone */])(originalOpts);\n\n  // CouchDB responds in weird ways when you provide a non-string to _id;\n  // we mimic the behavior for consistency. See issue66 tests for details.\n\n  if (opts.descending) {\n    if ('endkey' in opts && typeof opts.endkey !== 'string') {\n      opts.endkey = '';\n    }\n    if ('startkey' in opts && typeof opts.startkey !== 'string') {\n      opts.limit = 0;\n    }\n  } else {\n    if ('startkey' in opts && typeof opts.startkey !== 'string') {\n      opts.startkey = '';\n    }\n    if ('endkey' in opts && typeof opts.endkey !== 'string') {\n      opts.limit = 0;\n    }\n  }\n  if ('key' in opts && typeof opts.key !== 'string') {\n    opts.limit = 0;\n  }\n\n  return db.allDocs(opts).then(function (res) {\n    // filter out any design docs that _all_docs might return\n    res.rows = res.rows.filter(function (row) {\n      return !/^_design\\//.test(row.id);\n    });\n    return res;\n  });\n}\n\nfunction find$1(db, requestDef, explain) {\n  if (requestDef.selector) {\n    requestDef.selector = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_pouchdb_selector_core__[\"g\" /* massageSelector */])(requestDef.selector);\n  }\n\n  if (requestDef.sort) {\n    requestDef.sort = massageSort(requestDef.sort);\n  }\n\n  if (requestDef.use_index) {\n    requestDef.use_index = massageUseIndex(requestDef.use_index);\n  }\n\n  validateFindRequest(requestDef);\n\n  return getIndexes$1(db).then(function (getIndexesRes) {\n\n    db.constructor.emit('debug', ['find', 'planning query', requestDef]);\n    var queryPlan = planQuery(requestDef, getIndexesRes.indexes);\n    db.constructor.emit('debug', ['find', 'query plan', queryPlan]);\n\n    var indexToUse = queryPlan.index;\n\n    validateSort(requestDef, indexToUse);\n\n    var opts = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_pouchdb_utils__[\"b\" /* assign */])({\n      include_docs: true,\n      reduce: false\n    }, queryPlan.queryOpts);\n\n    if ('startkey' in opts && 'endkey' in opts && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_pouchdb_collate__[\"a\" /* collate */])(opts.startkey, opts.endkey) > 0) {\n      // can't possibly return any results, startkey > endkey\n      return { docs: [] };\n    }\n\n    var isDescending = requestDef.sort && typeof requestDef.sort[0] !== 'string' && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_pouchdb_selector_core__[\"e\" /* getValue */])(requestDef.sort[0]) === 'desc';\n\n    if (isDescending) {\n      // either all descending or all ascending\n      opts.descending = true;\n      opts = reverseOptions(opts);\n    }\n\n    if (!queryPlan.inMemoryFields.length) {\n      // no in-memory filtering necessary, so we can let the\n      // database do the limit/skip for us\n      if ('limit' in requestDef) {\n        opts.limit = requestDef.limit;\n      }\n      if ('skip' in requestDef) {\n        opts.skip = requestDef.skip;\n      }\n    }\n\n    if (explain) {\n      return __WEBPACK_IMPORTED_MODULE_1_pouchdb_promise__[\"a\" /* default */].resolve(queryPlan, opts);\n    }\n\n    return __WEBPACK_IMPORTED_MODULE_1_pouchdb_promise__[\"a\" /* default */].resolve().then(function () {\n      if (indexToUse.name === '_all_docs') {\n        return doAllDocs(db, opts);\n      } else {\n        var signature = indexToSignature(indexToUse);\n        return abstractMapper.query.call(db, signature, opts);\n      }\n    }).then(function (res) {\n      if (opts.inclusive_start === false) {\n        // may have to manually filter the first one,\n        // since couchdb has no true inclusive_start option\n        res.rows = filterInclusiveStart(res.rows, opts.startkey, indexToUse);\n      }\n\n      if (queryPlan.inMemoryFields.length) {\n        // need to filter some stuff in-memory\n        res.rows = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_pouchdb_selector_core__[\"h\" /* filterInMemoryFields */])(res.rows, requestDef, queryPlan.inMemoryFields);\n      }\n\n      var resp = {\n        docs: res.rows.map(function (row) {\n          var doc = row.doc;\n          if (requestDef.fields) {\n            return pick(doc, requestDef.fields);\n          }\n          return doc;\n        })\n      };\n\n      if (indexToUse.defaultUsed) {\n        resp.warning = 'no matching index found, create an index to optimize query time';\n      }\n\n      return resp;\n    });\n  });\n}\n\nfunction explain$1(db, requestDef) {\n  return find$1(db, requestDef, true).then(function (queryPlan) {\n    return {\n      dbname: db.name,\n      index: queryPlan.index,\n      selector: requestDef.selector,\n      range: {\n        start_key: queryPlan.queryOpts.startkey,\n        end_key: queryPlan.queryOpts.endkey\n      },\n      opts: {\n        use_index: requestDef.use_index || [],\n        bookmark: \"nil\", //hardcoded to match CouchDB since its not supported,\n        limit: requestDef.limit,\n        skip: requestDef.skip,\n        sort: requestDef.sort || {},\n        fields: requestDef.fields,\n        conflicts: false, //hardcoded to match CouchDB since its not supported,\n        r: [49] // hardcoded to match CouchDB since its not support\n      },\n      limit: requestDef.limit,\n      skip: requestDef.skip || 0,\n      fields: requestDef.fields\n    };\n  });\n}\n\nfunction deleteIndex$1(db, index) {\n\n  if (!index.ddoc) {\n    throw new Error('you must supply an index.ddoc when deleting');\n  }\n\n  if (!index.name) {\n    throw new Error('you must supply an index.name when deleting');\n  }\n\n  var docId = index.ddoc;\n  var viewName = index.name;\n\n  function deltaFun(doc) {\n    if (Object.keys(doc.views).length === 1 && doc.views[viewName]) {\n      // only one view in this ddoc, delete the whole ddoc\n      return { _id: docId, _deleted: true };\n    }\n    // more than one view here, just remove the view\n    delete doc.views[viewName];\n    return doc;\n  }\n\n  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_pouchdb_utils__[\"c\" /* upsert */])(db, docId, deltaFun).then(function () {\n    return abstractMapper.viewCleanup.apply(db);\n  }).then(function () {\n    return { ok: true };\n  });\n}\n\nvar createIndexAsCallback = callbackify(createIndex$1);\nvar findAsCallback = callbackify(find$1);\nvar explainAsCallback = callbackify(explain$1);\nvar getIndexesAsCallback = callbackify(getIndexes$1);\nvar deleteIndexAsCallback = callbackify(deleteIndex$1);\n\nvar plugin = {};\nplugin.createIndex = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_pouchdb_utils__[\"d\" /* toPromise */])(function (requestDef, callback) {\n\n  if (typeof requestDef !== 'object') {\n    return callback(new Error('you must provide an index to create'));\n  }\n\n  var createIndex$$1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_pouchdb_utils__[\"e\" /* isRemote */])(this) ? createIndex : createIndexAsCallback;\n  createIndex$$1(this, requestDef, callback);\n});\n\nplugin.find = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_pouchdb_utils__[\"d\" /* toPromise */])(function (requestDef, callback) {\n\n  if (typeof callback === 'undefined') {\n    callback = requestDef;\n    requestDef = undefined;\n  }\n\n  if (typeof requestDef !== 'object') {\n    return callback(new Error('you must provide search parameters to find()'));\n  }\n\n  var find$$1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_pouchdb_utils__[\"e\" /* isRemote */])(this) ? find : findAsCallback;\n  find$$1(this, requestDef, callback);\n});\n\nplugin.explain = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_pouchdb_utils__[\"d\" /* toPromise */])(function (requestDef, callback) {\n\n  if (typeof callback === 'undefined') {\n    callback = requestDef;\n    requestDef = undefined;\n  }\n\n  if (typeof requestDef !== 'object') {\n    return callback(new Error('you must provide search parameters to explain()'));\n  }\n\n  var find$$1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_pouchdb_utils__[\"e\" /* isRemote */])(this) ? explain : explainAsCallback;\n  find$$1(this, requestDef, callback);\n});\n\nplugin.getIndexes = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_pouchdb_utils__[\"d\" /* toPromise */])(function (callback) {\n\n  var getIndexes$$1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_pouchdb_utils__[\"e\" /* isRemote */])(this) ? getIndexes : getIndexesAsCallback;\n  getIndexes$$1(this, callback);\n});\n\nplugin.deleteIndex = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_pouchdb_utils__[\"d\" /* toPromise */])(function (indexDef, callback) {\n\n  if (typeof indexDef !== 'object') {\n    return callback(new Error('you must provide an index to delete'));\n  }\n\n  var deleteIndex$$1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_pouchdb_utils__[\"e\" /* isRemote */])(this) ? deleteIndex : deleteIndexAsCallback;\n  deleteIndex$$1(this, indexDef, callback);\n});\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (plugin);\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(\"xdep\")))\n\n/***/ }),\n\n/***/ \"uUPe\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nvar scheduleDrain;\n\n{\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n    scheduleDrain = function scheduleDrain() {\n      element.data = called = ++called % 2;\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n    scheduleDrain = function scheduleDrain() {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function scheduleDrain() {\n\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function scheduleDrain() {\n      setTimeout(nextTick, 0);\n    };\n  }\n}\n\nvar draining;\nvar queue = [];\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n    while (++i < len) {\n      oldQueue[i]();\n    }\n    len = queue.length;\n  }\n  draining = false;\n}\n\nmodule.exports = immediate;\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(\"h4f+\")))\n\n/***/ }),\n\n/***/ \"wdwc\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _require = __webpack_require__(\"1ipf\"),\n    ShoppingListRepository = _require.ShoppingListRepository;\n\nvar _require2 = __webpack_require__(\"YrHc\"),\n    ShoppingListFactory = _require2.ShoppingListFactory;\n\nvar _require3 = __webpack_require__(\"d18E\"),\n    Record = _require3.Record;\n\nvar ShoppingListRepositoryPouchDB = function (_ShoppingListReposito) {\n  _inherits(ShoppingListRepositoryPouchDB, _ShoppingListReposito);\n\n  function ShoppingListRepositoryPouchDB(db) {\n    _classCallCheck(this, ShoppingListRepositoryPouchDB);\n\n    var _this = _possibleConstructorReturn(this, _ShoppingListReposito.call(this));\n\n    _this.db = db;\n    _this._shoppingListFactory = new ShoppingListFactory();\n    return _this;\n  }\n\n  ShoppingListRepositoryPouchDB.prototype._guardShoppingList = function _guardShoppingList(shoppingList) {\n    if (!Record.isRecord(shoppingList)) {\n      throw new Error(\"Shopping List must be a Record\");\n    }\n    if (shoppingList._id === undefined) {\n      throw new Error(\"Shopping List _id must be set\");\n    }\n    if (shoppingList.type != \"list\") {\n      throw new Error(\"Shopping List type must be list\");\n    }\n  };\n\n  ShoppingListRepositoryPouchDB.prototype._guardShoppingListItem = function _guardShoppingListItem(shoppingListItem) {\n    if (!Record.isRecord(shoppingListItem)) {\n      throw new Error(\"Shopping List Item must be a Record\");\n    }\n    if (shoppingListItem._id === undefined) {\n      throw new Error(\"Shopping List Item _id must be set\");\n    }\n    if (shoppingListItem.type != \"item\") {\n      throw new Error(\"Shopping List Item type must be item\");\n    }\n  };\n\n  ShoppingListRepositoryPouchDB.prototype._guardRequest = function _guardRequest(request) {\n    if (!request) {\n      throw new Error(\"Request must be defined\");\n    }\n    if (!request.selector) {\n      throw new Error(\"Request must have a selector property\");\n    }\n    if (!request.selector.type) {\n      throw new Error(\"Request selector must have a type property\");\n    }\n  };\n\n  ShoppingListRepositoryPouchDB.prototype._guardShoppingListRequest = function _guardShoppingListRequest(request) {\n    this._guardRequest(request);\n    if (request.selector.type != \"list\") {\n      throw new Error(\"Request selector must have a type property with a value of 'list'\");\n    }\n  };\n\n  ShoppingListRepositoryPouchDB.prototype._guardShoppingListItemRequest = function _guardShoppingListItemRequest(request) {\n    this._guardRequest(request);\n    if (request.selector.type != \"item\") {\n      throw new Error(\"Request selector must have a type property with a value of 'item'\");\n    }\n  };\n\n  ShoppingListRepositoryPouchDB.prototype._put = function _put(record) {\n    var updatedAt = new Date().toISOString();\n    if (!record._rev) {\n      record = record.mergeDeep({\n        createdAt: updatedAt\n      });\n    }\n    record = record.mergeDeep({\n      updatedAt: updatedAt\n    });\n    return this.db.put(record.toJSON()).then(function (result) {\n      return record.mergeDeep({\n        _id: result.id,\n        _rev: result.rev\n      });\n    });\n  };\n\n  ShoppingListRepositoryPouchDB.prototype._get = function _get(id) {\n    return this.db.get(id);\n  };\n\n  ShoppingListRepositoryPouchDB.prototype._delete = function _delete(record) {\n    var updatedAt = new Date().toISOString();\n    record = record.mergeDeep({\n      _deleted: true,\n      updatedAt: updatedAt\n    });\n    return this.db.put(record.toJSON()).then(function (result) {\n      return record.mergeDeep({\n        _rev: result.rev\n      });\n    });\n  };\n\n  ShoppingListRepositoryPouchDB.prototype._ensureIndexOfType = function _ensureIndexOfType() {\n    return this.db.createIndex({\n      index: {\n        fields: [\"type\"]\n      }\n    });\n  };\n\n  ShoppingListRepositoryPouchDB.prototype._ensureIndexOfTypeAndList = function _ensureIndexOfTypeAndList() {\n    return this.db.createIndex({\n      index: {\n        fields: [\"type\", \"list\"]\n      }\n    });\n  };\n\n  ShoppingListRepositoryPouchDB.prototype._ensureIndexOfTypeAndChecked = function _ensureIndexOfTypeAndChecked() {\n    return this.db.createIndex({\n      index: {\n        fields: [\"type\", \"checked\"]\n      }\n    });\n  };\n\n  ShoppingListRepositoryPouchDB.prototype._ensureIndexOfTypeAndListAndChecked = function _ensureIndexOfTypeAndListAndChecked() {\n    return this.db.createIndex({\n      index: {\n        fields: [\"type\", \"list\", \"checked\"]\n      }\n    });\n  };\n\n  ShoppingListRepositoryPouchDB.prototype.ensureIndexes = function ensureIndexes() {\n    return Promise.all([this._ensureIndexOfType(), this._ensureIndexOfTypeAndList(), this._ensureIndexOfTypeAndChecked(), this._ensureIndexOfTypeAndListAndChecked()]);\n  };\n\n  ShoppingListRepositoryPouchDB.prototype.put = function put(shoppingList) {\n    this._guardShoppingList(shoppingList);\n    return this._put(shoppingList);\n  };\n\n  ShoppingListRepositoryPouchDB.prototype.putBulk = function putBulk(shoppingLists) {\n    var _this2 = this;\n\n    var putLists = [];\n    shoppingLists.forEach(function (shoppingList) {\n      putLists.push(_this2.put(shoppingList));\n    });\n    return Promise.all(putLists).then(function (shoppingLists) {\n      return _this2._shoppingListFactory.newListOfShoppingLists(shoppingLists);\n    });\n  };\n\n  ShoppingListRepositoryPouchDB.prototype.get = function get(shoppingListId) {\n    var _this3 = this;\n\n    return this._get(shoppingListId).then(function (doc) {\n      var shoppingList = _this3._shoppingListFactory.newShoppingList(doc);\n      _this3._guardShoppingList(shoppingList);\n      return shoppingList;\n    });\n  };\n\n  ShoppingListRepositoryPouchDB.prototype.find = function find() {\n    var _this4 = this;\n\n    var request = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { selector: { type: \"list\" } };\n\n    this._guardShoppingListRequest(request);\n    return this.db.find(request).then(function (result) {\n      if (result.warning) {\n        console.warn(result.warning);\n      }\n      var listOfShoppingLists = _this4._shoppingListFactory.newListOfShoppingLists();\n      result.docs.forEach(function (doc) {\n        listOfShoppingLists = listOfShoppingLists.push(_this4._shoppingListFactory.newShoppingList(doc));\n      });\n      return listOfShoppingLists;\n    });\n  };\n\n  ShoppingListRepositoryPouchDB.prototype.delete = function _delete(shoppingList) {\n    var _this5 = this;\n\n    this._guardShoppingList(shoppingList);\n    return this._delete(shoppingList).then(function (shoppingList) {\n      return _this5.deleteItemsBulkByFind({\n        selector: {\n          type: \"item\",\n          list: shoppingList._id\n        }\n      }).then(function (listOfShoppingListItems) {\n        return shoppingList;\n      });\n    });\n  };\n\n  ShoppingListRepositoryPouchDB.prototype.putItem = function putItem(shoppingListItem) {\n    this._guardShoppingListItem(shoppingListItem);\n    return this._put(shoppingListItem);\n  };\n\n  ShoppingListRepositoryPouchDB.prototype.putItemsBulk = function putItemsBulk(shoppingListItems) {\n    var _this6 = this;\n\n    var putItems = [];\n    shoppingListItems.forEach(function (shoppingListItem) {\n      putItems.push(_this6.putItem(shoppingListItem));\n    });\n    return Promise.all(putItems).then(function (shoppingListItems) {\n      return _this6._shoppingListFactory.newListOfShoppingListItems(shoppingListItems);\n    });\n  };\n\n  ShoppingListRepositoryPouchDB.prototype.getItem = function getItem(shoppingListItemId) {\n    var _this7 = this;\n\n    return this._get(shoppingListItemId).then(function (doc) {\n      var shoppingListItem = _this7._shoppingListFactory.newShoppingListItem(doc);\n      _this7._guardShoppingListItem(shoppingListItem);\n      return shoppingListItem;\n    });\n  };\n\n  ShoppingListRepositoryPouchDB.prototype.findItems = function findItems() {\n    var _this8 = this;\n\n    var request = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { selector: { type: \"item\" } };\n\n    this._guardShoppingListItemRequest(request);\n    return this.db.find(request).then(function (result) {\n      if (result.warning) {\n        console.warn(result.warning);\n      }\n      var listOfShoppingListItems = _this8._shoppingListFactory.newListOfShoppingListItems();\n      result.docs.forEach(function (doc) {\n        listOfShoppingListItems = listOfShoppingListItems.push(_this8._shoppingListFactory.newShoppingListItem(doc));\n      });\n      return listOfShoppingListItems;\n    });\n  };\n\n  ShoppingListRepositoryPouchDB.prototype.findItemsCountByList = function findItemsCountByList() {\n    var request = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { selector: { type: \"item\" }, fields: [\"list\"] };\n\n    if (request.fields && !request.fields.includes(\"list\")) {\n      throw new Error(\"Request must have a fields property that includes a value of 'list'\");\n    }\n    return this.findItems(request).then(function (listOfShoppingListItems) {\n      return listOfShoppingListItems.countBy(function (shoppingListItem) {\n        return shoppingListItem.list;\n      });\n    });\n  };\n\n  ShoppingListRepositoryPouchDB.prototype.deleteItem = function deleteItem(shoppingListItem) {\n    this._guardShoppingListItem(shoppingListItem);\n    return this._delete(shoppingListItem);\n  };\n\n  ShoppingListRepositoryPouchDB.prototype.deleteItemsBulk = function deleteItemsBulk(shoppingListItems) {\n    var _this9 = this;\n\n    var deletedItems = [];\n    shoppingListItems.forEach(function (shoppingListItem) {\n      deletedItems.push(_this9.deleteItem(shoppingListItem));\n    });\n    return Promise.all(deletedItems).then(function (shoppingListItems) {\n      return _this9._shoppingListFactory.newListOfShoppingListItems(shoppingListItems);\n    });\n  };\n\n  ShoppingListRepositoryPouchDB.prototype.deleteItemsBulkByFind = function deleteItemsBulkByFind() {\n    var _this10 = this;\n\n    var request = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { selector: { type: \"item\" } };\n\n    if (request.fields) {\n      throw new Error(\"Request must not have a fields property\");\n    }\n    return this.findItems(request).then(function (listOfShoppingListItems) {\n      return _this10.deleteItemsBulk(listOfShoppingListItems);\n    });\n  };\n\n  return ShoppingListRepositoryPouchDB;\n}(ShoppingListRepository);\n\nexports.ShoppingListRepositoryPouchDB = ShoppingListRepositoryPouchDB;\n\n/***/ }),\n\n/***/ \"xdep\":\n/***/ (function(module, exports, __webpack_require__) {\n\nexports.nextTick = function nextTick(fn) {\n    setTimeout(fn, 0);\n};\n\nexports.platform = exports.arch = exports.execPath = exports.title = 'browser';\nexports.pid = 1;\nexports.browser = true;\nexports.env = {};\nexports.argv = [];\n\nexports.binding = function (name) {\n    throw new Error('No such module. (Possibly not yet loaded)');\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    exports.cwd = function () {\n        return cwd;\n    };\n    exports.chdir = function (dir) {\n        if (!path) path = __webpack_require__(\"IFa6\");\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n\nexports.exit = exports.kill = exports.umask = exports.dlopen = exports.uptime = exports.memoryUsage = exports.uvCounters = function () {};\nexports.features = {};\n\n/***/ }),\n\n/***/ \"xz3w\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar immediate = __webpack_require__(\"uUPe\");\n\n/* istanbul ignore next */\nfunction INTERNAL() {}\n\nvar handlers = {};\n\nvar REJECTED = ['REJECTED'];\nvar FULFILLED = ['FULFILLED'];\nvar PENDING = ['PENDING'];\n\nmodule.exports = Promise;\n\nfunction Promise(resolver) {\n  if (typeof resolver !== 'function') {\n    throw new TypeError('resolver must be a function');\n  }\n  this.state = PENDING;\n  this.queue = [];\n  this.outcome = void 0;\n  if (resolver !== INTERNAL) {\n    safelyResolveThenable(this, resolver);\n  }\n}\n\nPromise.prototype[\"catch\"] = function (onRejected) {\n  return this.then(null, onRejected);\n};\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  if (typeof onFulfilled !== 'function' && this.state === FULFILLED || typeof onRejected !== 'function' && this.state === REJECTED) {\n    return this;\n  }\n  var promise = new this.constructor(INTERNAL);\n  if (this.state !== PENDING) {\n    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n    unwrap(promise, resolver, this.outcome);\n  } else {\n    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n  }\n\n  return promise;\n};\nfunction QueueItem(promise, onFulfilled, onRejected) {\n  this.promise = promise;\n  if (typeof onFulfilled === 'function') {\n    this.onFulfilled = onFulfilled;\n    this.callFulfilled = this.otherCallFulfilled;\n  }\n  if (typeof onRejected === 'function') {\n    this.onRejected = onRejected;\n    this.callRejected = this.otherCallRejected;\n  }\n}\nQueueItem.prototype.callFulfilled = function (value) {\n  handlers.resolve(this.promise, value);\n};\nQueueItem.prototype.otherCallFulfilled = function (value) {\n  unwrap(this.promise, this.onFulfilled, value);\n};\nQueueItem.prototype.callRejected = function (value) {\n  handlers.reject(this.promise, value);\n};\nQueueItem.prototype.otherCallRejected = function (value) {\n  unwrap(this.promise, this.onRejected, value);\n};\n\nfunction unwrap(promise, func, value) {\n  immediate(function () {\n    var returnValue;\n    try {\n      returnValue = func(value);\n    } catch (e) {\n      return handlers.reject(promise, e);\n    }\n    if (returnValue === promise) {\n      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n    } else {\n      handlers.resolve(promise, returnValue);\n    }\n  });\n}\n\nhandlers.resolve = function (self, value) {\n  var result = tryCatch(getThen, value);\n  if (result.status === 'error') {\n    return handlers.reject(self, result.value);\n  }\n  var thenable = result.value;\n\n  if (thenable) {\n    safelyResolveThenable(self, thenable);\n  } else {\n    self.state = FULFILLED;\n    self.outcome = value;\n    var i = -1;\n    var len = self.queue.length;\n    while (++i < len) {\n      self.queue[i].callFulfilled(value);\n    }\n  }\n  return self;\n};\nhandlers.reject = function (self, error) {\n  self.state = REJECTED;\n  self.outcome = error;\n  var i = -1;\n  var len = self.queue.length;\n  while (++i < len) {\n    self.queue[i].callRejected(error);\n  }\n  return self;\n};\n\nfunction getThen(obj) {\n  // Make sure we only access the accessor once as required by the spec\n  var then = obj && obj.then;\n  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {\n    return function appyThen() {\n      then.apply(obj, arguments);\n    };\n  }\n}\n\nfunction safelyResolveThenable(self, thenable) {\n  // Either fulfill, reject or reject with error\n  var called = false;\n  function onError(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.reject(self, value);\n  }\n\n  function onSuccess(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.resolve(self, value);\n  }\n\n  function tryToUnwrap() {\n    thenable(onSuccess, onError);\n  }\n\n  var result = tryCatch(tryToUnwrap);\n  if (result.status === 'error') {\n    onError(result.value);\n  }\n}\n\nfunction tryCatch(func, value) {\n  var out = {};\n  try {\n    out.value = func(value);\n    out.status = 'success';\n  } catch (e) {\n    out.status = 'error';\n    out.value = e;\n  }\n  return out;\n}\n\nPromise.resolve = resolve;\nfunction resolve(value) {\n  if (value instanceof this) {\n    return value;\n  }\n  return handlers.resolve(new this(INTERNAL), value);\n}\n\nPromise.reject = reject;\nfunction reject(reason) {\n  var promise = new this(INTERNAL);\n  return handlers.reject(promise, reason);\n}\n\nPromise.all = all;\nfunction all(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var values = new Array(len);\n  var resolved = 0;\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    allResolver(iterable[i], i);\n  }\n  return promise;\n  function allResolver(value, i) {\n    self.resolve(value).then(resolveFromAll, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n    function resolveFromAll(outValue) {\n      values[i] = outValue;\n      if (++resolved === len && !called) {\n        called = true;\n        handlers.resolve(promise, values);\n      }\n    }\n  }\n}\n\nPromise.race = race;\nfunction race(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    resolver(iterable[i]);\n  }\n  return promise;\n  function resolver(value) {\n    self.resolve(value).then(function (response) {\n      if (!called) {\n        called = true;\n        handlers.resolve(promise, response);\n      }\n    }, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n  }\n}\n\n/***/ }),\n\n/***/ \"y5CM\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = __webpack_require__(\"6IAg\");\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0,\n      i;\n\n  for (i in namespace) {\n    hash = (hash << 5) - hash + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n/***/ })\n\n/******/ });\n\n\n// WEBPACK FOOTER //\n// bundle.db381.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"./\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 2e3fd2c57d167260d556","import uuidV4 from 'uuid';\nimport lie from 'lie';\nimport getArguments from 'argsarray';\nimport { EventEmitter } from 'events';\nimport inherits from 'inherits';\nimport nextTick from 'immediate';\nimport debug from 'debug';\nimport Md5 from 'spark-md5';\nimport vuvuzela from 'vuvuzela';\n\n/* istanbul ignore next */\nvar PouchPromise$1 = typeof Promise === 'function' ? Promise : lie;\n\nfunction isBinaryObject(object) {\n  return (typeof ArrayBuffer !== 'undefined' && object instanceof ArrayBuffer) ||\n    (typeof Blob !== 'undefined' && object instanceof Blob);\n}\n\nfunction cloneArrayBuffer(buff) {\n  if (typeof buff.slice === 'function') {\n    return buff.slice(0);\n  }\n  // IE10-11 slice() polyfill\n  var target = new ArrayBuffer(buff.byteLength);\n  var targetArray = new Uint8Array(target);\n  var sourceArray = new Uint8Array(buff);\n  targetArray.set(sourceArray);\n  return target;\n}\n\nfunction cloneBinaryObject(object) {\n  if (object instanceof ArrayBuffer) {\n    return cloneArrayBuffer(object);\n  }\n  var size = object.size;\n  var type = object.type;\n  // Blob\n  if (typeof object.slice === 'function') {\n    return object.slice(0, size, type);\n  }\n  // PhantomJS slice() replacement\n  return object.webkitSlice(0, size, type);\n}\n\n// most of this is borrowed from lodash.isPlainObject:\n// https://github.com/fis-components/lodash.isplainobject/\n// blob/29c358140a74f252aeb08c9eb28bef86f2217d4a/index.js\n\nvar funcToString = Function.prototype.toString;\nvar objectCtorString = funcToString.call(Object);\n\nfunction isPlainObject(value) {\n  var proto = Object.getPrototypeOf(value);\n  /* istanbul ignore if */\n  if (proto === null) { // not sure when this happens, but I guess it can\n    return true;\n  }\n  var Ctor = proto.constructor;\n  return (typeof Ctor == 'function' &&\n    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);\n}\n\nfunction clone(object) {\n  var newObject;\n  var i;\n  var len;\n\n  if (!object || typeof object !== 'object') {\n    return object;\n  }\n\n  if (Array.isArray(object)) {\n    newObject = [];\n    for (i = 0, len = object.length; i < len; i++) {\n      newObject[i] = clone(object[i]);\n    }\n    return newObject;\n  }\n\n  // special case: to avoid inconsistencies between IndexedDB\n  // and other backends, we automatically stringify Dates\n  if (object instanceof Date) {\n    return object.toISOString();\n  }\n\n  if (isBinaryObject(object)) {\n    return cloneBinaryObject(object);\n  }\n\n  if (!isPlainObject(object)) {\n    return object; // don't clone objects like Workers\n  }\n\n  newObject = {};\n  for (i in object) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(object, i)) {\n      var value = clone(object[i]);\n      if (typeof value !== 'undefined') {\n        newObject[i] = value;\n      }\n    }\n  }\n  return newObject;\n}\n\nfunction once(fun) {\n  var called = false;\n  return getArguments(function (args) {\n    /* istanbul ignore if */\n    if (called) {\n      // this is a smoke test and should never actually happen\n      throw new Error('once called more than once');\n    } else {\n      called = true;\n      fun.apply(this, args);\n    }\n  });\n}\n\nfunction toPromise(func) {\n  //create the function we will be returning\n  return getArguments(function (args) {\n    // Clone arguments\n    args = clone(args);\n    var self = this;\n    // if the last argument is a function, assume its a callback\n    var usedCB = (typeof args[args.length - 1] === 'function') ? args.pop() : false;\n    var promise = new PouchPromise$1(function (fulfill, reject) {\n      var resp;\n      try {\n        var callback = once(function (err, mesg) {\n          if (err) {\n            reject(err);\n          } else {\n            fulfill(mesg);\n          }\n        });\n        // create a callback for this invocation\n        // apply the function in the orig context\n        args.push(callback);\n        resp = func.apply(self, args);\n        if (resp && typeof resp.then === 'function') {\n          fulfill(resp);\n        }\n      } catch (e) {\n        reject(e);\n      }\n    });\n    // if there is a callback, call it back\n    if (usedCB) {\n      promise.then(function (result) {\n        usedCB(null, result);\n      }, usedCB);\n    }\n    return promise;\n  });\n}\n\nfunction logApiCall(self, name, args) {\n  /* istanbul ignore if */\n  if (self.constructor.listeners('debug').length) {\n    var logArgs = ['api', self.name, name];\n    for (var i = 0; i < args.length - 1; i++) {\n      logArgs.push(args[i]);\n    }\n    self.constructor.emit('debug', logArgs);\n\n    // override the callback itself to log the response\n    var origCallback = args[args.length - 1];\n    args[args.length - 1] = function (err, res) {\n      var responseArgs = ['api', self.name, name];\n      responseArgs = responseArgs.concat(\n        err ? ['error', err] : ['success', res]\n      );\n      self.constructor.emit('debug', responseArgs);\n      origCallback(err, res);\n    };\n  }\n}\n\nfunction adapterFun(name, callback) {\n  return toPromise(getArguments(function (args) {\n    if (this._closed) {\n      return PouchPromise$1.reject(new Error('database is closed'));\n    }\n    if (this._destroyed) {\n      return PouchPromise$1.reject(new Error('database is destroyed'));\n    }\n    var self = this;\n    logApiCall(self, name, args);\n    if (!this.taskqueue.isReady) {\n      return new PouchPromise$1(function (fulfill, reject) {\n        self.taskqueue.addTask(function (failed) {\n          if (failed) {\n            reject(failed);\n          } else {\n            fulfill(self[name].apply(self, args));\n          }\n        });\n      });\n    }\n    return callback.apply(this, args);\n  }));\n}\n\nfunction mangle(key) {\n  return '$' + key;\n}\nfunction unmangle(key) {\n  return key.substring(1);\n}\nfunction Map$1() {\n  this._store = {};\n}\nMap$1.prototype.get = function (key) {\n  var mangled = mangle(key);\n  return this._store[mangled];\n};\nMap$1.prototype.set = function (key, value) {\n  var mangled = mangle(key);\n  this._store[mangled] = value;\n  return true;\n};\nMap$1.prototype.has = function (key) {\n  var mangled = mangle(key);\n  return mangled in this._store;\n};\nMap$1.prototype.delete = function (key) {\n  var mangled = mangle(key);\n  var res = mangled in this._store;\n  delete this._store[mangled];\n  return res;\n};\nMap$1.prototype.forEach = function (cb) {\n  var keys = Object.keys(this._store);\n  for (var i = 0, len = keys.length; i < len; i++) {\n    var key = keys[i];\n    var value = this._store[key];\n    key = unmangle(key);\n    cb(value, key);\n  }\n};\nObject.defineProperty(Map$1.prototype, 'size', {\n  get: function () {\n    return Object.keys(this._store).length;\n  }\n});\n\nfunction Set$1(array) {\n  this._store = new Map$1();\n\n  // init with an array\n  if (array && Array.isArray(array)) {\n    for (var i = 0, len = array.length; i < len; i++) {\n      this.add(array[i]);\n    }\n  }\n}\nSet$1.prototype.add = function (key) {\n  return this._store.set(key, true);\n};\nSet$1.prototype.has = function (key) {\n  return this._store.has(key);\n};\nSet$1.prototype.forEach = function (cb) {\n  this._store.forEach(function (value, key) {\n    cb(key);\n  });\n};\nObject.defineProperty(Set$1.prototype, 'size', {\n  get: function () {\n    return this._store.size;\n  }\n});\n\n/* global Map,Set,Symbol */\n// Based on https://kangax.github.io/compat-table/es6/ we can sniff out\n// incomplete Map/Set implementations which would otherwise cause our tests to fail.\n// Notably they fail in IE11 and iOS 8.4, which this prevents.\nfunction supportsMapAndSet() {\n  if (typeof Symbol === 'undefined' || typeof Map === 'undefined' || typeof Set === 'undefined') {\n    return false;\n  }\n  var prop = Object.getOwnPropertyDescriptor(Map, Symbol.species);\n  return prop && 'get' in prop && Map[Symbol.species] === Map;\n}\n\n// based on https://github.com/montagejs/collections\n/* global Map,Set */\n\nvar ExportedSet;\nvar ExportedMap;\n\n{\n  if (supportsMapAndSet()) { // prefer built-in Map/Set\n    ExportedSet = Set;\n    ExportedMap = Map;\n  } else { // fall back to our polyfill\n    ExportedSet = Set$1;\n    ExportedMap = Map$1;\n  }\n}\n\n// like underscore/lodash _.pick()\nfunction pick(obj, arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var prop = arr[i];\n    if (prop in obj) {\n      res[prop] = obj[prop];\n    }\n  }\n  return res;\n}\n\n// Most browsers throttle concurrent requests at 6, so it's silly\n// to shim _bulk_get by trying to launch potentially hundreds of requests\n// and then letting the majority time out. We can handle this ourselves.\nvar MAX_NUM_CONCURRENT_REQUESTS = 6;\n\nfunction identityFunction(x) {\n  return x;\n}\n\nfunction formatResultForOpenRevsGet(result) {\n  return [{\n    ok: result\n  }];\n}\n\n// shim for P/CouchDB adapters that don't directly implement _bulk_get\nfunction bulkGet(db, opts, callback) {\n  var requests = opts.docs;\n\n  // consolidate into one request per doc if possible\n  var requestsById = new ExportedMap();\n  requests.forEach(function (request) {\n    if (requestsById.has(request.id)) {\n      requestsById.get(request.id).push(request);\n    } else {\n      requestsById.set(request.id, [request]);\n    }\n  });\n\n  var numDocs = requestsById.size;\n  var numDone = 0;\n  var perDocResults = new Array(numDocs);\n\n  function collapseResultsAndFinish() {\n    var results = [];\n    perDocResults.forEach(function (res) {\n      res.docs.forEach(function (info) {\n        results.push({\n          id: res.id,\n          docs: [info]\n        });\n      });\n    });\n    callback(null, {results: results});\n  }\n\n  function checkDone() {\n    if (++numDone === numDocs) {\n      collapseResultsAndFinish();\n    }\n  }\n\n  function gotResult(docIndex, id, docs) {\n    perDocResults[docIndex] = {id: id, docs: docs};\n    checkDone();\n  }\n\n  var allRequests = [];\n  requestsById.forEach(function (value, key) {\n    allRequests.push(key);\n  });\n\n  var i = 0;\n\n  function nextBatch() {\n\n    if (i >= allRequests.length) {\n      return;\n    }\n\n    var upTo = Math.min(i + MAX_NUM_CONCURRENT_REQUESTS, allRequests.length);\n    var batch = allRequests.slice(i, upTo);\n    processBatch(batch, i);\n    i += batch.length;\n  }\n\n  function processBatch(batch, offset) {\n    batch.forEach(function (docId, j) {\n      var docIdx = offset + j;\n      var docRequests = requestsById.get(docId);\n\n      // just use the first request as the \"template\"\n      // TODO: The _bulk_get API allows for more subtle use cases than this,\n      // but for now it is unlikely that there will be a mix of different\n      // \"atts_since\" or \"attachments\" in the same request, since it's just\n      // replicate.js that is using this for the moment.\n      // Also, atts_since is aspirational, since we don't support it yet.\n      var docOpts = pick(docRequests[0], ['atts_since', 'attachments']);\n      docOpts.open_revs = docRequests.map(function (request) {\n        // rev is optional, open_revs disallowed\n        return request.rev;\n      });\n\n      // remove falsey / undefined revisions\n      docOpts.open_revs = docOpts.open_revs.filter(identityFunction);\n\n      var formatResult = identityFunction;\n\n      if (docOpts.open_revs.length === 0) {\n        delete docOpts.open_revs;\n\n        // when fetching only the \"winning\" leaf,\n        // transform the result so it looks like an open_revs\n        // request\n        formatResult = formatResultForOpenRevsGet;\n      }\n\n      // globally-supplied options\n      ['revs', 'attachments', 'binary', 'ajax', 'latest'].forEach(function (param) {\n        if (param in opts) {\n          docOpts[param] = opts[param];\n        }\n      });\n      db.get(docId, docOpts, function (err, res) {\n        var result;\n        /* istanbul ignore if */\n        if (err) {\n          result = [{error: err}];\n        } else {\n          result = formatResult(res);\n        }\n        gotResult(docIdx, docId, result);\n        nextBatch();\n      });\n    });\n  }\n\n  nextBatch();\n\n}\n\nfunction isChromeApp() {\n  return (typeof chrome !== \"undefined\" &&\n    typeof chrome.storage !== \"undefined\" &&\n    typeof chrome.storage.local !== \"undefined\");\n}\n\nvar hasLocal;\n\nif (isChromeApp()) {\n  hasLocal = false;\n} else {\n  try {\n    localStorage.setItem('_pouch_check_localstorage', 1);\n    hasLocal = !!localStorage.getItem('_pouch_check_localstorage');\n  } catch (e) {\n    hasLocal = false;\n  }\n}\n\nfunction hasLocalStorage() {\n  return hasLocal;\n}\n\n// Custom nextTick() shim for browsers. In node, this will just be process.nextTick(). We\n// avoid using process.nextTick() directly because the polyfill is very large and we don't\n// need all of it (see: https://github.com/defunctzombie/node-process).\n// \"immediate\" 3.0.8 is used by lie, and it's a smaller version of the latest \"immediate\"\n// package, so it's the one we use.\n// When we use nextTick() in our codebase, we only care about not releasing Zalgo\n// (see: http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony).\n// Microtask vs macrotask doesn't matter to us. So we're free to use the fastest\n// (least latency) option, which is \"immediate\" due to use of microtasks.\n// All of our nextTicks are isolated to this one function so we can easily swap out one\n// implementation for another.\n\ninherits(Changes, EventEmitter);\n\n/* istanbul ignore next */\nfunction attachBrowserEvents(self) {\n  if (isChromeApp()) {\n    chrome.storage.onChanged.addListener(function (e) {\n      // make sure it's event addressed to us\n      if (e.db_name != null) {\n        //object only has oldValue, newValue members\n        self.emit(e.dbName.newValue);\n      }\n    });\n  } else if (hasLocalStorage()) {\n    if (typeof addEventListener !== 'undefined') {\n      addEventListener(\"storage\", function (e) {\n        self.emit(e.key);\n      });\n    } else { // old IE\n      window.attachEvent(\"storage\", function (e) {\n        self.emit(e.key);\n      });\n    }\n  }\n}\n\nfunction Changes() {\n  EventEmitter.call(this);\n  this._listeners = {};\n\n  attachBrowserEvents(this);\n}\nChanges.prototype.addListener = function (dbName, id, db, opts) {\n  /* istanbul ignore if */\n  if (this._listeners[id]) {\n    return;\n  }\n  var self = this;\n  var inprogress = false;\n  function eventFunction() {\n    /* istanbul ignore if */\n    if (!self._listeners[id]) {\n      return;\n    }\n    if (inprogress) {\n      inprogress = 'waiting';\n      return;\n    }\n    inprogress = true;\n    var changesOpts = pick(opts, [\n      'style', 'include_docs', 'attachments', 'conflicts', 'filter',\n      'doc_ids', 'view', 'since', 'query_params', 'binary'\n    ]);\n\n    /* istanbul ignore next */\n    function onError() {\n      inprogress = false;\n    }\n\n    db.changes(changesOpts).on('change', function (c) {\n      if (c.seq > opts.since && !opts.cancelled) {\n        opts.since = c.seq;\n        opts.onChange(c);\n      }\n    }).on('complete', function () {\n      if (inprogress === 'waiting') {\n        nextTick(eventFunction);\n      }\n      inprogress = false;\n    }).on('error', onError);\n  }\n  this._listeners[id] = eventFunction;\n  this.on(dbName, eventFunction);\n};\n\nChanges.prototype.removeListener = function (dbName, id) {\n  /* istanbul ignore if */\n  if (!(id in this._listeners)) {\n    return;\n  }\n  EventEmitter.prototype.removeListener.call(this, dbName,\n    this._listeners[id]);\n  delete this._listeners[id];\n};\n\n\n/* istanbul ignore next */\nChanges.prototype.notifyLocalWindows = function (dbName) {\n  //do a useless change on a storage thing\n  //in order to get other windows's listeners to activate\n  if (isChromeApp()) {\n    chrome.storage.local.set({dbName: dbName});\n  } else if (hasLocalStorage()) {\n    localStorage[dbName] = (localStorage[dbName] === \"a\") ? \"b\" : \"a\";\n  }\n};\n\nChanges.prototype.notify = function (dbName) {\n  this.emit(dbName);\n  this.notifyLocalWindows(dbName);\n};\n\nfunction guardedConsole(method) {\n  /* istanbul ignore else */\n  if (console !== 'undefined' && method in console) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    console[method].apply(console, args);\n  }\n}\n\nfunction randomNumber(min, max) {\n  var maxTimeout = 600000; // Hard-coded default of 10 minutes\n  min = parseInt(min, 10) || 0;\n  max = parseInt(max, 10);\n  if (max !== max || max <= min) {\n    max = (min || 1) << 1; //doubling\n  } else {\n    max = max + 1;\n  }\n  // In order to not exceed maxTimeout, pick a random value between half of maxTimeout and maxTimeout\n  if (max > maxTimeout) {\n    min = maxTimeout >> 1; // divide by two\n    max = maxTimeout;\n  }\n  var ratio = Math.random();\n  var range = max - min;\n\n  return ~~(range * ratio + min); // ~~ coerces to an int, but fast.\n}\n\nfunction defaultBackOff(min) {\n  var max = 0;\n  if (!min) {\n    max = 2000;\n  }\n  return randomNumber(min, max);\n}\n\n// designed to give info to browser users, who are disturbed\n// when they see http errors in the console\nfunction explainError(status, str) {\n  guardedConsole('info', 'The above ' + status + ' is totally normal. ' + str);\n}\n\nvar assign;\n{\n  if (typeof Object.assign === 'function') {\n    assign = Object.assign;\n  } else {\n    // lite Object.assign polyfill based on\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n    assign = function (target) {\n      var to = Object(target);\n\n      for (var index = 1; index < arguments.length; index++) {\n        var nextSource = arguments[index];\n\n        if (nextSource != null) { // Skip over if undefined or null\n          for (var nextKey in nextSource) {\n            // Avoid bugs when hasOwnProperty is shadowed\n            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n              to[nextKey] = nextSource[nextKey];\n            }\n          }\n        }\n      }\n      return to;\n    };\n  }\n}\n\nvar $inject_Object_assign = assign;\n\ninherits(PouchError, Error);\n\nfunction PouchError(status, error, reason) {\n  Error.call(this, reason);\n  this.status = status;\n  this.name = error;\n  this.message = reason;\n  this.error = true;\n}\n\nPouchError.prototype.toString = function () {\n  return JSON.stringify({\n    status: this.status,\n    name: this.name,\n    message: this.message,\n    reason: this.reason\n  });\n};\n\nvar UNAUTHORIZED = new PouchError(401, 'unauthorized', \"Name or password is incorrect.\");\nvar MISSING_BULK_DOCS = new PouchError(400, 'bad_request', \"Missing JSON list of 'docs'\");\nvar MISSING_DOC = new PouchError(404, 'not_found', 'missing');\nvar REV_CONFLICT = new PouchError(409, 'conflict', 'Document update conflict');\nvar INVALID_ID = new PouchError(400, 'bad_request', '_id field must contain a string');\nvar MISSING_ID = new PouchError(412, 'missing_id', '_id is required for puts');\nvar RESERVED_ID = new PouchError(400, 'bad_request', 'Only reserved document ids may start with underscore.');\nvar NOT_OPEN = new PouchError(412, 'precondition_failed', 'Database not open');\nvar UNKNOWN_ERROR = new PouchError(500, 'unknown_error', 'Database encountered an unknown error');\nvar BAD_ARG = new PouchError(500, 'badarg', 'Some query argument is invalid');\nvar INVALID_REQUEST = new PouchError(400, 'invalid_request', 'Request was invalid');\nvar QUERY_PARSE_ERROR = new PouchError(400, 'query_parse_error', 'Some query parameter is invalid');\nvar DOC_VALIDATION = new PouchError(500, 'doc_validation', 'Bad special document member');\nvar BAD_REQUEST = new PouchError(400, 'bad_request', 'Something wrong with the request');\nvar NOT_AN_OBJECT = new PouchError(400, 'bad_request', 'Document must be a JSON object');\nvar DB_MISSING = new PouchError(404, 'not_found', 'Database not found');\nvar IDB_ERROR = new PouchError(500, 'indexed_db_went_bad', 'unknown');\nvar WSQ_ERROR = new PouchError(500, 'web_sql_went_bad', 'unknown');\nvar LDB_ERROR = new PouchError(500, 'levelDB_went_went_bad', 'unknown');\nvar FORBIDDEN = new PouchError(403, 'forbidden', 'Forbidden by design doc validate_doc_update function');\nvar INVALID_REV = new PouchError(400, 'bad_request', 'Invalid rev format');\nvar FILE_EXISTS = new PouchError(412, 'file_exists', 'The database could not be created, the file already exists.');\nvar MISSING_STUB = new PouchError(412, 'missing_stub', 'A pre-existing attachment stub wasn\\'t found');\nvar INVALID_URL = new PouchError(413, 'invalid_url', 'Provided URL is invalid');\n\nfunction createError(error, reason) {\n  function CustomPouchError(reason) {\n    // inherit error properties from our parent error manually\n    // so as to allow proper JSON parsing.\n    /* jshint ignore:start */\n    for (var p in error) {\n      if (typeof error[p] !== 'function') {\n        this[p] = error[p];\n      }\n    }\n    /* jshint ignore:end */\n    if (reason !== undefined) {\n      this.reason = reason;\n    }\n  }\n  CustomPouchError.prototype = PouchError.prototype;\n  return new CustomPouchError(reason);\n}\n\nfunction generateErrorFromResponse(err) {\n\n  if (typeof err !== 'object') {\n    var data = err;\n    err = UNKNOWN_ERROR;\n    err.data = data;\n  }\n\n  if ('error' in err && err.error === 'conflict') {\n    err.name = 'conflict';\n    err.status = 409;\n  }\n\n  if (!('name' in err)) {\n    err.name = err.error || 'unknown';\n  }\n\n  if (!('status' in err)) {\n    err.status = 500;\n  }\n\n  if (!('message' in err)) {\n    err.message = err.message || err.reason;\n  }\n\n  return err;\n}\n\nfunction tryFilter(filter, doc, req) {\n  try {\n    return !filter(doc, req);\n  } catch (err) {\n    var msg = 'Filter function threw: ' + err.toString();\n    return createError(BAD_REQUEST, msg);\n  }\n}\n\nfunction filterChange(opts) {\n  var req = {};\n  var hasFilter = opts.filter && typeof opts.filter === 'function';\n  req.query = opts.query_params;\n\n  return function filter(change) {\n    if (!change.doc) {\n      // CSG sends events on the changes feed that don't have documents,\n      // this hack makes a whole lot of existing code robust.\n      change.doc = {};\n    }\n\n    var filterReturn = hasFilter && tryFilter(opts.filter, change.doc, req);\n\n    if (typeof filterReturn === 'object') {\n      return filterReturn;\n    }\n\n    if (filterReturn) {\n      return false;\n    }\n\n    if (!opts.include_docs) {\n      delete change.doc;\n    } else if (!opts.attachments) {\n      for (var att in change.doc._attachments) {\n        /* istanbul ignore else */\n        if (change.doc._attachments.hasOwnProperty(att)) {\n          change.doc._attachments[att].stub = true;\n        }\n      }\n    }\n    return true;\n  };\n}\n\nfunction flatten(arrs) {\n  var res = [];\n  for (var i = 0, len = arrs.length; i < len; i++) {\n    res = res.concat(arrs[i]);\n  }\n  return res;\n}\n\n// shim for Function.prototype.name,\n// for browsers that don't support it like IE\n\n/* istanbul ignore next */\nfunction f() {}\n\nvar hasName = f.name;\nvar res;\n\n// We dont run coverage in IE\n/* istanbul ignore else */\nif (hasName) {\n  res = function (fun) {\n    return fun.name;\n  };\n} else {\n  res = function (fun) {\n    return fun.toString().match(/^\\s*function\\s*(\\S*)\\s*\\(/)[1];\n  };\n}\n\n// Determine id an ID is valid\n//   - invalid IDs begin with an underescore that does not begin '_design' or\n//     '_local'\n//   - any other string value is a valid id\n// Returns the specific error object for each case\nfunction invalidIdError(id) {\n  var err;\n  if (!id) {\n    err = createError(MISSING_ID);\n  } else if (typeof id !== 'string') {\n    err = createError(INVALID_ID);\n  } else if (/^_/.test(id) && !(/^_(design|local)/).test(id)) {\n    err = createError(RESERVED_ID);\n  }\n  if (err) {\n    throw err;\n  }\n}\n\n// Checks if a PouchDB object is \"remote\" or not. This is\n// designed to opt-in to certain optimizations, such as\n// avoiding checks for \"dependentDbs\" and other things that\n// we know only apply to local databases. In general, \"remote\"\n// should be true for the http adapter, and for third-party\n// adapters with similar expensive boundaries to cross for\n// every API call, such as socket-pouch and worker-pouch.\n// Previously, this was handled via db.type() === 'http'\n// which is now deprecated.\n\nfunction isRemote(db) {\n  if (typeof db._remote === 'boolean') {\n    return db._remote;\n  }\n  /* istanbul ignore next */\n  if (typeof db.type === 'function') {\n    guardedConsole('warn',\n      'db.type() is deprecated and will be removed in ' +\n      'a future version of PouchDB');\n    return db.type() === 'http';\n  }\n  /* istanbul ignore next */\n  return false;\n}\n\nfunction listenerCount(ee, type) {\n  return 'listenerCount' in ee ? ee.listenerCount(type) :\n                                 EventEmitter.listenerCount(ee, type);\n}\n\nfunction parseDesignDocFunctionName(s) {\n  if (!s) {\n    return null;\n  }\n  var parts = s.split('/');\n  if (parts.length === 2) {\n    return parts;\n  }\n  if (parts.length === 1) {\n    return [s, s];\n  }\n  return null;\n}\n\nfunction normalizeDesignDocFunctionName(s) {\n  var normalized = parseDesignDocFunctionName(s);\n  return normalized ? normalized.join('/') : null;\n}\n\n// originally parseUri 1.2.2, now patched by us\n// (c) Steven Levithan <stevenlevithan.com>\n// MIT License\nvar keys = [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\",\n    \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"];\nvar qName =\"queryKey\";\nvar qParser = /(?:^|&)([^&=]*)=?([^&]*)/g;\n\n// use the \"loose\" parser\n/* eslint maxlen: 0, no-useless-escape: 0 */\nvar parser = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\nfunction parseUri(str) {\n  var m = parser.exec(str);\n  var uri = {};\n  var i = 14;\n\n  while (i--) {\n    var key = keys[i];\n    var value = m[i] || \"\";\n    var encoded = ['user', 'password'].indexOf(key) !== -1;\n    uri[key] = encoded ? decodeURIComponent(value) : value;\n  }\n\n  uri[qName] = {};\n  uri[keys[12]].replace(qParser, function ($0, $1, $2) {\n    if ($1) {\n      uri[qName][$1] = $2;\n    }\n  });\n\n  return uri;\n}\n\n// Based on https://github.com/alexdavid/scope-eval v0.0.3\n// (source: https://unpkg.com/scope-eval@0.0.3/scope_eval.js)\n// This is basically just a wrapper around new Function()\n\nfunction scopeEval(source, scope) {\n  var keys = [];\n  var values = [];\n  for (var key in scope) {\n    if (scope.hasOwnProperty(key)) {\n      keys.push(key);\n      values.push(scope[key]);\n    }\n  }\n  keys.push(source);\n  return Function.apply(null, keys).apply(null, values);\n}\n\n// this is essentially the \"update sugar\" function from daleharvey/pouchdb#1388\n// the diffFun tells us what delta to apply to the doc.  it either returns\n// the doc, or false if it doesn't need to do an update after all\nfunction upsert(db, docId, diffFun) {\n  return new PouchPromise$1(function (fulfill, reject) {\n    db.get(docId, function (err, doc) {\n      if (err) {\n        /* istanbul ignore next */\n        if (err.status !== 404) {\n          return reject(err);\n        }\n        doc = {};\n      }\n\n      // the user might change the _rev, so save it for posterity\n      var docRev = doc._rev;\n      var newDoc = diffFun(doc);\n\n      if (!newDoc) {\n        // if the diffFun returns falsy, we short-circuit as\n        // an optimization\n        return fulfill({updated: false, rev: docRev});\n      }\n\n      // users aren't allowed to modify these values,\n      // so reset them here\n      newDoc._id = docId;\n      newDoc._rev = docRev;\n      fulfill(tryAndPut(db, newDoc, diffFun));\n    });\n  });\n}\n\nfunction tryAndPut(db, doc, diffFun) {\n  return db.put(doc).then(function (res) {\n    return {\n      updated: true,\n      rev: res.rev\n    };\n  }, function (err) {\n    /* istanbul ignore next */\n    if (err.status !== 409) {\n      throw err;\n    }\n    return upsert(db, doc._id, diffFun);\n  });\n}\n\nfunction rev() {\n  return uuidV4.v4().replace(/-/g, '').toLowerCase();\n}\n\nvar uuid = uuidV4.v4;\n\n// We fetch all leafs of the revision tree, and sort them based on tree length\n// and whether they were deleted, undeleted documents with the longest revision\n// tree (most edits) win\n// The final sort algorithm is slightly documented in a sidebar here:\n// http://guide.couchdb.org/draft/conflicts.html\nfunction winningRev(metadata) {\n  var winningId;\n  var winningPos;\n  var winningDeleted;\n  var toVisit = metadata.rev_tree.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var tree = node.ids;\n    var branches = tree[2];\n    var pos = node.pos;\n    if (branches.length) { // non-leaf\n      for (var i = 0, len = branches.length; i < len; i++) {\n        toVisit.push({pos: pos + 1, ids: branches[i]});\n      }\n      continue;\n    }\n    var deleted = !!tree[1].deleted;\n    var id = tree[0];\n    // sort by deleted, then pos, then id\n    if (!winningId || (winningDeleted !== deleted ? winningDeleted :\n        winningPos !== pos ? winningPos < pos : winningId < id)) {\n      winningId = id;\n      winningPos = pos;\n      winningDeleted = deleted;\n    }\n  }\n\n  return winningPos + '-' + winningId;\n}\n\n// Pretty much all below can be combined into a higher order function to\n// traverse revisions\n// The return value from the callback will be passed as context to all\n// children of that node\nfunction traverseRevTree(revs, callback) {\n  var toVisit = revs.slice();\n\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var branches = tree[2];\n    var newCtx =\n      callback(branches.length === 0, pos, tree[0], node.ctx, tree[1]);\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: pos + 1, ids: branches[i], ctx: newCtx});\n    }\n  }\n}\n\nfunction sortByPos(a, b) {\n  return a.pos - b.pos;\n}\n\nfunction collectLeaves(revs) {\n  var leaves = [];\n  traverseRevTree(revs, function (isLeaf, pos, id, acc, opts) {\n    if (isLeaf) {\n      leaves.push({rev: pos + \"-\" + id, pos: pos, opts: opts});\n    }\n  });\n  leaves.sort(sortByPos).reverse();\n  for (var i = 0, len = leaves.length; i < len; i++) {\n    delete leaves[i].pos;\n  }\n  return leaves;\n}\n\n// returns revs of all conflicts that is leaves such that\n// 1. are not deleted and\n// 2. are different than winning revision\nfunction collectConflicts(metadata) {\n  var win = winningRev(metadata);\n  var leaves = collectLeaves(metadata.rev_tree);\n  var conflicts = [];\n  for (var i = 0, len = leaves.length; i < len; i++) {\n    var leaf = leaves[i];\n    if (leaf.rev !== win && !leaf.opts.deleted) {\n      conflicts.push(leaf.rev);\n    }\n  }\n  return conflicts;\n}\n\n// compact a tree by marking its non-leafs as missing,\n// and return a list of revs to delete\nfunction compactTree(metadata) {\n  var revs = [];\n  traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n                                               revHash, ctx, opts) {\n    if (opts.status === 'available' && !isLeaf) {\n      revs.push(pos + '-' + revHash);\n      opts.status = 'missing';\n    }\n  });\n  return revs;\n}\n\n// build up a list of all the paths to the leafs in this revision tree\nfunction rootToLeaf(revs) {\n  var paths = [];\n  var toVisit = revs.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var id = tree[0];\n    var opts = tree[1];\n    var branches = tree[2];\n    var isLeaf = branches.length === 0;\n\n    var history = node.history ? node.history.slice() : [];\n    history.push({id: id, opts: opts});\n    if (isLeaf) {\n      paths.push({pos: (pos + 1 - history.length), ids: history});\n    }\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: pos + 1, ids: branches[i], history: history});\n    }\n  }\n  return paths.reverse();\n}\n\n// for a better overview of what this is doing, read:\n// https://github.com/apache/couchdb-couch/blob/master/src/couch_key_tree.erl\n//\n// But for a quick intro, CouchDB uses a revision tree to store a documents\n// history, A -> B -> C, when a document has conflicts, that is a branch in the\n// tree, A -> (B1 | B2 -> C), We store these as a nested array in the format\n//\n// KeyTree = [Path ... ]\n// Path = {pos: position_from_root, ids: Tree}\n// Tree = [Key, Opts, [Tree, ...]], in particular single node: [Key, []]\n\nfunction sortByPos$1(a, b) {\n  return a.pos - b.pos;\n}\n\n// classic binary search\nfunction binarySearch(arr, item, comparator) {\n  var low = 0;\n  var high = arr.length;\n  var mid;\n  while (low < high) {\n    mid = (low + high) >>> 1;\n    if (comparator(arr[mid], item) < 0) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  return low;\n}\n\n// assuming the arr is sorted, insert the item in the proper place\nfunction insertSorted(arr, item, comparator) {\n  var idx = binarySearch(arr, item, comparator);\n  arr.splice(idx, 0, item);\n}\n\n// Turn a path as a flat array into a tree with a single branch.\n// If any should be stemmed from the beginning of the array, that's passed\n// in as the second argument\nfunction pathToTree(path, numStemmed) {\n  var root;\n  var leaf;\n  for (var i = numStemmed, len = path.length; i < len; i++) {\n    var node = path[i];\n    var currentLeaf = [node.id, node.opts, []];\n    if (leaf) {\n      leaf[2].push(currentLeaf);\n      leaf = currentLeaf;\n    } else {\n      root = leaf = currentLeaf;\n    }\n  }\n  return root;\n}\n\n// compare the IDs of two trees\nfunction compareTree(a, b) {\n  return a[0] < b[0] ? -1 : 1;\n}\n\n// Merge two trees together\n// The roots of tree1 and tree2 must be the same revision\nfunction mergeTree(in_tree1, in_tree2) {\n  var queue = [{tree1: in_tree1, tree2: in_tree2}];\n  var conflicts = false;\n  while (queue.length > 0) {\n    var item = queue.pop();\n    var tree1 = item.tree1;\n    var tree2 = item.tree2;\n\n    if (tree1[1].status || tree2[1].status) {\n      tree1[1].status =\n        (tree1[1].status ===  'available' ||\n        tree2[1].status === 'available') ? 'available' : 'missing';\n    }\n\n    for (var i = 0; i < tree2[2].length; i++) {\n      if (!tree1[2][0]) {\n        conflicts = 'new_leaf';\n        tree1[2][0] = tree2[2][i];\n        continue;\n      }\n\n      var merged = false;\n      for (var j = 0; j < tree1[2].length; j++) {\n        if (tree1[2][j][0] === tree2[2][i][0]) {\n          queue.push({tree1: tree1[2][j], tree2: tree2[2][i]});\n          merged = true;\n        }\n      }\n      if (!merged) {\n        conflicts = 'new_branch';\n        insertSorted(tree1[2], tree2[2][i], compareTree);\n      }\n    }\n  }\n  return {conflicts: conflicts, tree: in_tree1};\n}\n\nfunction doMerge(tree, path, dontExpand) {\n  var restree = [];\n  var conflicts = false;\n  var merged = false;\n  var res;\n\n  if (!tree.length) {\n    return {tree: [path], conflicts: 'new_leaf'};\n  }\n\n  for (var i = 0, len = tree.length; i < len; i++) {\n    var branch = tree[i];\n    if (branch.pos === path.pos && branch.ids[0] === path.ids[0]) {\n      // Paths start at the same position and have the same root, so they need\n      // merged\n      res = mergeTree(branch.ids, path.ids);\n      restree.push({pos: branch.pos, ids: res.tree});\n      conflicts = conflicts || res.conflicts;\n      merged = true;\n    } else if (dontExpand !== true) {\n      // The paths start at a different position, take the earliest path and\n      // traverse up until it as at the same point from root as the path we\n      // want to merge.  If the keys match we return the longer path with the\n      // other merged After stemming we dont want to expand the trees\n\n      var t1 = branch.pos < path.pos ? branch : path;\n      var t2 = branch.pos < path.pos ? path : branch;\n      var diff = t2.pos - t1.pos;\n\n      var candidateParents = [];\n\n      var trees = [];\n      trees.push({ids: t1.ids, diff: diff, parent: null, parentIdx: null});\n      while (trees.length > 0) {\n        var item = trees.pop();\n        if (item.diff === 0) {\n          if (item.ids[0] === t2.ids[0]) {\n            candidateParents.push(item);\n          }\n          continue;\n        }\n        var elements = item.ids[2];\n        for (var j = 0, elementsLen = elements.length; j < elementsLen; j++) {\n          trees.push({\n            ids: elements[j],\n            diff: item.diff - 1,\n            parent: item.ids,\n            parentIdx: j\n          });\n        }\n      }\n\n      var el = candidateParents[0];\n\n      if (!el) {\n        restree.push(branch);\n      } else {\n        res = mergeTree(el.ids, t2.ids);\n        el.parent[2][el.parentIdx] = res.tree;\n        restree.push({pos: t1.pos, ids: t1.ids});\n        conflicts = conflicts || res.conflicts;\n        merged = true;\n      }\n    } else {\n      restree.push(branch);\n    }\n  }\n\n  // We didnt find\n  if (!merged) {\n    restree.push(path);\n  }\n\n  restree.sort(sortByPos$1);\n\n  return {\n    tree: restree,\n    conflicts: conflicts || 'internal_node'\n  };\n}\n\n// To ensure we dont grow the revision tree infinitely, we stem old revisions\nfunction stem(tree, depth) {\n  // First we break out the tree into a complete list of root to leaf paths\n  var paths = rootToLeaf(tree);\n  var stemmedRevs;\n\n  var result;\n  for (var i = 0, len = paths.length; i < len; i++) {\n    // Then for each path, we cut off the start of the path based on the\n    // `depth` to stem to, and generate a new set of flat trees\n    var path = paths[i];\n    var stemmed = path.ids;\n    var node;\n    if (stemmed.length > depth) {\n      // only do the stemming work if we actually need to stem\n      if (!stemmedRevs) {\n        stemmedRevs = {}; // avoid allocating this object unnecessarily\n      }\n      var numStemmed = stemmed.length - depth;\n      node = {\n        pos: path.pos + numStemmed,\n        ids: pathToTree(stemmed, numStemmed)\n      };\n\n      for (var s = 0; s < numStemmed; s++) {\n        var rev = (path.pos + s) + '-' + stemmed[s].id;\n        stemmedRevs[rev] = true;\n      }\n    } else { // no need to actually stem\n      node = {\n        pos: path.pos,\n        ids: pathToTree(stemmed, 0)\n      };\n    }\n\n    // Then we remerge all those flat trees together, ensuring that we dont\n    // connect trees that would go beyond the depth limit\n    if (result) {\n      result = doMerge(result, node, true).tree;\n    } else {\n      result = [node];\n    }\n  }\n\n  // this is memory-heavy per Chrome profiler, avoid unless we actually stemmed\n  if (stemmedRevs) {\n    traverseRevTree(result, function (isLeaf, pos, revHash) {\n      // some revisions may have been removed in a branch but not in another\n      delete stemmedRevs[pos + '-' + revHash];\n    });\n  }\n\n  return {\n    tree: result,\n    revs: stemmedRevs ? Object.keys(stemmedRevs) : []\n  };\n}\n\nfunction merge(tree, path, depth) {\n  var newTree = doMerge(tree, path);\n  var stemmed = stem(newTree.tree, depth);\n  return {\n    tree: stemmed.tree,\n    stemmedRevs: stemmed.revs,\n    conflicts: newTree.conflicts\n  };\n}\n\n// return true if a rev exists in the rev tree, false otherwise\nfunction revExists(revs, rev) {\n  var toVisit = revs.slice();\n  var splitRev = rev.split('-');\n  var targetPos = parseInt(splitRev[0], 10);\n  var targetId = splitRev[1];\n\n  var node;\n  while ((node = toVisit.pop())) {\n    if (node.pos === targetPos && node.ids[0] === targetId) {\n      return true;\n    }\n    var branches = node.ids[2];\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: node.pos + 1, ids: branches[i]});\n    }\n  }\n  return false;\n}\n\nfunction getTrees(node) {\n  return node.ids;\n}\n\n// check if a specific revision of a doc has been deleted\n//  - metadata: the metadata object from the doc store\n//  - rev: (optional) the revision to check. defaults to winning revision\nfunction isDeleted(metadata, rev) {\n  if (!rev) {\n    rev = winningRev(metadata);\n  }\n  var id = rev.substring(rev.indexOf('-') + 1);\n  var toVisit = metadata.rev_tree.map(getTrees);\n\n  var tree;\n  while ((tree = toVisit.pop())) {\n    if (tree[0] === id) {\n      return !!tree[1].deleted;\n    }\n    toVisit = toVisit.concat(tree[2]);\n  }\n}\n\nfunction isLocalId(id) {\n  return (/^_local/).test(id);\n}\n\n// returns the current leaf node for a given revision\nfunction latest(rev, metadata) {\n  var toVisit = metadata.rev_tree.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var id = tree[0];\n    var opts = tree[1];\n    var branches = tree[2];\n    var isLeaf = branches.length === 0;\n\n    var history = node.history ? node.history.slice() : [];\n    history.push({id: id, pos: pos, opts: opts});\n\n    if (isLeaf) {\n      for (var i = 0, len = history.length; i < len; i++) {\n        var historyNode = history[i];\n        var historyRev = historyNode.pos + '-' + historyNode.id;\n\n        if (historyRev === rev) {\n          // return the rev of this leaf\n          return pos + '-' + id;\n        }\n      }\n    }\n\n    for (var j = 0, l = branches.length; j < l; j++) {\n      toVisit.push({pos: pos + 1, ids: branches[j], history: history});\n    }\n  }\n\n  /* istanbul ignore next */\n  throw new Error('Unable to resolve latest revision for id ' + metadata.id + ', rev ' + rev);\n}\n\ninherits(Changes$2, EventEmitter);\n\nfunction tryCatchInChangeListener(self, change) {\n  // isolate try/catches to avoid V8 deoptimizations\n  try {\n    self.emit('change', change);\n  } catch (e) {\n    guardedConsole('error', 'Error in .on(\"change\", function):', e);\n  }\n}\n\nfunction Changes$2(db, opts, callback) {\n  EventEmitter.call(this);\n  var self = this;\n  this.db = db;\n  opts = opts ? clone(opts) : {};\n  var complete = opts.complete = once(function (err, resp) {\n    if (err) {\n      if (listenerCount(self, 'error') > 0) {\n        self.emit('error', err);\n      }\n    } else {\n      self.emit('complete', resp);\n    }\n    self.removeAllListeners();\n    db.removeListener('destroyed', onDestroy);\n  });\n  if (callback) {\n    self.on('complete', function (resp) {\n      callback(null, resp);\n    });\n    self.on('error', callback);\n  }\n  function onDestroy() {\n    self.cancel();\n  }\n  db.once('destroyed', onDestroy);\n\n  opts.onChange = function (change) {\n    /* istanbul ignore if */\n    if (self.isCancelled) {\n      return;\n    }\n    tryCatchInChangeListener(self, change);\n  };\n\n  var promise = new PouchPromise$1(function (fulfill, reject) {\n    opts.complete = function (err, res) {\n      if (err) {\n        reject(err);\n      } else {\n        fulfill(res);\n      }\n    };\n  });\n  self.once('cancel', function () {\n    db.removeListener('destroyed', onDestroy);\n    opts.complete(null, {status: 'cancelled'});\n  });\n  this.then = promise.then.bind(promise);\n  this['catch'] = promise['catch'].bind(promise);\n  this.then(function (result) {\n    complete(null, result);\n  }, complete);\n\n\n\n  if (!db.taskqueue.isReady) {\n    db.taskqueue.addTask(function (failed) {\n      if (failed) {\n        opts.complete(failed);\n      } else if (self.isCancelled) {\n        self.emit('cancel');\n      } else {\n        self.validateChanges(opts);\n      }\n    });\n  } else {\n    self.validateChanges(opts);\n  }\n}\nChanges$2.prototype.cancel = function () {\n  this.isCancelled = true;\n  if (this.db.taskqueue.isReady) {\n    this.emit('cancel');\n  }\n};\nfunction processChange(doc, metadata, opts) {\n  var changeList = [{rev: doc._rev}];\n  if (opts.style === 'all_docs') {\n    changeList = collectLeaves(metadata.rev_tree)\n    .map(function (x) { return {rev: x.rev}; });\n  }\n  var change = {\n    id: metadata.id,\n    changes: changeList,\n    doc: doc\n  };\n\n  if (isDeleted(metadata, doc._rev)) {\n    change.deleted = true;\n  }\n  if (opts.conflicts) {\n    change.doc._conflicts = collectConflicts(metadata);\n    if (!change.doc._conflicts.length) {\n      delete change.doc._conflicts;\n    }\n  }\n  return change;\n}\n\nChanges$2.prototype.validateChanges = function (opts) {\n  var callback = opts.complete;\n  var self = this;\n\n  /* istanbul ignore else */\n  if (PouchDB$5._changesFilterPlugin) {\n    PouchDB$5._changesFilterPlugin.validate(opts, function (err) {\n      if (err) {\n        return callback(err);\n      }\n      self.doChanges(opts);\n    });\n  } else {\n    self.doChanges(opts);\n  }\n};\n\nChanges$2.prototype.doChanges = function (opts) {\n  var self = this;\n  var callback = opts.complete;\n\n  opts = clone(opts);\n  if ('live' in opts && !('continuous' in opts)) {\n    opts.continuous = opts.live;\n  }\n  opts.processChange = processChange;\n\n  if (opts.since === 'latest') {\n    opts.since = 'now';\n  }\n  if (!opts.since) {\n    opts.since = 0;\n  }\n  if (opts.since === 'now') {\n    this.db.info().then(function (info) {\n      /* istanbul ignore if */\n      if (self.isCancelled) {\n        callback(null, {status: 'cancelled'});\n        return;\n      }\n      opts.since = info.update_seq;\n      self.doChanges(opts);\n    }, callback);\n    return;\n  }\n\n  /* istanbul ignore else */\n  if (PouchDB$5._changesFilterPlugin) {\n    PouchDB$5._changesFilterPlugin.normalize(opts);\n    if (PouchDB$5._changesFilterPlugin.shouldFilter(this, opts)) {\n      return PouchDB$5._changesFilterPlugin.filter(this, opts);\n    }\n  } else {\n    ['doc_ids', 'filter', 'selector', 'view'].forEach(function (key) {\n      if (key in opts) {\n        guardedConsole('warn',\n          'The \"' + key + '\" option was passed in to changes/replicate, ' +\n          'but pouchdb-changes-filter plugin is not installed, so it ' +\n          'was ignored. Please install the plugin to enable filtering.'\n        );\n      }\n    });\n  }\n\n  if (!('descending' in opts)) {\n    opts.descending = false;\n  }\n\n  // 0 and 1 should return 1 document\n  opts.limit = opts.limit === 0 ? 1 : opts.limit;\n  opts.complete = callback;\n  var newPromise = this.db._changes(opts);\n  /* istanbul ignore else */\n  if (newPromise && typeof newPromise.cancel === 'function') {\n    var cancel = self.cancel;\n    self.cancel = getArguments(function (args) {\n      newPromise.cancel();\n      cancel.apply(this, args);\n    });\n  }\n};\n\n/*\n * A generic pouch adapter\n */\n\nfunction compare(left, right) {\n  return left < right ? -1 : left > right ? 1 : 0;\n}\n\n// Wrapper for functions that call the bulkdocs api with a single doc,\n// if the first result is an error, return an error\nfunction yankError(callback, docId) {\n  return function (err, results) {\n    if (err || (results[0] && results[0].error)) {\n      err = err || results[0];\n      err.docId = docId;\n      callback(err);\n    } else {\n      callback(null, results.length ? results[0]  : results);\n    }\n  };\n}\n\n// clean docs given to us by the user\nfunction cleanDocs(docs) {\n  for (var i = 0; i < docs.length; i++) {\n    var doc = docs[i];\n    if (doc._deleted) {\n      delete doc._attachments; // ignore atts for deleted docs\n    } else if (doc._attachments) {\n      // filter out extraneous keys from _attachments\n      var atts = Object.keys(doc._attachments);\n      for (var j = 0; j < atts.length; j++) {\n        var att = atts[j];\n        doc._attachments[att] = pick(doc._attachments[att],\n          ['data', 'digest', 'content_type', 'length', 'revpos', 'stub']);\n      }\n    }\n  }\n}\n\n// compare two docs, first by _id then by _rev\nfunction compareByIdThenRev(a, b) {\n  var idCompare = compare(a._id, b._id);\n  if (idCompare !== 0) {\n    return idCompare;\n  }\n  var aStart = a._revisions ? a._revisions.start : 0;\n  var bStart = b._revisions ? b._revisions.start : 0;\n  return compare(aStart, bStart);\n}\n\n// for every node in a revision tree computes its distance from the closest\n// leaf\nfunction computeHeight(revs) {\n  var height = {};\n  var edges = [];\n  traverseRevTree(revs, function (isLeaf, pos, id, prnt) {\n    var rev$$1 = pos + \"-\" + id;\n    if (isLeaf) {\n      height[rev$$1] = 0;\n    }\n    if (prnt !== undefined) {\n      edges.push({from: prnt, to: rev$$1});\n    }\n    return rev$$1;\n  });\n\n  edges.reverse();\n  edges.forEach(function (edge) {\n    if (height[edge.from] === undefined) {\n      height[edge.from] = 1 + height[edge.to];\n    } else {\n      height[edge.from] = Math.min(height[edge.from], 1 + height[edge.to]);\n    }\n  });\n  return height;\n}\n\nfunction allDocsKeysQuery(api, opts, callback) {\n  var keys =  ('limit' in opts) ?\n      opts.keys.slice(opts.skip, opts.limit + opts.skip) :\n      (opts.skip > 0) ? opts.keys.slice(opts.skip) : opts.keys;\n  if (opts.descending) {\n    keys.reverse();\n  }\n  if (!keys.length) {\n    return api._allDocs({limit: 0}, callback);\n  }\n  var finalResults = {\n    offset: opts.skip\n  };\n  return PouchPromise$1.all(keys.map(function (key) {\n    var subOpts = $inject_Object_assign({key: key, deleted: 'ok'}, opts);\n    ['limit', 'skip', 'keys'].forEach(function (optKey) {\n      delete subOpts[optKey];\n    });\n    return new PouchPromise$1(function (resolve, reject) {\n      api._allDocs(subOpts, function (err, res) {\n        /* istanbul ignore if */\n        if (err) {\n          return reject(err);\n        }\n        finalResults.total_rows = res.total_rows;\n        resolve(res.rows[0] || {key: key, error: 'not_found'});\n      });\n    });\n  })).then(function (results) {\n    finalResults.rows = results;\n    return finalResults;\n  });\n}\n\n// all compaction is done in a queue, to avoid attaching\n// too many listeners at once\nfunction doNextCompaction(self) {\n  var task = self._compactionQueue[0];\n  var opts = task.opts;\n  var callback = task.callback;\n  self.get('_local/compaction').catch(function () {\n    return false;\n  }).then(function (doc) {\n    if (doc && doc.last_seq) {\n      opts.last_seq = doc.last_seq;\n    }\n    self._compact(opts, function (err, res) {\n      /* istanbul ignore if */\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, res);\n      }\n      nextTick(function () {\n        self._compactionQueue.shift();\n        if (self._compactionQueue.length) {\n          doNextCompaction(self);\n        }\n      });\n    });\n  });\n}\n\nfunction attachmentNameError(name) {\n  if (name.charAt(0) === '_') {\n    return name + ' is not a valid attachment name, attachment ' +\n      'names cannot start with \\'_\\'';\n  }\n  return false;\n}\n\ninherits(AbstractPouchDB, EventEmitter);\n\nfunction AbstractPouchDB() {\n  EventEmitter.call(this);\n}\n\nAbstractPouchDB.prototype.post =\n  adapterFun('post', function (doc, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof doc !== 'object' || Array.isArray(doc)) {\n    return callback(createError(NOT_AN_OBJECT));\n  }\n  this.bulkDocs({docs: [doc]}, opts, yankError(callback, doc._id));\n});\n\nAbstractPouchDB.prototype.put = adapterFun('put', function (doc, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n  if (typeof doc !== 'object' || Array.isArray(doc)) {\n    return cb(createError(NOT_AN_OBJECT));\n  }\n  invalidIdError(doc._id);\n  if (isLocalId(doc._id) && typeof this._putLocal === 'function') {\n    if (doc._deleted) {\n      return this._removeLocal(doc, cb);\n    } else {\n      return this._putLocal(doc, cb);\n    }\n  }\n  var self = this;\n  if (opts.force && doc._rev) {\n    transformForceOptionToNewEditsOption();\n    putDoc(function (err) {\n      var result = err ? null : {ok: true, id: doc._id, rev: doc._rev};\n      cb(err, result);\n    });\n  } else {\n    putDoc(cb);\n  }\n\n  function transformForceOptionToNewEditsOption() {\n    var parts = doc._rev.split('-');\n    var oldRevId = parts[1];\n    var oldRevNum = parseInt(parts[0], 10);\n\n    var newRevNum = oldRevNum + 1;\n    var newRevId = rev();\n\n    doc._revisions = {\n      start: newRevNum,\n      ids: [newRevId, oldRevId]\n    };\n    doc._rev = newRevNum + '-' + newRevId;\n    opts.new_edits = false;\n  }\n  function putDoc(next) {\n    if (typeof self._put === 'function' && opts.new_edits !== false) {\n      self._put(doc, opts, next);\n    } else {\n      self.bulkDocs({docs: [doc]}, opts, yankError(next, doc._id));\n    }\n  }\n});\n\nAbstractPouchDB.prototype.putAttachment =\n  adapterFun('putAttachment', function (docId, attachmentId, rev$$1,\n                                              blob, type) {\n  var api = this;\n  if (typeof type === 'function') {\n    type = blob;\n    blob = rev$$1;\n    rev$$1 = null;\n  }\n  // Lets fix in https://github.com/pouchdb/pouchdb/issues/3267\n  /* istanbul ignore if */\n  if (typeof type === 'undefined') {\n    type = blob;\n    blob = rev$$1;\n    rev$$1 = null;\n  }\n  if (!type) {\n    guardedConsole('warn', 'Attachment', attachmentId, 'on document', docId, 'is missing content_type');\n  }\n\n  function createAttachment(doc) {\n    var prevrevpos = '_rev' in doc ? parseInt(doc._rev, 10) : 0;\n    doc._attachments = doc._attachments || {};\n    doc._attachments[attachmentId] = {\n      content_type: type,\n      data: blob,\n      revpos: ++prevrevpos\n    };\n    return api.put(doc);\n  }\n\n  return api.get(docId).then(function (doc) {\n    if (doc._rev !== rev$$1) {\n      throw createError(REV_CONFLICT);\n    }\n\n    return createAttachment(doc);\n  }, function (err) {\n     // create new doc\n    /* istanbul ignore else */\n    if (err.reason === MISSING_DOC.message) {\n      return createAttachment({_id: docId});\n    } else {\n      throw err;\n    }\n  });\n});\n\nAbstractPouchDB.prototype.removeAttachment =\n  adapterFun('removeAttachment', function (docId, attachmentId, rev$$1,\n                                                 callback) {\n  var self = this;\n  self.get(docId, function (err, obj) {\n    /* istanbul ignore if */\n    if (err) {\n      callback(err);\n      return;\n    }\n    if (obj._rev !== rev$$1) {\n      callback(createError(REV_CONFLICT));\n      return;\n    }\n    /* istanbul ignore if */\n    if (!obj._attachments) {\n      return callback();\n    }\n    delete obj._attachments[attachmentId];\n    if (Object.keys(obj._attachments).length === 0) {\n      delete obj._attachments;\n    }\n    self.put(obj, callback);\n  });\n});\n\nAbstractPouchDB.prototype.remove =\n  adapterFun('remove', function (docOrId, optsOrRev, opts, callback) {\n  var doc;\n  if (typeof optsOrRev === 'string') {\n    // id, rev, opts, callback style\n    doc = {\n      _id: docOrId,\n      _rev: optsOrRev\n    };\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n  } else {\n    // doc, opts, callback style\n    doc = docOrId;\n    if (typeof optsOrRev === 'function') {\n      callback = optsOrRev;\n      opts = {};\n    } else {\n      callback = opts;\n      opts = optsOrRev;\n    }\n  }\n  opts = opts || {};\n  opts.was_delete = true;\n  var newDoc = {_id: doc._id, _rev: (doc._rev || opts.rev)};\n  newDoc._deleted = true;\n  if (isLocalId(newDoc._id) && typeof this._removeLocal === 'function') {\n    return this._removeLocal(doc, callback);\n  }\n  this.bulkDocs({docs: [newDoc]}, opts, yankError(callback, newDoc._id));\n});\n\nAbstractPouchDB.prototype.revsDiff =\n  adapterFun('revsDiff', function (req, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  var ids = Object.keys(req);\n\n  if (!ids.length) {\n    return callback(null, {});\n  }\n\n  var count = 0;\n  var missing = new ExportedMap();\n\n  function addToMissing(id, revId) {\n    if (!missing.has(id)) {\n      missing.set(id, {missing: []});\n    }\n    missing.get(id).missing.push(revId);\n  }\n\n  function processDoc(id, rev_tree) {\n    // Is this fast enough? Maybe we should switch to a set simulated by a map\n    var missingForId = req[id].slice(0);\n    traverseRevTree(rev_tree, function (isLeaf, pos, revHash, ctx,\n      opts) {\n        var rev$$1 = pos + '-' + revHash;\n        var idx = missingForId.indexOf(rev$$1);\n        if (idx === -1) {\n          return;\n        }\n\n        missingForId.splice(idx, 1);\n        /* istanbul ignore if */\n        if (opts.status !== 'available') {\n          addToMissing(id, rev$$1);\n        }\n      });\n\n    // Traversing the tree is synchronous, so now `missingForId` contains\n    // revisions that were not found in the tree\n    missingForId.forEach(function (rev$$1) {\n      addToMissing(id, rev$$1);\n    });\n  }\n\n  ids.map(function (id) {\n    this._getRevisionTree(id, function (err, rev_tree) {\n      if (err && err.status === 404 && err.message === 'missing') {\n        missing.set(id, {missing: req[id]});\n      } else if (err) {\n        /* istanbul ignore next */\n        return callback(err);\n      } else {\n        processDoc(id, rev_tree);\n      }\n\n      if (++count === ids.length) {\n        // convert LazyMap to object\n        var missingObj = {};\n        missing.forEach(function (value, key) {\n          missingObj[key] = value;\n        });\n        return callback(null, missingObj);\n      }\n    });\n  }, this);\n});\n\n// _bulk_get API for faster replication, as described in\n// https://github.com/apache/couchdb-chttpd/pull/33\n// At the \"abstract\" level, it will just run multiple get()s in\n// parallel, because this isn't much of a performance cost\n// for local databases (except the cost of multiple transactions, which is\n// small). The http adapter overrides this in order\n// to do a more efficient single HTTP request.\nAbstractPouchDB.prototype.bulkGet =\n  adapterFun('bulkGet', function (opts, callback) {\n  bulkGet(this, opts, callback);\n});\n\n// compact one document and fire callback\n// by compacting we mean removing all revisions which\n// are further from the leaf in revision tree than max_height\nAbstractPouchDB.prototype.compactDocument =\n  adapterFun('compactDocument', function (docId, maxHeight, callback) {\n  var self = this;\n  this._getRevisionTree(docId, function (err, revTree) {\n    /* istanbul ignore if */\n    if (err) {\n      return callback(err);\n    }\n    var height = computeHeight(revTree);\n    var candidates = [];\n    var revs = [];\n    Object.keys(height).forEach(function (rev$$1) {\n      if (height[rev$$1] > maxHeight) {\n        candidates.push(rev$$1);\n      }\n    });\n\n    traverseRevTree(revTree, function (isLeaf, pos, revHash, ctx, opts) {\n      var rev$$1 = pos + '-' + revHash;\n      if (opts.status === 'available' && candidates.indexOf(rev$$1) !== -1) {\n        revs.push(rev$$1);\n      }\n    });\n    self._doCompaction(docId, revs, callback);\n  });\n});\n\n// compact the whole database using single document\n// compaction\nAbstractPouchDB.prototype.compact =\n  adapterFun('compact', function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  var self = this;\n  opts = opts || {};\n\n  self._compactionQueue = self._compactionQueue || [];\n  self._compactionQueue.push({opts: opts, callback: callback});\n  if (self._compactionQueue.length === 1) {\n    doNextCompaction(self);\n  }\n});\nAbstractPouchDB.prototype._compact = function (opts, callback) {\n  var self = this;\n  var changesOpts = {\n    return_docs: false,\n    last_seq: opts.last_seq || 0\n  };\n  var promises = [];\n\n  function onChange(row) {\n    promises.push(self.compactDocument(row.id, 0));\n  }\n  function onComplete(resp) {\n    var lastSeq = resp.last_seq;\n    PouchPromise$1.all(promises).then(function () {\n      return upsert(self, '_local/compaction', function deltaFunc(doc) {\n        if (!doc.last_seq || doc.last_seq < lastSeq) {\n          doc.last_seq = lastSeq;\n          return doc;\n        }\n        return false; // somebody else got here first, don't update\n      });\n    }).then(function () {\n      callback(null, {ok: true});\n    }).catch(callback);\n  }\n  self.changes(changesOpts)\n    .on('change', onChange)\n    .on('complete', onComplete)\n    .on('error', callback);\n};\n\n/* Begin api wrappers. Specific functionality to storage belongs in the\n   _[method] */\nAbstractPouchDB.prototype.get = adapterFun('get', function (id, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n  if (typeof id !== 'string') {\n    return cb(createError(INVALID_ID));\n  }\n  if (isLocalId(id) && typeof this._getLocal === 'function') {\n    return this._getLocal(id, cb);\n  }\n  var leaves = [], self = this;\n\n  function finishOpenRevs() {\n    var result = [];\n    var count = leaves.length;\n    /* istanbul ignore if */\n    if (!count) {\n      return cb(null, result);\n    }\n\n    // order with open_revs is unspecified\n    leaves.forEach(function (leaf) {\n      self.get(id, {\n        rev: leaf,\n        revs: opts.revs,\n        latest: opts.latest,\n        attachments: opts.attachments\n      }, function (err, doc) {\n        if (!err) {\n          // using latest=true can produce duplicates\n          var existing;\n          for (var i = 0, l = result.length; i < l; i++) {\n            if (result[i].ok && result[i].ok._rev === doc._rev) {\n              existing = true;\n              break;\n            }\n          }\n          if (!existing) {\n            result.push({ok: doc});\n          }\n        } else {\n          result.push({missing: leaf});\n        }\n        count--;\n        if (!count) {\n          cb(null, result);\n        }\n      });\n    });\n  }\n\n  if (opts.open_revs) {\n    if (opts.open_revs === \"all\") {\n      this._getRevisionTree(id, function (err, rev_tree) {\n        if (err) {\n          return cb(err);\n        }\n        leaves = collectLeaves(rev_tree).map(function (leaf) {\n          return leaf.rev;\n        });\n        finishOpenRevs();\n      });\n    } else {\n      if (Array.isArray(opts.open_revs)) {\n        leaves = opts.open_revs;\n        for (var i = 0; i < leaves.length; i++) {\n          var l = leaves[i];\n          // looks like it's the only thing couchdb checks\n          if (!(typeof (l) === \"string\" && /^\\d+-/.test(l))) {\n            return cb(createError(INVALID_REV));\n          }\n        }\n        finishOpenRevs();\n      } else {\n        return cb(createError(UNKNOWN_ERROR, 'function_clause'));\n      }\n    }\n    return; // open_revs does not like other options\n  }\n\n  return this._get(id, opts, function (err, result) {\n    if (err) {\n      err.docId = id;\n      return cb(err);\n    }\n\n    var doc = result.doc;\n    var metadata = result.metadata;\n    var ctx = result.ctx;\n\n    if (opts.conflicts) {\n      var conflicts = collectConflicts(metadata);\n      if (conflicts.length) {\n        doc._conflicts = conflicts;\n      }\n    }\n\n    if (isDeleted(metadata, doc._rev)) {\n      doc._deleted = true;\n    }\n\n    if (opts.revs || opts.revs_info) {\n      var splittedRev = doc._rev.split('-');\n      var revNo       = parseInt(splittedRev[0], 10);\n      var revHash     = splittedRev[1];\n\n      var paths = rootToLeaf(metadata.rev_tree);\n      var path = null;\n\n      for (var i = 0; i < paths.length; i++) {\n        var currentPath = paths[i];\n        var hashIndex = currentPath.ids.map(function (x) { return x.id; })\n          .indexOf(revHash);\n        var hashFoundAtRevPos = hashIndex === (revNo - 1);\n\n        if (hashFoundAtRevPos || (!path && hashIndex !== -1)) {\n          path = currentPath;\n        }\n      }\n\n      var indexOfRev = path.ids.map(function (x) { return x.id; })\n        .indexOf(doc._rev.split('-')[1]) + 1;\n      var howMany = path.ids.length - indexOfRev;\n      path.ids.splice(indexOfRev, howMany);\n      path.ids.reverse();\n\n      if (opts.revs) {\n        doc._revisions = {\n          start: (path.pos + path.ids.length) - 1,\n          ids: path.ids.map(function (rev$$1) {\n            return rev$$1.id;\n          })\n        };\n      }\n      if (opts.revs_info) {\n        var pos =  path.pos + path.ids.length;\n        doc._revs_info = path.ids.map(function (rev$$1) {\n          pos--;\n          return {\n            rev: pos + '-' + rev$$1.id,\n            status: rev$$1.opts.status\n          };\n        });\n      }\n    }\n\n    if (opts.attachments && doc._attachments) {\n      var attachments = doc._attachments;\n      var count = Object.keys(attachments).length;\n      if (count === 0) {\n        return cb(null, doc);\n      }\n      Object.keys(attachments).forEach(function (key) {\n        this._getAttachment(doc._id, key, attachments[key], {\n          // Previously the revision handling was done in adapter.js\n          // getAttachment, however since idb-next doesnt we need to\n          // pass the rev through\n          rev: doc._rev,\n          binary: opts.binary,\n          ctx: ctx\n        }, function (err, data) {\n          var att = doc._attachments[key];\n          att.data = data;\n          delete att.stub;\n          delete att.length;\n          if (!--count) {\n            cb(null, doc);\n          }\n        });\n      }, self);\n    } else {\n      if (doc._attachments) {\n        for (var key in doc._attachments) {\n          /* istanbul ignore else */\n          if (doc._attachments.hasOwnProperty(key)) {\n            doc._attachments[key].stub = true;\n          }\n        }\n      }\n      cb(null, doc);\n    }\n  });\n});\n\n// TODO: I dont like this, it forces an extra read for every\n// attachment read and enforces a confusing api between\n// adapter.js and the adapter implementation\nAbstractPouchDB.prototype.getAttachment =\n  adapterFun('getAttachment', function (docId, attachmentId, opts, callback) {\n  var self = this;\n  if (opts instanceof Function) {\n    callback = opts;\n    opts = {};\n  }\n  this._get(docId, opts, function (err, res) {\n    if (err) {\n      return callback(err);\n    }\n    if (res.doc._attachments && res.doc._attachments[attachmentId]) {\n      opts.ctx = res.ctx;\n      opts.binary = true;\n      self._getAttachment(docId, attachmentId,\n                          res.doc._attachments[attachmentId], opts, callback);\n    } else {\n      return callback(createError(MISSING_DOC));\n    }\n  });\n});\n\nAbstractPouchDB.prototype.allDocs =\n  adapterFun('allDocs', function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  opts.skip = typeof opts.skip !== 'undefined' ? opts.skip : 0;\n  if (opts.start_key) {\n    opts.startkey = opts.start_key;\n  }\n  if (opts.end_key) {\n    opts.endkey = opts.end_key;\n  }\n  if ('keys' in opts) {\n    if (!Array.isArray(opts.keys)) {\n      return callback(new TypeError('options.keys must be an array'));\n    }\n    var incompatibleOpt =\n      ['startkey', 'endkey', 'key'].filter(function (incompatibleOpt) {\n      return incompatibleOpt in opts;\n    })[0];\n    if (incompatibleOpt) {\n      callback(createError(QUERY_PARSE_ERROR,\n        'Query parameter `' + incompatibleOpt +\n        '` is not compatible with multi-get'\n      ));\n      return;\n    }\n    if (!isRemote(this)) {\n      return allDocsKeysQuery(this, opts, callback);\n    }\n  }\n\n  return this._allDocs(opts, callback);\n});\n\nAbstractPouchDB.prototype.changes = function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return new Changes$2(this, opts, callback);\n};\n\nAbstractPouchDB.prototype.close = adapterFun('close', function (callback) {\n  this._closed = true;\n  this.emit('closed');\n  return this._close(callback);\n});\n\nAbstractPouchDB.prototype.info = adapterFun('info', function (callback) {\n  var self = this;\n  this._info(function (err, info) {\n    if (err) {\n      return callback(err);\n    }\n    // assume we know better than the adapter, unless it informs us\n    info.db_name = info.db_name || self.name;\n    info.auto_compaction = !!(self.auto_compaction && !isRemote(self));\n    info.adapter = self.adapter;\n    callback(null, info);\n  });\n});\n\nAbstractPouchDB.prototype.id = adapterFun('id', function (callback) {\n  return this._id(callback);\n});\n\n/* istanbul ignore next */\nAbstractPouchDB.prototype.type = function () {\n  return (typeof this._type === 'function') ? this._type() : this.adapter;\n};\n\nAbstractPouchDB.prototype.bulkDocs =\n  adapterFun('bulkDocs', function (req, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  opts = opts || {};\n\n  if (Array.isArray(req)) {\n    req = {\n      docs: req\n    };\n  }\n\n  if (!req || !req.docs || !Array.isArray(req.docs)) {\n    return callback(createError(MISSING_BULK_DOCS));\n  }\n\n  for (var i = 0; i < req.docs.length; ++i) {\n    if (typeof req.docs[i] !== 'object' || Array.isArray(req.docs[i])) {\n      return callback(createError(NOT_AN_OBJECT));\n    }\n  }\n\n  var attachmentError;\n  req.docs.forEach(function (doc) {\n    if (doc._attachments) {\n      Object.keys(doc._attachments).forEach(function (name) {\n        attachmentError = attachmentError || attachmentNameError(name);\n        if (!doc._attachments[name].content_type) {\n          guardedConsole('warn', 'Attachment', name, 'on document', doc._id, 'is missing content_type');\n        }\n      });\n    }\n  });\n\n  if (attachmentError) {\n    return callback(createError(BAD_REQUEST, attachmentError));\n  }\n\n  if (!('new_edits' in opts)) {\n    if ('new_edits' in req) {\n      opts.new_edits = req.new_edits;\n    } else {\n      opts.new_edits = true;\n    }\n  }\n\n  var adapter = this;\n  if (!opts.new_edits && !isRemote(adapter)) {\n    // ensure revisions of the same doc are sorted, so that\n    // the local adapter processes them correctly (#2935)\n    req.docs.sort(compareByIdThenRev);\n  }\n\n  cleanDocs(req.docs);\n\n  // in the case of conflicts, we want to return the _ids to the user\n  // however, the underlying adapter may destroy the docs array, so\n  // create a copy here\n  var ids = req.docs.map(function (doc) {\n    return doc._id;\n  });\n\n  return this._bulkDocs(req, opts, function (err, res) {\n    if (err) {\n      return callback(err);\n    }\n    if (!opts.new_edits) {\n      // this is what couch does when new_edits is false\n      res = res.filter(function (x) {\n        return x.error;\n      });\n    }\n    // add ids for error/conflict responses (not required for CouchDB)\n    if (!isRemote(adapter)) {\n      for (var i = 0, l = res.length; i < l; i++) {\n        res[i].id = res[i].id || ids[i];\n      }\n    }\n\n    callback(null, res);\n  });\n});\n\nAbstractPouchDB.prototype.registerDependentDatabase =\n  adapterFun('registerDependentDatabase', function (dependentDb,\n                                                          callback) {\n  var depDB = new this.constructor(dependentDb, this.__opts);\n\n  function diffFun(doc) {\n    doc.dependentDbs = doc.dependentDbs || {};\n    if (doc.dependentDbs[dependentDb]) {\n      return false; // no update required\n    }\n    doc.dependentDbs[dependentDb] = true;\n    return doc;\n  }\n  upsert(this, '_local/_pouch_dependentDbs', diffFun)\n    .then(function () {\n      callback(null, {db: depDB});\n    }).catch(callback);\n});\n\nAbstractPouchDB.prototype.destroy =\n  adapterFun('destroy', function (opts, callback) {\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  var self = this;\n  var usePrefix = 'use_prefix' in self ? self.use_prefix : true;\n\n  function destroyDb() {\n    // call destroy method of the particular adaptor\n    self._destroy(opts, function (err, resp) {\n      if (err) {\n        return callback(err);\n      }\n      self._destroyed = true;\n      self.emit('destroyed');\n      callback(null, resp || { 'ok': true });\n    });\n  }\n\n  if (isRemote(self)) {\n    // no need to check for dependent DBs if it's a remote DB\n    return destroyDb();\n  }\n\n  self.get('_local/_pouch_dependentDbs', function (err, localDoc) {\n    if (err) {\n      /* istanbul ignore if */\n      if (err.status !== 404) {\n        return callback(err);\n      } else { // no dependencies\n        return destroyDb();\n      }\n    }\n    var dependentDbs = localDoc.dependentDbs;\n    var PouchDB = self.constructor;\n    var deletedMap = Object.keys(dependentDbs).map(function (name) {\n      // use_prefix is only false in the browser\n      /* istanbul ignore next */\n      var trueName = usePrefix ?\n        name.replace(new RegExp('^' + PouchDB.prefix), '') : name;\n      return new PouchDB(trueName, self.__opts).destroy();\n    });\n    PouchPromise$1.all(deletedMap).then(destroyDb, callback);\n  });\n});\n\nfunction TaskQueue$1() {\n  this.isReady = false;\n  this.failed = false;\n  this.queue = [];\n}\n\nTaskQueue$1.prototype.execute = function () {\n  var fun;\n  if (this.failed) {\n    while ((fun = this.queue.shift())) {\n      fun(this.failed);\n    }\n  } else {\n    while ((fun = this.queue.shift())) {\n      fun();\n    }\n  }\n};\n\nTaskQueue$1.prototype.fail = function (err) {\n  this.failed = err;\n  this.execute();\n};\n\nTaskQueue$1.prototype.ready = function (db) {\n  this.isReady = true;\n  this.db = db;\n  this.execute();\n};\n\nTaskQueue$1.prototype.addTask = function (fun) {\n  this.queue.push(fun);\n  if (this.failed) {\n    this.execute();\n  }\n};\n\nfunction parseAdapter(name, opts) {\n  var match = name.match(/([a-z-]*):\\/\\/(.*)/);\n  if (match) {\n    // the http adapter expects the fully qualified name\n    return {\n      name: /https?/.test(match[1]) ? match[1] + '://' + match[2] : match[2],\n      adapter: match[1]\n    };\n  }\n\n  var adapters = PouchDB$5.adapters;\n  var preferredAdapters = PouchDB$5.preferredAdapters;\n  var prefix = PouchDB$5.prefix;\n  var adapterName = opts.adapter;\n\n  if (!adapterName) { // automatically determine adapter\n    for (var i = 0; i < preferredAdapters.length; ++i) {\n      adapterName = preferredAdapters[i];\n      // check for browsers that have been upgraded from websql-only to websql+idb\n      /* istanbul ignore if */\n      if (adapterName === 'idb' && 'websql' in adapters &&\n          hasLocalStorage() && localStorage['_pouch__websqldb_' + prefix + name]) {\n        // log it, because this can be confusing during development\n        guardedConsole('log', 'PouchDB is downgrading \"' + name + '\" to WebSQL to' +\n          ' avoid data loss, because it was already opened with WebSQL.');\n        continue; // keep using websql to avoid user data loss\n      }\n      break;\n    }\n  }\n\n  var adapter = adapters[adapterName];\n\n  // if adapter is invalid, then an error will be thrown later\n  var usePrefix = (adapter && 'use_prefix' in adapter) ?\n    adapter.use_prefix : true;\n\n  return {\n    name: usePrefix ? (prefix + name) : name,\n    adapter: adapterName\n  };\n}\n\n// OK, so here's the deal. Consider this code:\n//     var db1 = new PouchDB('foo');\n//     var db2 = new PouchDB('foo');\n//     db1.destroy();\n// ^ these two both need to emit 'destroyed' events,\n// as well as the PouchDB constructor itself.\n// So we have one db object (whichever one got destroy() called on it)\n// responsible for emitting the initial event, which then gets emitted\n// by the constructor, which then broadcasts it to any other dbs\n// that may have been created with the same name.\nfunction prepareForDestruction(self) {\n\n  function onDestroyed(from_constructor) {\n    self.removeListener('closed', onClosed);\n    if (!from_constructor) {\n      self.constructor.emit('destroyed', self.name);\n    }\n  }\n\n  function onClosed() {\n    self.removeListener('destroyed', onDestroyed);\n    self.constructor.emit('unref', self);\n  }\n\n  self.once('destroyed', onDestroyed);\n  self.once('closed', onClosed);\n  self.constructor.emit('ref', self);\n}\n\ninherits(PouchDB$5, AbstractPouchDB);\nfunction PouchDB$5(name, opts) {\n  // In Node our test suite only tests this for PouchAlt unfortunately\n  /* istanbul ignore if */\n  if (!(this instanceof PouchDB$5)) {\n    return new PouchDB$5(name, opts);\n  }\n\n  var self = this;\n  opts = opts || {};\n\n  if (name && typeof name === 'object') {\n    opts = name;\n    name = opts.name;\n    delete opts.name;\n  }\n\n  this.__opts = opts = clone(opts);\n\n  self.auto_compaction = opts.auto_compaction;\n  self.prefix = PouchDB$5.prefix;\n\n  if (typeof name !== 'string') {\n    throw new Error('Missing/invalid DB name');\n  }\n\n  var prefixedName = (opts.prefix || '') + name;\n  var backend = parseAdapter(prefixedName, opts);\n\n  opts.name = backend.name;\n  opts.adapter = opts.adapter || backend.adapter;\n\n  self.name = name;\n  self._adapter = opts.adapter;\n  PouchDB$5.emit('debug', ['adapter', 'Picked adapter: ', opts.adapter]);\n\n  if (!PouchDB$5.adapters[opts.adapter] ||\n      !PouchDB$5.adapters[opts.adapter].valid()) {\n    throw new Error('Invalid Adapter: ' + opts.adapter);\n  }\n\n  AbstractPouchDB.call(self);\n  self.taskqueue = new TaskQueue$1();\n\n  self.adapter = opts.adapter;\n\n  PouchDB$5.adapters[opts.adapter].call(self, opts, function (err) {\n    if (err) {\n      return self.taskqueue.fail(err);\n    }\n    prepareForDestruction(self);\n\n    self.emit('created', self);\n    PouchDB$5.emit('created', self.name);\n    self.taskqueue.ready(self);\n  });\n\n}\n\nPouchDB$5.adapters = {};\nPouchDB$5.preferredAdapters = [];\n\nPouchDB$5.prefix = '_pouch_';\n\nvar eventEmitter = new EventEmitter();\n\nfunction setUpEventEmitter(Pouch) {\n  Object.keys(EventEmitter.prototype).forEach(function (key) {\n    if (typeof EventEmitter.prototype[key] === 'function') {\n      Pouch[key] = eventEmitter[key].bind(eventEmitter);\n    }\n  });\n\n  // these are created in constructor.js, and allow us to notify each DB with\n  // the same name that it was destroyed, via the constructor object\n  var destructListeners = Pouch._destructionListeners = new ExportedMap();\n\n  Pouch.on('ref', function onConstructorRef(db) {\n    if (!destructListeners.has(db.name)) {\n      destructListeners.set(db.name, []);\n    }\n    destructListeners.get(db.name).push(db);\n  });\n\n  Pouch.on('unref', function onConstructorUnref(db) {\n    if (!destructListeners.has(db.name)) {\n      return;\n    }\n    var dbList = destructListeners.get(db.name);\n    var pos = dbList.indexOf(db);\n    if (pos < 0) {\n      /* istanbul ignore next */\n      return;\n    }\n    dbList.splice(pos, 1);\n    if (dbList.length > 1) {\n      /* istanbul ignore next */\n      destructListeners.set(db.name, dbList);\n    } else {\n      destructListeners.delete(db.name);\n    }\n  });\n\n  Pouch.on('destroyed', function onConstructorDestroyed(name) {\n    if (!destructListeners.has(name)) {\n      return;\n    }\n    var dbList = destructListeners.get(name);\n    destructListeners.delete(name);\n    dbList.forEach(function (db) {\n      db.emit('destroyed',true);\n    });\n  });\n}\n\nsetUpEventEmitter(PouchDB$5);\n\nPouchDB$5.adapter = function (id, obj, addToPreferredAdapters) {\n  /* istanbul ignore else */\n  if (obj.valid()) {\n    PouchDB$5.adapters[id] = obj;\n    if (addToPreferredAdapters) {\n      PouchDB$5.preferredAdapters.push(id);\n    }\n  }\n};\n\nPouchDB$5.plugin = function (obj) {\n  if (typeof obj === 'function') { // function style for plugins\n    obj(PouchDB$5);\n  } else if (typeof obj !== 'object' || Object.keys(obj).length === 0) {\n    throw new Error('Invalid plugin: got \"' + obj + '\", expected an object or a function');\n  } else {\n    Object.keys(obj).forEach(function (id) { // object style for plugins\n      PouchDB$5.prototype[id] = obj[id];\n    });\n  }\n  if (this.__defaults) {\n    PouchDB$5.__defaults = $inject_Object_assign({}, this.__defaults);\n  }\n  return PouchDB$5;\n};\n\nPouchDB$5.defaults = function (defaultOpts) {\n  function PouchAlt(name, opts) {\n    if (!(this instanceof PouchAlt)) {\n      return new PouchAlt(name, opts);\n    }\n\n    opts = opts || {};\n\n    if (name && typeof name === 'object') {\n      opts = name;\n      name = opts.name;\n      delete opts.name;\n    }\n\n    opts = $inject_Object_assign({}, PouchAlt.__defaults, opts);\n    PouchDB$5.call(this, name, opts);\n  }\n\n  inherits(PouchAlt, PouchDB$5);\n\n  PouchAlt.preferredAdapters = PouchDB$5.preferredAdapters.slice();\n  Object.keys(PouchDB$5).forEach(function (key) {\n    if (!(key in PouchAlt)) {\n      PouchAlt[key] = PouchDB$5[key];\n    }\n  });\n\n  // make default options transitive\n  // https://github.com/pouchdb/pouchdb/issues/5922\n  PouchAlt.__defaults = $inject_Object_assign({}, this.__defaults, defaultOpts);\n\n  return PouchAlt;\n};\n\n// managed automatically by set-version.js\nvar version = \"6.3.4\";\n\nfunction debugPouch(PouchDB) {\n  PouchDB.debug = debug;\n  var logs = {};\n  /* istanbul ignore next */\n  PouchDB.on('debug', function (args) {\n    // first argument is log identifier\n    var logId = args[0];\n    // rest should be passed verbatim to debug module\n    var logArgs = args.slice(1);\n    if (!logs[logId]) {\n      logs[logId] = debug('pouchdb:' + logId);\n    }\n    logs[logId].apply(null, logArgs);\n  });\n}\n\n// this would just be \"return doc[field]\", but fields\n// can be \"deep\" due to dot notation\nfunction getFieldFromDoc(doc, parsedField) {\n  var value = doc;\n  for (var i = 0, len = parsedField.length; i < len; i++) {\n    var key = parsedField[i];\n    value = value[key];\n    if (!value) {\n      break;\n    }\n  }\n  return value;\n}\n\nfunction compare$1(left, right) {\n  return left < right ? -1 : left > right ? 1 : 0;\n}\n\n// Converts a string in dot notation to an array of its components, with backslash escaping\nfunction parseField(fieldName) {\n  // fields may be deep (e.g. \"foo.bar.baz\"), so parse\n  var fields = [];\n  var current = '';\n  for (var i = 0, len = fieldName.length; i < len; i++) {\n    var ch = fieldName[i];\n    if (ch === '.') {\n      if (i > 0 && fieldName[i - 1] === '\\\\') { // escaped delimiter\n        current = current.substring(0, current.length - 1) + '.';\n      } else { // not escaped, so delimiter\n        fields.push(current);\n        current = '';\n      }\n    } else { // normal character\n      current += ch;\n    }\n  }\n  fields.push(current);\n  return fields;\n}\n\nvar combinationFields = ['$or', '$nor', '$not'];\nfunction isCombinationalField(field) {\n  return combinationFields.indexOf(field) > -1;\n}\n\nfunction getKey(obj) {\n  return Object.keys(obj)[0];\n}\n\nfunction getValue(obj) {\n  return obj[getKey(obj)];\n}\n\n\n// flatten an array of selectors joined by an $and operator\nfunction mergeAndedSelectors(selectors) {\n\n  // sort to ensure that e.g. if the user specified\n  // $and: [{$gt: 'a'}, {$gt: 'b'}], then it's collapsed into\n  // just {$gt: 'b'}\n  var res = {};\n\n  selectors.forEach(function (selector) {\n    Object.keys(selector).forEach(function (field) {\n      var matcher = selector[field];\n      if (typeof matcher !== 'object') {\n        matcher = {$eq: matcher};\n      }\n\n      if (isCombinationalField(field)) {\n        if (matcher instanceof Array) {\n          res[field] = matcher.map(function (m) {\n            return mergeAndedSelectors([m]);\n          });\n        } else {\n          res[field] = mergeAndedSelectors([matcher]);\n        }\n      } else {\n        var fieldMatchers = res[field] = res[field] || {};\n        Object.keys(matcher).forEach(function (operator) {\n          var value = matcher[operator];\n\n          if (operator === '$gt' || operator === '$gte') {\n            return mergeGtGte(operator, value, fieldMatchers);\n          } else if (operator === '$lt' || operator === '$lte') {\n            return mergeLtLte(operator, value, fieldMatchers);\n          } else if (operator === '$ne') {\n            return mergeNe(value, fieldMatchers);\n          } else if (operator === '$eq') {\n            return mergeEq(value, fieldMatchers);\n          }\n          fieldMatchers[operator] = value;\n        });\n      }\n    });\n  });\n\n  return res;\n}\n\n\n\n// collapse logically equivalent gt/gte values\nfunction mergeGtGte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$gte !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gte) { // more specificity\n        fieldMatchers.$gte = value;\n      }\n    } else { // operator === '$gt'\n      if (value >= fieldMatchers.$gte) { // more specificity\n        delete fieldMatchers.$gte;\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$gt !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gt) { // more specificity\n        delete fieldMatchers.$gt;\n        fieldMatchers.$gte = value;\n      }\n    } else { // operator === '$gt'\n      if (value > fieldMatchers.$gt) { // more specificity\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// collapse logically equivalent lt/lte values\nfunction mergeLtLte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$lte !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lte) { // more specificity\n        fieldMatchers.$lte = value;\n      }\n    } else { // operator === '$gt'\n      if (value <= fieldMatchers.$lte) { // more specificity\n        delete fieldMatchers.$lte;\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$lt !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lt) { // more specificity\n        delete fieldMatchers.$lt;\n        fieldMatchers.$lte = value;\n      }\n    } else { // operator === '$gt'\n      if (value < fieldMatchers.$lt) { // more specificity\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// combine $ne values into one array\nfunction mergeNe(value, fieldMatchers) {\n  if ('$ne' in fieldMatchers) {\n    // there are many things this could \"not\" be\n    fieldMatchers.$ne.push(value);\n  } else { // doesn't exist yet\n    fieldMatchers.$ne = [value];\n  }\n}\n\n// add $eq into the mix\nfunction mergeEq(value, fieldMatchers) {\n  // these all have less specificity than the $eq\n  // TODO: check for user errors here\n  delete fieldMatchers.$gt;\n  delete fieldMatchers.$gte;\n  delete fieldMatchers.$lt;\n  delete fieldMatchers.$lte;\n  delete fieldMatchers.$ne;\n  fieldMatchers.$eq = value;\n}\n\n\n//\n// normalize the selector\n//\nfunction massageSelector(input) {\n  var result = clone(input);\n  var wasAnded = false;\n  if ('$and' in result) {\n    result = mergeAndedSelectors(result['$and']);\n    wasAnded = true;\n  }\n\n  ['$or', '$nor'].forEach(function (orOrNor) {\n    if (orOrNor in result) {\n      // message each individual selector\n      // e.g. {foo: 'bar'} becomes {foo: {$eq: 'bar'}}\n      result[orOrNor].forEach(function (subSelector) {\n        var fields = Object.keys(subSelector);\n        for (var i = 0; i < fields.length; i++) {\n          var field = fields[i];\n          var matcher = subSelector[field];\n          if (typeof matcher !== 'object' || matcher === null) {\n            subSelector[field] = {$eq: matcher};\n          }\n        }\n      });\n    }\n  });\n\n  if ('$not' in result) {\n    //This feels a little like forcing, but it will work for now,\n    //I would like to come back to this and make the merging of selectors a little more generic\n    result['$not'] = mergeAndedSelectors([result['$not']]);\n  }\n\n  var fields = Object.keys(result);\n\n  for (var i = 0; i < fields.length; i++) {\n    var field = fields[i];\n    var matcher = result[field];\n\n    if (typeof matcher !== 'object' || matcher === null) {\n      matcher = {$eq: matcher};\n    } else if ('$ne' in matcher && !wasAnded) {\n      // I put these in an array, since there may be more than one\n      // but in the \"mergeAnded\" operation, I already take care of that\n      matcher.$ne = [matcher.$ne];\n    }\n    result[field] = matcher;\n  }\n\n  return result;\n}\n\nfunction pad(str, padWith, upToLength) {\n  var padding = '';\n  var targetLength = upToLength - str.length;\n  /* istanbul ignore next */\n  while (padding.length < targetLength) {\n    padding += padWith;\n  }\n  return padding;\n}\n\nfunction padLeft(str, padWith, upToLength) {\n  var padding = pad(str, padWith, upToLength);\n  return padding + str;\n}\n\nvar MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE\nvar MAGNITUDE_DIGITS = 3; // ditto\nvar SEP = ''; // set to '_' for easier debugging \n\nfunction collate(a, b) {\n\n  if (a === b) {\n    return 0;\n  }\n\n  a = normalizeKey(a);\n  b = normalizeKey(b);\n\n  var ai = collationIndex(a);\n  var bi = collationIndex(b);\n  if ((ai - bi) !== 0) {\n    return ai - bi;\n  }\n  switch (typeof a) {\n    case 'number':\n      return a - b;\n    case 'boolean':\n      return a < b ? -1 : 1;\n    case 'string':\n      return stringCollate(a, b);\n  }\n  return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);\n}\n\n// couch considers null/NaN/Infinity/-Infinity === undefined,\n// for the purposes of mapreduce indexes. also, dates get stringified.\nfunction normalizeKey(key) {\n  switch (typeof key) {\n    case 'undefined':\n      return null;\n    case 'number':\n      if (key === Infinity || key === -Infinity || isNaN(key)) {\n        return null;\n      }\n      return key;\n    case 'object':\n      var origKey = key;\n      if (Array.isArray(key)) {\n        var len = key.length;\n        key = new Array(len);\n        for (var i = 0; i < len; i++) {\n          key[i] = normalizeKey(origKey[i]);\n        }\n      /* istanbul ignore next */\n      } else if (key instanceof Date) {\n        return key.toJSON();\n      } else if (key !== null) { // generic object\n        key = {};\n        for (var k in origKey) {\n          if (origKey.hasOwnProperty(k)) {\n            var val = origKey[k];\n            if (typeof val !== 'undefined') {\n              key[k] = normalizeKey(val);\n            }\n          }\n        }\n      }\n  }\n  return key;\n}\n\nfunction indexify(key) {\n  if (key !== null) {\n    switch (typeof key) {\n      case 'boolean':\n        return key ? 1 : 0;\n      case 'number':\n        return numToIndexableString(key);\n      case 'string':\n        // We've to be sure that key does not contain \\u0000\n        // Do order-preserving replacements:\n        // 0 -> 1, 1\n        // 1 -> 1, 2\n        // 2 -> 2, 2\n        return key\n          .replace(/\\u0002/g, '\\u0002\\u0002')\n          .replace(/\\u0001/g, '\\u0001\\u0002')\n          .replace(/\\u0000/g, '\\u0001\\u0001');\n      case 'object':\n        var isArray = Array.isArray(key);\n        var arr = isArray ? key : Object.keys(key);\n        var i = -1;\n        var len = arr.length;\n        var result = '';\n        if (isArray) {\n          while (++i < len) {\n            result += toIndexableString(arr[i]);\n          }\n        } else {\n          while (++i < len) {\n            var objKey = arr[i];\n            result += toIndexableString(objKey) +\n                toIndexableString(key[objKey]);\n          }\n        }\n        return result;\n    }\n  }\n  return '';\n}\n\n// convert the given key to a string that would be appropriate\n// for lexical sorting, e.g. within a database, where the\n// sorting is the same given by the collate() function.\nfunction toIndexableString(key) {\n  var zero = '\\u0000';\n  key = normalizeKey(key);\n  return collationIndex(key) + SEP + indexify(key) + zero;\n}\n\nfunction parseNumber(str, i) {\n  var originalIdx = i;\n  var num;\n  var zero = str[i] === '1';\n  if (zero) {\n    num = 0;\n    i++;\n  } else {\n    var neg = str[i] === '0';\n    i++;\n    var numAsString = '';\n    var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);\n    var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;\n    /* istanbul ignore next */\n    if (neg) {\n      magnitude = -magnitude;\n    }\n    i += MAGNITUDE_DIGITS;\n    while (true) {\n      var ch = str[i];\n      if (ch === '\\u0000') {\n        break;\n      } else {\n        numAsString += ch;\n      }\n      i++;\n    }\n    numAsString = numAsString.split('.');\n    if (numAsString.length === 1) {\n      num = parseInt(numAsString, 10);\n    } else {\n      /* istanbul ignore next */\n      num = parseFloat(numAsString[0] + '.' + numAsString[1]);\n    }\n    /* istanbul ignore next */\n    if (neg) {\n      num = num - 10;\n    }\n    /* istanbul ignore next */\n    if (magnitude !== 0) {\n      // parseFloat is more reliable than pow due to rounding errors\n      // e.g. Number.MAX_VALUE would return Infinity if we did\n      // num * Math.pow(10, magnitude);\n      num = parseFloat(num + 'e' + magnitude);\n    }\n  }\n  return {num: num, length : i - originalIdx};\n}\n\n// move up the stack while parsing\n// this function moved outside of parseIndexableString for performance\nfunction pop(stack, metaStack) {\n  var obj = stack.pop();\n\n  if (metaStack.length) {\n    var lastMetaElement = metaStack[metaStack.length - 1];\n    if (obj === lastMetaElement.element) {\n      // popping a meta-element, e.g. an object whose value is another object\n      metaStack.pop();\n      lastMetaElement = metaStack[metaStack.length - 1];\n    }\n    var element = lastMetaElement.element;\n    var lastElementIndex = lastMetaElement.index;\n    if (Array.isArray(element)) {\n      element.push(obj);\n    } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n      var key = stack.pop();\n      element[key] = obj;\n    } else {\n      stack.push(obj); // obj with key only\n    }\n  }\n}\n\nfunction parseIndexableString(str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n\n  /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n  while (true) {\n    var collationIndex = str[i++];\n    if (collationIndex === '\\u0000') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case '1':\n        stack.push(null);\n        break;\n      case '2':\n        stack.push(str[i] === '1');\n        i++;\n        break;\n      case '3':\n        var parsedNum = parseNumber(str, i);\n        stack.push(parsedNum.num);\n        i += parsedNum.length;\n        break;\n      case '4':\n        var parsedStr = '';\n        /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n        while (true) {\n          var ch = str[i];\n          if (ch === '\\u0000') {\n            break;\n          }\n          parsedStr += ch;\n          i++;\n        }\n        // perform the reverse of the order-preserving replacement\n        // algorithm (see above)\n        parsedStr = parsedStr.replace(/\\u0001\\u0001/g, '\\u0000')\n          .replace(/\\u0001\\u0002/g, '\\u0001')\n          .replace(/\\u0002\\u0002/g, '\\u0002');\n        stack.push(parsedStr);\n        break;\n      case '5':\n        var arrayElement = { element: [], index: stack.length };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '6':\n        var objElement = { element: {}, index: stack.length };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      /* istanbul ignore next */\n      default:\n        throw new Error(\n          'bad collationIndex or unexpectedly reached end of input: ' +\n            collationIndex);\n    }\n  }\n}\n\nfunction arrayCollate(a, b) {\n  var len = Math.min(a.length, b.length);\n  for (var i = 0; i < len; i++) {\n    var sort = collate(a[i], b[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n  }\n  return (a.length === b.length) ? 0 :\n    (a.length > b.length) ? 1 : -1;\n}\nfunction stringCollate(a, b) {\n  // See: https://github.com/daleharvey/pouchdb/issues/40\n  // This is incompatible with the CouchDB implementation, but its the\n  // best we can do for now\n  return (a === b) ? 0 : ((a > b) ? 1 : -1);\n}\nfunction objectCollate(a, b) {\n  var ak = Object.keys(a), bk = Object.keys(b);\n  var len = Math.min(ak.length, bk.length);\n  for (var i = 0; i < len; i++) {\n    // First sort the keys\n    var sort = collate(ak[i], bk[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n    // if the keys are equal sort the values\n    sort = collate(a[ak[i]], b[bk[i]]);\n    if (sort !== 0) {\n      return sort;\n    }\n\n  }\n  return (ak.length === bk.length) ? 0 :\n    (ak.length > bk.length) ? 1 : -1;\n}\n// The collation is defined by erlangs ordered terms\n// the atoms null, true, false come first, then numbers, strings,\n// arrays, then objects\n// null/undefined/NaN/Infinity/-Infinity are all considered null\nfunction collationIndex(x) {\n  var id = ['boolean', 'number', 'string', 'object'];\n  var idx = id.indexOf(typeof x);\n  //false if -1 otherwise true, but fast!!!!1\n  if (~idx) {\n    if (x === null) {\n      return 1;\n    }\n    if (Array.isArray(x)) {\n      return 5;\n    }\n    return idx < 3 ? (idx + 2) : (idx + 3);\n  }\n  /* istanbul ignore next */\n  if (Array.isArray(x)) {\n    return 5;\n  }\n}\n\n// conversion:\n// x yyy zz...zz\n// x = 0 for negative, 1 for 0, 2 for positive\n// y = exponent (for negative numbers negated) moved so that it's >= 0\n// z = mantisse\nfunction numToIndexableString(num) {\n\n  if (num === 0) {\n    return '1';\n  }\n\n  // convert number to exponential format for easier and\n  // more succinct string sorting\n  var expFormat = num.toExponential().split(/e\\+?/);\n  var magnitude = parseInt(expFormat[1], 10);\n\n  var neg = num < 0;\n\n  var result = neg ? '0' : '2';\n\n  // first sort by magnitude\n  // it's easier if all magnitudes are positive\n  var magForComparison = ((neg ? -magnitude : magnitude) - MIN_MAGNITUDE);\n  var magString = padLeft((magForComparison).toString(), '0', MAGNITUDE_DIGITS);\n\n  result += SEP + magString;\n\n  // then sort by the factor\n  var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)\n  /* istanbul ignore next */\n  if (neg) { // for negative reverse ordering\n    factor = 10 - factor;\n  }\n\n  var factorStr = factor.toFixed(20);\n\n  // strip zeros from the end\n  factorStr = factorStr.replace(/\\.?0+$/, '');\n\n  result += SEP + factorStr;\n\n  return result;\n}\n\n// create a comparator based on the sort object\nfunction createFieldSorter(sort) {\n\n  function getFieldValuesAsArray(doc) {\n    return sort.map(function (sorting) {\n      var fieldName = getKey(sorting);\n      var parsedField = parseField(fieldName);\n      var docFieldValue = getFieldFromDoc(doc, parsedField);\n      return docFieldValue;\n    });\n  }\n\n  return function (aRow, bRow) {\n    var aFieldValues = getFieldValuesAsArray(aRow.doc);\n    var bFieldValues = getFieldValuesAsArray(bRow.doc);\n    var collation = collate(aFieldValues, bFieldValues);\n    if (collation !== 0) {\n      return collation;\n    }\n    // this is what mango seems to do\n    return compare$1(aRow.doc._id, bRow.doc._id);\n  };\n}\n\nfunction filterInMemoryFields(rows, requestDef, inMemoryFields) {\n  rows = rows.filter(function (row) {\n    return rowFilter(row.doc, requestDef.selector, inMemoryFields);\n  });\n\n  if (requestDef.sort) {\n    // in-memory sort\n    var fieldSorter = createFieldSorter(requestDef.sort);\n    rows = rows.sort(fieldSorter);\n    if (typeof requestDef.sort[0] !== 'string' &&\n        getValue(requestDef.sort[0]) === 'desc') {\n      rows = rows.reverse();\n    }\n  }\n\n  if ('limit' in requestDef || 'skip' in requestDef) {\n    // have to do the limit in-memory\n    var skip = requestDef.skip || 0;\n    var limit = ('limit' in requestDef ? requestDef.limit : rows.length) + skip;\n    rows = rows.slice(skip, limit);\n  }\n  return rows;\n}\n\nfunction rowFilter(doc, selector, inMemoryFields) {\n  return inMemoryFields.every(function (field) {\n    var matcher = selector[field];\n    var parsedField = parseField(field);\n    var docFieldValue = getFieldFromDoc(doc, parsedField);\n    if (isCombinationalField(field)) {\n      return matchCominationalSelector(field, matcher, doc);\n    }\n\n    return matchSelector(matcher, doc, parsedField, docFieldValue);\n  });\n}\n\nfunction matchSelector(matcher, doc, parsedField, docFieldValue) {\n  if (!matcher) {\n    // no filtering necessary; this field is just needed for sorting\n    return true;\n  }\n\n  return Object.keys(matcher).every(function (userOperator) {\n    var userValue = matcher[userOperator];\n    return match(userOperator, doc, userValue, parsedField, docFieldValue);\n  });\n}\n\nfunction matchCominationalSelector(field, matcher, doc) {\n\n  if (field === '$or') {\n    return matcher.some(function (orMatchers) {\n      return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n    });\n  }\n\n  if (field === '$not') {\n    return !rowFilter(doc, matcher, Object.keys(matcher));\n  }\n\n  //`$nor`\n  return !matcher.find(function (orMatchers) {\n    return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n  });\n\n}\n\nfunction match(userOperator, doc, userValue, parsedField, docFieldValue) {\n  if (!matchers[userOperator]) {\n    throw new Error('unknown operator \"' + userOperator +\n      '\" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, ' +\n      '$nin, $size, $mod, $regex, $elemMatch, $type, $allMatch or $all');\n  }\n  return matchers[userOperator](doc, userValue, parsedField, docFieldValue);\n}\n\nfunction fieldExists(docFieldValue) {\n  return typeof docFieldValue !== 'undefined' && docFieldValue !== null;\n}\n\nfunction fieldIsNotUndefined(docFieldValue) {\n  return typeof docFieldValue !== 'undefined';\n}\n\nfunction modField(docFieldValue, userValue) {\n  var divisor = userValue[0];\n  var mod = userValue[1];\n  if (divisor === 0) {\n    throw new Error('Bad divisor, cannot divide by zero');\n  }\n\n  if (parseInt(divisor, 10) !== divisor ) {\n    throw new Error('Divisor is not an integer');\n  }\n\n  if (parseInt(mod, 10) !== mod ) {\n    throw new Error('Modulus is not an integer');\n  }\n\n  if (parseInt(docFieldValue, 10) !== docFieldValue) {\n    return false;\n  }\n\n  return docFieldValue % divisor === mod;\n}\n\nfunction arrayContainsValue(docFieldValue, userValue) {\n  return userValue.some(function (val) {\n    if (docFieldValue instanceof Array) {\n      return docFieldValue.indexOf(val) > -1;\n    }\n\n    return docFieldValue === val;\n  });\n}\n\nfunction arrayContainsAllValues(docFieldValue, userValue) {\n  return userValue.every(function (val) {\n    return docFieldValue.indexOf(val) > -1;\n  });\n}\n\nfunction arraySize(docFieldValue, userValue) {\n  return docFieldValue.length === userValue;\n}\n\nfunction regexMatch(docFieldValue, userValue) {\n  var re = new RegExp(userValue);\n\n  return re.test(docFieldValue);\n}\n\nfunction typeMatch(docFieldValue, userValue) {\n\n  switch (userValue) {\n    case 'null':\n      return docFieldValue === null;\n    case 'boolean':\n      return typeof (docFieldValue) === 'boolean';\n    case 'number':\n      return typeof (docFieldValue) === 'number';\n    case 'string':\n      return typeof (docFieldValue) === 'string';\n    case 'array':\n      return docFieldValue instanceof Array;\n    case 'object':\n      return ({}).toString.call(docFieldValue) === '[object Object]';\n  }\n\n  throw new Error(userValue + ' not supported as a type.' +\n                  'Please use one of object, string, array, number, boolean or null.');\n\n}\n\nvar matchers = {\n\n  '$elemMatch': function (doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object') {\n      return docFieldValue.some(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.some(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n\n  '$allMatch': function (doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n\n    /* istanbul ignore next */\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object') {\n      return docFieldValue.every(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.every(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n\n  '$eq': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) === 0;\n  },\n\n  '$gte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) >= 0;\n  },\n\n  '$gt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) > 0;\n  },\n\n  '$lte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) <= 0;\n  },\n\n  '$lt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) < 0;\n  },\n\n  '$exists': function (doc, userValue, parsedField, docFieldValue) {\n    //a field that is null is still considered to exist\n    if (userValue) {\n      return fieldIsNotUndefined(docFieldValue);\n    }\n\n    return !fieldIsNotUndefined(docFieldValue);\n  },\n\n  '$mod': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && modField(docFieldValue, userValue);\n  },\n\n  '$ne': function (doc, userValue, parsedField, docFieldValue) {\n    return userValue.every(function (neValue) {\n      return collate(docFieldValue, neValue) !== 0;\n    });\n  },\n  '$in': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$nin': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && !arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$size': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arraySize(docFieldValue, userValue);\n  },\n\n  '$all': function (doc, userValue, parsedField, docFieldValue) {\n    return Array.isArray(docFieldValue) && arrayContainsAllValues(docFieldValue, userValue);\n  },\n\n  '$regex': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && regexMatch(docFieldValue, userValue);\n  },\n\n  '$type': function (doc, userValue, parsedField, docFieldValue) {\n    return typeMatch(docFieldValue, userValue);\n  }\n};\n\n// return true if the given doc matches the supplied selector\nfunction matchesSelector(doc, selector) {\n  /* istanbul ignore if */\n  if (typeof selector !== 'object') {\n    // match the CouchDB error message\n    throw new Error('Selector error: expected a JSON object');\n  }\n\n  selector = massageSelector(selector);\n  var row = {\n    'doc': doc\n  };\n\n  var rowsMatched = filterInMemoryFields([row], { 'selector': selector }, Object.keys(selector));\n  return rowsMatched && rowsMatched.length === 1;\n}\n\nfunction evalFilter(input) {\n  return scopeEval('\"use strict\";\\nreturn ' + input + ';', {});\n}\n\nfunction evalView(input) {\n  var code = [\n    'return function(doc) {',\n    '  \"use strict\";',\n    '  var emitted = false;',\n    '  var emit = function (a, b) {',\n    '    emitted = true;',\n    '  };',\n    '  var view = ' + input + ';',\n    '  view(doc);',\n    '  if (emitted) {',\n    '    return true;',\n    '  }',\n    '};'\n  ].join('\\n');\n\n  return scopeEval(code, {});\n}\n\nfunction validate(opts, callback) {\n  if (opts.selector) {\n    if (opts.filter && opts.filter !== '_selector') {\n      var filterName = typeof opts.filter === 'string' ?\n        opts.filter : 'function';\n      return callback(new Error('selector invalid for filter \"' + filterName + '\"'));\n    }\n  }\n  callback();\n}\n\nfunction normalize(opts) {\n  if (opts.view && !opts.filter) {\n    opts.filter = '_view';\n  }\n\n  if (opts.selector && !opts.filter) {\n    opts.filter = '_selector';\n  }\n\n  if (opts.filter && typeof opts.filter === 'string') {\n    if (opts.filter === '_view') {\n      opts.view = normalizeDesignDocFunctionName(opts.view);\n    } else {\n      opts.filter = normalizeDesignDocFunctionName(opts.filter);\n    }\n  }\n}\n\nfunction shouldFilter(changesHandler, opts) {\n  return opts.filter && typeof opts.filter === 'string' &&\n    !opts.doc_ids && !isRemote(changesHandler.db);\n}\n\nfunction filter(changesHandler, opts) {\n  var callback = opts.complete;\n  if (opts.filter === '_view') {\n    if (!opts.view || typeof opts.view !== 'string') {\n      var err = createError(BAD_REQUEST,\n        '`view` filter parameter not found or invalid.');\n      return callback(err);\n    }\n    // fetch a view from a design doc, make it behave like a filter\n    var viewName = parseDesignDocFunctionName(opts.view);\n    changesHandler.db.get('_design/' + viewName[0], function (err, ddoc) {\n      /* istanbul ignore if */\n      if (changesHandler.isCancelled) {\n        return callback(null, {status: 'cancelled'});\n      }\n      /* istanbul ignore next */\n      if (err) {\n        return callback(generateErrorFromResponse(err));\n      }\n      var mapFun = ddoc && ddoc.views && ddoc.views[viewName[1]] &&\n        ddoc.views[viewName[1]].map;\n      if (!mapFun) {\n        return callback(createError(MISSING_DOC,\n          (ddoc.views ? 'missing json key: ' + viewName[1] :\n            'missing json key: views')));\n      }\n      opts.filter = evalView(mapFun);\n      changesHandler.doChanges(opts);\n    });\n  } else if (opts.selector) {\n    opts.filter = function (doc) {\n      return matchesSelector(doc, opts.selector);\n    };\n    changesHandler.doChanges(opts);\n  } else {\n    // fetch a filter from a design doc\n    var filterName = parseDesignDocFunctionName(opts.filter);\n    changesHandler.db.get('_design/' + filterName[0], function (err, ddoc) {\n      /* istanbul ignore if */\n      if (changesHandler.isCancelled) {\n        return callback(null, {status: 'cancelled'});\n      }\n      /* istanbul ignore next */\n      if (err) {\n        return callback(generateErrorFromResponse(err));\n      }\n      var filterFun = ddoc && ddoc.filters && ddoc.filters[filterName[1]];\n      if (!filterFun) {\n        return callback(createError(MISSING_DOC,\n          ((ddoc && ddoc.filters) ? 'missing json key: ' + filterName[1]\n            : 'missing json key: filters')));\n      }\n      opts.filter = evalFilter(filterFun);\n      changesHandler.doChanges(opts);\n    });\n  }\n}\n\nfunction applyChangesFilterPlugin(PouchDB) {\n  PouchDB._changesFilterPlugin = {\n    validate: validate,\n    normalize: normalize,\n    shouldFilter: shouldFilter,\n    filter: filter\n  };\n}\n\n// TODO: remove from pouchdb-core (breaking)\nPouchDB$5.plugin(debugPouch);\n\n// TODO: remove from pouchdb-core (breaking)\nPouchDB$5.plugin(applyChangesFilterPlugin);\n\nPouchDB$5.version = version;\n\nfunction toObject(array) {\n  return array.reduce(function (obj, item) {\n    obj[item] = true;\n    return obj;\n  }, {});\n}\n// List of top level reserved words for doc\nvar reservedWords = toObject([\n  '_id',\n  '_rev',\n  '_attachments',\n  '_deleted',\n  '_revisions',\n  '_revs_info',\n  '_conflicts',\n  '_deleted_conflicts',\n  '_local_seq',\n  '_rev_tree',\n  //replication documents\n  '_replication_id',\n  '_replication_state',\n  '_replication_state_time',\n  '_replication_state_reason',\n  '_replication_stats',\n  // Specific to Couchbase Sync Gateway\n  '_removed'\n]);\n\n// List of reserved words that should end up the document\nvar dataWords = toObject([\n  '_attachments',\n  //replication documents\n  '_replication_id',\n  '_replication_state',\n  '_replication_state_time',\n  '_replication_state_reason',\n  '_replication_stats'\n]);\n\nfunction parseRevisionInfo(rev$$1) {\n  if (!/^\\d+-./.test(rev$$1)) {\n    return createError(INVALID_REV);\n  }\n  var idx = rev$$1.indexOf('-');\n  var left = rev$$1.substring(0, idx);\n  var right = rev$$1.substring(idx + 1);\n  return {\n    prefix: parseInt(left, 10),\n    id: right\n  };\n}\n\nfunction makeRevTreeFromRevisions(revisions, opts) {\n  var pos = revisions.start - revisions.ids.length + 1;\n\n  var revisionIds = revisions.ids;\n  var ids = [revisionIds[0], opts, []];\n\n  for (var i = 1, len = revisionIds.length; i < len; i++) {\n    ids = [revisionIds[i], {status: 'missing'}, [ids]];\n  }\n\n  return [{\n    pos: pos,\n    ids: ids\n  }];\n}\n\n// Preprocess documents, parse their revisions, assign an id and a\n// revision for new writes that are missing them, etc\nfunction parseDoc(doc, newEdits) {\n\n  var nRevNum;\n  var newRevId;\n  var revInfo;\n  var opts = {status: 'available'};\n  if (doc._deleted) {\n    opts.deleted = true;\n  }\n\n  if (newEdits) {\n    if (!doc._id) {\n      doc._id = uuid();\n    }\n    newRevId = rev();\n    if (doc._rev) {\n      revInfo = parseRevisionInfo(doc._rev);\n      if (revInfo.error) {\n        return revInfo;\n      }\n      doc._rev_tree = [{\n        pos: revInfo.prefix,\n        ids: [revInfo.id, {status: 'missing'}, [[newRevId, opts, []]]]\n      }];\n      nRevNum = revInfo.prefix + 1;\n    } else {\n      doc._rev_tree = [{\n        pos: 1,\n        ids : [newRevId, opts, []]\n      }];\n      nRevNum = 1;\n    }\n  } else {\n    if (doc._revisions) {\n      doc._rev_tree = makeRevTreeFromRevisions(doc._revisions, opts);\n      nRevNum = doc._revisions.start;\n      newRevId = doc._revisions.ids[0];\n    }\n    if (!doc._rev_tree) {\n      revInfo = parseRevisionInfo(doc._rev);\n      if (revInfo.error) {\n        return revInfo;\n      }\n      nRevNum = revInfo.prefix;\n      newRevId = revInfo.id;\n      doc._rev_tree = [{\n        pos: nRevNum,\n        ids: [newRevId, opts, []]\n      }];\n    }\n  }\n\n  invalidIdError(doc._id);\n\n  doc._rev = nRevNum + '-' + newRevId;\n\n  var result = {metadata : {}, data : {}};\n  for (var key in doc) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(doc, key)) {\n      var specialKey = key[0] === '_';\n      if (specialKey && !reservedWords[key]) {\n        var error = createError(DOC_VALIDATION, key);\n        error.message = DOC_VALIDATION.message + ': ' + key;\n        throw error;\n      } else if (specialKey && !dataWords[key]) {\n        result.metadata[key.slice(1)] = doc[key];\n      } else {\n        result.data[key] = doc[key];\n      }\n    }\n  }\n  return result;\n}\n\nvar thisAtob = function (str) {\n  return atob(str);\n};\n\nvar thisBtoa = function (str) {\n  return btoa(str);\n};\n\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor (e.g.\n// old QtWebKit versions, Android < 4.4).\nfunction createBlob(parts, properties) {\n  /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n  parts = parts || [];\n  properties = properties || {};\n  try {\n    return new Blob(parts, properties);\n  } catch (e) {\n    if (e.name !== \"TypeError\") {\n      throw e;\n    }\n    var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :\n                  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :\n                  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder :\n                  WebKitBlobBuilder;\n    var builder = new Builder();\n    for (var i = 0; i < parts.length; i += 1) {\n      builder.append(parts[i]);\n    }\n    return builder.getBlob(properties.type);\n  }\n}\n\n// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n// encode-decode-image-with-base64-breaks-image (2013-04-21)\nfunction binaryStringToArrayBuffer(bin) {\n  var length = bin.length;\n  var buf = new ArrayBuffer(length);\n  var arr = new Uint8Array(buf);\n  for (var i = 0; i < length; i++) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return buf;\n}\n\nfunction binStringToBluffer(binString, type) {\n  return createBlob([binaryStringToArrayBuffer(binString)], {type: type});\n}\n\nfunction b64ToBluffer(b64, type) {\n  return binStringToBluffer(thisAtob(b64), type);\n}\n\n//Can't find original post, but this is close\n//http://stackoverflow.com/questions/6965107/ (continues on next line)\n//converting-between-strings-and-arraybuffers\nfunction arrayBufferToBinaryString(buffer) {\n  var binary = '';\n  var bytes = new Uint8Array(buffer);\n  var length = bytes.byteLength;\n  for (var i = 0; i < length; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return binary;\n}\n\n// shim for browsers that don't support it\nfunction readAsBinaryString(blob, callback) {\n  if (typeof FileReader === 'undefined') {\n    // fix for Firefox in a web worker\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n    return callback(arrayBufferToBinaryString(\n      new FileReaderSync().readAsArrayBuffer(blob)));\n  }\n\n  var reader = new FileReader();\n  var hasBinaryString = typeof reader.readAsBinaryString === 'function';\n  reader.onloadend = function (e) {\n    var result = e.target.result || '';\n    if (hasBinaryString) {\n      return callback(result);\n    }\n    callback(arrayBufferToBinaryString(result));\n  };\n  if (hasBinaryString) {\n    reader.readAsBinaryString(blob);\n  } else {\n    reader.readAsArrayBuffer(blob);\n  }\n}\n\nfunction blobToBinaryString(blobOrBuffer, callback) {\n  readAsBinaryString(blobOrBuffer, function (bin) {\n    callback(bin);\n  });\n}\n\nfunction blobToBase64(blobOrBuffer, callback) {\n  blobToBinaryString(blobOrBuffer, function (base64) {\n    callback(thisBtoa(base64));\n  });\n}\n\n// simplified API. universal browser support is assumed\nfunction readAsArrayBuffer(blob, callback) {\n  if (typeof FileReader === 'undefined') {\n    // fix for Firefox in a web worker:\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n    return callback(new FileReaderSync().readAsArrayBuffer(blob));\n  }\n\n  var reader = new FileReader();\n  reader.onloadend = function (e) {\n    var result = e.target.result || new ArrayBuffer(0);\n    callback(result);\n  };\n  reader.readAsArrayBuffer(blob);\n}\n\n// this is not used in the browser\n\nvar setImmediateShim = global.setImmediate || global.setTimeout;\nvar MD5_CHUNK_SIZE = 32768;\n\nfunction rawToBase64(raw) {\n  return thisBtoa(raw);\n}\n\nfunction sliceBlob(blob, start, end) {\n  if (blob.webkitSlice) {\n    return blob.webkitSlice(start, end);\n  }\n  return blob.slice(start, end);\n}\n\nfunction appendBlob(buffer, blob, start, end, callback) {\n  if (start > 0 || end < blob.size) {\n    // only slice blob if we really need to\n    blob = sliceBlob(blob, start, end);\n  }\n  readAsArrayBuffer(blob, function (arrayBuffer) {\n    buffer.append(arrayBuffer);\n    callback();\n  });\n}\n\nfunction appendString(buffer, string, start, end, callback) {\n  if (start > 0 || end < string.length) {\n    // only create a substring if we really need to\n    string = string.substring(start, end);\n  }\n  buffer.appendBinary(string);\n  callback();\n}\n\nfunction binaryMd5(data, callback) {\n  var inputIsString = typeof data === 'string';\n  var len = inputIsString ? data.length : data.size;\n  var chunkSize = Math.min(MD5_CHUNK_SIZE, len);\n  var chunks = Math.ceil(len / chunkSize);\n  var currentChunk = 0;\n  var buffer = inputIsString ? new Md5() : new Md5.ArrayBuffer();\n\n  var append = inputIsString ? appendString : appendBlob;\n\n  function next() {\n    setImmediateShim(loadNextChunk);\n  }\n\n  function done() {\n    var raw = buffer.end(true);\n    var base64 = rawToBase64(raw);\n    callback(base64);\n    buffer.destroy();\n  }\n\n  function loadNextChunk() {\n    var start = currentChunk * chunkSize;\n    var end = start + chunkSize;\n    currentChunk++;\n    if (currentChunk < chunks) {\n      append(buffer, data, start, end, next);\n    } else {\n      append(buffer, data, start, end, done);\n    }\n  }\n  loadNextChunk();\n}\n\nfunction stringMd5(string) {\n  return Md5.hash(string);\n}\n\nfunction parseBase64(data) {\n  try {\n    return thisAtob(data);\n  } catch (e) {\n    var err = createError(BAD_ARG,\n      'Attachment is not a valid base64 string');\n    return {error: err};\n  }\n}\n\nfunction preprocessString(att, blobType, callback) {\n  var asBinary = parseBase64(att.data);\n  if (asBinary.error) {\n    return callback(asBinary.error);\n  }\n\n  att.length = asBinary.length;\n  if (blobType === 'blob') {\n    att.data = binStringToBluffer(asBinary, att.content_type);\n  } else if (blobType === 'base64') {\n    att.data = thisBtoa(asBinary);\n  } else { // binary\n    att.data = asBinary;\n  }\n  binaryMd5(asBinary, function (result) {\n    att.digest = 'md5-' + result;\n    callback();\n  });\n}\n\nfunction preprocessBlob(att, blobType, callback) {\n  binaryMd5(att.data, function (md5) {\n    att.digest = 'md5-' + md5;\n    // size is for blobs (browser), length is for buffers (node)\n    att.length = att.data.size || att.data.length || 0;\n    if (blobType === 'binary') {\n      blobToBinaryString(att.data, function (binString) {\n        att.data = binString;\n        callback();\n      });\n    } else if (blobType === 'base64') {\n      blobToBase64(att.data, function (b64) {\n        att.data = b64;\n        callback();\n      });\n    } else {\n      callback();\n    }\n  });\n}\n\nfunction preprocessAttachment(att, blobType, callback) {\n  if (att.stub) {\n    return callback();\n  }\n  if (typeof att.data === 'string') { // input is a base64 string\n    preprocessString(att, blobType, callback);\n  } else { // input is a blob\n    preprocessBlob(att, blobType, callback);\n  }\n}\n\nfunction preprocessAttachments(docInfos, blobType, callback) {\n\n  if (!docInfos.length) {\n    return callback();\n  }\n\n  var docv = 0;\n  var overallErr;\n\n  docInfos.forEach(function (docInfo) {\n    var attachments = docInfo.data && docInfo.data._attachments ?\n      Object.keys(docInfo.data._attachments) : [];\n    var recv = 0;\n\n    if (!attachments.length) {\n      return done();\n    }\n\n    function processedAttachment(err) {\n      overallErr = err;\n      recv++;\n      if (recv === attachments.length) {\n        done();\n      }\n    }\n\n    for (var key in docInfo.data._attachments) {\n      if (docInfo.data._attachments.hasOwnProperty(key)) {\n        preprocessAttachment(docInfo.data._attachments[key],\n          blobType, processedAttachment);\n      }\n    }\n  });\n\n  function done() {\n    docv++;\n    if (docInfos.length === docv) {\n      if (overallErr) {\n        callback(overallErr);\n      } else {\n        callback();\n      }\n    }\n  }\n}\n\nfunction updateDoc(revLimit, prev, docInfo, results,\n                   i, cb, writeDoc, newEdits) {\n\n  if (revExists(prev.rev_tree, docInfo.metadata.rev)) {\n    results[i] = docInfo;\n    return cb();\n  }\n\n  // sometimes this is pre-calculated. historically not always\n  var previousWinningRev = prev.winningRev || winningRev(prev);\n  var previouslyDeleted = 'deleted' in prev ? prev.deleted :\n    isDeleted(prev, previousWinningRev);\n  var deleted = 'deleted' in docInfo.metadata ? docInfo.metadata.deleted :\n    isDeleted(docInfo.metadata);\n  var isRoot = /^1-/.test(docInfo.metadata.rev);\n\n  if (previouslyDeleted && !deleted && newEdits && isRoot) {\n    var newDoc = docInfo.data;\n    newDoc._rev = previousWinningRev;\n    newDoc._id = docInfo.metadata.id;\n    docInfo = parseDoc(newDoc, newEdits);\n  }\n\n  var merged = merge(prev.rev_tree, docInfo.metadata.rev_tree[0], revLimit);\n\n  var inConflict = newEdits && ((\n    (previouslyDeleted && deleted && merged.conflicts !== 'new_leaf') ||\n    (!previouslyDeleted && merged.conflicts !== 'new_leaf') ||\n    (previouslyDeleted && !deleted && merged.conflicts === 'new_branch')));\n\n  if (inConflict) {\n    var err = createError(REV_CONFLICT);\n    results[i] = err;\n    return cb();\n  }\n\n  var newRev = docInfo.metadata.rev;\n  docInfo.metadata.rev_tree = merged.tree;\n  docInfo.stemmedRevs = merged.stemmedRevs || [];\n  /* istanbul ignore else */\n  if (prev.rev_map) {\n    docInfo.metadata.rev_map = prev.rev_map; // used only by leveldb\n  }\n\n  // recalculate\n  var winningRev$$1 = winningRev(docInfo.metadata);\n  var winningRevIsDeleted = isDeleted(docInfo.metadata, winningRev$$1);\n\n  // calculate the total number of documents that were added/removed,\n  // from the perspective of total_rows/doc_count\n  var delta = (previouslyDeleted === winningRevIsDeleted) ? 0 :\n    previouslyDeleted < winningRevIsDeleted ? -1 : 1;\n\n  var newRevIsDeleted;\n  if (newRev === winningRev$$1) {\n    // if the new rev is the same as the winning rev, we can reuse that value\n    newRevIsDeleted = winningRevIsDeleted;\n  } else {\n    // if they're not the same, then we need to recalculate\n    newRevIsDeleted = isDeleted(docInfo.metadata, newRev);\n  }\n\n  writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n    true, delta, i, cb);\n}\n\nfunction rootIsMissing(docInfo) {\n  return docInfo.metadata.rev_tree[0].ids[1].status === 'missing';\n}\n\nfunction processDocs(revLimit, docInfos, api, fetchedDocs, tx, results,\n                     writeDoc, opts, overallCallback) {\n\n  // Default to 1000 locally\n  revLimit = revLimit || 1000;\n\n  function insertDoc(docInfo, resultsIdx, callback) {\n    // Cant insert new deleted documents\n    var winningRev$$1 = winningRev(docInfo.metadata);\n    var deleted = isDeleted(docInfo.metadata, winningRev$$1);\n    if ('was_delete' in opts && deleted) {\n      results[resultsIdx] = createError(MISSING_DOC, 'deleted');\n      return callback();\n    }\n\n    // 4712 - detect whether a new document was inserted with a _rev\n    var inConflict = newEdits && rootIsMissing(docInfo);\n\n    if (inConflict) {\n      var err = createError(REV_CONFLICT);\n      results[resultsIdx] = err;\n      return callback();\n    }\n\n    var delta = deleted ? 0 : 1;\n\n    writeDoc(docInfo, winningRev$$1, deleted, deleted, false,\n      delta, resultsIdx, callback);\n  }\n\n  var newEdits = opts.new_edits;\n  var idsToDocs = new ExportedMap();\n\n  var docsDone = 0;\n  var docsToDo = docInfos.length;\n\n  function checkAllDocsDone() {\n    if (++docsDone === docsToDo && overallCallback) {\n      overallCallback();\n    }\n  }\n\n  docInfos.forEach(function (currentDoc, resultsIdx) {\n\n    if (currentDoc._id && isLocalId(currentDoc._id)) {\n      var fun = currentDoc._deleted ? '_removeLocal' : '_putLocal';\n      api[fun](currentDoc, {ctx: tx}, function (err, res) {\n        results[resultsIdx] = err || res;\n        checkAllDocsDone();\n      });\n      return;\n    }\n\n    var id = currentDoc.metadata.id;\n    if (idsToDocs.has(id)) {\n      docsToDo--; // duplicate\n      idsToDocs.get(id).push([currentDoc, resultsIdx]);\n    } else {\n      idsToDocs.set(id, [[currentDoc, resultsIdx]]);\n    }\n  });\n\n  // in the case of new_edits, the user can provide multiple docs\n  // with the same id. these need to be processed sequentially\n  idsToDocs.forEach(function (docs, id) {\n    var numDone = 0;\n\n    function docWritten() {\n      if (++numDone < docs.length) {\n        nextDoc();\n      } else {\n        checkAllDocsDone();\n      }\n    }\n    function nextDoc() {\n      var value = docs[numDone];\n      var currentDoc = value[0];\n      var resultsIdx = value[1];\n\n      if (fetchedDocs.has(id)) {\n        updateDoc(revLimit, fetchedDocs.get(id), currentDoc, results,\n          resultsIdx, docWritten, writeDoc, newEdits);\n      } else {\n        // Ensure stemming applies to new writes as well\n        var merged = merge([], currentDoc.metadata.rev_tree[0], revLimit);\n        currentDoc.metadata.rev_tree = merged.tree;\n        currentDoc.stemmedRevs = merged.stemmedRevs || [];\n        insertDoc(currentDoc, resultsIdx, docWritten);\n      }\n    }\n    nextDoc();\n  });\n}\n\n// IndexedDB requires a versioned database structure, so we use the\n// version here to manage migrations.\nvar ADAPTER_VERSION = 5;\n\n// The object stores created for each database\n// DOC_STORE stores the document meta data, its revision history and state\n// Keyed by document id\nvar DOC_STORE = 'document-store';\n// BY_SEQ_STORE stores a particular version of a document, keyed by its\n// sequence id\nvar BY_SEQ_STORE = 'by-sequence';\n// Where we store attachments\nvar ATTACH_STORE = 'attach-store';\n// Where we store many-to-many relations\n// between attachment digests and seqs\nvar ATTACH_AND_SEQ_STORE = 'attach-seq-store';\n\n// Where we store database-wide meta data in a single record\n// keyed by id: META_STORE\nvar META_STORE = 'meta-store';\n// Where we store local documents\nvar LOCAL_STORE = 'local-store';\n// Where we detect blob support\nvar DETECT_BLOB_SUPPORT_STORE = 'detect-blob-support';\n\nfunction safeJsonParse(str) {\n  // This try/catch guards against stack overflow errors.\n  // JSON.parse() is faster than vuvuzela.parse() but vuvuzela\n  // cannot overflow.\n  try {\n    return JSON.parse(str);\n  } catch (e) {\n    /* istanbul ignore next */\n    return vuvuzela.parse(str);\n  }\n}\n\nfunction safeJsonStringify(json) {\n  try {\n    return JSON.stringify(json);\n  } catch (e) {\n    /* istanbul ignore next */\n    return vuvuzela.stringify(json);\n  }\n}\n\nfunction idbError(callback) {\n  return function (evt) {\n    var message = 'unknown_error';\n    if (evt.target && evt.target.error) {\n      message = evt.target.error.name || evt.target.error.message;\n    }\n    callback(createError(IDB_ERROR, message, evt.type));\n  };\n}\n\n// Unfortunately, the metadata has to be stringified\n// when it is put into the database, because otherwise\n// IndexedDB can throw errors for deeply-nested objects.\n// Originally we just used JSON.parse/JSON.stringify; now\n// we use this custom vuvuzela library that avoids recursion.\n// If we could do it all over again, we'd probably use a\n// format for the revision trees other than JSON.\nfunction encodeMetadata(metadata, winningRev, deleted) {\n  return {\n    data: safeJsonStringify(metadata),\n    winningRev: winningRev,\n    deletedOrLocal: deleted ? '1' : '0',\n    seq: metadata.seq, // highest seq for this doc\n    id: metadata.id\n  };\n}\n\nfunction decodeMetadata(storedObject) {\n  if (!storedObject) {\n    return null;\n  }\n  var metadata = safeJsonParse(storedObject.data);\n  metadata.winningRev = storedObject.winningRev;\n  metadata.deleted = storedObject.deletedOrLocal === '1';\n  metadata.seq = storedObject.seq;\n  return metadata;\n}\n\n// read the doc back out from the database. we don't store the\n// _id or _rev because we already have _doc_id_rev.\nfunction decodeDoc(doc) {\n  if (!doc) {\n    return doc;\n  }\n  var idx = doc._doc_id_rev.lastIndexOf(':');\n  doc._id = doc._doc_id_rev.substring(0, idx - 1);\n  doc._rev = doc._doc_id_rev.substring(idx + 1);\n  delete doc._doc_id_rev;\n  return doc;\n}\n\n// Read a blob from the database, encoding as necessary\n// and translating from base64 if the IDB doesn't support\n// native Blobs\nfunction readBlobData(body, type, asBlob, callback) {\n  if (asBlob) {\n    if (!body) {\n      callback(createBlob([''], {type: type}));\n    } else if (typeof body !== 'string') { // we have blob support\n      callback(body);\n    } else { // no blob support\n      callback(b64ToBluffer(body, type));\n    }\n  } else { // as base64 string\n    if (!body) {\n      callback('');\n    } else if (typeof body !== 'string') { // we have blob support\n      readAsBinaryString(body, function (binary) {\n        callback(thisBtoa(binary));\n      });\n    } else { // no blob support\n      callback(body);\n    }\n  }\n}\n\nfunction fetchAttachmentsIfNecessary(doc, opts, txn, cb) {\n  var attachments = Object.keys(doc._attachments || {});\n  if (!attachments.length) {\n    return cb && cb();\n  }\n  var numDone = 0;\n\n  function checkDone() {\n    if (++numDone === attachments.length && cb) {\n      cb();\n    }\n  }\n\n  function fetchAttachment(doc, att) {\n    var attObj = doc._attachments[att];\n    var digest = attObj.digest;\n    var req = txn.objectStore(ATTACH_STORE).get(digest);\n    req.onsuccess = function (e) {\n      attObj.body = e.target.result.body;\n      checkDone();\n    };\n  }\n\n  attachments.forEach(function (att) {\n    if (opts.attachments && opts.include_docs) {\n      fetchAttachment(doc, att);\n    } else {\n      doc._attachments[att].stub = true;\n      checkDone();\n    }\n  });\n}\n\n// IDB-specific postprocessing necessary because\n// we don't know whether we stored a true Blob or\n// a base64-encoded string, and if it's a Blob it\n// needs to be read outside of the transaction context\nfunction postProcessAttachments(results, asBlob) {\n  return PouchPromise$1.all(results.map(function (row) {\n    if (row.doc && row.doc._attachments) {\n      var attNames = Object.keys(row.doc._attachments);\n      return PouchPromise$1.all(attNames.map(function (att) {\n        var attObj = row.doc._attachments[att];\n        if (!('body' in attObj)) { // already processed\n          return;\n        }\n        var body = attObj.body;\n        var type = attObj.content_type;\n        return new PouchPromise$1(function (resolve) {\n          readBlobData(body, type, asBlob, function (data) {\n            row.doc._attachments[att] = $inject_Object_assign(\n              pick(attObj, ['digest', 'content_type']),\n              {data: data}\n            );\n            resolve();\n          });\n        });\n      }));\n    }\n  }));\n}\n\nfunction compactRevs(revs, docId, txn) {\n\n  var possiblyOrphanedDigests = [];\n  var seqStore = txn.objectStore(BY_SEQ_STORE);\n  var attStore = txn.objectStore(ATTACH_STORE);\n  var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n  var count = revs.length;\n\n  function checkDone() {\n    count--;\n    if (!count) { // done processing all revs\n      deleteOrphanedAttachments();\n    }\n  }\n\n  function deleteOrphanedAttachments() {\n    if (!possiblyOrphanedDigests.length) {\n      return;\n    }\n    possiblyOrphanedDigests.forEach(function (digest) {\n      var countReq = attAndSeqStore.index('digestSeq').count(\n        IDBKeyRange.bound(\n          digest + '::', digest + '::\\uffff', false, false));\n      countReq.onsuccess = function (e) {\n        var count = e.target.result;\n        if (!count) {\n          // orphaned\n          attStore.delete(digest);\n        }\n      };\n    });\n  }\n\n  revs.forEach(function (rev$$1) {\n    var index = seqStore.index('_doc_id_rev');\n    var key = docId + \"::\" + rev$$1;\n    index.getKey(key).onsuccess = function (e) {\n      var seq = e.target.result;\n      if (typeof seq !== 'number') {\n        return checkDone();\n      }\n      seqStore.delete(seq);\n\n      var cursor = attAndSeqStore.index('seq')\n        .openCursor(IDBKeyRange.only(seq));\n\n      cursor.onsuccess = function (event) {\n        var cursor = event.target.result;\n        if (cursor) {\n          var digest = cursor.value.digestSeq.split('::')[0];\n          possiblyOrphanedDigests.push(digest);\n          attAndSeqStore.delete(cursor.primaryKey);\n          cursor.continue();\n        } else { // done\n          checkDone();\n        }\n      };\n    };\n  });\n}\n\nfunction openTransactionSafely(idb, stores, mode) {\n  try {\n    return {\n      txn: idb.transaction(stores, mode)\n    };\n  } catch (err) {\n    return {\n      error: err\n    };\n  }\n}\n\nvar changesHandler = new Changes();\n\nfunction idbBulkDocs(dbOpts, req, opts, api, idb, callback) {\n  var docInfos = req.docs;\n  var txn;\n  var docStore;\n  var bySeqStore;\n  var attachStore;\n  var attachAndSeqStore;\n  var metaStore;\n  var docInfoError;\n  var metaDoc;\n\n  for (var i = 0, len = docInfos.length; i < len; i++) {\n    var doc = docInfos[i];\n    if (doc._id && isLocalId(doc._id)) {\n      continue;\n    }\n    doc = docInfos[i] = parseDoc(doc, opts.new_edits);\n    if (doc.error && !docInfoError) {\n      docInfoError = doc;\n    }\n  }\n\n  if (docInfoError) {\n    return callback(docInfoError);\n  }\n\n  var allDocsProcessed = false;\n  var docCountDelta = 0;\n  var results = new Array(docInfos.length);\n  var fetchedDocs = new ExportedMap();\n  var preconditionErrored = false;\n  var blobType = api._meta.blobSupport ? 'blob' : 'base64';\n\n  preprocessAttachments(docInfos, blobType, function (err) {\n    if (err) {\n      return callback(err);\n    }\n    startTransaction();\n  });\n\n  function startTransaction() {\n\n    var stores = [\n      DOC_STORE, BY_SEQ_STORE,\n      ATTACH_STORE,\n      LOCAL_STORE, ATTACH_AND_SEQ_STORE,\n      META_STORE\n    ];\n    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    txn = txnResult.txn;\n    txn.onabort = idbError(callback);\n    txn.ontimeout = idbError(callback);\n    txn.oncomplete = complete;\n    docStore = txn.objectStore(DOC_STORE);\n    bySeqStore = txn.objectStore(BY_SEQ_STORE);\n    attachStore = txn.objectStore(ATTACH_STORE);\n    attachAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n    metaStore = txn.objectStore(META_STORE);\n\n    metaStore.get(META_STORE).onsuccess = function (e) {\n      metaDoc = e.target.result;\n      updateDocCountIfReady();\n    };\n\n    verifyAttachments(function (err) {\n      if (err) {\n        preconditionErrored = true;\n        return callback(err);\n      }\n      fetchExistingDocs();\n    });\n  }\n\n  function onAllDocsProcessed() {\n    allDocsProcessed = true;\n    updateDocCountIfReady();\n  }\n\n  function idbProcessDocs() {\n    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs,\n                txn, results, writeDoc, opts, onAllDocsProcessed);\n  }\n\n  function updateDocCountIfReady() {\n    if (!metaDoc || !allDocsProcessed) {\n      return;\n    }\n    // caching the docCount saves a lot of time in allDocs() and\n    // info(), which is why we go to all the trouble of doing this\n    metaDoc.docCount += docCountDelta;\n    metaStore.put(metaDoc);\n  }\n\n  function fetchExistingDocs() {\n\n    if (!docInfos.length) {\n      return;\n    }\n\n    var numFetched = 0;\n\n    function checkDone() {\n      if (++numFetched === docInfos.length) {\n        idbProcessDocs();\n      }\n    }\n\n    function readMetadata(event) {\n      var metadata = decodeMetadata(event.target.result);\n\n      if (metadata) {\n        fetchedDocs.set(metadata.id, metadata);\n      }\n      checkDone();\n    }\n\n    for (var i = 0, len = docInfos.length; i < len; i++) {\n      var docInfo = docInfos[i];\n      if (docInfo._id && isLocalId(docInfo._id)) {\n        checkDone(); // skip local docs\n        continue;\n      }\n      var req = docStore.get(docInfo.metadata.id);\n      req.onsuccess = readMetadata;\n    }\n  }\n\n  function complete() {\n    if (preconditionErrored) {\n      return;\n    }\n\n    changesHandler.notify(api._meta.name);\n    callback(null, results);\n  }\n\n  function verifyAttachment(digest, callback) {\n\n    var req = attachStore.get(digest);\n    req.onsuccess = function (e) {\n      if (!e.target.result) {\n        var err = createError(MISSING_STUB,\n          'unknown stub attachment with digest ' +\n          digest);\n        err.status = 412;\n        callback(err);\n      } else {\n        callback();\n      }\n    };\n  }\n\n  function verifyAttachments(finish) {\n\n\n    var digests = [];\n    docInfos.forEach(function (docInfo) {\n      if (docInfo.data && docInfo.data._attachments) {\n        Object.keys(docInfo.data._attachments).forEach(function (filename) {\n          var att = docInfo.data._attachments[filename];\n          if (att.stub) {\n            digests.push(att.digest);\n          }\n        });\n      }\n    });\n    if (!digests.length) {\n      return finish();\n    }\n    var numDone = 0;\n    var err;\n\n    function checkDone() {\n      if (++numDone === digests.length) {\n        finish(err);\n      }\n    }\n    digests.forEach(function (digest) {\n      verifyAttachment(digest, function (attErr) {\n        if (attErr && !err) {\n          err = attErr;\n        }\n        checkDone();\n      });\n    });\n  }\n\n  function writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n                    isUpdate, delta, resultsIdx, callback) {\n\n    docInfo.metadata.winningRev = winningRev$$1;\n    docInfo.metadata.deleted = winningRevIsDeleted;\n\n    var doc = docInfo.data;\n    doc._id = docInfo.metadata.id;\n    doc._rev = docInfo.metadata.rev;\n\n    if (newRevIsDeleted) {\n      doc._deleted = true;\n    }\n\n    var hasAttachments = doc._attachments &&\n      Object.keys(doc._attachments).length;\n    if (hasAttachments) {\n      return writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,\n        isUpdate, resultsIdx, callback);\n    }\n\n    docCountDelta += delta;\n    updateDocCountIfReady();\n\n    finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n      isUpdate, resultsIdx, callback);\n  }\n\n  function finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n                     isUpdate, resultsIdx, callback) {\n\n    var doc = docInfo.data;\n    var metadata = docInfo.metadata;\n\n    doc._doc_id_rev = metadata.id + '::' + metadata.rev;\n    delete doc._id;\n    delete doc._rev;\n\n    function afterPutDoc(e) {\n      var revsToDelete = docInfo.stemmedRevs || [];\n\n      if (isUpdate && api.auto_compaction) {\n        revsToDelete = revsToDelete.concat(compactTree(docInfo.metadata));\n      }\n\n      if (revsToDelete && revsToDelete.length) {\n        compactRevs(revsToDelete, docInfo.metadata.id, txn);\n      }\n\n      metadata.seq = e.target.result;\n      // Current _rev is calculated from _rev_tree on read\n      // delete metadata.rev;\n      var metadataToStore = encodeMetadata(metadata, winningRev$$1,\n        winningRevIsDeleted);\n      var metaDataReq = docStore.put(metadataToStore);\n      metaDataReq.onsuccess = afterPutMetadata;\n    }\n\n    function afterPutDocError(e) {\n      // ConstraintError, need to update, not put (see #1638 for details)\n      e.preventDefault(); // avoid transaction abort\n      e.stopPropagation(); // avoid transaction onerror\n      var index = bySeqStore.index('_doc_id_rev');\n      var getKeyReq = index.getKey(doc._doc_id_rev);\n      getKeyReq.onsuccess = function (e) {\n        var putReq = bySeqStore.put(doc, e.target.result);\n        putReq.onsuccess = afterPutDoc;\n      };\n    }\n\n    function afterPutMetadata() {\n      results[resultsIdx] = {\n        ok: true,\n        id: metadata.id,\n        rev: metadata.rev\n      };\n      fetchedDocs.set(docInfo.metadata.id, docInfo.metadata);\n      insertAttachmentMappings(docInfo, metadata.seq, callback);\n    }\n\n    var putReq = bySeqStore.put(doc);\n\n    putReq.onsuccess = afterPutDoc;\n    putReq.onerror = afterPutDocError;\n  }\n\n  function writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,\n                            isUpdate, resultsIdx, callback) {\n\n\n    var doc = docInfo.data;\n\n    var numDone = 0;\n    var attachments = Object.keys(doc._attachments);\n\n    function collectResults() {\n      if (numDone === attachments.length) {\n        finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n          isUpdate, resultsIdx, callback);\n      }\n    }\n\n    function attachmentSaved() {\n      numDone++;\n      collectResults();\n    }\n\n    attachments.forEach(function (key) {\n      var att = docInfo.data._attachments[key];\n      if (!att.stub) {\n        var data = att.data;\n        delete att.data;\n        att.revpos = parseInt(winningRev$$1, 10);\n        var digest = att.digest;\n        saveAttachment(digest, data, attachmentSaved);\n      } else {\n        numDone++;\n        collectResults();\n      }\n    });\n  }\n\n  // map seqs to attachment digests, which\n  // we will need later during compaction\n  function insertAttachmentMappings(docInfo, seq, callback) {\n\n    var attsAdded = 0;\n    var attsToAdd = Object.keys(docInfo.data._attachments || {});\n\n    if (!attsToAdd.length) {\n      return callback();\n    }\n\n    function checkDone() {\n      if (++attsAdded === attsToAdd.length) {\n        callback();\n      }\n    }\n\n    function add(att) {\n      var digest = docInfo.data._attachments[att].digest;\n      var req = attachAndSeqStore.put({\n        seq: seq,\n        digestSeq: digest + '::' + seq\n      });\n\n      req.onsuccess = checkDone;\n      req.onerror = function (e) {\n        // this callback is for a constaint error, which we ignore\n        // because this docid/rev has already been associated with\n        // the digest (e.g. when new_edits == false)\n        e.preventDefault(); // avoid transaction abort\n        e.stopPropagation(); // avoid transaction onerror\n        checkDone();\n      };\n    }\n    for (var i = 0; i < attsToAdd.length; i++) {\n      add(attsToAdd[i]); // do in parallel\n    }\n  }\n\n  function saveAttachment(digest, data, callback) {\n\n\n    var getKeyReq = attachStore.count(digest);\n    getKeyReq.onsuccess = function (e) {\n      var count = e.target.result;\n      if (count) {\n        return callback(); // already exists\n      }\n      var newAtt = {\n        digest: digest,\n        body: data\n      };\n      var putReq = attachStore.put(newAtt);\n      putReq.onsuccess = callback;\n    };\n  }\n}\n\n// Abstraction over IDBCursor and getAll()/getAllKeys() that allows us to batch our operations\n// while falling back to a normal IDBCursor operation on browsers that don't support getAll() or\n// getAllKeys(). This allows for a much faster implementation than just straight-up cursors, because\n// we're not processing each document one-at-a-time.\nfunction runBatchedCursor(objectStore, keyRange, descending, batchSize, onBatch) {\n\n  // Bail out of getAll()/getAllKeys() in the following cases:\n  // 1) either method is unsupported - we need both\n  // 2) batchSize is 1 (might as well use IDBCursor), or batchSize is -1 (i.e. batchSize unlimited,\n  //    not really clear the user wants a batched approach where the entire DB is read into memory,\n  //    perhaps they are filtering on a per-doc basis)\n  // 3) descending – no real way to do this via getAll()/getAllKeys()\n\n  var useGetAll = typeof objectStore.getAll === 'function' &&\n    typeof objectStore.getAllKeys === 'function' &&\n    batchSize > 1 && !descending;\n\n  var keysBatch;\n  var valuesBatch;\n  var pseudoCursor;\n\n  function onGetAll(e) {\n    valuesBatch = e.target.result;\n    if (keysBatch) {\n      onBatch(keysBatch, valuesBatch, pseudoCursor);\n    }\n  }\n\n  function onGetAllKeys(e) {\n    keysBatch = e.target.result;\n    if (valuesBatch) {\n      onBatch(keysBatch, valuesBatch, pseudoCursor);\n    }\n  }\n\n  function continuePseudoCursor() {\n    if (!keysBatch.length) { // no more results\n      return onBatch();\n    }\n    // fetch next batch, exclusive start\n    var lastKey = keysBatch[keysBatch.length - 1];\n    var newKeyRange;\n    if (keyRange && keyRange.upper) {\n      try {\n        newKeyRange = IDBKeyRange.bound(lastKey, keyRange.upper,\n          true, keyRange.upperOpen);\n      } catch (e) {\n        if (e.name === \"DataError\" && e.code === 0) {\n          return onBatch(); // we're done, startkey and endkey are equal\n        }\n      }\n    } else {\n      newKeyRange = IDBKeyRange.lowerBound(lastKey, true);\n    }\n    keyRange = newKeyRange;\n    keysBatch = null;\n    valuesBatch = null;\n    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;\n    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;\n  }\n\n  function onCursor(e) {\n    var cursor = e.target.result;\n    if (!cursor) { // done\n      return onBatch();\n    }\n    // regular IDBCursor acts like a batch where batch size is always 1\n    onBatch([cursor.key], [cursor.value], cursor);\n  }\n\n  if (useGetAll) {\n    pseudoCursor = {\"continue\": continuePseudoCursor};\n    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;\n    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;\n  } else if (descending) {\n    objectStore.openCursor(keyRange, 'prev').onsuccess = onCursor;\n  } else {\n    objectStore.openCursor(keyRange).onsuccess = onCursor;\n  }\n}\n\n// simple shim for objectStore.getAll(), falling back to IDBCursor\nfunction getAll(objectStore, keyRange, onSuccess) {\n  if (typeof objectStore.getAll === 'function') {\n    // use native getAll\n    objectStore.getAll(keyRange).onsuccess = onSuccess;\n    return;\n  }\n  // fall back to cursors\n  var values = [];\n\n  function onCursor(e) {\n    var cursor = e.target.result;\n    if (cursor) {\n      values.push(cursor.value);\n      cursor.continue();\n    } else {\n      onSuccess({\n        target: {\n          result: values\n        }\n      });\n    }\n  }\n\n  objectStore.openCursor(keyRange).onsuccess = onCursor;\n}\n\nfunction createKeyRange(start, end, inclusiveEnd, key, descending) {\n  try {\n    if (start && end) {\n      if (descending) {\n        return IDBKeyRange.bound(end, start, !inclusiveEnd, false);\n      } else {\n        return IDBKeyRange.bound(start, end, false, !inclusiveEnd);\n      }\n    } else if (start) {\n      if (descending) {\n        return IDBKeyRange.upperBound(start);\n      } else {\n        return IDBKeyRange.lowerBound(start);\n      }\n    } else if (end) {\n      if (descending) {\n        return IDBKeyRange.lowerBound(end, !inclusiveEnd);\n      } else {\n        return IDBKeyRange.upperBound(end, !inclusiveEnd);\n      }\n    } else if (key) {\n      return IDBKeyRange.only(key);\n    }\n  } catch (e) {\n    return {error: e};\n  }\n  return null;\n}\n\nfunction idbAllDocs(opts, idb, callback) {\n  var start = 'startkey' in opts ? opts.startkey : false;\n  var end = 'endkey' in opts ? opts.endkey : false;\n  var key = 'key' in opts ? opts.key : false;\n  var skip = opts.skip || 0;\n  var limit = typeof opts.limit === 'number' ? opts.limit : -1;\n  var inclusiveEnd = opts.inclusive_end !== false;\n\n  var keyRange = createKeyRange(start, end, inclusiveEnd, key, opts.descending);\n  var keyRangeError = keyRange && keyRange.error;\n  if (keyRangeError && !(keyRangeError.name === \"DataError\" &&\n      keyRangeError.code === 0)) {\n    // DataError with error code 0 indicates start is less than end, so\n    // can just do an empty query. Else need to throw\n    return callback(createError(IDB_ERROR,\n      keyRangeError.name, keyRangeError.message));\n  }\n\n  var stores = [DOC_STORE, BY_SEQ_STORE, META_STORE];\n\n  if (opts.attachments) {\n    stores.push(ATTACH_STORE);\n  }\n  var txnResult = openTransactionSafely(idb, stores, 'readonly');\n  if (txnResult.error) {\n    return callback(txnResult.error);\n  }\n  var txn = txnResult.txn;\n  txn.oncomplete = onTxnComplete;\n  txn.onabort = idbError(callback);\n  var docStore = txn.objectStore(DOC_STORE);\n  var seqStore = txn.objectStore(BY_SEQ_STORE);\n  var metaStore = txn.objectStore(META_STORE);\n  var docIdRevIndex = seqStore.index('_doc_id_rev');\n  var results = [];\n  var docCount;\n\n  metaStore.get(META_STORE).onsuccess = function (e) {\n    docCount = e.target.result.docCount;\n  };\n\n  // if the user specifies include_docs=true, then we don't\n  // want to block the main cursor while we're fetching the doc\n  function fetchDocAsynchronously(metadata, row, winningRev$$1) {\n    var key = metadata.id + \"::\" + winningRev$$1;\n    docIdRevIndex.get(key).onsuccess =  function onGetDoc(e) {\n      row.doc = decodeDoc(e.target.result);\n      if (opts.conflicts) {\n        var conflicts = collectConflicts(metadata);\n        if (conflicts.length) {\n          row.doc._conflicts = conflicts;\n        }\n      }\n      fetchAttachmentsIfNecessary(row.doc, opts, txn);\n    };\n  }\n\n  function allDocsInner(winningRev$$1, metadata) {\n    var row = {\n      id: metadata.id,\n      key: metadata.id,\n      value: {\n        rev: winningRev$$1\n      }\n    };\n    var deleted = metadata.deleted;\n    if (opts.deleted === 'ok') {\n      results.push(row);\n      // deleted docs are okay with \"keys\" requests\n      if (deleted) {\n        row.value.deleted = true;\n        row.doc = null;\n      } else if (opts.include_docs) {\n        fetchDocAsynchronously(metadata, row, winningRev$$1);\n      }\n    } else if (!deleted && skip-- <= 0) {\n      results.push(row);\n      if (opts.include_docs) {\n        fetchDocAsynchronously(metadata, row, winningRev$$1);\n      }\n    }\n  }\n\n  function processBatch(batchValues) {\n    for (var i = 0, len = batchValues.length; i < len; i++) {\n      if (results.length === limit) {\n        break;\n      }\n      var batchValue = batchValues[i];\n      var metadata = decodeMetadata(batchValue);\n      var winningRev$$1 = metadata.winningRev;\n      allDocsInner(winningRev$$1, metadata);\n    }\n  }\n\n  function onBatch(batchKeys, batchValues, cursor) {\n    if (!cursor) {\n      return;\n    }\n    processBatch(batchValues);\n    if (results.length < limit) {\n      cursor.continue();\n    }\n  }\n\n  function onGetAll(e) {\n    var values = e.target.result;\n    if (opts.descending) {\n      values = values.reverse();\n    }\n    processBatch(values);\n  }\n\n  function onResultsReady() {\n    callback(null, {\n      total_rows: docCount,\n      offset: opts.skip,\n      rows: results\n    });\n  }\n\n  function onTxnComplete() {\n    if (opts.attachments) {\n      postProcessAttachments(results, opts.binary).then(onResultsReady);\n    } else {\n      onResultsReady();\n    }\n  }\n\n  // don't bother doing any requests if start > end or limit === 0\n  if (keyRangeError || limit === 0) {\n    return;\n  }\n  if (limit === -1) { // just fetch everything\n    return getAll(docStore, keyRange, onGetAll);\n  }\n  // else do a cursor\n  // choose a batch size based on the skip, since we'll need to skip that many\n  runBatchedCursor(docStore, keyRange, opts.descending, limit + skip, onBatch);\n}\n\n//\n// Blobs are not supported in all versions of IndexedDB, notably\n// Chrome <37 and Android <5. In those versions, storing a blob will throw.\n//\n// Various other blob bugs exist in Chrome v37-42 (inclusive).\n// Detecting them is expensive and confusing to users, and Chrome 37-42\n// is at very low usage worldwide, so we do a hacky userAgent check instead.\n//\n// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n//\nfunction checkBlobSupport(txn) {\n  return new PouchPromise$1(function (resolve) {\n    var blob = createBlob(['']);\n    var req = txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');\n\n    req.onsuccess = function () {\n      var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n      var matchedEdge = navigator.userAgent.match(/Edge\\//);\n      // MS Edge pretends to be Chrome 42:\n      // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n      resolve(matchedEdge || !matchedChrome ||\n        parseInt(matchedChrome[1], 10) >= 43);\n    };\n\n    txn.onabort = function (e) {\n      // If the transaction aborts now its due to not being able to\n      // write to the database, likely due to the disk being full\n      e.preventDefault();\n      e.stopPropagation();\n      resolve(false);\n    };\n  }).catch(function () {\n    return false; // error, so assume unsupported\n  });\n}\n\nfunction countDocs(txn, cb) {\n  var index = txn.objectStore(DOC_STORE).index('deletedOrLocal');\n  index.count(IDBKeyRange.only('0')).onsuccess = function (e) {\n    cb(e.target.result);\n  };\n}\n\n// This task queue ensures that IDB open calls are done in their own tick\n// and sequentially - i.e. we wait for the async IDB open to *fully* complete\n// before calling the next one. This works around IE/Edge race conditions in IDB.\n\nvar running = false;\nvar queue = [];\n\nfunction tryCode(fun, err, res, PouchDB) {\n  try {\n    fun(err, res);\n  } catch (err) {\n    // Shouldn't happen, but in some odd cases\n    // IndexedDB implementations might throw a sync\n    // error, in which case this will at least log it.\n    PouchDB.emit('error', err);\n  }\n}\n\nfunction applyNext() {\n  if (running || !queue.length) {\n    return;\n  }\n  running = true;\n  queue.shift()();\n}\n\nfunction enqueueTask(action, callback, PouchDB) {\n  queue.push(function runAction() {\n    action(function runCallback(err, res) {\n      tryCode(callback, err, res, PouchDB);\n      running = false;\n      nextTick(function runNext() {\n        applyNext(PouchDB);\n      });\n    });\n  });\n  applyNext();\n}\n\nfunction changes(opts, api, dbName, idb) {\n  opts = clone(opts);\n\n  if (opts.continuous) {\n    var id = dbName + ':' + uuid();\n    changesHandler.addListener(dbName, id, api, opts);\n    changesHandler.notify(dbName);\n    return {\n      cancel: function () {\n        changesHandler.removeListener(dbName, id);\n      }\n    };\n  }\n\n  var docIds = opts.doc_ids && new ExportedSet(opts.doc_ids);\n\n  opts.since = opts.since || 0;\n  var lastSeq = opts.since;\n\n  var limit = 'limit' in opts ? opts.limit : -1;\n  if (limit === 0) {\n    limit = 1; // per CouchDB _changes spec\n  }\n  var returnDocs;\n  if ('return_docs' in opts) {\n    returnDocs = opts.return_docs;\n  } else if ('returnDocs' in opts) {\n    // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n    returnDocs = opts.returnDocs;\n  } else {\n    returnDocs = true;\n  }\n\n  var results = [];\n  var numResults = 0;\n  var filter = filterChange(opts);\n  var docIdsToMetadata = new ExportedMap();\n\n  var txn;\n  var bySeqStore;\n  var docStore;\n  var docIdRevIndex;\n\n  function onBatch(batchKeys, batchValues, cursor) {\n    if (!cursor || !batchKeys.length) { // done\n      return;\n    }\n\n    var winningDocs = new Array(batchKeys.length);\n    var metadatas = new Array(batchKeys.length);\n\n    function processMetadataAndWinningDoc(metadata, winningDoc) {\n      var change = opts.processChange(winningDoc, metadata, opts);\n      lastSeq = change.seq = metadata.seq;\n\n      var filtered = filter(change);\n      if (typeof filtered === 'object') { // anything but true/false indicates error\n        return opts.complete(filtered);\n      }\n\n      if (filtered) {\n        numResults++;\n        if (returnDocs) {\n          results.push(change);\n        }\n        // process the attachment immediately\n        // for the benefit of live listeners\n        if (opts.attachments && opts.include_docs) {\n          fetchAttachmentsIfNecessary(winningDoc, opts, txn, function () {\n            postProcessAttachments([change], opts.binary).then(function () {\n              opts.onChange(change);\n            });\n          });\n        } else {\n          opts.onChange(change);\n        }\n      }\n    }\n\n    function onBatchDone() {\n      for (var i = 0, len = winningDocs.length; i < len; i++) {\n        if (numResults === limit) {\n          break;\n        }\n        var winningDoc = winningDocs[i];\n        if (!winningDoc) {\n          continue;\n        }\n        var metadata = metadatas[i];\n        processMetadataAndWinningDoc(metadata, winningDoc);\n      }\n\n      if (numResults !== limit) {\n        cursor.continue();\n      }\n    }\n\n    // Fetch all metadatas/winningdocs from this batch in parallel, then process\n    // them all only once all data has been collected. This is done in parallel\n    // because it's faster than doing it one-at-a-time.\n    var numDone = 0;\n    batchValues.forEach(function (value, i) {\n      var doc = decodeDoc(value);\n      var seq = batchKeys[i];\n      fetchWinningDocAndMetadata(doc, seq, function (metadata, winningDoc) {\n        metadatas[i] = metadata;\n        winningDocs[i] = winningDoc;\n        if (++numDone === batchKeys.length) {\n          onBatchDone();\n        }\n      });\n    });\n  }\n\n  function onGetMetadata(doc, seq, metadata, cb) {\n    if (metadata.seq !== seq) {\n      // some other seq is later\n      return cb();\n    }\n\n    if (metadata.winningRev === doc._rev) {\n      // this is the winning doc\n      return cb(metadata, doc);\n    }\n\n    // fetch winning doc in separate request\n    var docIdRev = doc._id + '::' + metadata.winningRev;\n    var req = docIdRevIndex.get(docIdRev);\n    req.onsuccess = function (e) {\n      cb(metadata, decodeDoc(e.target.result));\n    };\n  }\n\n  function fetchWinningDocAndMetadata(doc, seq, cb) {\n    if (docIds && !docIds.has(doc._id)) {\n      return cb();\n    }\n\n    var metadata = docIdsToMetadata.get(doc._id);\n    if (metadata) { // cached\n      return onGetMetadata(doc, seq, metadata, cb);\n    }\n    // metadata not cached, have to go fetch it\n    docStore.get(doc._id).onsuccess = function (e) {\n      metadata = decodeMetadata(e.target.result);\n      docIdsToMetadata.set(doc._id, metadata);\n      onGetMetadata(doc, seq, metadata, cb);\n    };\n  }\n\n  function finish() {\n    opts.complete(null, {\n      results: results,\n      last_seq: lastSeq\n    });\n  }\n\n  function onTxnComplete() {\n    if (!opts.continuous && opts.attachments) {\n      // cannot guarantee that postProcessing was already done,\n      // so do it again\n      postProcessAttachments(results).then(finish);\n    } else {\n      finish();\n    }\n  }\n\n  var objectStores = [DOC_STORE, BY_SEQ_STORE];\n  if (opts.attachments) {\n    objectStores.push(ATTACH_STORE);\n  }\n  var txnResult = openTransactionSafely(idb, objectStores, 'readonly');\n  if (txnResult.error) {\n    return opts.complete(txnResult.error);\n  }\n  txn = txnResult.txn;\n  txn.onabort = idbError(opts.complete);\n  txn.oncomplete = onTxnComplete;\n\n  bySeqStore = txn.objectStore(BY_SEQ_STORE);\n  docStore = txn.objectStore(DOC_STORE);\n  docIdRevIndex = bySeqStore.index('_doc_id_rev');\n\n  var keyRange = (opts.since && !opts.descending) ?\n    IDBKeyRange.lowerBound(opts.since, true) : null;\n\n  runBatchedCursor(bySeqStore, keyRange, opts.descending, limit, onBatch);\n}\n\nvar cachedDBs = new ExportedMap();\nvar blobSupportPromise;\nvar openReqList = new ExportedMap();\n\nfunction IdbPouch(opts, callback) {\n  var api = this;\n\n  enqueueTask(function (thisCallback) {\n    init(api, opts, thisCallback);\n  }, callback, api.constructor);\n}\n\nfunction init(api, opts, callback) {\n\n  var dbName = opts.name;\n\n  var idb = null;\n  api._meta = null;\n\n  // called when creating a fresh new database\n  function createSchema(db) {\n    var docStore = db.createObjectStore(DOC_STORE, {keyPath : 'id'});\n    db.createObjectStore(BY_SEQ_STORE, {autoIncrement: true})\n      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n    db.createObjectStore(ATTACH_STORE, {keyPath: 'digest'});\n    db.createObjectStore(META_STORE, {keyPath: 'id', autoIncrement: false});\n    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n\n    // added in v2\n    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});\n\n    // added in v3\n    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'});\n\n    // added in v4\n    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,\n      {autoIncrement: true});\n    attAndSeqStore.createIndex('seq', 'seq');\n    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});\n  }\n\n  // migration to version 2\n  // unfortunately \"deletedOrLocal\" is a misnomer now that we no longer\n  // store local docs in the main doc-store, but whaddyagonnado\n  function addDeletedOrLocalIndex(txn, callback) {\n    var docStore = txn.objectStore(DOC_STORE);\n    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});\n\n    docStore.openCursor().onsuccess = function (event) {\n      var cursor = event.target.result;\n      if (cursor) {\n        var metadata = cursor.value;\n        var deleted = isDeleted(metadata);\n        metadata.deletedOrLocal = deleted ? \"1\" : \"0\";\n        docStore.put(metadata);\n        cursor.continue();\n      } else {\n        callback();\n      }\n    };\n  }\n\n  // migration to version 3 (part 1)\n  function createLocalStoreSchema(db) {\n    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'})\n      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n  }\n\n  // migration to version 3 (part 2)\n  function migrateLocalStore(txn, cb) {\n    var localStore = txn.objectStore(LOCAL_STORE);\n    var docStore = txn.objectStore(DOC_STORE);\n    var seqStore = txn.objectStore(BY_SEQ_STORE);\n\n    var cursor = docStore.openCursor();\n    cursor.onsuccess = function (event) {\n      var cursor = event.target.result;\n      if (cursor) {\n        var metadata = cursor.value;\n        var docId = metadata.id;\n        var local = isLocalId(docId);\n        var rev$$1 = winningRev(metadata);\n        if (local) {\n          var docIdRev = docId + \"::\" + rev$$1;\n          // remove all seq entries\n          // associated with this docId\n          var start = docId + \"::\";\n          var end = docId + \"::~\";\n          var index = seqStore.index('_doc_id_rev');\n          var range = IDBKeyRange.bound(start, end, false, false);\n          var seqCursor = index.openCursor(range);\n          seqCursor.onsuccess = function (e) {\n            seqCursor = e.target.result;\n            if (!seqCursor) {\n              // done\n              docStore.delete(cursor.primaryKey);\n              cursor.continue();\n            } else {\n              var data = seqCursor.value;\n              if (data._doc_id_rev === docIdRev) {\n                localStore.put(data);\n              }\n              seqStore.delete(seqCursor.primaryKey);\n              seqCursor.continue();\n            }\n          };\n        } else {\n          cursor.continue();\n        }\n      } else if (cb) {\n        cb();\n      }\n    };\n  }\n\n  // migration to version 4 (part 1)\n  function addAttachAndSeqStore(db) {\n    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,\n      {autoIncrement: true});\n    attAndSeqStore.createIndex('seq', 'seq');\n    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});\n  }\n\n  // migration to version 4 (part 2)\n  function migrateAttsAndSeqs(txn, callback) {\n    var seqStore = txn.objectStore(BY_SEQ_STORE);\n    var attStore = txn.objectStore(ATTACH_STORE);\n    var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n\n    // need to actually populate the table. this is the expensive part,\n    // so as an optimization, check first that this database even\n    // contains attachments\n    var req = attStore.count();\n    req.onsuccess = function (e) {\n      var count = e.target.result;\n      if (!count) {\n        return callback(); // done\n      }\n\n      seqStore.openCursor().onsuccess = function (e) {\n        var cursor = e.target.result;\n        if (!cursor) {\n          return callback(); // done\n        }\n        var doc = cursor.value;\n        var seq = cursor.primaryKey;\n        var atts = Object.keys(doc._attachments || {});\n        var digestMap = {};\n        for (var j = 0; j < atts.length; j++) {\n          var att = doc._attachments[atts[j]];\n          digestMap[att.digest] = true; // uniq digests, just in case\n        }\n        var digests = Object.keys(digestMap);\n        for (j = 0; j < digests.length; j++) {\n          var digest = digests[j];\n          attAndSeqStore.put({\n            seq: seq,\n            digestSeq: digest + '::' + seq\n          });\n        }\n        cursor.continue();\n      };\n    };\n  }\n\n  // migration to version 5\n  // Instead of relying on on-the-fly migration of metadata,\n  // this brings the doc-store to its modern form:\n  // - metadata.winningrev\n  // - metadata.seq\n  // - stringify the metadata when storing it\n  function migrateMetadata(txn) {\n\n    function decodeMetadataCompat(storedObject) {\n      if (!storedObject.data) {\n        // old format, when we didn't store it stringified\n        storedObject.deleted = storedObject.deletedOrLocal === '1';\n        return storedObject;\n      }\n      return decodeMetadata(storedObject);\n    }\n\n    // ensure that every metadata has a winningRev and seq,\n    // which was previously created on-the-fly but better to migrate\n    var bySeqStore = txn.objectStore(BY_SEQ_STORE);\n    var docStore = txn.objectStore(DOC_STORE);\n    var cursor = docStore.openCursor();\n    cursor.onsuccess = function (e) {\n      var cursor = e.target.result;\n      if (!cursor) {\n        return; // done\n      }\n      var metadata = decodeMetadataCompat(cursor.value);\n\n      metadata.winningRev = metadata.winningRev ||\n        winningRev(metadata);\n\n      function fetchMetadataSeq() {\n        // metadata.seq was added post-3.2.0, so if it's missing,\n        // we need to fetch it manually\n        var start = metadata.id + '::';\n        var end = metadata.id + '::\\uffff';\n        var req = bySeqStore.index('_doc_id_rev').openCursor(\n          IDBKeyRange.bound(start, end));\n\n        var metadataSeq = 0;\n        req.onsuccess = function (e) {\n          var cursor = e.target.result;\n          if (!cursor) {\n            metadata.seq = metadataSeq;\n            return onGetMetadataSeq();\n          }\n          var seq = cursor.primaryKey;\n          if (seq > metadataSeq) {\n            metadataSeq = seq;\n          }\n          cursor.continue();\n        };\n      }\n\n      function onGetMetadataSeq() {\n        var metadataToStore = encodeMetadata(metadata,\n          metadata.winningRev, metadata.deleted);\n\n        var req = docStore.put(metadataToStore);\n        req.onsuccess = function () {\n          cursor.continue();\n        };\n      }\n\n      if (metadata.seq) {\n        return onGetMetadataSeq();\n      }\n\n      fetchMetadataSeq();\n    };\n\n  }\n\n  api._remote = false;\n  api.type = function () {\n    return 'idb';\n  };\n\n  api._id = toPromise(function (callback) {\n    callback(null, api._meta.instanceId);\n  });\n\n  api._bulkDocs = function idb_bulkDocs(req, reqOpts, callback) {\n    idbBulkDocs(opts, req, reqOpts, api, idb, callback);\n  };\n\n  // First we look up the metadata in the ids database, then we fetch the\n  // current revision(s) from the by sequence store\n  api._get = function idb_get(id, opts, callback) {\n    var doc;\n    var metadata;\n    var err;\n    var txn = opts.ctx;\n    if (!txn) {\n      var txnResult = openTransactionSafely(idb,\n        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      txn = txnResult.txn;\n    }\n\n    function finish() {\n      callback(err, {doc: doc, metadata: metadata, ctx: txn});\n    }\n\n    txn.objectStore(DOC_STORE).get(id).onsuccess = function (e) {\n      metadata = decodeMetadata(e.target.result);\n      // we can determine the result here if:\n      // 1. there is no such document\n      // 2. the document is deleted and we don't ask about specific rev\n      // When we ask with opts.rev we expect the answer to be either\n      // doc (possibly with _deleted=true) or missing error\n      if (!metadata) {\n        err = createError(MISSING_DOC, 'missing');\n        return finish();\n      }\n\n      var rev$$1;\n      if (!opts.rev) {\n        rev$$1 = metadata.winningRev;\n        var deleted = isDeleted(metadata);\n        if (deleted) {\n          err = createError(MISSING_DOC, \"deleted\");\n          return finish();\n        }\n      } else {\n        rev$$1 = opts.latest ? latest(opts.rev, metadata) : opts.rev;\n      }\n\n      var objectStore = txn.objectStore(BY_SEQ_STORE);\n      var key = metadata.id + '::' + rev$$1;\n\n      objectStore.index('_doc_id_rev').get(key).onsuccess = function (e) {\n        doc = e.target.result;\n        if (doc) {\n          doc = decodeDoc(doc);\n        }\n        if (!doc) {\n          err = createError(MISSING_DOC, 'missing');\n          return finish();\n        }\n        finish();\n      };\n    };\n  };\n\n  api._getAttachment = function (docId, attachId, attachment, opts, callback) {\n    var txn;\n    if (opts.ctx) {\n      txn = opts.ctx;\n    } else {\n      var txnResult = openTransactionSafely(idb,\n        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      txn = txnResult.txn;\n    }\n    var digest = attachment.digest;\n    var type = attachment.content_type;\n\n    txn.objectStore(ATTACH_STORE).get(digest).onsuccess = function (e) {\n      var body = e.target.result.body;\n      readBlobData(body, type, opts.binary, function (blobData) {\n        callback(null, blobData);\n      });\n    };\n  };\n\n  api._info = function idb_info(callback) {\n    var updateSeq;\n    var docCount;\n\n    var txnResult = openTransactionSafely(idb, [META_STORE, BY_SEQ_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {\n      docCount = e.target.result.docCount;\n    };\n    txn.objectStore(BY_SEQ_STORE).openCursor(null, 'prev').onsuccess = function (e) {\n      var cursor = e.target.result;\n      updateSeq = cursor ? cursor.key : 0;\n    };\n\n    txn.oncomplete = function () {\n      callback(null, {\n        doc_count: docCount,\n        update_seq: updateSeq,\n        // for debugging\n        idb_attachment_format: (api._meta.blobSupport ? 'binary' : 'base64')\n      });\n    };\n  };\n\n  api._allDocs = function idb_allDocs(opts, callback) {\n    idbAllDocs(opts, idb, callback);\n  };\n\n  api._changes = function idbChanges(opts) {\n    return changes(opts, api, dbName, idb);\n  };\n\n  api._close = function (callback) {\n    // https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#close\n    // \"Returns immediately and closes the connection in a separate thread...\"\n    idb.close();\n    cachedDBs.delete(dbName);\n    callback();\n  };\n\n  api._getRevisionTree = function (docId, callback) {\n    var txnResult = openTransactionSafely(idb, [DOC_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n    var req = txn.objectStore(DOC_STORE).get(docId);\n    req.onsuccess = function (event) {\n      var doc = decodeMetadata(event.target.result);\n      if (!doc) {\n        callback(createError(MISSING_DOC));\n      } else {\n        callback(null, doc.rev_tree);\n      }\n    };\n  };\n\n  // This function removes revisions of document docId\n  // which are listed in revs and sets this document\n  // revision to to rev_tree\n  api._doCompaction = function (docId, revs, callback) {\n    var stores = [\n      DOC_STORE,\n      BY_SEQ_STORE,\n      ATTACH_STORE,\n      ATTACH_AND_SEQ_STORE\n    ];\n    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n\n    var docStore = txn.objectStore(DOC_STORE);\n\n    docStore.get(docId).onsuccess = function (event) {\n      var metadata = decodeMetadata(event.target.result);\n      traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n                                                         revHash, ctx, opts) {\n        var rev$$1 = pos + '-' + revHash;\n        if (revs.indexOf(rev$$1) !== -1) {\n          opts.status = 'missing';\n        }\n      });\n      compactRevs(revs, docId, txn);\n      var winningRev$$1 = metadata.winningRev;\n      var deleted = metadata.deleted;\n      txn.objectStore(DOC_STORE).put(\n        encodeMetadata(metadata, winningRev$$1, deleted));\n    };\n    txn.onabort = idbError(callback);\n    txn.oncomplete = function () {\n      callback();\n    };\n  };\n\n\n  api._getLocal = function (id, callback) {\n    var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var tx = txnResult.txn;\n    var req = tx.objectStore(LOCAL_STORE).get(id);\n\n    req.onerror = idbError(callback);\n    req.onsuccess = function (e) {\n      var doc = e.target.result;\n      if (!doc) {\n        callback(createError(MISSING_DOC));\n      } else {\n        delete doc['_doc_id_rev']; // for backwards compat\n        callback(null, doc);\n      }\n    };\n  };\n\n  api._putLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    delete doc._revisions; // ignore this, trust the rev\n    var oldRev = doc._rev;\n    var id = doc._id;\n    if (!oldRev) {\n      doc._rev = '0-1';\n    } else {\n      doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);\n    }\n\n    var tx = opts.ctx;\n    var ret;\n    if (!tx) {\n      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      tx = txnResult.txn;\n      tx.onerror = idbError(callback);\n      tx.oncomplete = function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      };\n    }\n\n    var oStore = tx.objectStore(LOCAL_STORE);\n    var req;\n    if (oldRev) {\n      req = oStore.get(id);\n      req.onsuccess = function (e) {\n        var oldDoc = e.target.result;\n        if (!oldDoc || oldDoc._rev !== oldRev) {\n          callback(createError(REV_CONFLICT));\n        } else { // update\n          var req = oStore.put(doc);\n          req.onsuccess = function () {\n            ret = {ok: true, id: doc._id, rev: doc._rev};\n            if (opts.ctx) { // return immediately\n              callback(null, ret);\n            }\n          };\n        }\n      };\n    } else { // new doc\n      req = oStore.add(doc);\n      req.onerror = function (e) {\n        // constraint error, already exists\n        callback(createError(REV_CONFLICT));\n        e.preventDefault(); // avoid transaction abort\n        e.stopPropagation(); // avoid transaction onerror\n      };\n      req.onsuccess = function () {\n        ret = {ok: true, id: doc._id, rev: doc._rev};\n        if (opts.ctx) { // return immediately\n          callback(null, ret);\n        }\n      };\n    }\n  };\n\n  api._removeLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var tx = opts.ctx;\n    if (!tx) {\n      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      tx = txnResult.txn;\n      tx.oncomplete = function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      };\n    }\n    var ret;\n    var id = doc._id;\n    var oStore = tx.objectStore(LOCAL_STORE);\n    var req = oStore.get(id);\n\n    req.onerror = idbError(callback);\n    req.onsuccess = function (e) {\n      var oldDoc = e.target.result;\n      if (!oldDoc || oldDoc._rev !== doc._rev) {\n        callback(createError(MISSING_DOC));\n      } else {\n        oStore.delete(id);\n        ret = {ok: true, id: id, rev: '0-0'};\n        if (opts.ctx) { // return immediately\n          callback(null, ret);\n        }\n      }\n    };\n  };\n\n  api._destroy = function (opts, callback) {\n    changesHandler.removeAllListeners(dbName);\n\n    //Close open request for \"dbName\" database to fix ie delay.\n    var openReq = openReqList.get(dbName);\n    if (openReq && openReq.result) {\n      openReq.result.close();\n      cachedDBs.delete(dbName);\n    }\n    var req = indexedDB.deleteDatabase(dbName);\n\n    req.onsuccess = function () {\n      //Remove open request from the list.\n      openReqList.delete(dbName);\n      if (hasLocalStorage() && (dbName in localStorage)) {\n        delete localStorage[dbName];\n      }\n      callback(null, { 'ok': true });\n    };\n\n    req.onerror = idbError(callback);\n  };\n\n  var cached = cachedDBs.get(dbName);\n\n  if (cached) {\n    idb = cached.idb;\n    api._meta = cached.global;\n    return nextTick(function () {\n      callback(null, api);\n    });\n  }\n\n  var req;\n  if (opts.storage) {\n    req = tryStorageOption(dbName, opts.storage);\n  } else {\n    req = indexedDB.open(dbName, ADAPTER_VERSION);\n  }\n\n  openReqList.set(dbName, req);\n\n  req.onupgradeneeded = function (e) {\n    var db = e.target.result;\n    if (e.oldVersion < 1) {\n      return createSchema(db); // new db, initial schema\n    }\n    // do migrations\n\n    var txn = e.currentTarget.transaction;\n    // these migrations have to be done in this function, before\n    // control is returned to the event loop, because IndexedDB\n\n    if (e.oldVersion < 3) {\n      createLocalStoreSchema(db); // v2 -> v3\n    }\n    if (e.oldVersion < 4) {\n      addAttachAndSeqStore(db); // v3 -> v4\n    }\n\n    var migrations = [\n      addDeletedOrLocalIndex, // v1 -> v2\n      migrateLocalStore,      // v2 -> v3\n      migrateAttsAndSeqs,     // v3 -> v4\n      migrateMetadata         // v4 -> v5\n    ];\n\n    var i = e.oldVersion;\n\n    function next() {\n      var migration = migrations[i - 1];\n      i++;\n      if (migration) {\n        migration(txn, next);\n      }\n    }\n\n    next();\n  };\n\n  req.onsuccess = function (e) {\n\n    idb = e.target.result;\n\n    idb.onversionchange = function () {\n      idb.close();\n      cachedDBs.delete(dbName);\n    };\n\n    idb.onabort = function (e) {\n      guardedConsole('error', 'Database has a global failure', e.target.error);\n      idb.close();\n      cachedDBs.delete(dbName);\n    };\n\n    // Do a few setup operations (in parallel as much as possible):\n    // 1. Fetch meta doc\n    // 2. Check blob support\n    // 3. Calculate docCount\n    // 4. Generate an instanceId if necessary\n    // 5. Store docCount and instanceId on meta doc\n\n    var txn = idb.transaction([\n      META_STORE,\n      DETECT_BLOB_SUPPORT_STORE,\n      DOC_STORE\n    ], 'readwrite');\n\n    var storedMetaDoc = false;\n    var metaDoc;\n    var docCount;\n    var blobSupport;\n    var instanceId;\n\n    function completeSetup() {\n      if (typeof blobSupport === 'undefined' || !storedMetaDoc) {\n        return;\n      }\n      api._meta = {\n        name: dbName,\n        instanceId: instanceId,\n        blobSupport: blobSupport\n      };\n\n      cachedDBs.set(dbName, {\n        idb: idb,\n        global: api._meta\n      });\n      callback(null, api);\n    }\n\n    function storeMetaDocIfReady() {\n      if (typeof docCount === 'undefined' || typeof metaDoc === 'undefined') {\n        return;\n      }\n      var instanceKey = dbName + '_id';\n      if (instanceKey in metaDoc) {\n        instanceId = metaDoc[instanceKey];\n      } else {\n        metaDoc[instanceKey] = instanceId = uuid();\n      }\n      metaDoc.docCount = docCount;\n      txn.objectStore(META_STORE).put(metaDoc);\n    }\n\n    //\n    // fetch or generate the instanceId\n    //\n    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {\n      metaDoc = e.target.result || { id: META_STORE };\n      storeMetaDocIfReady();\n    };\n\n    //\n    // countDocs\n    //\n    countDocs(txn, function (count) {\n      docCount = count;\n      storeMetaDocIfReady();\n    });\n\n    //\n    // check blob support\n    //\n    if (!blobSupportPromise) {\n      // make sure blob support is only checked once\n      blobSupportPromise = checkBlobSupport(txn);\n    }\n\n    blobSupportPromise.then(function (val) {\n      blobSupport = val;\n      completeSetup();\n    });\n\n    // only when the metadata put transaction has completed,\n    // consider the setup done\n    txn.oncomplete = function () {\n      storedMetaDoc = true;\n      completeSetup();\n    };\n  };\n\n  req.onerror = function () {\n    var msg = 'Failed to open indexedDB, are you in private browsing mode?';\n    guardedConsole('error', msg);\n    callback(createError(IDB_ERROR, msg));\n  };\n}\n\nIdbPouch.valid = function () {\n  // Issue #2533, we finally gave up on doing bug\n  // detection instead of browser sniffing. Safari brought us\n  // to our knees.\n  var isSafari = typeof openDatabase !== 'undefined' &&\n    /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) &&\n    !/Chrome/.test(navigator.userAgent) &&\n    !/BlackBerry/.test(navigator.platform);\n\n  // some outdated implementations of IDB that appear on Samsung\n  // and HTC Android devices <4.4 are missing IDBKeyRange\n  return !isSafari && typeof indexedDB !== 'undefined' &&\n    typeof IDBKeyRange !== 'undefined';\n};\n\nfunction tryStorageOption(dbName, storage) {\n  try { // option only available in Firefox 26+\n    return indexedDB.open(dbName, {\n      version: ADAPTER_VERSION,\n      storage: storage\n    });\n  } catch (err) {\n      return indexedDB.open(dbName, ADAPTER_VERSION);\n  }\n}\n\nvar IDBPouch = function (PouchDB) {\n  PouchDB.adapter('idb', IdbPouch, true);\n};\n\n//\n// Parsing hex strings. Yeah.\n//\n// So basically we need this because of a bug in WebSQL:\n// https://code.google.com/p/chromium/issues/detail?id=422690\n// https://bugs.webkit.org/show_bug.cgi?id=137637\n//\n// UTF-8 and UTF-16 are provided as separate functions\n// for meager performance improvements\n//\n\nfunction decodeUtf8(str) {\n  return decodeURIComponent(escape(str));\n}\n\nfunction hexToInt(charCode) {\n  // '0'-'9' is 48-57\n  // 'A'-'F' is 65-70\n  // SQLite will only give us uppercase hex\n  return charCode < 65 ? (charCode - 48) : (charCode - 55);\n}\n\n\n// Example:\n// pragma encoding=utf8;\n// select hex('A');\n// returns '41'\nfunction parseHexUtf8(str, start, end) {\n  var result = '';\n  while (start < end) {\n    result += String.fromCharCode(\n      (hexToInt(str.charCodeAt(start++)) << 4) |\n        hexToInt(str.charCodeAt(start++)));\n  }\n  return result;\n}\n\n// Example:\n// pragma encoding=utf16;\n// select hex('A');\n// returns '4100'\n// notice that the 00 comes after the 41 (i.e. it's swizzled)\nfunction parseHexUtf16(str, start, end) {\n  var result = '';\n  while (start < end) {\n    // UTF-16, so swizzle the bytes\n    result += String.fromCharCode(\n      (hexToInt(str.charCodeAt(start + 2)) << 12) |\n        (hexToInt(str.charCodeAt(start + 3)) << 8) |\n        (hexToInt(str.charCodeAt(start)) << 4) |\n        hexToInt(str.charCodeAt(start + 1)));\n    start += 4;\n  }\n  return result;\n}\n\nfunction parseHexString(str, encoding) {\n  if (encoding === 'UTF-8') {\n    return decodeUtf8(parseHexUtf8(str, 0, str.length));\n  } else {\n    return parseHexUtf16(str, 0, str.length);\n  }\n}\n\nfunction quote(str) {\n  return \"'\" + str + \"'\";\n}\n\nvar ADAPTER_VERSION$1 = 7; // used to manage migrations\n\n// The object stores created for each database\n// DOC_STORE stores the document meta data, its revision history and state\nvar DOC_STORE$1 = quote('document-store');\n// BY_SEQ_STORE stores a particular version of a document, keyed by its\n// sequence id\nvar BY_SEQ_STORE$1 = quote('by-sequence');\n// Where we store attachments\nvar ATTACH_STORE$1 = quote('attach-store');\nvar LOCAL_STORE$1 = quote('local-store');\nvar META_STORE$1 = quote('metadata-store');\n// where we store many-to-many relations between attachment\n// digests and seqs\nvar ATTACH_AND_SEQ_STORE$1 = quote('attach-seq-store');\n\n// escapeBlob and unescapeBlob are workarounds for a websql bug:\n// https://code.google.com/p/chromium/issues/detail?id=422690\n// https://bugs.webkit.org/show_bug.cgi?id=137637\n// The goal is to never actually insert the \\u0000 character\n// in the database.\nfunction escapeBlob(str) {\n  return str\n    .replace(/\\u0002/g, '\\u0002\\u0002')\n    .replace(/\\u0001/g, '\\u0001\\u0002')\n    .replace(/\\u0000/g, '\\u0001\\u0001');\n}\n\nfunction unescapeBlob(str) {\n  return str\n    .replace(/\\u0001\\u0001/g, '\\u0000')\n    .replace(/\\u0001\\u0002/g, '\\u0001')\n    .replace(/\\u0002\\u0002/g, '\\u0002');\n}\n\nfunction stringifyDoc(doc) {\n  // don't bother storing the id/rev. it uses lots of space,\n  // in persistent map/reduce especially\n  delete doc._id;\n  delete doc._rev;\n  return JSON.stringify(doc);\n}\n\nfunction unstringifyDoc(doc, id, rev$$1) {\n  doc = JSON.parse(doc);\n  doc._id = id;\n  doc._rev = rev$$1;\n  return doc;\n}\n\n// question mark groups IN queries, e.g. 3 -> '(?,?,?)'\nfunction qMarks(num) {\n  var s = '(';\n  while (num--) {\n    s += '?';\n    if (num) {\n      s += ',';\n    }\n  }\n  return s + ')';\n}\n\nfunction select(selector, table, joiner, where, orderBy) {\n  return 'SELECT ' + selector + ' FROM ' +\n    (typeof table === 'string' ? table : table.join(' JOIN ')) +\n    (joiner ? (' ON ' + joiner) : '') +\n    (where ? (' WHERE ' +\n    (typeof where === 'string' ? where : where.join(' AND '))) : '') +\n    (orderBy ? (' ORDER BY ' + orderBy) : '');\n}\n\nfunction compactRevs$1(revs, docId, tx) {\n\n  if (!revs.length) {\n    return;\n  }\n\n  var numDone = 0;\n  var seqs = [];\n\n  function checkDone() {\n    if (++numDone === revs.length) { // done\n      deleteOrphans();\n    }\n  }\n\n  function deleteOrphans() {\n    // find orphaned attachment digests\n\n    if (!seqs.length) {\n      return;\n    }\n\n    var sql = 'SELECT DISTINCT digest AS digest FROM ' +\n      ATTACH_AND_SEQ_STORE$1 + ' WHERE seq IN ' + qMarks(seqs.length);\n\n    tx.executeSql(sql, seqs, function (tx, res) {\n\n      var digestsToCheck = [];\n      for (var i = 0; i < res.rows.length; i++) {\n        digestsToCheck.push(res.rows.item(i).digest);\n      }\n      if (!digestsToCheck.length) {\n        return;\n      }\n\n      var sql = 'DELETE FROM ' + ATTACH_AND_SEQ_STORE$1 +\n        ' WHERE seq IN (' +\n        seqs.map(function () { return '?'; }).join(',') +\n        ')';\n      tx.executeSql(sql, seqs, function (tx) {\n\n        var sql = 'SELECT digest FROM ' + ATTACH_AND_SEQ_STORE$1 +\n          ' WHERE digest IN (' +\n          digestsToCheck.map(function () { return '?'; }).join(',') +\n          ')';\n        tx.executeSql(sql, digestsToCheck, function (tx, res) {\n          var nonOrphanedDigests = new ExportedSet();\n          for (var i = 0; i < res.rows.length; i++) {\n            nonOrphanedDigests.add(res.rows.item(i).digest);\n          }\n          digestsToCheck.forEach(function (digest) {\n            if (nonOrphanedDigests.has(digest)) {\n              return;\n            }\n            tx.executeSql(\n              'DELETE FROM ' + ATTACH_AND_SEQ_STORE$1 + ' WHERE digest=?',\n              [digest]);\n            tx.executeSql(\n              'DELETE FROM ' + ATTACH_STORE$1 + ' WHERE digest=?', [digest]);\n          });\n        });\n      });\n    });\n  }\n\n  // update by-seq and attach stores in parallel\n  revs.forEach(function (rev$$1) {\n    var sql = 'SELECT seq FROM ' + BY_SEQ_STORE$1 +\n      ' WHERE doc_id=? AND rev=?';\n\n    tx.executeSql(sql, [docId, rev$$1], function (tx, res) {\n      if (!res.rows.length) { // already deleted\n        return checkDone();\n      }\n      var seq = res.rows.item(0).seq;\n      seqs.push(seq);\n\n      tx.executeSql(\n        'DELETE FROM ' + BY_SEQ_STORE$1 + ' WHERE seq=?', [seq], checkDone);\n    });\n  });\n}\n\nfunction websqlError(callback) {\n  return function (event) {\n    guardedConsole('error', 'WebSQL threw an error', event);\n    // event may actually be a SQLError object, so report is as such\n    var errorNameMatch = event && event.constructor.toString()\n        .match(/function ([^(]+)/);\n    var errorName = (errorNameMatch && errorNameMatch[1]) || event.type;\n    var errorReason = event.target || event.message;\n    callback(createError(WSQ_ERROR, errorReason, errorName));\n  };\n}\n\nfunction getSize(opts) {\n  if ('size' in opts) {\n    // triggers immediate popup in iOS, fixes #2347\n    // e.g. 5000001 asks for 5 MB, 10000001 asks for 10 MB,\n    return opts.size * 1000000;\n  }\n  // In iOS, doesn't matter as long as it's <= 5000000.\n  // Except that if you request too much, our tests fail\n  // because of the native \"do you accept?\" popup.\n  // In Android <=4.3, this value is actually used as an\n  // honest-to-god ceiling for data, so we need to\n  // set it to a decently high number.\n  var isAndroid = typeof navigator !== 'undefined' &&\n    /Android/.test(navigator.userAgent);\n  return isAndroid ? 5000000 : 1; // in PhantomJS, if you use 0 it will crash\n}\n\nfunction websqlBulkDocs(dbOpts, req, opts, api, db, websqlChanges, callback) {\n  var newEdits = opts.new_edits;\n  var userDocs = req.docs;\n\n  // Parse the docs, give them a sequence number for the result\n  var docInfos = userDocs.map(function (doc) {\n    if (doc._id && isLocalId(doc._id)) {\n      return doc;\n    }\n    var newDoc = parseDoc(doc, newEdits);\n    return newDoc;\n  });\n\n  var docInfoErrors = docInfos.filter(function (docInfo) {\n    return docInfo.error;\n  });\n  if (docInfoErrors.length) {\n    return callback(docInfoErrors[0]);\n  }\n\n  var tx;\n  var results = new Array(docInfos.length);\n  var fetchedDocs = new ExportedMap();\n\n  var preconditionErrored;\n  function complete() {\n    if (preconditionErrored) {\n      return callback(preconditionErrored);\n    }\n    websqlChanges.notify(api._name);\n    callback(null, results);\n  }\n\n  function verifyAttachment(digest, callback) {\n    var sql = 'SELECT count(*) as cnt FROM ' + ATTACH_STORE$1 +\n      ' WHERE digest=?';\n    tx.executeSql(sql, [digest], function (tx, result) {\n      if (result.rows.item(0).cnt === 0) {\n        var err = createError(MISSING_STUB,\n          'unknown stub attachment with digest ' +\n          digest);\n        callback(err);\n      } else {\n        callback();\n      }\n    });\n  }\n\n  function verifyAttachments(finish) {\n    var digests = [];\n    docInfos.forEach(function (docInfo) {\n      if (docInfo.data && docInfo.data._attachments) {\n        Object.keys(docInfo.data._attachments).forEach(function (filename) {\n          var att = docInfo.data._attachments[filename];\n          if (att.stub) {\n            digests.push(att.digest);\n          }\n        });\n      }\n    });\n    if (!digests.length) {\n      return finish();\n    }\n    var numDone = 0;\n    var err;\n\n    function checkDone() {\n      if (++numDone === digests.length) {\n        finish(err);\n      }\n    }\n    digests.forEach(function (digest) {\n      verifyAttachment(digest, function (attErr) {\n        if (attErr && !err) {\n          err = attErr;\n        }\n        checkDone();\n      });\n    });\n  }\n\n  function writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n                    isUpdate, delta, resultsIdx, callback) {\n\n    function finish() {\n      var data = docInfo.data;\n      var deletedInt = newRevIsDeleted ? 1 : 0;\n\n      var id = data._id;\n      var rev = data._rev;\n      var json = stringifyDoc(data);\n      var sql = 'INSERT INTO ' + BY_SEQ_STORE$1 +\n        ' (doc_id, rev, json, deleted) VALUES (?, ?, ?, ?);';\n      var sqlArgs = [id, rev, json, deletedInt];\n\n      // map seqs to attachment digests, which\n      // we will need later during compaction\n      function insertAttachmentMappings(seq, callback) {\n        var attsAdded = 0;\n        var attsToAdd = Object.keys(data._attachments || {});\n\n        if (!attsToAdd.length) {\n          return callback();\n        }\n        function checkDone() {\n          if (++attsAdded === attsToAdd.length) {\n            callback();\n          }\n          return false; // ack handling a constraint error\n        }\n        function add(att) {\n          var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE$1 +\n            ' (digest, seq) VALUES (?,?)';\n          var sqlArgs = [data._attachments[att].digest, seq];\n          tx.executeSql(sql, sqlArgs, checkDone, checkDone);\n          // second callback is for a constaint error, which we ignore\n          // because this docid/rev has already been associated with\n          // the digest (e.g. when new_edits == false)\n        }\n        for (var i = 0; i < attsToAdd.length; i++) {\n          add(attsToAdd[i]); // do in parallel\n        }\n      }\n\n      tx.executeSql(sql, sqlArgs, function (tx, result) {\n        var seq = result.insertId;\n        insertAttachmentMappings(seq, function () {\n          dataWritten(tx, seq);\n        });\n      }, function () {\n        // constraint error, recover by updating instead (see #1638)\n        var fetchSql = select('seq', BY_SEQ_STORE$1, null,\n          'doc_id=? AND rev=?');\n        tx.executeSql(fetchSql, [id, rev], function (tx, res) {\n          var seq = res.rows.item(0).seq;\n          var sql = 'UPDATE ' + BY_SEQ_STORE$1 +\n            ' SET json=?, deleted=? WHERE doc_id=? AND rev=?;';\n          var sqlArgs = [json, deletedInt, id, rev];\n          tx.executeSql(sql, sqlArgs, function (tx) {\n            insertAttachmentMappings(seq, function () {\n              dataWritten(tx, seq);\n            });\n          });\n        });\n        return false; // ack that we've handled the error\n      });\n    }\n\n    function collectResults(attachmentErr) {\n      if (!err) {\n        if (attachmentErr) {\n          err = attachmentErr;\n          callback(err);\n        } else if (recv === attachments.length) {\n          finish();\n        }\n      }\n    }\n\n    var err = null;\n    var recv = 0;\n\n    docInfo.data._id = docInfo.metadata.id;\n    docInfo.data._rev = docInfo.metadata.rev;\n    var attachments = Object.keys(docInfo.data._attachments || {});\n\n\n    if (newRevIsDeleted) {\n      docInfo.data._deleted = true;\n    }\n\n    function attachmentSaved(err) {\n      recv++;\n      collectResults(err);\n    }\n\n    attachments.forEach(function (key) {\n      var att = docInfo.data._attachments[key];\n      if (!att.stub) {\n        var data = att.data;\n        delete att.data;\n        att.revpos = parseInt(winningRev$$1, 10);\n        var digest = att.digest;\n        saveAttachment(digest, data, attachmentSaved);\n      } else {\n        recv++;\n        collectResults();\n      }\n    });\n\n    if (!attachments.length) {\n      finish();\n    }\n\n    function dataWritten(tx, seq) {\n      var id = docInfo.metadata.id;\n\n      var revsToCompact = docInfo.stemmedRevs || [];\n      if (isUpdate && api.auto_compaction) {\n        revsToCompact = compactTree(docInfo.metadata).concat(revsToCompact);\n      }\n      if (revsToCompact.length) {\n        compactRevs$1(revsToCompact, id, tx);\n      }\n\n      docInfo.metadata.seq = seq;\n      var rev = docInfo.metadata.rev;\n      delete docInfo.metadata.rev;\n\n      var sql = isUpdate ?\n      'UPDATE ' + DOC_STORE$1 +\n      ' SET json=?, max_seq=?, winningseq=' +\n      '(SELECT seq FROM ' + BY_SEQ_STORE$1 +\n      ' WHERE doc_id=' + DOC_STORE$1 + '.id AND rev=?) WHERE id=?'\n        : 'INSERT INTO ' + DOC_STORE$1 +\n      ' (id, winningseq, max_seq, json) VALUES (?,?,?,?);';\n      var metadataStr = safeJsonStringify(docInfo.metadata);\n      var params = isUpdate ?\n        [metadataStr, seq, winningRev$$1, id] :\n        [id, seq, seq, metadataStr];\n      tx.executeSql(sql, params, function () {\n        results[resultsIdx] = {\n          ok: true,\n          id: docInfo.metadata.id,\n          rev: rev\n        };\n        fetchedDocs.set(id, docInfo.metadata);\n        callback();\n      });\n    }\n  }\n\n  function websqlProcessDocs() {\n    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs, tx,\n                results, writeDoc, opts);\n  }\n\n  function fetchExistingDocs(callback) {\n    if (!docInfos.length) {\n      return callback();\n    }\n\n    var numFetched = 0;\n\n    function checkDone() {\n      if (++numFetched === docInfos.length) {\n        callback();\n      }\n    }\n\n    docInfos.forEach(function (docInfo) {\n      if (docInfo._id && isLocalId(docInfo._id)) {\n        return checkDone(); // skip local docs\n      }\n      var id = docInfo.metadata.id;\n      tx.executeSql('SELECT json FROM ' + DOC_STORE$1 +\n      ' WHERE id = ?', [id], function (tx, result) {\n        if (result.rows.length) {\n          var metadata = safeJsonParse(result.rows.item(0).json);\n          fetchedDocs.set(id, metadata);\n        }\n        checkDone();\n      });\n    });\n  }\n\n  function saveAttachment(digest, data, callback) {\n    var sql = 'SELECT digest FROM ' + ATTACH_STORE$1 + ' WHERE digest=?';\n    tx.executeSql(sql, [digest], function (tx, result) {\n      if (result.rows.length) { // attachment already exists\n        return callback();\n      }\n      // we could just insert before selecting and catch the error,\n      // but my hunch is that it's cheaper not to serialize the blob\n      // from JS to C if we don't have to (TODO: confirm this)\n      sql = 'INSERT INTO ' + ATTACH_STORE$1 +\n      ' (digest, body, escaped) VALUES (?,?,1)';\n      tx.executeSql(sql, [digest, escapeBlob(data)], function () {\n        callback();\n      }, function () {\n        // ignore constaint errors, means it already exists\n        callback();\n        return false; // ack we handled the error\n      });\n    });\n  }\n\n  preprocessAttachments(docInfos, 'binary', function (err) {\n    if (err) {\n      return callback(err);\n    }\n    db.transaction(function (txn) {\n      tx = txn;\n      verifyAttachments(function (err) {\n        if (err) {\n          preconditionErrored = err;\n        } else {\n          fetchExistingDocs(websqlProcessDocs);\n        }\n      });\n    }, websqlError(callback), complete);\n  });\n}\n\nvar cachedDatabases = new ExportedMap();\n\n// openDatabase passed in through opts (e.g. for node-websql)\nfunction openDatabaseWithOpts(opts) {\n  return opts.websql(opts.name, opts.version, opts.description, opts.size);\n}\n\nfunction openDBSafely(opts) {\n  try {\n    return {\n      db: openDatabaseWithOpts(opts)\n    };\n  } catch (err) {\n    return {\n      error: err\n    };\n  }\n}\n\nfunction openDB$1(opts) {\n  var cachedResult = cachedDatabases.get(opts.name);\n  if (!cachedResult) {\n    cachedResult = openDBSafely(opts);\n    cachedDatabases.set(opts.name, cachedResult);\n  }\n  return cachedResult;\n}\n\nvar websqlChanges = new Changes();\n\nfunction fetchAttachmentsIfNecessary$1(doc, opts, api, txn, cb) {\n  var attachments = Object.keys(doc._attachments || {});\n  if (!attachments.length) {\n    return cb && cb();\n  }\n  var numDone = 0;\n\n  function checkDone() {\n    if (++numDone === attachments.length && cb) {\n      cb();\n    }\n  }\n\n  function fetchAttachment(doc, att) {\n    var attObj = doc._attachments[att];\n    var attOpts = {binary: opts.binary, ctx: txn};\n    api._getAttachment(doc._id, att, attObj, attOpts, function (_, data) {\n      doc._attachments[att] = $inject_Object_assign(\n        pick(attObj, ['digest', 'content_type']),\n        { data: data }\n      );\n      checkDone();\n    });\n  }\n\n  attachments.forEach(function (att) {\n    if (opts.attachments && opts.include_docs) {\n      fetchAttachment(doc, att);\n    } else {\n      doc._attachments[att].stub = true;\n      checkDone();\n    }\n  });\n}\n\nvar POUCH_VERSION = 1;\n\n// these indexes cover the ground for most allDocs queries\nvar BY_SEQ_STORE_DELETED_INDEX_SQL =\n  'CREATE INDEX IF NOT EXISTS \\'by-seq-deleted-idx\\' ON ' +\n  BY_SEQ_STORE$1 + ' (seq, deleted)';\nvar BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL =\n  'CREATE UNIQUE INDEX IF NOT EXISTS \\'by-seq-doc-id-rev\\' ON ' +\n    BY_SEQ_STORE$1 + ' (doc_id, rev)';\nvar DOC_STORE_WINNINGSEQ_INDEX_SQL =\n  'CREATE INDEX IF NOT EXISTS \\'doc-winningseq-idx\\' ON ' +\n  DOC_STORE$1 + ' (winningseq)';\nvar ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL =\n  'CREATE INDEX IF NOT EXISTS \\'attach-seq-seq-idx\\' ON ' +\n    ATTACH_AND_SEQ_STORE$1 + ' (seq)';\nvar ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL =\n  'CREATE UNIQUE INDEX IF NOT EXISTS \\'attach-seq-digest-idx\\' ON ' +\n    ATTACH_AND_SEQ_STORE$1 + ' (digest, seq)';\n\nvar DOC_STORE_AND_BY_SEQ_JOINER = BY_SEQ_STORE$1 +\n  '.seq = ' + DOC_STORE$1 + '.winningseq';\n\nvar SELECT_DOCS = BY_SEQ_STORE$1 + '.seq AS seq, ' +\n  BY_SEQ_STORE$1 + '.deleted AS deleted, ' +\n  BY_SEQ_STORE$1 + '.json AS data, ' +\n  BY_SEQ_STORE$1 + '.rev AS rev, ' +\n  DOC_STORE$1 + '.json AS metadata';\n\nfunction WebSqlPouch$1(opts, callback) {\n  var api = this;\n  var instanceId = null;\n  var size = getSize(opts);\n  var idRequests = [];\n  var encoding;\n\n  api._name = opts.name;\n\n  // extend the options here, because sqlite plugin has a ton of options\n  // and they are constantly changing, so it's more prudent to allow anything\n  var websqlOpts = $inject_Object_assign({}, opts, {\n    version: POUCH_VERSION,\n    description: opts.name,\n    size: size\n  });\n  var openDBResult = openDB$1(websqlOpts);\n  if (openDBResult.error) {\n    return websqlError(callback)(openDBResult.error);\n  }\n  var db = openDBResult.db;\n  if (typeof db.readTransaction !== 'function') {\n    // doesn't exist in sqlite plugin\n    db.readTransaction = db.transaction;\n  }\n\n  function dbCreated() {\n    // note the db name in case the browser upgrades to idb\n    if (hasLocalStorage()) {\n      window.localStorage['_pouch__websqldb_' + api._name] = true;\n    }\n    callback(null, api);\n  }\n\n  // In this migration, we added the 'deleted' and 'local' columns to the\n  // by-seq and doc store tables.\n  // To preserve existing user data, we re-process all the existing JSON\n  // and add these values.\n  // Called migration2 because it corresponds to adapter version (db_version) #2\n  function runMigration2(tx, callback) {\n    // index used for the join in the allDocs query\n    tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);\n\n    tx.executeSql('ALTER TABLE ' + BY_SEQ_STORE$1 +\n      ' ADD COLUMN deleted TINYINT(1) DEFAULT 0', [], function () {\n      tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);\n      tx.executeSql('ALTER TABLE ' + DOC_STORE$1 +\n        ' ADD COLUMN local TINYINT(1) DEFAULT 0', [], function () {\n        tx.executeSql('CREATE INDEX IF NOT EXISTS \\'doc-store-local-idx\\' ON ' +\n          DOC_STORE$1 + ' (local, id)');\n\n        var sql = 'SELECT ' + DOC_STORE$1 + '.winningseq AS seq, ' + DOC_STORE$1 +\n          '.json AS metadata FROM ' + BY_SEQ_STORE$1 + ' JOIN ' + DOC_STORE$1 +\n          ' ON ' + BY_SEQ_STORE$1 + '.seq = ' + DOC_STORE$1 + '.winningseq';\n\n        tx.executeSql(sql, [], function (tx, result) {\n\n          var deleted = [];\n          var local = [];\n\n          for (var i = 0; i < result.rows.length; i++) {\n            var item = result.rows.item(i);\n            var seq = item.seq;\n            var metadata = JSON.parse(item.metadata);\n            if (isDeleted(metadata)) {\n              deleted.push(seq);\n            }\n            if (isLocalId(metadata.id)) {\n              local.push(metadata.id);\n            }\n          }\n          tx.executeSql('UPDATE ' + DOC_STORE$1 + 'SET local = 1 WHERE id IN ' +\n            qMarks(local.length), local, function () {\n            tx.executeSql('UPDATE ' + BY_SEQ_STORE$1 +\n              ' SET deleted = 1 WHERE seq IN ' +\n              qMarks(deleted.length), deleted, callback);\n          });\n        });\n      });\n    });\n  }\n\n  // in this migration, we make all the local docs unversioned\n  function runMigration3(tx, callback) {\n    var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE$1 +\n      ' (id UNIQUE, rev, json)';\n    tx.executeSql(local, [], function () {\n      var sql = 'SELECT ' + DOC_STORE$1 + '.id AS id, ' +\n        BY_SEQ_STORE$1 + '.json AS data ' +\n        'FROM ' + BY_SEQ_STORE$1 + ' JOIN ' +\n        DOC_STORE$1 + ' ON ' + BY_SEQ_STORE$1 + '.seq = ' +\n        DOC_STORE$1 + '.winningseq WHERE local = 1';\n      tx.executeSql(sql, [], function (tx, res) {\n        var rows = [];\n        for (var i = 0; i < res.rows.length; i++) {\n          rows.push(res.rows.item(i));\n        }\n        function doNext() {\n          if (!rows.length) {\n            return callback(tx);\n          }\n          var row = rows.shift();\n          var rev$$1 = JSON.parse(row.data)._rev;\n          tx.executeSql('INSERT INTO ' + LOCAL_STORE$1 +\n              ' (id, rev, json) VALUES (?,?,?)',\n              [row.id, rev$$1, row.data], function (tx) {\n            tx.executeSql('DELETE FROM ' + DOC_STORE$1 + ' WHERE id=?',\n                [row.id], function (tx) {\n              tx.executeSql('DELETE FROM ' + BY_SEQ_STORE$1 + ' WHERE seq=?',\n                  [row.seq], function () {\n                doNext();\n              });\n            });\n          });\n        }\n        doNext();\n      });\n    });\n  }\n\n  // in this migration, we remove doc_id_rev and just use rev\n  function runMigration4(tx, callback) {\n\n    function updateRows(rows) {\n      function doNext() {\n        if (!rows.length) {\n          return callback(tx);\n        }\n        var row = rows.shift();\n        var doc_id_rev = parseHexString(row.hex, encoding);\n        var idx = doc_id_rev.lastIndexOf('::');\n        var doc_id = doc_id_rev.substring(0, idx);\n        var rev$$1 = doc_id_rev.substring(idx + 2);\n        var sql = 'UPDATE ' + BY_SEQ_STORE$1 +\n          ' SET doc_id=?, rev=? WHERE doc_id_rev=?';\n        tx.executeSql(sql, [doc_id, rev$$1, doc_id_rev], function () {\n          doNext();\n        });\n      }\n      doNext();\n    }\n\n    var sql = 'ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN doc_id';\n    tx.executeSql(sql, [], function (tx) {\n      var sql = 'ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN rev';\n      tx.executeSql(sql, [], function (tx) {\n        tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL, [], function (tx) {\n          var sql = 'SELECT hex(doc_id_rev) as hex FROM ' + BY_SEQ_STORE$1;\n          tx.executeSql(sql, [], function (tx, res) {\n            var rows = [];\n            for (var i = 0; i < res.rows.length; i++) {\n              rows.push(res.rows.item(i));\n            }\n            updateRows(rows);\n          });\n        });\n      });\n    });\n  }\n\n  // in this migration, we add the attach_and_seq table\n  // for issue #2818\n  function runMigration5(tx, callback) {\n\n    function migrateAttsAndSeqs(tx) {\n      // need to actually populate the table. this is the expensive part,\n      // so as an optimization, check first that this database even\n      // contains attachments\n      var sql = 'SELECT COUNT(*) AS cnt FROM ' + ATTACH_STORE$1;\n      tx.executeSql(sql, [], function (tx, res) {\n        var count = res.rows.item(0).cnt;\n        if (!count) {\n          return callback(tx);\n        }\n\n        var offset = 0;\n        var pageSize = 10;\n        function nextPage() {\n          var sql = select(\n            SELECT_DOCS + ', ' + DOC_STORE$1 + '.id AS id',\n            [DOC_STORE$1, BY_SEQ_STORE$1],\n            DOC_STORE_AND_BY_SEQ_JOINER,\n            null,\n            DOC_STORE$1 + '.id '\n          );\n          sql += ' LIMIT ' + pageSize + ' OFFSET ' + offset;\n          offset += pageSize;\n          tx.executeSql(sql, [], function (tx, res) {\n            if (!res.rows.length) {\n              return callback(tx);\n            }\n            var digestSeqs = {};\n            function addDigestSeq(digest, seq) {\n              // uniq digest/seq pairs, just in case there are dups\n              var seqs = digestSeqs[digest] = (digestSeqs[digest] || []);\n              if (seqs.indexOf(seq) === -1) {\n                seqs.push(seq);\n              }\n            }\n            for (var i = 0; i < res.rows.length; i++) {\n              var row = res.rows.item(i);\n              var doc = unstringifyDoc(row.data, row.id, row.rev);\n              var atts = Object.keys(doc._attachments || {});\n              for (var j = 0; j < atts.length; j++) {\n                var att = doc._attachments[atts[j]];\n                addDigestSeq(att.digest, row.seq);\n              }\n            }\n            var digestSeqPairs = [];\n            Object.keys(digestSeqs).forEach(function (digest) {\n              var seqs = digestSeqs[digest];\n              seqs.forEach(function (seq) {\n                digestSeqPairs.push([digest, seq]);\n              });\n            });\n            if (!digestSeqPairs.length) {\n              return nextPage();\n            }\n            var numDone = 0;\n            digestSeqPairs.forEach(function (pair) {\n              var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE$1 +\n                ' (digest, seq) VALUES (?,?)';\n              tx.executeSql(sql, pair, function () {\n                if (++numDone === digestSeqPairs.length) {\n                  nextPage();\n                }\n              });\n            });\n          });\n        }\n        nextPage();\n      });\n    }\n\n    var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' +\n      ATTACH_AND_SEQ_STORE$1 + ' (digest, seq INTEGER)';\n    tx.executeSql(attachAndRev, [], function (tx) {\n      tx.executeSql(\n        ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL, [], function (tx) {\n          tx.executeSql(\n            ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL, [],\n            migrateAttsAndSeqs);\n        });\n    });\n  }\n\n  // in this migration, we use escapeBlob() and unescapeBlob()\n  // instead of reading out the binary as HEX, which is slow\n  function runMigration6(tx, callback) {\n    var sql = 'ALTER TABLE ' + ATTACH_STORE$1 +\n      ' ADD COLUMN escaped TINYINT(1) DEFAULT 0';\n    tx.executeSql(sql, [], callback);\n  }\n\n  // issue #3136, in this migration we need a \"latest seq\" as well\n  // as the \"winning seq\" in the doc store\n  function runMigration7(tx, callback) {\n    var sql = 'ALTER TABLE ' + DOC_STORE$1 +\n      ' ADD COLUMN max_seq INTEGER';\n    tx.executeSql(sql, [], function (tx) {\n      var sql = 'UPDATE ' + DOC_STORE$1 + ' SET max_seq=(SELECT MAX(seq) FROM ' +\n        BY_SEQ_STORE$1 + ' WHERE doc_id=id)';\n      tx.executeSql(sql, [], function (tx) {\n        // add unique index after filling, else we'll get a constraint\n        // error when we do the ALTER TABLE\n        var sql =\n          'CREATE UNIQUE INDEX IF NOT EXISTS \\'doc-max-seq-idx\\' ON ' +\n          DOC_STORE$1 + ' (max_seq)';\n        tx.executeSql(sql, [], callback);\n      });\n    });\n  }\n\n  function checkEncoding(tx, cb) {\n    // UTF-8 on chrome/android, UTF-16 on safari < 7.1\n    tx.executeSql('SELECT HEX(\"a\") AS hex', [], function (tx, res) {\n        var hex = res.rows.item(0).hex;\n        encoding = hex.length === 2 ? 'UTF-8' : 'UTF-16';\n        cb();\n      }\n    );\n  }\n\n  function onGetInstanceId() {\n    while (idRequests.length > 0) {\n      var idCallback = idRequests.pop();\n      idCallback(null, instanceId);\n    }\n  }\n\n  function onGetVersion(tx, dbVersion) {\n    if (dbVersion === 0) {\n      // initial schema\n\n      var meta = 'CREATE TABLE IF NOT EXISTS ' + META_STORE$1 +\n        ' (dbid, db_version INTEGER)';\n      var attach = 'CREATE TABLE IF NOT EXISTS ' + ATTACH_STORE$1 +\n        ' (digest UNIQUE, escaped TINYINT(1), body BLOB)';\n      var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' +\n        ATTACH_AND_SEQ_STORE$1 + ' (digest, seq INTEGER)';\n      // TODO: migrate winningseq to INTEGER\n      var doc = 'CREATE TABLE IF NOT EXISTS ' + DOC_STORE$1 +\n        ' (id unique, json, winningseq, max_seq INTEGER UNIQUE)';\n      var seq = 'CREATE TABLE IF NOT EXISTS ' + BY_SEQ_STORE$1 +\n        ' (seq INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, ' +\n        'json, deleted TINYINT(1), doc_id, rev)';\n      var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE$1 +\n        ' (id UNIQUE, rev, json)';\n\n      // creates\n      tx.executeSql(attach);\n      tx.executeSql(local);\n      tx.executeSql(attachAndRev, [], function () {\n        tx.executeSql(ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL);\n        tx.executeSql(ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL);\n      });\n      tx.executeSql(doc, [], function () {\n        tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);\n        tx.executeSql(seq, [], function () {\n          tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);\n          tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL);\n          tx.executeSql(meta, [], function () {\n            // mark the db version, and new dbid\n            var initSeq = 'INSERT INTO ' + META_STORE$1 +\n              ' (db_version, dbid) VALUES (?,?)';\n            instanceId = uuid();\n            var initSeqArgs = [ADAPTER_VERSION$1, instanceId];\n            tx.executeSql(initSeq, initSeqArgs, function () {\n              onGetInstanceId();\n            });\n          });\n        });\n      });\n    } else { // version > 0\n\n      var setupDone = function () {\n        var migrated = dbVersion < ADAPTER_VERSION$1;\n        if (migrated) {\n          // update the db version within this transaction\n          tx.executeSql('UPDATE ' + META_STORE$1 + ' SET db_version = ' +\n            ADAPTER_VERSION$1);\n        }\n        // notify db.id() callers\n        var sql = 'SELECT dbid FROM ' + META_STORE$1;\n        tx.executeSql(sql, [], function (tx, result) {\n          instanceId = result.rows.item(0).dbid;\n          onGetInstanceId();\n        });\n      };\n\n      // would love to use promises here, but then websql\n      // ends the transaction early\n      var tasks = [\n        runMigration2,\n        runMigration3,\n        runMigration4,\n        runMigration5,\n        runMigration6,\n        runMigration7,\n        setupDone\n      ];\n\n      // run each migration sequentially\n      var i = dbVersion;\n      var nextMigration = function (tx) {\n        tasks[i - 1](tx, nextMigration);\n        i++;\n      };\n      nextMigration(tx);\n    }\n  }\n\n  function setup() {\n    db.transaction(function (tx) {\n      // first check the encoding\n      checkEncoding(tx, function () {\n        // then get the version\n        fetchVersion(tx);\n      });\n    }, websqlError(callback), dbCreated);\n  }\n\n  function fetchVersion(tx) {\n    var sql = 'SELECT sql FROM sqlite_master WHERE tbl_name = ' + META_STORE$1;\n    tx.executeSql(sql, [], function (tx, result) {\n      if (!result.rows.length) {\n        // database hasn't even been created yet (version 0)\n        onGetVersion(tx, 0);\n      } else if (!/db_version/.test(result.rows.item(0).sql)) {\n        // table was created, but without the new db_version column,\n        // so add it.\n        tx.executeSql('ALTER TABLE ' + META_STORE$1 +\n          ' ADD COLUMN db_version INTEGER', [], function () {\n          // before version 2, this column didn't even exist\n          onGetVersion(tx, 1);\n        });\n      } else { // column exists, we can safely get it\n        tx.executeSql('SELECT db_version FROM ' + META_STORE$1,\n          [], function (tx, result) {\n          var dbVersion = result.rows.item(0).db_version;\n          onGetVersion(tx, dbVersion);\n        });\n      }\n    });\n  }\n\n  setup();\n\n  function getMaxSeq(tx, callback) {\n    var sql = 'SELECT MAX(seq) AS seq FROM ' + BY_SEQ_STORE$1;\n    tx.executeSql(sql, [], function (tx, res) {\n      var updateSeq = res.rows.item(0).seq || 0;\n      callback(updateSeq);\n    });\n  }\n\n  function countDocs(tx, callback) {\n    // count the total rows\n    var sql = select(\n      'COUNT(' + DOC_STORE$1 + '.id) AS \\'num\\'',\n      [DOC_STORE$1, BY_SEQ_STORE$1],\n      DOC_STORE_AND_BY_SEQ_JOINER,\n      BY_SEQ_STORE$1 + '.deleted=0');\n\n    tx.executeSql(sql, [], function (tx, result) {\n      callback(result.rows.item(0).num);\n    });\n  }\n\n  api._remote = false;\n  api.type = function () {\n    return 'websql';\n  };\n\n  api._id = toPromise(function (callback) {\n    callback(null, instanceId);\n  });\n\n  api._info = function (callback) {\n    var seq;\n    var docCount;\n    db.readTransaction(function (tx) {\n      getMaxSeq(tx, function (theSeq) {\n        seq = theSeq;\n      });\n      countDocs(tx, function (theDocCount) {\n        docCount = theDocCount;\n      });\n    }, websqlError(callback), function () {\n      callback(null, {\n        doc_count: docCount,\n        update_seq: seq,\n        websql_encoding: encoding\n      });\n    });\n  };\n\n  api._bulkDocs = function (req, reqOpts, callback) {\n    websqlBulkDocs(opts, req, reqOpts, api, db, websqlChanges, callback);\n  };\n\n  function latest$$1(tx, id, rev$$1, callback, finish) {\n    var sql = select(\n        SELECT_DOCS,\n        [DOC_STORE$1, BY_SEQ_STORE$1],\n        DOC_STORE_AND_BY_SEQ_JOINER,\n        DOC_STORE$1 + '.id=?');\n    var sqlArgs = [id];\n\n    tx.executeSql(sql, sqlArgs, function (a, results) {\n      if (!results.rows.length) {\n        var err = createError(MISSING_DOC, 'missing');\n        return finish(err);\n      }\n      var item = results.rows.item(0);\n      var metadata = safeJsonParse(item.metadata);\n      callback(latest(rev$$1, metadata));\n    });\n  }\n\n  api._get = function (id, opts, callback) {\n    var doc;\n    var metadata;\n    var tx = opts.ctx;\n    if (!tx) {\n      return db.readTransaction(function (txn) {\n        api._get(id, $inject_Object_assign({ctx: txn}, opts), callback);\n      });\n    }\n\n    function finish(err) {\n      callback(err, {doc: doc, metadata: metadata, ctx: tx});\n    }\n\n    var sql;\n    var sqlArgs;\n\n    if (!opts.rev) {\n      sql = select(\n        SELECT_DOCS,\n        [DOC_STORE$1, BY_SEQ_STORE$1],\n        DOC_STORE_AND_BY_SEQ_JOINER,\n        DOC_STORE$1 + '.id=?');\n      sqlArgs = [id];\n    } else if (opts.latest) {\n      latest$$1(tx, id, opts.rev, function (latestRev) {\n        opts.latest = false;\n        opts.rev = latestRev;\n        api._get(id, opts, callback);\n      }, finish);\n      return;\n    } else {\n      sql = select(\n        SELECT_DOCS,\n        [DOC_STORE$1, BY_SEQ_STORE$1],\n        DOC_STORE$1 + '.id=' + BY_SEQ_STORE$1 + '.doc_id',\n        [BY_SEQ_STORE$1 + '.doc_id=?', BY_SEQ_STORE$1 + '.rev=?']);\n      sqlArgs = [id, opts.rev];\n    }\n\n    tx.executeSql(sql, sqlArgs, function (a, results) {\n      if (!results.rows.length) {\n        var missingErr = createError(MISSING_DOC, 'missing');\n        return finish(missingErr);\n      }\n      var item = results.rows.item(0);\n      metadata = safeJsonParse(item.metadata);\n      if (item.deleted && !opts.rev) {\n        var deletedErr = createError(MISSING_DOC, 'deleted');\n        return finish(deletedErr);\n      }\n      doc = unstringifyDoc(item.data, metadata.id, item.rev);\n      finish();\n    });\n  };\n\n  api._allDocs = function (opts, callback) {\n    var results = [];\n    var totalRows;\n\n    var start = 'startkey' in opts ? opts.startkey : false;\n    var end = 'endkey' in opts ? opts.endkey : false;\n    var key = 'key' in opts ? opts.key : false;\n    var descending = 'descending' in opts ? opts.descending : false;\n    var limit = 'limit' in opts ? opts.limit : -1;\n    var offset = 'skip' in opts ? opts.skip : 0;\n    var inclusiveEnd = opts.inclusive_end !== false;\n\n    var sqlArgs = [];\n    var criteria = [];\n\n    if (key !== false) {\n      criteria.push(DOC_STORE$1 + '.id = ?');\n      sqlArgs.push(key);\n    } else if (start !== false || end !== false) {\n      if (start !== false) {\n        criteria.push(DOC_STORE$1 + '.id ' + (descending ? '<=' : '>=') + ' ?');\n        sqlArgs.push(start);\n      }\n      if (end !== false) {\n        var comparator = descending ? '>' : '<';\n        if (inclusiveEnd) {\n          comparator += '=';\n        }\n        criteria.push(DOC_STORE$1 + '.id ' + comparator + ' ?');\n        sqlArgs.push(end);\n      }\n      if (key !== false) {\n        criteria.push(DOC_STORE$1 + '.id = ?');\n        sqlArgs.push(key);\n      }\n    }\n\n    if (opts.deleted !== 'ok') {\n      // report deleted if keys are specified\n      criteria.push(BY_SEQ_STORE$1 + '.deleted = 0');\n    }\n\n    db.readTransaction(function (tx) {\n      // count the docs in parallel to other operations\n      countDocs(tx, function (docCount) {\n        totalRows = docCount;\n      });\n\n      if (limit === 0) {\n        return;\n      }\n\n      // do a single query to fetch the documents\n      var sql = select(\n        SELECT_DOCS,\n        [DOC_STORE$1, BY_SEQ_STORE$1],\n        DOC_STORE_AND_BY_SEQ_JOINER,\n        criteria,\n        DOC_STORE$1 + '.id ' + (descending ? 'DESC' : 'ASC')\n        );\n      sql += ' LIMIT ' + limit + ' OFFSET ' + offset;\n\n      tx.executeSql(sql, sqlArgs, function (tx, result) {\n        for (var i = 0, l = result.rows.length; i < l; i++) {\n          var item = result.rows.item(i);\n          var metadata = safeJsonParse(item.metadata);\n          var id = metadata.id;\n          var data = unstringifyDoc(item.data, id, item.rev);\n          var winningRev$$1 = data._rev;\n          var doc = {\n            id: id,\n            key: id,\n            value: {rev: winningRev$$1}\n          };\n          if (opts.include_docs) {\n            doc.doc = data;\n            doc.doc._rev = winningRev$$1;\n            if (opts.conflicts) {\n              var conflicts = collectConflicts(metadata);\n              if (conflicts.length) {\n                doc.doc._conflicts = conflicts;\n              }\n            }\n            fetchAttachmentsIfNecessary$1(doc.doc, opts, api, tx);\n          }\n          if (item.deleted) {\n            if (opts.deleted === 'ok') {\n              doc.value.deleted = true;\n              doc.doc = null;\n            } else {\n              continue;\n            }\n          }\n          results.push(doc);\n        }\n      });\n    }, websqlError(callback), function () {\n      callback(null, {\n        total_rows: totalRows,\n        offset: opts.skip,\n        rows: results\n      });\n    });\n  };\n\n  api._changes = function (opts) {\n    opts = clone(opts);\n\n    if (opts.continuous) {\n      var id = api._name + ':' + uuid();\n      websqlChanges.addListener(api._name, id, api, opts);\n      websqlChanges.notify(api._name);\n      return {\n        cancel: function () {\n          websqlChanges.removeListener(api._name, id);\n        }\n      };\n    }\n\n    var descending = opts.descending;\n\n    // Ignore the `since` parameter when `descending` is true\n    opts.since = opts.since && !descending ? opts.since : 0;\n\n    var limit = 'limit' in opts ? opts.limit : -1;\n    if (limit === 0) {\n      limit = 1; // per CouchDB _changes spec\n    }\n\n    var returnDocs;\n    if ('return_docs' in opts) {\n      returnDocs = opts.return_docs;\n    } else if ('returnDocs' in opts) {\n      // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n      returnDocs = opts.returnDocs;\n    } else {\n      returnDocs = true;\n    }\n    var results = [];\n    var numResults = 0;\n\n    function fetchChanges() {\n\n      var selectStmt =\n        DOC_STORE$1 + '.json AS metadata, ' +\n        DOC_STORE$1 + '.max_seq AS maxSeq, ' +\n        BY_SEQ_STORE$1 + '.json AS winningDoc, ' +\n        BY_SEQ_STORE$1 + '.rev AS winningRev ';\n\n      var from = DOC_STORE$1 + ' JOIN ' + BY_SEQ_STORE$1;\n\n      var joiner = DOC_STORE$1 + '.id=' + BY_SEQ_STORE$1 + '.doc_id' +\n        ' AND ' + DOC_STORE$1 + '.winningseq=' + BY_SEQ_STORE$1 + '.seq';\n\n      var criteria = ['maxSeq > ?'];\n      var sqlArgs = [opts.since];\n\n      if (opts.doc_ids) {\n        criteria.push(DOC_STORE$1 + '.id IN ' + qMarks(opts.doc_ids.length));\n        sqlArgs = sqlArgs.concat(opts.doc_ids);\n      }\n\n      var orderBy = 'maxSeq ' + (descending ? 'DESC' : 'ASC');\n\n      var sql = select(selectStmt, from, joiner, criteria, orderBy);\n\n      var filter = filterChange(opts);\n      if (!opts.view && !opts.filter) {\n        // we can just limit in the query\n        sql += ' LIMIT ' + limit;\n      }\n\n      var lastSeq = opts.since || 0;\n      db.readTransaction(function (tx) {\n        tx.executeSql(sql, sqlArgs, function (tx, result) {\n          function reportChange(change) {\n            return function () {\n              opts.onChange(change);\n            };\n          }\n          for (var i = 0, l = result.rows.length; i < l; i++) {\n            var item = result.rows.item(i);\n            var metadata = safeJsonParse(item.metadata);\n            lastSeq = item.maxSeq;\n\n            var doc = unstringifyDoc(item.winningDoc, metadata.id,\n              item.winningRev);\n            var change = opts.processChange(doc, metadata, opts);\n            change.seq = item.maxSeq;\n\n            var filtered = filter(change);\n            if (typeof filtered === 'object') {\n              return opts.complete(filtered);\n            }\n\n            if (filtered) {\n              numResults++;\n              if (returnDocs) {\n                results.push(change);\n              }\n              // process the attachment immediately\n              // for the benefit of live listeners\n              if (opts.attachments && opts.include_docs) {\n                fetchAttachmentsIfNecessary$1(doc, opts, api, tx,\n                  reportChange(change));\n              } else {\n                reportChange(change)();\n              }\n            }\n            if (numResults === limit) {\n              break;\n            }\n          }\n        });\n      }, websqlError(opts.complete), function () {\n        if (!opts.continuous) {\n          opts.complete(null, {\n            results: results,\n            last_seq: lastSeq\n          });\n        }\n      });\n    }\n\n    fetchChanges();\n  };\n\n  api._close = function (callback) {\n    //WebSQL databases do not need to be closed\n    callback();\n  };\n\n  api._getAttachment = function (docId, attachId, attachment, opts, callback) {\n    var res;\n    var tx = opts.ctx;\n    var digest = attachment.digest;\n    var type = attachment.content_type;\n    var sql = 'SELECT escaped, ' +\n      'CASE WHEN escaped = 1 THEN body ELSE HEX(body) END AS body FROM ' +\n      ATTACH_STORE$1 + ' WHERE digest=?';\n    tx.executeSql(sql, [digest], function (tx, result) {\n      // websql has a bug where \\u0000 causes early truncation in strings\n      // and blobs. to work around this, we used to use the hex() function,\n      // but that's not performant. after migration 6, we remove \\u0000\n      // and add it back in afterwards\n      var item = result.rows.item(0);\n      var data = item.escaped ? unescapeBlob(item.body) :\n        parseHexString(item.body, encoding);\n      if (opts.binary) {\n        res = binStringToBluffer(data, type);\n      } else {\n        res = thisBtoa(data);\n      }\n      callback(null, res);\n    });\n  };\n\n  api._getRevisionTree = function (docId, callback) {\n    db.readTransaction(function (tx) {\n      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE$1 + ' WHERE id = ?';\n      tx.executeSql(sql, [docId], function (tx, result) {\n        if (!result.rows.length) {\n          callback(createError(MISSING_DOC));\n        } else {\n          var data = safeJsonParse(result.rows.item(0).metadata);\n          callback(null, data.rev_tree);\n        }\n      });\n    });\n  };\n\n  api._doCompaction = function (docId, revs, callback) {\n    if (!revs.length) {\n      return callback();\n    }\n    db.transaction(function (tx) {\n\n      // update doc store\n      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE$1 + ' WHERE id = ?';\n      tx.executeSql(sql, [docId], function (tx, result) {\n        var metadata = safeJsonParse(result.rows.item(0).metadata);\n        traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n                                                           revHash, ctx, opts) {\n          var rev$$1 = pos + '-' + revHash;\n          if (revs.indexOf(rev$$1) !== -1) {\n            opts.status = 'missing';\n          }\n        });\n\n        var sql = 'UPDATE ' + DOC_STORE$1 + ' SET json = ? WHERE id = ?';\n        tx.executeSql(sql, [safeJsonStringify(metadata), docId]);\n      });\n\n      compactRevs$1(revs, docId, tx);\n    }, websqlError(callback), function () {\n      callback();\n    });\n  };\n\n  api._getLocal = function (id, callback) {\n    db.readTransaction(function (tx) {\n      var sql = 'SELECT json, rev FROM ' + LOCAL_STORE$1 + ' WHERE id=?';\n      tx.executeSql(sql, [id], function (tx, res) {\n        if (res.rows.length) {\n          var item = res.rows.item(0);\n          var doc = unstringifyDoc(item.json, id, item.rev);\n          callback(null, doc);\n        } else {\n          callback(createError(MISSING_DOC));\n        }\n      });\n    });\n  };\n\n  api._putLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    delete doc._revisions; // ignore this, trust the rev\n    var oldRev = doc._rev;\n    var id = doc._id;\n    var newRev;\n    if (!oldRev) {\n      newRev = doc._rev = '0-1';\n    } else {\n      newRev = doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);\n    }\n    var json = stringifyDoc(doc);\n\n    var ret;\n    function putLocal(tx) {\n      var sql;\n      var values;\n      if (oldRev) {\n        sql = 'UPDATE ' + LOCAL_STORE$1 + ' SET rev=?, json=? ' +\n          'WHERE id=? AND rev=?';\n        values = [newRev, json, id, oldRev];\n      } else {\n        sql = 'INSERT INTO ' + LOCAL_STORE$1 + ' (id, rev, json) VALUES (?,?,?)';\n        values = [id, newRev, json];\n      }\n      tx.executeSql(sql, values, function (tx, res) {\n        if (res.rowsAffected) {\n          ret = {ok: true, id: id, rev: newRev};\n          if (opts.ctx) { // return immediately\n            callback(null, ret);\n          }\n        } else {\n          callback(createError(REV_CONFLICT));\n        }\n      }, function () {\n        callback(createError(REV_CONFLICT));\n        return false; // ack that we handled the error\n      });\n    }\n\n    if (opts.ctx) {\n      putLocal(opts.ctx);\n    } else {\n      db.transaction(putLocal, websqlError(callback), function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      });\n    }\n  };\n\n  api._removeLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var ret;\n\n    function removeLocal(tx) {\n      var sql = 'DELETE FROM ' + LOCAL_STORE$1 + ' WHERE id=? AND rev=?';\n      var params = [doc._id, doc._rev];\n      tx.executeSql(sql, params, function (tx, res) {\n        if (!res.rowsAffected) {\n          return callback(createError(MISSING_DOC));\n        }\n        ret = {ok: true, id: doc._id, rev: '0-0'};\n        if (opts.ctx) { // return immediately\n          callback(null, ret);\n        }\n      });\n    }\n\n    if (opts.ctx) {\n      removeLocal(opts.ctx);\n    } else {\n      db.transaction(removeLocal, websqlError(callback), function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      });\n    }\n  };\n\n  api._destroy = function (opts, callback) {\n    websqlChanges.removeAllListeners(api._name);\n    db.transaction(function (tx) {\n      var stores = [DOC_STORE$1, BY_SEQ_STORE$1, ATTACH_STORE$1, META_STORE$1,\n        LOCAL_STORE$1, ATTACH_AND_SEQ_STORE$1];\n      stores.forEach(function (store) {\n        tx.executeSql('DROP TABLE IF EXISTS ' + store, []);\n      });\n    }, websqlError(callback), function () {\n      if (hasLocalStorage()) {\n        delete window.localStorage['_pouch__websqldb_' + api._name];\n        delete window.localStorage[api._name];\n      }\n      callback(null, {'ok': true});\n    });\n  };\n}\n\nfunction canOpenTestDB() {\n  try {\n    openDatabase('_pouch_validate_websql', 1, '', 1);\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\n// WKWebView had a bug where WebSQL would throw a DOM Exception 18\n// (see https://bugs.webkit.org/show_bug.cgi?id=137760 and\n// https://github.com/pouchdb/pouchdb/issues/5079)\n// This has been fixed in latest WebKit, so we try to detect it here.\nfunction isValidWebSQL() {\n  // WKWebView UA:\n  //   Mozilla/5.0 (iPhone; CPU iPhone OS 9_2 like Mac OS X)\n  //   AppleWebKit/601.1.46 (KHTML, like Gecko) Mobile/13C75\n  // Chrome for iOS UA:\n  //   Mozilla/5.0 (iPhone; U; CPU iPhone OS 5_1_1 like Mac OS X; en)\n  //   AppleWebKit/534.46.0 (KHTML, like Gecko) CriOS/19.0.1084.60\n  //   Mobile/9B206 Safari/7534.48.3\n  // Firefox for iOS UA:\n  //   Mozilla/5.0 (iPhone; CPU iPhone OS 8_3 like Mac OS X) AppleWebKit/600.1.4\n  //   (KHTML, like Gecko) FxiOS/1.0 Mobile/12F69 Safari/600.1.4\n\n  // indexedDB is null on some UIWebViews and undefined in others\n  // see: https://bugs.webkit.org/show_bug.cgi?id=137034\n  if (typeof indexedDB === 'undefined' || indexedDB === null ||\n      !/iP(hone|od|ad)/.test(navigator.userAgent)) {\n    // definitely not WKWebView, avoid creating an unnecessary database\n    return true;\n  }\n  // Cache the result in LocalStorage. Reason we do this is because if we\n  // call openDatabase() too many times, Safari craps out in SauceLabs and\n  // starts throwing DOM Exception 14s.\n  var hasLS = hasLocalStorage();\n  // Include user agent in the hash, so that if Safari is upgraded, we don't\n  // continually think it's broken.\n  var localStorageKey = '_pouch__websqldb_valid_' + navigator.userAgent;\n  if (hasLS && localStorage[localStorageKey]) {\n    return localStorage[localStorageKey] === '1';\n  }\n  var openedTestDB = canOpenTestDB();\n  if (hasLS) {\n    localStorage[localStorageKey] = openedTestDB ? '1' : '0';\n  }\n  return openedTestDB;\n}\n\nfunction valid() {\n  if (typeof openDatabase !== 'function') {\n    return false;\n  }\n  return isValidWebSQL();\n}\n\nfunction openDB(name, version, description, size) {\n  // Traditional WebSQL API\n  return openDatabase(name, version, description, size);\n}\n\nfunction WebSQLPouch(opts, callback) {\n  var _opts = $inject_Object_assign({\n    websql: openDB\n  }, opts);\n\n  WebSqlPouch$1.call(this, _opts, callback);\n}\n\nWebSQLPouch.valid = valid;\n\nWebSQLPouch.use_prefix = true;\n\nvar WebSqlPouch = function (PouchDB) {\n  PouchDB.adapter('websql', WebSQLPouch, true);\n};\n\n/* global fetch */\n/* global Headers */\nfunction wrappedFetch() {\n  var wrappedPromise = {};\n\n  var promise = new PouchPromise$1(function (resolve, reject) {\n    wrappedPromise.resolve = resolve;\n    wrappedPromise.reject = reject;\n  });\n\n  var args = new Array(arguments.length);\n\n  for (var i = 0; i < args.length; i++) {\n    args[i] = arguments[i];\n  }\n\n  wrappedPromise.promise = promise;\n\n  PouchPromise$1.resolve().then(function () {\n    return fetch.apply(null, args);\n  }).then(function (response) {\n    wrappedPromise.resolve(response);\n  }).catch(function (error) {\n    wrappedPromise.reject(error);\n  });\n\n  return wrappedPromise;\n}\n\nfunction fetchRequest(options, callback) {\n  var wrappedPromise, timer, response;\n\n  var headers = new Headers();\n\n  var fetchOptions = {\n    method: options.method,\n    credentials: 'include',\n    headers: headers\n  };\n\n  if (options.json) {\n    headers.set('Accept', 'application/json');\n    headers.set('Content-Type', options.headers['Content-Type'] ||\n      'application/json');\n  }\n\n  if (options.body &&\n      options.processData &&\n      typeof options.body !== 'string') {\n    fetchOptions.body = JSON.stringify(options.body);\n  } else if ('body' in options) {\n    fetchOptions.body = options.body;\n  } else {\n    fetchOptions.body = null;\n  }\n\n  Object.keys(options.headers).forEach(function (key) {\n    if (options.headers.hasOwnProperty(key)) {\n      headers.set(key, options.headers[key]);\n    }\n  });\n\n  wrappedPromise = wrappedFetch(options.url, fetchOptions);\n\n  if (options.timeout > 0) {\n    timer = setTimeout(function () {\n      wrappedPromise.reject(new Error('Load timeout for resource: ' +\n        options.url));\n    }, options.timeout);\n  }\n\n  wrappedPromise.promise.then(function (fetchResponse) {\n    response = {\n      statusCode: fetchResponse.status\n    };\n\n    if (options.timeout > 0) {\n      clearTimeout(timer);\n    }\n\n    if (response.statusCode >= 200 && response.statusCode < 300) {\n      return options.binary ? fetchResponse.blob() : fetchResponse.text();\n    }\n\n    return fetchResponse.json();\n  }).then(function (result) {\n    if (response.statusCode >= 200 && response.statusCode < 300) {\n      callback(null, response, result);\n    } else {\n      result.status = response.statusCode;\n      callback(result);\n    }\n  }).catch(function (error) {\n    if (!error) {\n      // this happens when the listener is canceled\n      error = new Error('canceled');\n    }\n    callback(error);\n  });\n\n  return {abort: wrappedPromise.reject};\n}\n\nfunction xhRequest(options, callback) {\n\n  var xhr, timer;\n  var timedout = false;\n\n  var abortReq = function () {\n    xhr.abort();\n    cleanUp();\n  };\n\n  var timeoutReq = function () {\n    timedout = true;\n    xhr.abort();\n    cleanUp();\n  };\n\n  var ret = {abort: abortReq};\n\n  var cleanUp = function () {\n    clearTimeout(timer);\n    ret.abort = function () {};\n    if (xhr) {\n      xhr.onprogress = undefined;\n      if (xhr.upload) {\n        xhr.upload.onprogress = undefined;\n      }\n      xhr.onreadystatechange = undefined;\n      xhr = undefined;\n    }\n  };\n\n  if (options.xhr) {\n    xhr = new options.xhr();\n  } else {\n    xhr = new XMLHttpRequest();\n  }\n\n  try {\n    xhr.open(options.method, options.url);\n  } catch (exception) {\n    return callback(new Error(exception.name || 'Url is invalid'));\n  }\n\n  xhr.withCredentials = ('withCredentials' in options) ?\n    options.withCredentials : true;\n\n  if (options.method === 'GET') {\n    delete options.headers['Content-Type'];\n  } else if (options.json) {\n    options.headers.Accept = 'application/json';\n    options.headers['Content-Type'] = options.headers['Content-Type'] ||\n      'application/json';\n    if (options.body &&\n        options.processData &&\n        typeof options.body !== \"string\") {\n      options.body = JSON.stringify(options.body);\n    }\n  }\n\n  if (options.binary) {\n    xhr.responseType = 'arraybuffer';\n  }\n\n  if (!('body' in options)) {\n    options.body = null;\n  }\n\n  for (var key in options.headers) {\n    if (options.headers.hasOwnProperty(key)) {\n      xhr.setRequestHeader(key, options.headers[key]);\n    }\n  }\n\n  if (options.timeout > 0) {\n    timer = setTimeout(timeoutReq, options.timeout);\n    xhr.onprogress = function () {\n      clearTimeout(timer);\n      if (xhr.readyState !== 4) {\n        timer = setTimeout(timeoutReq, options.timeout);\n      }\n    };\n    if (typeof xhr.upload !== 'undefined') { // does not exist in ie9\n      xhr.upload.onprogress = xhr.onprogress;\n    }\n  }\n\n  xhr.onreadystatechange = function () {\n    if (xhr.readyState !== 4) {\n      return;\n    }\n\n    var response = {\n      statusCode: xhr.status\n    };\n\n    if (xhr.status >= 200 && xhr.status < 300) {\n      var data;\n      if (options.binary) {\n        data = createBlob([xhr.response || ''], {\n          type: xhr.getResponseHeader('Content-Type')\n        });\n      } else {\n        data = xhr.responseText;\n      }\n      callback(null, response, data);\n    } else {\n      var err = {};\n      if (timedout) {\n        err = new Error('ETIMEDOUT');\n        err.code = 'ETIMEDOUT';\n      } else if (typeof xhr.response === 'string') {\n        try {\n          err = JSON.parse(xhr.response);\n        } catch (e) {}\n      }\n      err.status = xhr.status;\n      callback(err);\n    }\n    cleanUp();\n  };\n\n  if (options.body && (options.body instanceof Blob)) {\n    readAsArrayBuffer(options.body, function (arrayBuffer) {\n      xhr.send(arrayBuffer);\n    });\n  } else {\n    xhr.send(options.body);\n  }\n\n  return ret;\n}\n\nfunction testXhr() {\n  try {\n    new XMLHttpRequest();\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\nvar hasXhr = testXhr();\n\nfunction ajax$1(options, callback) {\n  if (!false && (hasXhr || options.xhr)) {\n    return xhRequest(options, callback);\n  } else {\n    return fetchRequest(options, callback);\n  }\n}\n\n// the blob already has a type; do nothing\nvar res$2 = function () {};\n\nfunction defaultBody() {\n  return '';\n}\n\nfunction ajaxCore$1(options, callback) {\n\n  options = clone(options);\n\n  var defaultOptions = {\n    method : \"GET\",\n    headers: {},\n    json: true,\n    processData: true,\n    timeout: 10000,\n    cache: false\n  };\n\n  options = $inject_Object_assign(defaultOptions, options);\n\n  function onSuccess(obj, resp, cb) {\n    if (!options.binary && options.json && typeof obj === 'string') {\n      /* istanbul ignore next */\n      try {\n        obj = JSON.parse(obj);\n      } catch (e) {\n        // Probably a malformed JSON from server\n        return cb(e);\n      }\n    }\n    if (Array.isArray(obj)) {\n      obj = obj.map(function (v) {\n        if (v.error || v.missing) {\n          return generateErrorFromResponse(v);\n        } else {\n          return v;\n        }\n      });\n    }\n    if (options.binary) {\n      res$2(obj, resp);\n    }\n    cb(null, obj, resp);\n  }\n\n  if (options.json) {\n    if (!options.binary) {\n      options.headers.Accept = 'application/json';\n    }\n    options.headers['Content-Type'] = options.headers['Content-Type'] ||\n      'application/json';\n  }\n\n  if (options.binary) {\n    options.encoding = null;\n    options.json = false;\n  }\n\n  if (!options.processData) {\n    options.json = false;\n  }\n\n  return ajax$1(options, function (err, response, body) {\n\n    if (err) {\n      return callback(generateErrorFromResponse(err));\n    }\n\n    var error;\n    var content_type = response.headers && response.headers['content-type'];\n    var data = body || defaultBody();\n\n    // CouchDB doesn't always return the right content-type for JSON data, so\n    // we check for ^{ and }$ (ignoring leading/trailing whitespace)\n    if (!options.binary && (options.json || !options.processData) &&\n        typeof data !== 'object' &&\n        (/json/.test(content_type) ||\n         (/^[\\s]*\\{/.test(data) && /\\}[\\s]*$/.test(data)))) {\n      try {\n        data = JSON.parse(data.toString());\n      } catch (e) {}\n    }\n\n    if (response.statusCode >= 200 && response.statusCode < 300) {\n      onSuccess(data, response, callback);\n    } else {\n      error = generateErrorFromResponse(data);\n      error.status = response.statusCode;\n      callback(error);\n    }\n  });\n}\n\nfunction ajax(opts, callback) {\n\n  // cache-buster, specifically designed to work around IE's aggressive caching\n  // see http://www.dashbay.com/2011/05/internet-explorer-caches-ajax/\n  // Also Safari caches POSTs, so we need to cache-bust those too.\n  var ua = (navigator && navigator.userAgent) ?\n    navigator.userAgent.toLowerCase() : '';\n\n  var isSafari = ua.indexOf('safari') !== -1 && ua.indexOf('chrome') === -1;\n  var isIE = ua.indexOf('msie') !== -1;\n  var isEdge = ua.indexOf('edge') !== -1;\n\n  // it appears the new version of safari also caches GETs,\n  // see https://github.com/pouchdb/pouchdb/issues/5010\n  var shouldCacheBust = (isSafari ||\n    ((isIE || isEdge) && opts.method === 'GET'));\n\n  var cache = 'cache' in opts ? opts.cache : true;\n\n  var isBlobUrl = /^blob:/.test(opts.url); // don't append nonces for blob URLs\n\n  if (!isBlobUrl && (shouldCacheBust || !cache)) {\n    var hasArgs = opts.url.indexOf('?') !== -1;\n    opts.url += (hasArgs ? '&' : '?') + '_nonce=' + Date.now();\n  }\n\n  return ajaxCore$1(opts, callback);\n}\n\n// dead simple promise pool, inspired by https://github.com/timdp/es6-promise-pool\n// but much smaller in code size. limits the number of concurrent promises that are executed\n\n\nfunction pool(promiseFactories, limit) {\n  return new PouchPromise$1(function (resolve, reject) {\n    var running = 0;\n    var current = 0;\n    var done = 0;\n    var len = promiseFactories.length;\n    var err;\n\n    function runNext() {\n      running++;\n      promiseFactories[current++]().then(onSuccess, onError);\n    }\n\n    function doNext() {\n      if (++done === len) {\n        /* istanbul ignore if */\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      } else {\n        runNextBatch();\n      }\n    }\n\n    function onSuccess() {\n      running--;\n      doNext();\n    }\n\n    /* istanbul ignore next */\n    function onError(thisErr) {\n      running--;\n      err = err || thisErr;\n      doNext();\n    }\n\n    function runNextBatch() {\n      while (running < limit && current < len) {\n        runNext();\n      }\n    }\n\n    runNextBatch();\n  });\n}\n\nvar CHANGES_BATCH_SIZE = 25;\nvar MAX_SIMULTANEOUS_REVS = 50;\nvar CHANGES_TIMEOUT_BUFFER = 5000;\nvar DEFAULT_HEARTBEAT = 10000;\n\nvar supportsBulkGetMap = {};\n\nfunction readAttachmentsAsBlobOrBuffer(row) {\n  var atts = row.doc && row.doc._attachments;\n  if (!atts) {\n    return;\n  }\n  Object.keys(atts).forEach(function (filename) {\n    var att = atts[filename];\n    att.data = b64ToBluffer(att.data, att.content_type);\n  });\n}\n\nfunction encodeDocId(id) {\n  if (/^_design/.test(id)) {\n    return '_design/' + encodeURIComponent(id.slice(8));\n  }\n  if (/^_local/.test(id)) {\n    return '_local/' + encodeURIComponent(id.slice(7));\n  }\n  return encodeURIComponent(id);\n}\n\nfunction preprocessAttachments$2(doc) {\n  if (!doc._attachments || !Object.keys(doc._attachments)) {\n    return PouchPromise$1.resolve();\n  }\n\n  return PouchPromise$1.all(Object.keys(doc._attachments).map(function (key) {\n    var attachment = doc._attachments[key];\n    if (attachment.data && typeof attachment.data !== 'string') {\n      return new PouchPromise$1(function (resolve) {\n        blobToBase64(attachment.data, resolve);\n      }).then(function (b64) {\n        attachment.data = b64;\n      });\n    }\n  }));\n}\n\nfunction hasUrlPrefix(opts) {\n  if (!opts.prefix) {\n    return false;\n  }\n\n  var protocol = parseUri(opts.prefix).protocol;\n\n  return protocol === 'http' || protocol === 'https';\n}\n\n// Get all the information you possibly can about the URI given by name and\n// return it as a suitable object.\nfunction getHost(name, opts) {\n\n  // encode db name if opts.prefix is a url (#5574)\n  if (hasUrlPrefix(opts)) {\n    var dbName = opts.name.substr(opts.prefix.length);\n    name = opts.prefix + encodeURIComponent(dbName);\n  }\n\n  // Prase the URI into all its little bits\n  var uri = parseUri(name);\n\n  // Store the user and password as a separate auth object\n  if (uri.user || uri.password) {\n    uri.auth = {username: uri.user, password: uri.password};\n  }\n\n  // Split the path part of the URI into parts using '/' as the delimiter\n  // after removing any leading '/' and any trailing '/'\n  var parts = uri.path.replace(/(^\\/|\\/$)/g, '').split('/');\n\n  // Store the first part as the database name and remove it from the parts\n  // array\n  uri.db = parts.pop();\n  // Prevent double encoding of URI component\n  if (uri.db.indexOf('%') === -1) {\n    uri.db = encodeURIComponent(uri.db);\n  }\n\n  // Restore the path by joining all the remaining parts (all the parts\n  // except for the database name) with '/'s\n  uri.path = parts.join('/');\n\n  return uri;\n}\n\n// Generate a URL with the host data given by opts and the given path\nfunction genDBUrl(opts, path) {\n  return genUrl(opts, opts.db + '/' + path);\n}\n\n// Generate a URL with the host data given by opts and the given path\nfunction genUrl(opts, path) {\n  // If the host already has a path, then we need to have a path delimiter\n  // Otherwise, the path delimiter is the empty string\n  var pathDel = !opts.path ? '' : '/';\n\n  // If the host already has a path, then we need to have a path delimiter\n  // Otherwise, the path delimiter is the empty string\n  return opts.protocol + '://' + opts.host +\n         (opts.port ? (':' + opts.port) : '') +\n         '/' + opts.path + pathDel + path;\n}\n\nfunction paramsToStr(params) {\n  return '?' + Object.keys(params).map(function (k) {\n    return k + '=' + encodeURIComponent(params[k]);\n  }).join('&');\n}\n\n// Implements the PouchDB API for dealing with CouchDB instances over HTTP\nfunction HttpPouch(opts, callback) {\n\n  // The functions that will be publicly available for HttpPouch\n  var api = this;\n\n  var host = getHost(opts.name, opts);\n  var dbUrl = genDBUrl(host, '');\n\n  opts = clone(opts);\n  var ajaxOpts = opts.ajax || {};\n\n  if (opts.auth || host.auth) {\n    var nAuth = opts.auth || host.auth;\n    var str = nAuth.username + ':' + nAuth.password;\n    var token = thisBtoa(unescape(encodeURIComponent(str)));\n    ajaxOpts.headers = ajaxOpts.headers || {};\n    ajaxOpts.headers.Authorization = 'Basic ' + token;\n  }\n\n  // Not strictly necessary, but we do this because numerous tests\n  // rely on swapping ajax in and out.\n  api._ajax = ajax;\n\n  function ajax$$1(userOpts, options, callback) {\n    var reqAjax = userOpts.ajax || {};\n    var reqOpts = $inject_Object_assign(clone(ajaxOpts), reqAjax, options);\n    var defaultHeaders = clone(ajaxOpts.headers || {});\n    reqOpts.headers = $inject_Object_assign(defaultHeaders, reqAjax.headers,\n      options.headers || {});\n    /* istanbul ignore if */\n    if (api.constructor.listeners('debug').length) {\n      api.constructor.emit('debug', ['http', reqOpts.method, reqOpts.url]);\n    }\n    return api._ajax(reqOpts, callback);\n  }\n\n  function ajaxPromise(userOpts, opts) {\n    return new PouchPromise$1(function (resolve, reject) {\n      ajax$$1(userOpts, opts, function (err, res) {\n        /* istanbul ignore if */\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  function adapterFun$$1(name, fun) {\n    return adapterFun(name, getArguments(function (args) {\n      setup().then(function () {\n        return fun.apply(this, args);\n      }).catch(function (e) {\n        var callback = args.pop();\n        callback(e);\n      });\n    }));\n  }\n\n  var setupPromise;\n\n  function setup() {\n    // TODO: Remove `skipSetup` in favor of `skip_setup` in a future release\n    if (opts.skipSetup || opts.skip_setup) {\n      return PouchPromise$1.resolve();\n    }\n\n    // If there is a setup in process or previous successful setup\n    // done then we will use that\n    // If previous setups have been rejected we will try again\n    if (setupPromise) {\n      return setupPromise;\n    }\n\n    var checkExists = {method: 'GET', url: dbUrl};\n    setupPromise = ajaxPromise({}, checkExists).catch(function (err) {\n      if (err && err.status && err.status === 404) {\n        // Doesnt exist, create it\n        explainError(404, 'PouchDB is just detecting if the remote exists.');\n        return ajaxPromise({}, {method: 'PUT', url: dbUrl});\n      } else {\n        return PouchPromise$1.reject(err);\n      }\n    }).catch(function (err) {\n      // If we try to create a database that already exists, skipped in\n      // istanbul since its catching a race condition.\n      /* istanbul ignore if */\n      if (err && err.status && err.status === 412) {\n        return true;\n      }\n      return PouchPromise$1.reject(err);\n    });\n\n    setupPromise.catch(function () {\n      setupPromise = null;\n    });\n\n    return setupPromise;\n  }\n\n  nextTick(function () {\n    callback(null, api);\n  });\n\n  api._remote = true;\n  /* istanbul ignore next */\n  api.type = function () {\n    return 'http';\n  };\n\n  api.id = adapterFun$$1('id', function (callback) {\n    ajax$$1({}, {method: 'GET', url: genUrl(host, '')}, function (err, result) {\n      var uuid$$1 = (result && result.uuid) ?\n        (result.uuid + host.db) : genDBUrl(host, '');\n      callback(null, uuid$$1);\n    });\n  });\n\n  api.request = adapterFun$$1('request', function (options, callback) {\n    options.url = genDBUrl(host, options.url);\n    ajax$$1({}, options, callback);\n  });\n\n  // Sends a POST request to the host calling the couchdb _compact function\n  //    version: The version of CouchDB it is running\n  api.compact = adapterFun$$1('compact', function (opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n    ajax$$1(opts, {\n      url: genDBUrl(host, '_compact'),\n      method: 'POST'\n    }, function () {\n      function ping() {\n        api.info(function (err, res) {\n          // CouchDB may send a \"compact_running:true\" if it's\n          // already compacting. PouchDB Server doesn't.\n          /* istanbul ignore else */\n          if (res && !res.compact_running) {\n            callback(null, {ok: true});\n          } else {\n            setTimeout(ping, opts.interval || 200);\n          }\n        });\n      }\n      // Ping the http if it's finished compaction\n      ping();\n    });\n  });\n\n  api.bulkGet = adapterFun('bulkGet', function (opts, callback) {\n    var self = this;\n\n    function doBulkGet(cb) {\n      var params = {};\n      if (opts.revs) {\n        params.revs = true;\n      }\n      if (opts.attachments) {\n        /* istanbul ignore next */\n        params.attachments = true;\n      }\n      if (opts.latest) {\n        params.latest = true;\n      }\n      ajax$$1(opts, {\n        url: genDBUrl(host, '_bulk_get' + paramsToStr(params)),\n        method: 'POST',\n        body: { docs: opts.docs}\n      }, cb);\n    }\n\n    /* istanbul ignore next */\n    function doBulkGetShim() {\n      // avoid \"url too long error\" by splitting up into multiple requests\n      var batchSize = MAX_SIMULTANEOUS_REVS;\n      var numBatches = Math.ceil(opts.docs.length / batchSize);\n      var numDone = 0;\n      var results = new Array(numBatches);\n\n      function onResult(batchNum) {\n        return function (err, res) {\n          // err is impossible because shim returns a list of errs in that case\n          results[batchNum] = res.results;\n          if (++numDone === numBatches) {\n            callback(null, {results: flatten(results)});\n          }\n        };\n      }\n\n      for (var i = 0; i < numBatches; i++) {\n        var subOpts = pick(opts, ['revs', 'attachments', 'latest']);\n        subOpts.ajax = ajaxOpts;\n        subOpts.docs = opts.docs.slice(i * batchSize,\n          Math.min(opts.docs.length, (i + 1) * batchSize));\n        bulkGet(self, subOpts, onResult(i));\n      }\n    }\n\n    // mark the whole database as either supporting or not supporting _bulk_get\n    var dbUrl = genUrl(host, '');\n    var supportsBulkGet = supportsBulkGetMap[dbUrl];\n\n    /* istanbul ignore next */\n    if (typeof supportsBulkGet !== 'boolean') {\n      // check if this database supports _bulk_get\n      doBulkGet(function (err, res) {\n        if (err) {\n          supportsBulkGetMap[dbUrl] = false;\n          explainError(\n            err.status,\n            'PouchDB is just detecting if the remote ' +\n            'supports the _bulk_get API.'\n          );\n          doBulkGetShim();\n        } else {\n          supportsBulkGetMap[dbUrl] = true;\n          callback(null, res);\n        }\n      });\n    } else if (supportsBulkGet) {\n      doBulkGet(callback);\n    } else {\n      doBulkGetShim();\n    }\n  });\n\n  // Calls GET on the host, which gets back a JSON string containing\n  //    couchdb: A welcome string\n  //    version: The version of CouchDB it is running\n  api._info = function (callback) {\n    setup().then(function () {\n      ajax$$1({}, {\n        method: 'GET',\n        url: genDBUrl(host, '')\n      }, function (err, res) {\n        /* istanbul ignore next */\n        if (err) {\n        return callback(err);\n        }\n        res.host = genDBUrl(host, '');\n        callback(null, res);\n      });\n    }).catch(callback);\n  };\n\n  // Get the document with the given id from the database given by host.\n  // The id could be solely the _id in the database, or it may be a\n  // _design/ID or _local/ID path\n  api.get = adapterFun$$1('get', function (id, opts, callback) {\n    // If no options were given, set the callback to the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n\n    // List of parameters to add to the GET request\n    var params = {};\n\n    if (opts.revs) {\n      params.revs = true;\n    }\n\n    if (opts.revs_info) {\n      params.revs_info = true;\n    }\n\n    if (opts.latest) {\n      params.latest = true;\n    }\n\n    if (opts.open_revs) {\n      if (opts.open_revs !== \"all\") {\n        opts.open_revs = JSON.stringify(opts.open_revs);\n      }\n      params.open_revs = opts.open_revs;\n    }\n\n    if (opts.rev) {\n      params.rev = opts.rev;\n    }\n\n    if (opts.conflicts) {\n      params.conflicts = opts.conflicts;\n    }\n\n    id = encodeDocId(id);\n\n    // Set the options for the ajax call\n    var options = {\n      method: 'GET',\n      url: genDBUrl(host, id + paramsToStr(params))\n    };\n\n    function fetchAttachments(doc) {\n      var atts = doc._attachments;\n      var filenames = atts && Object.keys(atts);\n      if (!atts || !filenames.length) {\n        return;\n      }\n      // we fetch these manually in separate XHRs, because\n      // Sync Gateway would normally send it back as multipart/mixed,\n      // which we cannot parse. Also, this is more efficient than\n      // receiving attachments as base64-encoded strings.\n      function fetch(filename) {\n        var att = atts[filename];\n        var path = encodeDocId(doc._id) + '/' + encodeAttachmentId(filename) +\n          '?rev=' + doc._rev;\n        return ajaxPromise(opts, {\n          method: 'GET',\n          url: genDBUrl(host, path),\n          binary: true\n        }).then(function (blob) {\n          if (opts.binary) {\n            return blob;\n          }\n          return new PouchPromise$1(function (resolve) {\n            blobToBase64(blob, resolve);\n          });\n        }).then(function (data) {\n          delete att.stub;\n          delete att.length;\n          att.data = data;\n        });\n      }\n\n      var promiseFactories = filenames.map(function (filename) {\n        return function () {\n          return fetch(filename);\n        };\n      });\n\n      // This limits the number of parallel xhr requests to 5 any time\n      // to avoid issues with maximum browser request limits\n      return pool(promiseFactories, 5);\n    }\n\n    function fetchAllAttachments(docOrDocs) {\n      if (Array.isArray(docOrDocs)) {\n        return PouchPromise$1.all(docOrDocs.map(function (doc) {\n          if (doc.ok) {\n            return fetchAttachments(doc.ok);\n          }\n        }));\n      }\n      return fetchAttachments(docOrDocs);\n    }\n\n    ajaxPromise(opts, options).then(function (res) {\n      return PouchPromise$1.resolve().then(function () {\n        if (opts.attachments) {\n          return fetchAllAttachments(res);\n        }\n      }).then(function () {\n        callback(null, res);\n      });\n    }).catch(function (e) {\n      e.docId = id;\n      callback(e);\n    });\n  });\n\n  // Delete the document given by doc from the database given by host.\n  api.remove = adapterFun$$1('remove',\n      function (docOrId, optsOrRev, opts, callback) {\n    var doc;\n    if (typeof optsOrRev === 'string') {\n      // id, rev, opts, callback style\n      doc = {\n        _id: docOrId,\n        _rev: optsOrRev\n      };\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {};\n      }\n    } else {\n      // doc, opts, callback style\n      doc = docOrId;\n      if (typeof optsOrRev === 'function') {\n        callback = optsOrRev;\n        opts = {};\n      } else {\n        callback = opts;\n        opts = optsOrRev;\n      }\n    }\n\n    var rev$$1 = (doc._rev || opts.rev);\n\n    // Delete the document\n    ajax$$1(opts, {\n      method: 'DELETE',\n      url: genDBUrl(host, encodeDocId(doc._id)) + '?rev=' + rev$$1\n    }, callback);\n  });\n\n  function encodeAttachmentId(attachmentId) {\n    return attachmentId.split(\"/\").map(encodeURIComponent).join(\"/\");\n  }\n\n  // Get the attachment\n  api.getAttachment =\n    adapterFun$$1('getAttachment', function (docId, attachmentId, opts,\n                                                callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var params = opts.rev ? ('?rev=' + opts.rev) : '';\n    var url = genDBUrl(host, encodeDocId(docId)) + '/' +\n      encodeAttachmentId(attachmentId) + params;\n    ajax$$1(opts, {\n      method: 'GET',\n      url: url,\n      binary: true\n    }, callback);\n  });\n\n  // Remove the attachment given by the id and rev\n  api.removeAttachment =\n    adapterFun$$1('removeAttachment', function (docId, attachmentId, rev$$1,\n                                                   callback) {\n\n    var url = genDBUrl(host, encodeDocId(docId) + '/' +\n      encodeAttachmentId(attachmentId)) + '?rev=' + rev$$1;\n\n    ajax$$1({}, {\n      method: 'DELETE',\n      url: url\n    }, callback);\n  });\n\n  // Add the attachment given by blob and its contentType property\n  // to the document with the given id, the revision given by rev, and\n  // add it to the database given by host.\n  api.putAttachment =\n    adapterFun$$1('putAttachment', function (docId, attachmentId, rev$$1, blob,\n                                                type, callback) {\n    if (typeof type === 'function') {\n      callback = type;\n      type = blob;\n      blob = rev$$1;\n      rev$$1 = null;\n    }\n    var id = encodeDocId(docId) + '/' + encodeAttachmentId(attachmentId);\n    var url = genDBUrl(host, id);\n    if (rev$$1) {\n      url += '?rev=' + rev$$1;\n    }\n\n    if (typeof blob === 'string') {\n      // input is assumed to be a base64 string\n      var binary;\n      try {\n        binary = thisAtob(blob);\n      } catch (err) {\n        return callback(createError(BAD_ARG,\n                        'Attachment is not a valid base64 string'));\n      }\n      blob = binary ? binStringToBluffer(binary, type) : '';\n    }\n\n    var opts = {\n      headers: {'Content-Type': type},\n      method: 'PUT',\n      url: url,\n      processData: false,\n      body: blob,\n      timeout: ajaxOpts.timeout || 60000\n    };\n    // Add the attachment\n    ajax$$1({}, opts, callback);\n  });\n\n  // Update/create multiple documents given by req in the database\n  // given by host.\n  api._bulkDocs = function (req, opts, callback) {\n    // If new_edits=false then it prevents the database from creating\n    // new revision numbers for the documents. Instead it just uses\n    // the old ones. This is used in database replication.\n    req.new_edits = opts.new_edits;\n\n    setup().then(function () {\n      return PouchPromise$1.all(req.docs.map(preprocessAttachments$2));\n    }).then(function () {\n      // Update/create the documents\n      ajax$$1(opts, {\n        method: 'POST',\n        url: genDBUrl(host, '_bulk_docs'),\n        timeout: opts.timeout,\n        body: req\n      }, function (err, results) {\n        if (err) {\n          return callback(err);\n        }\n        results.forEach(function (result) {\n          result.ok = true; // smooths out cloudant not adding this\n        });\n        callback(null, results);\n      });\n    }).catch(callback);\n  };\n\n\n  // Update/create document\n  api._put = function (doc, opts, callback) {\n    setup().then(function () {\n      return preprocessAttachments$2(doc);\n    }).then(function () {\n      // Update/create the document\n      ajax$$1(opts, {\n        method: 'PUT',\n        url: genDBUrl(host, encodeDocId(doc._id)),\n        body: doc\n      }, function (err, result) {\n        if (err) {\n          err.docId = doc && doc._id;\n          return callback(err);\n        }\n        callback(null, result);\n      });\n    }).catch(callback);\n  };\n\n\n  // Get a listing of the documents in the database given\n  // by host and ordered by increasing id.\n  api.allDocs = adapterFun$$1('allDocs', function (opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n\n    // List of parameters to add to the GET request\n    var params = {};\n    var body;\n    var method = 'GET';\n\n    if (opts.conflicts) {\n      params.conflicts = true;\n    }\n\n    if (opts.descending) {\n      params.descending = true;\n    }\n\n    if (opts.include_docs) {\n      params.include_docs = true;\n    }\n\n    // added in CouchDB 1.6.0\n    if (opts.attachments) {\n      params.attachments = true;\n    }\n\n    if (opts.key) {\n      params.key = JSON.stringify(opts.key);\n    }\n\n    if (opts.start_key) {\n      opts.startkey = opts.start_key;\n    }\n\n    if (opts.startkey) {\n      params.startkey = JSON.stringify(opts.startkey);\n    }\n\n    if (opts.end_key) {\n      opts.endkey = opts.end_key;\n    }\n\n    if (opts.endkey) {\n      params.endkey = JSON.stringify(opts.endkey);\n    }\n\n    if (typeof opts.inclusive_end !== 'undefined') {\n      params.inclusive_end = !!opts.inclusive_end;\n    }\n\n    if (typeof opts.limit !== 'undefined') {\n      params.limit = opts.limit;\n    }\n\n    if (typeof opts.skip !== 'undefined') {\n      params.skip = opts.skip;\n    }\n\n    var paramStr = paramsToStr(params);\n\n    if (typeof opts.keys !== 'undefined') {\n      method = 'POST';\n      body = {keys: opts.keys};\n    }\n\n    // Get the document listing\n    ajaxPromise(opts, {\n      method: method,\n      url: genDBUrl(host, '_all_docs' + paramStr),\n      body: body\n    }).then(function (res) {\n      if (opts.include_docs && opts.attachments && opts.binary) {\n        res.rows.forEach(readAttachmentsAsBlobOrBuffer);\n      }\n      callback(null, res);\n    }).catch(callback);\n  });\n\n  // Get a list of changes made to documents in the database given by host.\n  // TODO According to the README, there should be two other methods here,\n  // api.changes.addListener and api.changes.removeListener.\n  api._changes = function (opts) {\n\n    // We internally page the results of a changes request, this means\n    // if there is a large set of changes to be returned we can start\n    // processing them quicker instead of waiting on the entire\n    // set of changes to return and attempting to process them at once\n    var batchSize = 'batch_size' in opts ? opts.batch_size : CHANGES_BATCH_SIZE;\n\n    opts = clone(opts);\n\n    if (opts.continuous && !('heartbeat' in opts)) {\n      opts.heartbeat = DEFAULT_HEARTBEAT;\n    }\n\n    var requestTimeout = ('timeout' in opts) ? opts.timeout :\n      ('timeout' in ajaxOpts) ? ajaxOpts.timeout :\n      30 * 1000;\n\n    // ensure CHANGES_TIMEOUT_BUFFER applies\n    if ('timeout' in opts && opts.timeout &&\n      (requestTimeout - opts.timeout) < CHANGES_TIMEOUT_BUFFER) {\n        requestTimeout = opts.timeout + CHANGES_TIMEOUT_BUFFER;\n    }\n\n    if ('heartbeat' in opts && opts.heartbeat &&\n       (requestTimeout - opts.heartbeat) < CHANGES_TIMEOUT_BUFFER) {\n        requestTimeout = opts.heartbeat + CHANGES_TIMEOUT_BUFFER;\n    }\n\n    var params = {};\n    if ('timeout' in opts && opts.timeout) {\n      params.timeout = opts.timeout;\n    }\n\n    var limit = (typeof opts.limit !== 'undefined') ? opts.limit : false;\n    var returnDocs;\n    if ('return_docs' in opts) {\n      returnDocs = opts.return_docs;\n    } else if ('returnDocs' in opts) {\n      // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n      returnDocs = opts.returnDocs;\n    } else {\n      returnDocs = true;\n    }\n    //\n    var leftToFetch = limit;\n\n    if (opts.style) {\n      params.style = opts.style;\n    }\n\n    if (opts.include_docs || opts.filter && typeof opts.filter === 'function') {\n      params.include_docs = true;\n    }\n\n    if (opts.attachments) {\n      params.attachments = true;\n    }\n\n    if (opts.continuous) {\n      params.feed = 'longpoll';\n    }\n\n    if (opts.conflicts) {\n      params.conflicts = true;\n    }\n\n    if (opts.descending) {\n      params.descending = true;\n    }\n\n    if ('heartbeat' in opts) {\n      // If the heartbeat value is false, it disables the default heartbeat\n      if (opts.heartbeat) {\n        params.heartbeat = opts.heartbeat;\n      }\n    }\n\n    if (opts.filter && typeof opts.filter === 'string') {\n      params.filter = opts.filter;\n    }\n\n    if (opts.view && typeof opts.view === 'string') {\n      params.filter = '_view';\n      params.view = opts.view;\n    }\n\n    // If opts.query_params exists, pass it through to the changes request.\n    // These parameters may be used by the filter on the source database.\n    if (opts.query_params && typeof opts.query_params === 'object') {\n      for (var param_name in opts.query_params) {\n        /* istanbul ignore else */\n        if (opts.query_params.hasOwnProperty(param_name)) {\n          params[param_name] = opts.query_params[param_name];\n        }\n      }\n    }\n\n    var method = 'GET';\n    var body;\n\n    if (opts.doc_ids) {\n      // set this automagically for the user; it's annoying that couchdb\n      // requires both a \"filter\" and a \"doc_ids\" param.\n      params.filter = '_doc_ids';\n      method = 'POST';\n      body = {doc_ids: opts.doc_ids };\n    }\n    /* istanbul ignore next */\n    else if (opts.selector) {\n      // set this automagically for the user, similar to above\n      params.filter = '_selector';\n      method = 'POST';\n      body = {selector: opts.selector };\n    }\n\n    var xhr;\n    var lastFetchedSeq;\n\n    // Get all the changes starting wtih the one immediately after the\n    // sequence number given by since.\n    var fetch = function (since, callback) {\n      if (opts.aborted) {\n        return;\n      }\n      params.since = since;\n      // \"since\" can be any kind of json object in Coudant/CouchDB 2.x\n      /* istanbul ignore next */\n      if (typeof params.since === \"object\") {\n        params.since = JSON.stringify(params.since);\n      }\n\n      if (opts.descending) {\n        if (limit) {\n          params.limit = leftToFetch;\n        }\n      } else {\n        params.limit = (!limit || leftToFetch > batchSize) ?\n          batchSize : leftToFetch;\n      }\n\n      // Set the options for the ajax call\n      var xhrOpts = {\n        method: method,\n        url: genDBUrl(host, '_changes' + paramsToStr(params)),\n        timeout: requestTimeout,\n        body: body\n      };\n      lastFetchedSeq = since;\n\n      /* istanbul ignore if */\n      if (opts.aborted) {\n        return;\n      }\n\n      // Get the changes\n      setup().then(function () {\n        xhr = ajax$$1(opts, xhrOpts, callback);\n      }).catch(callback);\n    };\n\n    // If opts.since exists, get all the changes from the sequence\n    // number given by opts.since. Otherwise, get all the changes\n    // from the sequence number 0.\n    var results = {results: []};\n\n    var fetched = function (err, res) {\n      if (opts.aborted) {\n        return;\n      }\n      var raw_results_length = 0;\n      // If the result of the ajax call (res) contains changes (res.results)\n      if (res && res.results) {\n        raw_results_length = res.results.length;\n        results.last_seq = res.last_seq;\n        // For each change\n        var req = {};\n        req.query = opts.query_params;\n        res.results = res.results.filter(function (c) {\n          leftToFetch--;\n          var ret = filterChange(opts)(c);\n          if (ret) {\n            if (opts.include_docs && opts.attachments && opts.binary) {\n              readAttachmentsAsBlobOrBuffer(c);\n            }\n            if (returnDocs) {\n              results.results.push(c);\n            }\n            opts.onChange(c);\n          }\n          return ret;\n        });\n      } else if (err) {\n        // In case of an error, stop listening for changes and call\n        // opts.complete\n        opts.aborted = true;\n        opts.complete(err);\n        return;\n      }\n\n      // The changes feed may have timed out with no results\n      // if so reuse last update sequence\n      if (res && res.last_seq) {\n        lastFetchedSeq = res.last_seq;\n      }\n\n      var finished = (limit && leftToFetch <= 0) ||\n        (res && raw_results_length < batchSize) ||\n        (opts.descending);\n\n      if ((opts.continuous && !(limit && leftToFetch <= 0)) || !finished) {\n        // Queue a call to fetch again with the newest sequence number\n        nextTick(function () { fetch(lastFetchedSeq, fetched); });\n      } else {\n        // We're done, call the callback\n        opts.complete(null, results);\n      }\n    };\n\n    fetch(opts.since || 0, fetched);\n\n    // Return a method to cancel this method from processing any more\n    return {\n      cancel: function () {\n        opts.aborted = true;\n        if (xhr) {\n          xhr.abort();\n        }\n      }\n    };\n  };\n\n  // Given a set of document/revision IDs (given by req), tets the subset of\n  // those that do NOT correspond to revisions stored in the database.\n  // See http://wiki.apache.org/couchdb/HttpPostRevsDiff\n  api.revsDiff = adapterFun$$1('revsDiff', function (req, opts, callback) {\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    // Get the missing document/revision IDs\n    ajax$$1(opts, {\n      method: 'POST',\n      url: genDBUrl(host, '_revs_diff'),\n      body: req\n    }, callback);\n  });\n\n  api._close = function (callback) {\n    callback();\n  };\n\n  api._destroy = function (options, callback) {\n    ajax$$1(options, {\n      url: genDBUrl(host, ''),\n      method: 'DELETE'\n    }, function (err, resp) {\n      if (err && err.status && err.status !== 404) {\n        return callback(err);\n      }\n      callback(null, resp);\n    });\n  };\n}\n\n// HttpPouch is a valid adapter.\nHttpPouch.valid = function () {\n  return true;\n};\n\nvar HttpPouch$1 = function (PouchDB) {\n  PouchDB.adapter('http', HttpPouch, false);\n  PouchDB.adapter('https', HttpPouch, false);\n};\n\nfunction QueryParseError(message) {\n  this.status = 400;\n  this.name = 'query_parse_error';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, QueryParseError);\n  } catch (e) {}\n}\n\ninherits(QueryParseError, Error);\n\nfunction NotFoundError(message) {\n  this.status = 404;\n  this.name = 'not_found';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, NotFoundError);\n  } catch (e) {}\n}\n\ninherits(NotFoundError, Error);\n\nfunction BuiltInError(message) {\n  this.status = 500;\n  this.name = 'invalid_value';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, BuiltInError);\n  } catch (e) {}\n}\n\ninherits(BuiltInError, Error);\n\nfunction promisedCallback(promise, callback) {\n  if (callback) {\n    promise.then(function (res) {\n      nextTick(function () {\n        callback(null, res);\n      });\n    }, function (reason) {\n      nextTick(function () {\n        callback(reason);\n      });\n    });\n  }\n  return promise;\n}\n\nfunction callbackify(fun) {\n  return getArguments(function (args) {\n    var cb = args.pop();\n    var promise = fun.apply(this, args);\n    if (typeof cb === 'function') {\n      promisedCallback(promise, cb);\n    }\n    return promise;\n  });\n}\n\n// Promise finally util similar to Q.finally\nfunction fin(promise, finalPromiseFactory) {\n  return promise.then(function (res) {\n    return finalPromiseFactory().then(function () {\n      return res;\n    });\n  }, function (reason) {\n    return finalPromiseFactory().then(function () {\n      throw reason;\n    });\n  });\n}\n\nfunction sequentialize(queue, promiseFactory) {\n  return function () {\n    var args = arguments;\n    var that = this;\n    return queue.add(function () {\n      return promiseFactory.apply(that, args);\n    });\n  };\n}\n\n// uniq an array of strings, order not guaranteed\n// similar to underscore/lodash _.uniq\nfunction uniq(arr) {\n  var theSet = new ExportedSet(arr);\n  var result = new Array(theSet.size);\n  var index = -1;\n  theSet.forEach(function (value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nfunction mapToKeysArray(map) {\n  var result = new Array(map.size);\n  var index = -1;\n  map.forEach(function (value, key) {\n    result[++index] = key;\n  });\n  return result;\n}\n\nfunction createBuiltInError(name) {\n  var message = 'builtin ' + name +\n    ' function requires map values to be numbers' +\n    ' or number arrays';\n  return new BuiltInError(message);\n}\n\nfunction sum(values) {\n  var result = 0;\n  for (var i = 0, len = values.length; i < len; i++) {\n    var num = values[i];\n    if (typeof num !== 'number') {\n      if (Array.isArray(num)) {\n        // lists of numbers are also allowed, sum them separately\n        result = typeof result === 'number' ? [result] : result;\n        for (var j = 0, jLen = num.length; j < jLen; j++) {\n          var jNum = num[j];\n          if (typeof jNum !== 'number') {\n            throw createBuiltInError('_sum');\n          } else if (typeof result[j] === 'undefined') {\n            result.push(jNum);\n          } else {\n            result[j] += jNum;\n          }\n        }\n      } else { // not array/number\n        throw createBuiltInError('_sum');\n      }\n    } else if (typeof result === 'number') {\n      result += num;\n    } else { // add number to array\n      result[0] += num;\n    }\n  }\n  return result;\n}\n\nvar log = guardedConsole.bind(null, 'log');\nvar isArray = Array.isArray;\nvar toJSON = JSON.parse;\n\nfunction evalFunctionWithEval(func, emit) {\n  return scopeEval(\n    \"return (\" + func.replace(/;\\s*$/, \"\") + \");\",\n    {\n      emit: emit,\n      sum: sum,\n      log: log,\n      isArray: isArray,\n      toJSON: toJSON\n    }\n  );\n}\n\n/*\n * Simple task queue to sequentialize actions. Assumes\n * callbacks will eventually fire (once).\n */\n\n\nfunction TaskQueue$2() {\n  this.promise = new PouchPromise$1(function (fulfill) {fulfill(); });\n}\nTaskQueue$2.prototype.add = function (promiseFactory) {\n  this.promise = this.promise.catch(function () {\n    // just recover\n  }).then(function () {\n    return promiseFactory();\n  });\n  return this.promise;\n};\nTaskQueue$2.prototype.finish = function () {\n  return this.promise;\n};\n\nfunction stringify(input) {\n  if (!input) {\n    return 'undefined'; // backwards compat for empty reduce\n  }\n  // for backwards compat with mapreduce, functions/strings are stringified\n  // as-is. everything else is JSON-stringified.\n  switch (typeof input) {\n    case 'function':\n      // e.g. a mapreduce map\n      return input.toString();\n    case 'string':\n      // e.g. a mapreduce built-in _reduce function\n      return input.toString();\n    default:\n      // e.g. a JSON object in the case of mango queries\n      return JSON.stringify(input);\n  }\n}\n\n/* create a string signature for a view so we can cache it and uniq it */\nfunction createViewSignature(mapFun, reduceFun) {\n  // the \"undefined\" part is for backwards compatibility\n  return stringify(mapFun) + stringify(reduceFun) + 'undefined';\n}\n\nfunction createView(sourceDB, viewName, mapFun, reduceFun, temporary, localDocName) {\n  var viewSignature = createViewSignature(mapFun, reduceFun);\n\n  var cachedViews;\n  if (!temporary) {\n    // cache this to ensure we don't try to update the same view twice\n    cachedViews = sourceDB._cachedViews = sourceDB._cachedViews || {};\n    if (cachedViews[viewSignature]) {\n      return cachedViews[viewSignature];\n    }\n  }\n\n  var promiseForView = sourceDB.info().then(function (info) {\n\n    var depDbName = info.db_name + '-mrview-' +\n      (temporary ? 'temp' : stringMd5(viewSignature));\n\n    // save the view name in the source db so it can be cleaned up if necessary\n    // (e.g. when the _design doc is deleted, remove all associated view data)\n    function diffFunction(doc) {\n      doc.views = doc.views || {};\n      var fullViewName = viewName;\n      if (fullViewName.indexOf('/') === -1) {\n        fullViewName = viewName + '/' + viewName;\n      }\n      var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};\n      /* istanbul ignore if */\n      if (depDbs[depDbName]) {\n        return; // no update necessary\n      }\n      depDbs[depDbName] = true;\n      return doc;\n    }\n    return upsert(sourceDB, '_local/' + localDocName, diffFunction).then(function () {\n      return sourceDB.registerDependentDatabase(depDbName).then(function (res) {\n        var db = res.db;\n        db.auto_compaction = true;\n        var view = {\n          name: depDbName,\n          db: db,\n          sourceDB: sourceDB,\n          adapter: sourceDB.adapter,\n          mapFun: mapFun,\n          reduceFun: reduceFun\n        };\n        return view.db.get('_local/lastSeq').catch(function (err) {\n          /* istanbul ignore if */\n          if (err.status !== 404) {\n            throw err;\n          }\n        }).then(function (lastSeqDoc) {\n          view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;\n          if (cachedViews) {\n            view.db.once('destroyed', function () {\n              delete cachedViews[viewSignature];\n            });\n          }\n          return view;\n        });\n      });\n    });\n  });\n\n  if (cachedViews) {\n    cachedViews[viewSignature] = promiseForView;\n  }\n  return promiseForView;\n}\n\nvar persistentQueues = {};\nvar tempViewQueue = new TaskQueue$2();\nvar CHANGES_BATCH_SIZE$1 = 50;\n\nfunction parseViewName(name) {\n  // can be either 'ddocname/viewname' or just 'viewname'\n  // (where the ddoc name is the same)\n  return name.indexOf('/') === -1 ? [name, name] : name.split('/');\n}\n\nfunction isGenOne(changes) {\n  // only return true if the current change is 1-\n  // and there are no other leafs\n  return changes.length === 1 && /^1-/.test(changes[0].rev);\n}\n\nfunction emitError(db, e) {\n  try {\n    db.emit('error', e);\n  } catch (err) {\n    guardedConsole('error',\n      'The user\\'s map/reduce function threw an uncaught error.\\n' +\n      'You can debug this error by doing:\\n' +\n      'myDatabase.on(\\'error\\', function (err) { debugger; });\\n' +\n      'Please double-check your map/reduce function.');\n    guardedConsole('error', e);\n  }\n}\n\n/**\n * Returns an \"abstract\" mapreduce object of the form:\n *\n *   {\n *     query: queryFun,\n *     viewCleanup: viewCleanupFun\n *   }\n *\n * Arguments are:\n *\n * localDoc: string\n *   This is for the local doc that gets saved in order to track the\n *   \"dependent\" DBs and clean them up for viewCleanup. It should be\n *   unique, so that indexer plugins don't collide with each other.\n * mapper: function (mapFunDef, emit)\n *   Returns a map function based on the mapFunDef, which in the case of\n *   normal map/reduce is just the de-stringified function, but may be\n *   something else, such as an object in the case of pouchdb-find.\n * reducer: function (reduceFunDef)\n *   Ditto, but for reducing. Modules don't have to support reducing\n *   (e.g. pouchdb-find).\n * ddocValidator: function (ddoc, viewName)\n *   Throws an error if the ddoc or viewName is not valid.\n *   This could be a way to communicate to the user that the configuration for the\n *   indexer is invalid.\n */\nfunction createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator) {\n\n  function tryMap(db, fun, doc) {\n    // emit an event if there was an error thrown by a map function.\n    // putting try/catches in a single function also avoids deoptimizations.\n    try {\n      fun(doc);\n    } catch (e) {\n      emitError(db, e);\n    }\n  }\n\n  function tryReduce(db, fun, keys, values, rereduce) {\n    // same as above, but returning the result or an error. there are two separate\n    // functions to avoid extra memory allocations since the tryCode() case is used\n    // for custom map functions (common) vs this function, which is only used for\n    // custom reduce functions (rare)\n    try {\n      return {output : fun(keys, values, rereduce)};\n    } catch (e) {\n      emitError(db, e);\n      return {error: e};\n    }\n  }\n\n  function sortByKeyThenValue(x, y) {\n    var keyCompare = collate(x.key, y.key);\n    return keyCompare !== 0 ? keyCompare : collate(x.value, y.value);\n  }\n\n  function sliceResults(results, limit, skip) {\n    skip = skip || 0;\n    if (typeof limit === 'number') {\n      return results.slice(skip, limit + skip);\n    } else if (skip > 0) {\n      return results.slice(skip);\n    }\n    return results;\n  }\n\n  function rowToDocId(row) {\n    var val = row.value;\n    // Users can explicitly specify a joined doc _id, or it\n    // defaults to the doc _id that emitted the key/value.\n    var docId = (val && typeof val === 'object' && val._id) || row.id;\n    return docId;\n  }\n\n  function readAttachmentsAsBlobOrBuffer(res) {\n    res.rows.forEach(function (row) {\n      var atts = row.doc && row.doc._attachments;\n      if (!atts) {\n        return;\n      }\n      Object.keys(atts).forEach(function (filename) {\n        var att = atts[filename];\n        atts[filename].data = b64ToBluffer(att.data, att.content_type);\n      });\n    });\n  }\n\n  function postprocessAttachments(opts) {\n    return function (res) {\n      if (opts.include_docs && opts.attachments && opts.binary) {\n        readAttachmentsAsBlobOrBuffer(res);\n      }\n      return res;\n    };\n  }\n\n  function addHttpParam(paramName, opts, params, asJson) {\n    // add an http param from opts to params, optionally json-encoded\n    var val = opts[paramName];\n    if (typeof val !== 'undefined') {\n      if (asJson) {\n        val = encodeURIComponent(JSON.stringify(val));\n      }\n      params.push(paramName + '=' + val);\n    }\n  }\n\n  function coerceInteger(integerCandidate) {\n    if (typeof integerCandidate !== 'undefined') {\n      var asNumber = Number(integerCandidate);\n      // prevents e.g. '1foo' or '1.1' being coerced to 1\n      if (!isNaN(asNumber) && asNumber === parseInt(integerCandidate, 10)) {\n        return asNumber;\n      } else {\n        return integerCandidate;\n      }\n    }\n  }\n\n  function coerceOptions(opts) {\n    opts.group_level = coerceInteger(opts.group_level);\n    opts.limit = coerceInteger(opts.limit);\n    opts.skip = coerceInteger(opts.skip);\n    return opts;\n  }\n\n  function checkPositiveInteger(number) {\n    if (number) {\n      if (typeof number !== 'number') {\n        return  new QueryParseError('Invalid value for integer: \"' +\n          number + '\"');\n      }\n      if (number < 0) {\n        return new QueryParseError('Invalid value for positive integer: ' +\n          '\"' + number + '\"');\n      }\n    }\n  }\n\n  function checkQueryParseError(options, fun) {\n    var startkeyName = options.descending ? 'endkey' : 'startkey';\n    var endkeyName = options.descending ? 'startkey' : 'endkey';\n\n    if (typeof options[startkeyName] !== 'undefined' &&\n      typeof options[endkeyName] !== 'undefined' &&\n      collate(options[startkeyName], options[endkeyName]) > 0) {\n      throw new QueryParseError('No rows can match your key range, ' +\n        'reverse your start_key and end_key or set {descending : true}');\n    } else if (fun.reduce && options.reduce !== false) {\n      if (options.include_docs) {\n        throw new QueryParseError('{include_docs:true} is invalid for reduce');\n      } else if (options.keys && options.keys.length > 1 &&\n        !options.group && !options.group_level) {\n        throw new QueryParseError('Multi-key fetches for reduce views must use ' +\n          '{group: true}');\n      }\n    }\n    ['group_level', 'limit', 'skip'].forEach(function (optionName) {\n      var error = checkPositiveInteger(options[optionName]);\n      if (error) {\n        throw error;\n      }\n    });\n  }\n\n  function httpQuery(db, fun, opts) {\n    // List of parameters to add to the PUT request\n    var params = [];\n    var body;\n    var method = 'GET';\n\n    // If opts.reduce exists and is defined, then add it to the list\n    // of parameters.\n    // If reduce=false then the results are that of only the map function\n    // not the final result of map and reduce.\n    addHttpParam('reduce', opts, params);\n    addHttpParam('include_docs', opts, params);\n    addHttpParam('attachments', opts, params);\n    addHttpParam('limit', opts, params);\n    addHttpParam('descending', opts, params);\n    addHttpParam('group', opts, params);\n    addHttpParam('group_level', opts, params);\n    addHttpParam('skip', opts, params);\n    addHttpParam('stale', opts, params);\n    addHttpParam('conflicts', opts, params);\n    addHttpParam('startkey', opts, params, true);\n    addHttpParam('start_key', opts, params, true);\n    addHttpParam('endkey', opts, params, true);\n    addHttpParam('end_key', opts, params, true);\n    addHttpParam('inclusive_end', opts, params);\n    addHttpParam('key', opts, params, true);\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    params = params === '' ? '' : '?' + params;\n\n    // If keys are supplied, issue a POST to circumvent GET query string limits\n    // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\n    if (typeof opts.keys !== 'undefined') {\n      var MAX_URL_LENGTH = 2000;\n      // according to http://stackoverflow.com/a/417184/680742,\n      // the de facto URL length limit is 2000 characters\n\n      var keysAsString =\n        'keys=' + encodeURIComponent(JSON.stringify(opts.keys));\n      if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {\n        // If the keys are short enough, do a GET. we do this to work around\n        // Safari not understanding 304s on POSTs (see pouchdb/pouchdb#1239)\n        params += (params[0] === '?' ? '&' : '?') + keysAsString;\n      } else {\n        method = 'POST';\n        if (typeof fun === 'string') {\n          body = {keys: opts.keys};\n        } else { // fun is {map : mapfun}, so append to this\n          fun.keys = opts.keys;\n        }\n      }\n    }\n\n    // We are referencing a query defined in the design doc\n    if (typeof fun === 'string') {\n      var parts = parseViewName(fun);\n      return db.request({\n        method: method,\n        url: '_design/' + parts[0] + '/_view/' + parts[1] + params,\n        body: body\n      }).then(\n        /* istanbul ignore next */\n        function (result) {\n          // fail the entire request if the result contains an error\n          result.rows.forEach(function (row) {\n            if (row.value && row.value.error && row.value.error === \"builtin_reduce_error\") {\n              throw new Error(row.reason);\n            }\n          });\n\n          return result;\n      })\n      .then(postprocessAttachments(opts));\n    }\n\n    // We are using a temporary view, terrible for performance, good for testing\n    body = body || {};\n    Object.keys(fun).forEach(function (key) {\n      if (Array.isArray(fun[key])) {\n        body[key] = fun[key];\n      } else {\n        body[key] = fun[key].toString();\n      }\n    });\n    return db.request({\n      method: 'POST',\n      url: '_temp_view' + params,\n      body: body\n    }).then(postprocessAttachments(opts));\n  }\n\n  // custom adapters can define their own api._query\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customQuery(db, fun, opts) {\n    return new PouchPromise$1(function (resolve, reject) {\n      db._query(fun, opts, function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  // custom adapters can define their own api._viewCleanup\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customViewCleanup(db) {\n    return new PouchPromise$1(function (resolve, reject) {\n      db._viewCleanup(function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  function defaultsTo(value) {\n    return function (reason) {\n      /* istanbul ignore else */\n      if (reason.status === 404) {\n        return value;\n      } else {\n        throw reason;\n      }\n    };\n  }\n\n  // returns a promise for a list of docs to update, based on the input docId.\n  // the order doesn't matter, because post-3.2.0, bulkDocs\n  // is an atomic operation in all three adapters.\n  function getDocsToPersist(docId, view, docIdsToChangesAndEmits) {\n    var metaDocId = '_local/doc_' + docId;\n    var defaultMetaDoc = {_id: metaDocId, keys: []};\n    var docData = docIdsToChangesAndEmits.get(docId);\n    var indexableKeysToKeyValues = docData[0];\n    var changes = docData[1];\n\n    function getMetaDoc() {\n      if (isGenOne(changes)) {\n        // generation 1, so we can safely assume initial state\n        // for performance reasons (avoids unnecessary GETs)\n        return PouchPromise$1.resolve(defaultMetaDoc);\n      }\n      return view.db.get(metaDocId).catch(defaultsTo(defaultMetaDoc));\n    }\n\n    function getKeyValueDocs(metaDoc) {\n      if (!metaDoc.keys.length) {\n        // no keys, no need for a lookup\n        return PouchPromise$1.resolve({rows: []});\n      }\n      return view.db.allDocs({\n        keys: metaDoc.keys,\n        include_docs: true\n      });\n    }\n\n    function processKeyValueDocs(metaDoc, kvDocsRes) {\n      var kvDocs = [];\n      var oldKeys = new ExportedSet();\n\n      for (var i = 0, len = kvDocsRes.rows.length; i < len; i++) {\n        var row = kvDocsRes.rows[i];\n        var doc = row.doc;\n        if (!doc) { // deleted\n          continue;\n        }\n        kvDocs.push(doc);\n        oldKeys.add(doc._id);\n        doc._deleted = !indexableKeysToKeyValues.has(doc._id);\n        if (!doc._deleted) {\n          var keyValue = indexableKeysToKeyValues.get(doc._id);\n          if ('value' in keyValue) {\n            doc.value = keyValue.value;\n          }\n        }\n      }\n      var newKeys = mapToKeysArray(indexableKeysToKeyValues);\n      newKeys.forEach(function (key) {\n        if (!oldKeys.has(key)) {\n          // new doc\n          var kvDoc = {\n            _id: key\n          };\n          var keyValue = indexableKeysToKeyValues.get(key);\n          if ('value' in keyValue) {\n            kvDoc.value = keyValue.value;\n          }\n          kvDocs.push(kvDoc);\n        }\n      });\n      metaDoc.keys = uniq(newKeys.concat(metaDoc.keys));\n      kvDocs.push(metaDoc);\n\n      return kvDocs;\n    }\n\n    return getMetaDoc().then(function (metaDoc) {\n      return getKeyValueDocs(metaDoc).then(function (kvDocsRes) {\n        return processKeyValueDocs(metaDoc, kvDocsRes);\n      });\n    });\n  }\n\n  // updates all emitted key/value docs and metaDocs in the mrview database\n  // for the given batch of documents from the source database\n  function saveKeyValues(view, docIdsToChangesAndEmits, seq) {\n    var seqDocId = '_local/lastSeq';\n    return view.db.get(seqDocId)\n      .catch(defaultsTo({_id: seqDocId, seq: 0}))\n      .then(function (lastSeqDoc) {\n        var docIds = mapToKeysArray(docIdsToChangesAndEmits);\n        return PouchPromise$1.all(docIds.map(function (docId) {\n          return getDocsToPersist(docId, view, docIdsToChangesAndEmits);\n        })).then(function (listOfDocsToPersist) {\n          var docsToPersist = flatten(listOfDocsToPersist);\n          lastSeqDoc.seq = seq;\n          docsToPersist.push(lastSeqDoc);\n          // write all docs in a single operation, update the seq once\n          return view.db.bulkDocs({docs : docsToPersist});\n        });\n      });\n  }\n\n  function getQueue(view) {\n    var viewName = typeof view === 'string' ? view : view.name;\n    var queue = persistentQueues[viewName];\n    if (!queue) {\n      queue = persistentQueues[viewName] = new TaskQueue$2();\n    }\n    return queue;\n  }\n\n  function updateView(view) {\n    return sequentialize(getQueue(view), function () {\n      return updateViewInQueue(view);\n    })();\n  }\n\n  function updateViewInQueue(view) {\n    // bind the emit function once\n    var mapResults;\n    var doc;\n\n    function emit(key, value) {\n      var output = {id: doc._id, key: normalizeKey(key)};\n      // Don't explicitly store the value unless it's defined and non-null.\n      // This saves on storage space, because often people don't use it.\n      if (typeof value !== 'undefined' && value !== null) {\n        output.value = normalizeKey(value);\n      }\n      mapResults.push(output);\n    }\n\n    var mapFun = mapper(view.mapFun, emit);\n\n    var currentSeq = view.seq || 0;\n\n    function processChange(docIdsToChangesAndEmits, seq) {\n      return function () {\n        return saveKeyValues(view, docIdsToChangesAndEmits, seq);\n      };\n    }\n\n    var queue = new TaskQueue$2();\n\n    function processNextBatch() {\n      return view.sourceDB.changes({\n        conflicts: true,\n        include_docs: true,\n        style: 'all_docs',\n        since: currentSeq,\n        limit: CHANGES_BATCH_SIZE$1\n      }).then(processBatch);\n    }\n\n    function processBatch(response) {\n      var results = response.results;\n      if (!results.length) {\n        return;\n      }\n      var docIdsToChangesAndEmits = createDocIdsToChangesAndEmits(results);\n      queue.add(processChange(docIdsToChangesAndEmits, currentSeq));\n      if (results.length < CHANGES_BATCH_SIZE$1) {\n        return;\n      }\n      return processNextBatch();\n    }\n\n    function createDocIdsToChangesAndEmits(results) {\n      var docIdsToChangesAndEmits = new ExportedMap();\n      for (var i = 0, len = results.length; i < len; i++) {\n        var change = results[i];\n        if (change.doc._id[0] !== '_') {\n          mapResults = [];\n          doc = change.doc;\n\n          if (!doc._deleted) {\n            tryMap(view.sourceDB, mapFun, doc);\n          }\n          mapResults.sort(sortByKeyThenValue);\n\n          var indexableKeysToKeyValues = createIndexableKeysToKeyValues(mapResults);\n          docIdsToChangesAndEmits.set(change.doc._id, [\n            indexableKeysToKeyValues,\n            change.changes\n          ]);\n        }\n        currentSeq = change.seq;\n      }\n      return docIdsToChangesAndEmits;\n    }\n\n    function createIndexableKeysToKeyValues(mapResults) {\n      var indexableKeysToKeyValues = new ExportedMap();\n      var lastKey;\n      for (var i = 0, len = mapResults.length; i < len; i++) {\n        var emittedKeyValue = mapResults[i];\n        var complexKey = [emittedKeyValue.key, emittedKeyValue.id];\n        if (i > 0 && collate(emittedKeyValue.key, lastKey) === 0) {\n          complexKey.push(i); // dup key+id, so make it unique\n        }\n        indexableKeysToKeyValues.set(toIndexableString(complexKey), emittedKeyValue);\n        lastKey = emittedKeyValue.key;\n      }\n      return indexableKeysToKeyValues;\n    }\n\n    return processNextBatch().then(function () {\n      return queue.finish();\n    }).then(function () {\n      view.seq = currentSeq;\n    });\n  }\n\n  function reduceView(view, results, options) {\n    if (options.group_level === 0) {\n      delete options.group_level;\n    }\n\n    var shouldGroup = options.group || options.group_level;\n\n    var reduceFun = reducer(view.reduceFun);\n\n    var groups = [];\n    var lvl = isNaN(options.group_level) ? Number.POSITIVE_INFINITY :\n      options.group_level;\n    results.forEach(function (e) {\n      var last = groups[groups.length - 1];\n      var groupKey = shouldGroup ? e.key : null;\n\n      // only set group_level for array keys\n      if (shouldGroup && Array.isArray(groupKey)) {\n        groupKey = groupKey.slice(0, lvl);\n      }\n\n      if (last && collate(last.groupKey, groupKey) === 0) {\n        last.keys.push([e.key, e.id]);\n        last.values.push(e.value);\n        return;\n      }\n      groups.push({\n        keys: [[e.key, e.id]],\n        values: [e.value],\n        groupKey: groupKey\n      });\n    });\n    results = [];\n    for (var i = 0, len = groups.length; i < len; i++) {\n      var e = groups[i];\n      var reduceTry = tryReduce(view.sourceDB, reduceFun, e.keys, e.values, false);\n      if (reduceTry.error && reduceTry.error instanceof BuiltInError) {\n        // CouchDB returns an error if a built-in errors out\n        throw reduceTry.error;\n      }\n      results.push({\n        // CouchDB just sets the value to null if a non-built-in errors out\n        value: reduceTry.error ? null : reduceTry.output,\n        key: e.groupKey\n      });\n    }\n    // no total_rows/offset when reducing\n    return {rows: sliceResults(results, options.limit, options.skip)};\n  }\n\n  function queryView(view, opts) {\n    return sequentialize(getQueue(view), function () {\n      return queryViewInQueue(view, opts);\n    })();\n  }\n\n  function queryViewInQueue(view, opts) {\n    var totalRows;\n    var shouldReduce = view.reduceFun && opts.reduce !== false;\n    var skip = opts.skip || 0;\n    if (typeof opts.keys !== 'undefined' && !opts.keys.length) {\n      // equivalent query\n      opts.limit = 0;\n      delete opts.keys;\n    }\n\n    function fetchFromView(viewOpts) {\n      viewOpts.include_docs = true;\n      return view.db.allDocs(viewOpts).then(function (res) {\n        totalRows = res.total_rows;\n        return res.rows.map(function (result) {\n\n          // implicit migration - in older versions of PouchDB,\n          // we explicitly stored the doc as {id: ..., key: ..., value: ...}\n          // this is tested in a migration test\n          /* istanbul ignore next */\n          if ('value' in result.doc && typeof result.doc.value === 'object' &&\n            result.doc.value !== null) {\n            var keys = Object.keys(result.doc.value).sort();\n            // this detection method is not perfect, but it's unlikely the user\n            // emitted a value which was an object with these 3 exact keys\n            var expectedKeys = ['id', 'key', 'value'];\n            if (!(keys < expectedKeys || keys > expectedKeys)) {\n              return result.doc.value;\n            }\n          }\n\n          var parsedKeyAndDocId = parseIndexableString(result.doc._id);\n          return {\n            key: parsedKeyAndDocId[0],\n            id: parsedKeyAndDocId[1],\n            value: ('value' in result.doc ? result.doc.value : null)\n          };\n        });\n      });\n    }\n\n    function onMapResultsReady(rows) {\n      var finalResults;\n      if (shouldReduce) {\n        finalResults = reduceView(view, rows, opts);\n      } else {\n        finalResults = {\n          total_rows: totalRows,\n          offset: skip,\n          rows: rows\n        };\n      }\n      if (opts.include_docs) {\n        var docIds = uniq(rows.map(rowToDocId));\n\n        return view.sourceDB.allDocs({\n          keys: docIds,\n          include_docs: true,\n          conflicts: opts.conflicts,\n          attachments: opts.attachments,\n          binary: opts.binary\n        }).then(function (allDocsRes) {\n          var docIdsToDocs = new ExportedMap();\n          allDocsRes.rows.forEach(function (row) {\n            docIdsToDocs.set(row.id, row.doc);\n          });\n          rows.forEach(function (row) {\n            var docId = rowToDocId(row);\n            var doc = docIdsToDocs.get(docId);\n            if (doc) {\n              row.doc = doc;\n            }\n          });\n          return finalResults;\n        });\n      } else {\n        return finalResults;\n      }\n    }\n\n    if (typeof opts.keys !== 'undefined') {\n      var keys = opts.keys;\n      var fetchPromises = keys.map(function (key) {\n        var viewOpts = {\n          startkey : toIndexableString([key]),\n          endkey   : toIndexableString([key, {}])\n        };\n        return fetchFromView(viewOpts);\n      });\n      return PouchPromise$1.all(fetchPromises).then(flatten).then(onMapResultsReady);\n    } else { // normal query, no 'keys'\n      var viewOpts = {\n        descending : opts.descending\n      };\n      var startkey;\n      var endkey;\n      if ('start_key' in opts) {\n        startkey = opts.start_key;\n      }\n      if ('startkey' in opts) {\n        startkey = opts.startkey;\n      }\n      if ('end_key' in opts) {\n        endkey = opts.end_key;\n      }\n      if ('endkey' in opts) {\n        endkey = opts.endkey;\n      }\n      if (typeof startkey !== 'undefined') {\n        viewOpts.startkey = opts.descending ?\n          toIndexableString([startkey, {}]) :\n          toIndexableString([startkey]);\n      }\n      if (typeof endkey !== 'undefined') {\n        var inclusiveEnd = opts.inclusive_end !== false;\n        if (opts.descending) {\n          inclusiveEnd = !inclusiveEnd;\n        }\n\n        viewOpts.endkey = toIndexableString(\n          inclusiveEnd ? [endkey, {}] : [endkey]);\n      }\n      if (typeof opts.key !== 'undefined') {\n        var keyStart = toIndexableString([opts.key]);\n        var keyEnd = toIndexableString([opts.key, {}]);\n        if (viewOpts.descending) {\n          viewOpts.endkey = keyStart;\n          viewOpts.startkey = keyEnd;\n        } else {\n          viewOpts.startkey = keyStart;\n          viewOpts.endkey = keyEnd;\n        }\n      }\n      if (!shouldReduce) {\n        if (typeof opts.limit === 'number') {\n          viewOpts.limit = opts.limit;\n        }\n        viewOpts.skip = skip;\n      }\n      return fetchFromView(viewOpts).then(onMapResultsReady);\n    }\n  }\n\n  function httpViewCleanup(db) {\n    return db.request({\n      method: 'POST',\n      url: '_view_cleanup'\n    });\n  }\n\n  function localViewCleanup(db) {\n    return db.get('_local/' + localDocName).then(function (metaDoc) {\n      var docsToViews = new ExportedMap();\n      Object.keys(metaDoc.views).forEach(function (fullViewName) {\n        var parts = parseViewName(fullViewName);\n        var designDocName = '_design/' + parts[0];\n        var viewName = parts[1];\n        var views = docsToViews.get(designDocName);\n        if (!views) {\n          views = new ExportedSet();\n          docsToViews.set(designDocName, views);\n        }\n        views.add(viewName);\n      });\n      var opts = {\n        keys : mapToKeysArray(docsToViews),\n        include_docs : true\n      };\n      return db.allDocs(opts).then(function (res) {\n        var viewsToStatus = {};\n        res.rows.forEach(function (row) {\n          var ddocName = row.key.substring(8); // cuts off '_design/'\n          docsToViews.get(row.key).forEach(function (viewName) {\n            var fullViewName = ddocName + '/' + viewName;\n            /* istanbul ignore if */\n            if (!metaDoc.views[fullViewName]) {\n              // new format, without slashes, to support PouchDB 2.2.0\n              // migration test in pouchdb's browser.migration.js verifies this\n              fullViewName = viewName;\n            }\n            var viewDBNames = Object.keys(metaDoc.views[fullViewName]);\n            // design doc deleted, or view function nonexistent\n            var statusIsGood = row.doc && row.doc.views &&\n              row.doc.views[viewName];\n            viewDBNames.forEach(function (viewDBName) {\n              viewsToStatus[viewDBName] =\n                viewsToStatus[viewDBName] || statusIsGood;\n            });\n          });\n        });\n        var dbsToDelete = Object.keys(viewsToStatus).filter(\n          function (viewDBName) { return !viewsToStatus[viewDBName]; });\n        var destroyPromises = dbsToDelete.map(function (viewDBName) {\n          return sequentialize(getQueue(viewDBName), function () {\n            return new db.constructor(viewDBName, db.__opts).destroy();\n          })();\n        });\n        return PouchPromise$1.all(destroyPromises).then(function () {\n          return {ok: true};\n        });\n      });\n    }, defaultsTo({ok: true}));\n  }\n\n  function queryPromised(db, fun, opts) {\n    /* istanbul ignore next */\n    if (typeof db._query === 'function') {\n      return customQuery(db, fun, opts);\n    }\n    if (isRemote(db)) {\n      return httpQuery(db, fun, opts);\n    }\n\n    if (typeof fun !== 'string') {\n      // temp_view\n      checkQueryParseError(opts, fun);\n\n      tempViewQueue.add(function () {\n        var createViewPromise = createView(\n          /* sourceDB */ db,\n          /* viewName */ 'temp_view/temp_view',\n          /* mapFun */ fun.map,\n          /* reduceFun */ fun.reduce,\n          /* temporary */ true,\n          /* localDocName */ localDocName);\n        return createViewPromise.then(function (view) {\n          return fin(updateView(view).then(function () {\n            return queryView(view, opts);\n          }), function () {\n            return view.db.destroy();\n          });\n        });\n      });\n      return tempViewQueue.finish();\n    } else {\n      // persistent view\n      var fullViewName = fun;\n      var parts = parseViewName(fullViewName);\n      var designDocName = parts[0];\n      var viewName = parts[1];\n      return db.get('_design/' + designDocName).then(function (doc) {\n        var fun = doc.views && doc.views[viewName];\n\n        if (!fun) {\n          // basic validator; it's assumed that every subclass would want this\n          throw new NotFoundError('ddoc ' + doc._id + ' has no view named ' +\n            viewName);\n        }\n\n        ddocValidator(doc, viewName);\n        checkQueryParseError(opts, fun);\n\n        var createViewPromise = createView(\n          /* sourceDB */ db,\n          /* viewName */ fullViewName,\n          /* mapFun */ fun.map,\n          /* reduceFun */ fun.reduce,\n          /* temporary */ false,\n          /* localDocName */ localDocName);\n        return createViewPromise.then(function (view) {\n          if (opts.stale === 'ok' || opts.stale === 'update_after') {\n            if (opts.stale === 'update_after') {\n              nextTick(function () {\n                updateView(view);\n              });\n            }\n            return queryView(view, opts);\n          } else { // stale not ok\n            return updateView(view).then(function () {\n              return queryView(view, opts);\n            });\n          }\n        });\n      });\n    }\n  }\n\n  function abstractQuery(fun, opts, callback) {\n    var db = this;\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = opts ? coerceOptions(opts) : {};\n\n    if (typeof fun === 'function') {\n      fun = {map : fun};\n    }\n\n    var promise = PouchPromise$1.resolve().then(function () {\n      return queryPromised(db, fun, opts);\n    });\n    promisedCallback(promise, callback);\n    return promise;\n  }\n\n  var abstractViewCleanup = callbackify(function () {\n    var db = this;\n    /* istanbul ignore next */\n    if (typeof db._viewCleanup === 'function') {\n      return customViewCleanup(db);\n    }\n    if (isRemote(db)) {\n      return httpViewCleanup(db);\n    }\n    return localViewCleanup(db);\n  });\n\n  return {\n    query: abstractQuery,\n    viewCleanup: abstractViewCleanup\n  };\n}\n\nvar builtInReduce = {\n  _sum: function (keys, values) {\n    return sum(values);\n  },\n\n  _count: function (keys, values) {\n    return values.length;\n  },\n\n  _stats: function (keys, values) {\n    // no need to implement rereduce=true, because Pouch\n    // will never call it\n    function sumsqr(values) {\n      var _sumsqr = 0;\n      for (var i = 0, len = values.length; i < len; i++) {\n        var num = values[i];\n        _sumsqr += (num * num);\n      }\n      return _sumsqr;\n    }\n    return {\n      sum     : sum(values),\n      min     : Math.min.apply(null, values),\n      max     : Math.max.apply(null, values),\n      count   : values.length,\n      sumsqr : sumsqr(values)\n    };\n  }\n};\n\nfunction getBuiltIn(reduceFunString) {\n  if (/^_sum/.test(reduceFunString)) {\n    return builtInReduce._sum;\n  } else if (/^_count/.test(reduceFunString)) {\n    return builtInReduce._count;\n  } else if (/^_stats/.test(reduceFunString)) {\n    return builtInReduce._stats;\n  } else if (/^_/.test(reduceFunString)) {\n    throw new Error(reduceFunString + ' is not a supported reduce function.');\n  }\n}\n\nfunction mapper(mapFun, emit) {\n  // for temp_views one can use emit(doc, emit), see #38\n  if (typeof mapFun === \"function\" && mapFun.length === 2) {\n    var origMap = mapFun;\n    return function (doc) {\n      return origMap(doc, emit);\n    };\n  } else {\n    return evalFunctionWithEval(mapFun.toString(), emit);\n  }\n}\n\nfunction reducer(reduceFun) {\n  var reduceFunString = reduceFun.toString();\n  var builtIn = getBuiltIn(reduceFunString);\n  if (builtIn) {\n    return builtIn;\n  } else {\n    return evalFunctionWithEval(reduceFunString);\n  }\n}\n\nfunction ddocValidator(ddoc, viewName) {\n  var fun = ddoc.views && ddoc.views[viewName];\n  if (typeof fun.map !== 'string') {\n    throw new NotFoundError('ddoc ' + ddoc._id + ' has no string view named ' +\n      viewName + ', instead found object of type: ' + typeof fun.map);\n  }\n}\n\nvar localDocName = 'mrviews';\nvar abstract = createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator);\n\nfunction query(fun, opts, callback) {\n  return abstract.query.call(this, fun, opts, callback);\n}\n\nfunction viewCleanup(callback) {\n  return abstract.viewCleanup.call(this, callback);\n}\n\nvar mapreduce = {\n  query: query,\n  viewCleanup: viewCleanup\n};\n\nfunction isGenOne$1(rev$$1) {\n  return /^1-/.test(rev$$1);\n}\n\nfunction fileHasChanged(localDoc, remoteDoc, filename) {\n  return !localDoc._attachments ||\n         !localDoc._attachments[filename] ||\n         localDoc._attachments[filename].digest !== remoteDoc._attachments[filename].digest;\n}\n\nfunction getDocAttachments(db, doc) {\n  var filenames = Object.keys(doc._attachments);\n  return PouchPromise$1.all(filenames.map(function (filename) {\n    return db.getAttachment(doc._id, filename, {rev: doc._rev});\n  }));\n}\n\nfunction getDocAttachmentsFromTargetOrSource(target, src, doc) {\n  var doCheckForLocalAttachments = isRemote(src) && !isRemote(target);\n  var filenames = Object.keys(doc._attachments);\n\n  if (!doCheckForLocalAttachments) {\n    return getDocAttachments(src, doc);\n  }\n\n  return target.get(doc._id).then(function (localDoc) {\n    return PouchPromise$1.all(filenames.map(function (filename) {\n      if (fileHasChanged(localDoc, doc, filename)) {\n        return src.getAttachment(doc._id, filename);\n      }\n\n      return target.getAttachment(localDoc._id, filename);\n    }));\n  }).catch(function (error) {\n    /* istanbul ignore if */\n    if (error.status !== 404) {\n      throw error;\n    }\n\n    return getDocAttachments(src, doc);\n  });\n}\n\nfunction createBulkGetOpts(diffs) {\n  var requests = [];\n  Object.keys(diffs).forEach(function (id) {\n    var missingRevs = diffs[id].missing;\n    missingRevs.forEach(function (missingRev) {\n      requests.push({\n        id: id,\n        rev: missingRev\n      });\n    });\n  });\n\n  return {\n    docs: requests,\n    revs: true,\n    latest: true\n  };\n}\n\n//\n// Fetch all the documents from the src as described in the \"diffs\",\n// which is a mapping of docs IDs to revisions. If the state ever\n// changes to \"cancelled\", then the returned promise will be rejected.\n// Else it will be resolved with a list of fetched documents.\n//\nfunction getDocs(src, target, diffs, state) {\n  diffs = clone(diffs); // we do not need to modify this\n\n  var resultDocs = [],\n      ok = true;\n\n  function getAllDocs() {\n\n    var bulkGetOpts = createBulkGetOpts(diffs);\n\n    if (!bulkGetOpts.docs.length) { // optimization: skip empty requests\n      return;\n    }\n\n    return src.bulkGet(bulkGetOpts).then(function (bulkGetResponse) {\n      /* istanbul ignore if */\n      if (state.cancelled) {\n        throw new Error('cancelled');\n      }\n      return PouchPromise$1.all(bulkGetResponse.results.map(function (bulkGetInfo) {\n        return PouchPromise$1.all(bulkGetInfo.docs.map(function (doc) {\n          var remoteDoc = doc.ok;\n\n          if (doc.error) {\n            // when AUTO_COMPACTION is set, docs can be returned which look\n            // like this: {\"missing\":\"1-7c3ac256b693c462af8442f992b83696\"}\n            ok = false;\n          }\n\n          if (!remoteDoc || !remoteDoc._attachments) {\n            return remoteDoc;\n          }\n\n          return getDocAttachmentsFromTargetOrSource(target, src, remoteDoc)\n                   .then(function (attachments) {\n                           var filenames = Object.keys(remoteDoc._attachments);\n                           attachments\n                             .forEach(function (attachment, i) {\n                                        var att = remoteDoc._attachments[filenames[i]];\n                                        delete att.stub;\n                                        delete att.length;\n                                        att.data = attachment;\n                                      });\n\n                                      return remoteDoc;\n                                    });\n        }));\n      }))\n\n      .then(function (results) {\n        resultDocs = resultDocs.concat(flatten(results).filter(Boolean));\n      });\n    });\n  }\n\n  function hasAttachments(doc) {\n    return doc._attachments && Object.keys(doc._attachments).length > 0;\n  }\n\n  function hasConflicts(doc) {\n    return doc._conflicts && doc._conflicts.length > 0;\n  }\n\n  function fetchRevisionOneDocs(ids) {\n    // Optimization: fetch gen-1 docs and attachments in\n    // a single request using _all_docs\n    return src.allDocs({\n      keys: ids,\n      include_docs: true,\n      conflicts: true\n    }).then(function (res) {\n      if (state.cancelled) {\n        throw new Error('cancelled');\n      }\n      res.rows.forEach(function (row) {\n        if (row.deleted || !row.doc || !isGenOne$1(row.value.rev) ||\n            hasAttachments(row.doc) || hasConflicts(row.doc)) {\n          // if any of these conditions apply, we need to fetch using get()\n          return;\n        }\n\n        // strip _conflicts array to appease CSG (#5793)\n        /* istanbul ignore if */\n        if (row.doc._conflicts) {\n          delete row.doc._conflicts;\n        }\n\n        // the doc we got back from allDocs() is sufficient\n        resultDocs.push(row.doc);\n        delete diffs[row.id];\n      });\n    });\n  }\n\n  function getRevisionOneDocs() {\n    // filter out the generation 1 docs and get them\n    // leaving the non-generation one docs to be got otherwise\n    var ids = Object.keys(diffs).filter(function (id) {\n      var missing = diffs[id].missing;\n      return missing.length === 1 && isGenOne$1(missing[0]);\n    });\n    if (ids.length > 0) {\n      return fetchRevisionOneDocs(ids);\n    }\n  }\n\n  function returnResult() {\n    return { ok:ok, docs:resultDocs };\n  }\n\n  return PouchPromise$1.resolve()\n    .then(getRevisionOneDocs)\n    .then(getAllDocs)\n    .then(returnResult);\n}\n\nvar CHECKPOINT_VERSION = 1;\nvar REPLICATOR = \"pouchdb\";\n// This is an arbitrary number to limit the\n// amount of replication history we save in the checkpoint.\n// If we save too much, the checkpoing docs will become very big,\n// if we save fewer, we'll run a greater risk of having to\n// read all the changes from 0 when checkpoint PUTs fail\n// CouchDB 2.0 has a more involved history pruning,\n// but let's go for the simple version for now.\nvar CHECKPOINT_HISTORY_SIZE = 5;\nvar LOWEST_SEQ = 0;\n\nfunction updateCheckpoint(db, id, checkpoint, session, returnValue) {\n  return db.get(id).catch(function (err) {\n    if (err.status === 404) {\n      if (db.adapter === 'http' || db.adapter === 'https') {\n        explainError(\n          404, 'PouchDB is just checking if a remote checkpoint exists.'\n        );\n      }\n      return {\n        session_id: session,\n        _id: id,\n        history: [],\n        replicator: REPLICATOR,\n        version: CHECKPOINT_VERSION\n      };\n    }\n    throw err;\n  }).then(function (doc) {\n    if (returnValue.cancelled) {\n      return;\n    }\n\n    // if the checkpoint has not changed, do not update\n    if (doc.last_seq === checkpoint) {\n      return;\n    }\n\n    // Filter out current entry for this replication\n    doc.history = (doc.history || []).filter(function (item) {\n      return item.session_id !== session;\n    });\n\n    // Add the latest checkpoint to history\n    doc.history.unshift({\n      last_seq: checkpoint,\n      session_id: session\n    });\n\n    // Just take the last pieces in history, to\n    // avoid really big checkpoint docs.\n    // see comment on history size above\n    doc.history = doc.history.slice(0, CHECKPOINT_HISTORY_SIZE);\n\n    doc.version = CHECKPOINT_VERSION;\n    doc.replicator = REPLICATOR;\n\n    doc.session_id = session;\n    doc.last_seq = checkpoint;\n\n    return db.put(doc).catch(function (err) {\n      if (err.status === 409) {\n        // retry; someone is trying to write a checkpoint simultaneously\n        return updateCheckpoint(db, id, checkpoint, session, returnValue);\n      }\n      throw err;\n    });\n  });\n}\n\nfunction Checkpointer(src, target, id, returnValue, opts) {\n  this.src = src;\n  this.target = target;\n  this.id = id;\n  this.returnValue = returnValue;\n  this.opts = opts;\n}\n\nCheckpointer.prototype.writeCheckpoint = function (checkpoint, session) {\n  var self = this;\n  return this.updateTarget(checkpoint, session).then(function () {\n    return self.updateSource(checkpoint, session);\n  });\n};\n\nCheckpointer.prototype.updateTarget = function (checkpoint, session) {\n  if (this.opts.writeTargetCheckpoint) {\n    return updateCheckpoint(this.target, this.id, checkpoint,\n      session, this.returnValue);\n  } else {\n    return PouchPromise$1.resolve(true);\n  }\n};\n\nCheckpointer.prototype.updateSource = function (checkpoint, session) {\n  if (this.opts.writeSourceCheckpoint) {\n    var self = this;\n    if (this.readOnlySource) {\n      return PouchPromise$1.resolve(true);\n    }\n    return updateCheckpoint(this.src, this.id, checkpoint,\n      session, this.returnValue)\n      .catch(function (err) {\n        if (isForbiddenError(err)) {\n          self.readOnlySource = true;\n          return true;\n        }\n        throw err;\n      });\n  } else {\n    return PouchPromise$1.resolve(true);\n  }\n};\n\nvar comparisons = {\n  \"undefined\": function (targetDoc, sourceDoc) {\n    // This is the previous comparison function\n    if (collate(targetDoc.last_seq, sourceDoc.last_seq) === 0) {\n      return sourceDoc.last_seq;\n    }\n    /* istanbul ignore next */\n    return 0;\n  },\n  \"1\": function (targetDoc, sourceDoc) {\n    // This is the comparison function ported from CouchDB\n    return compareReplicationLogs(sourceDoc, targetDoc).last_seq;\n  }\n};\n\nCheckpointer.prototype.getCheckpoint = function () {\n  var self = this;\n  return self.target.get(self.id).then(function (targetDoc) {\n    if (self.readOnlySource) {\n      return PouchPromise$1.resolve(targetDoc.last_seq);\n    }\n\n    return self.src.get(self.id).then(function (sourceDoc) {\n      // Since we can't migrate an old version doc to a new one\n      // (no session id), we just go with the lowest seq in this case\n      /* istanbul ignore if */\n      if (targetDoc.version !== sourceDoc.version) {\n        return LOWEST_SEQ;\n      }\n\n      var version;\n      if (targetDoc.version) {\n        version = targetDoc.version.toString();\n      } else {\n        version = \"undefined\";\n      }\n\n      if (version in comparisons) {\n        return comparisons[version](targetDoc, sourceDoc);\n      }\n      /* istanbul ignore next */\n      return LOWEST_SEQ;\n    }, function (err) {\n      if (err.status === 404 && targetDoc.last_seq) {\n        return self.src.put({\n          _id: self.id,\n          last_seq: LOWEST_SEQ\n        }).then(function () {\n          return LOWEST_SEQ;\n        }, function (err) {\n          if (isForbiddenError(err)) {\n            self.readOnlySource = true;\n            return targetDoc.last_seq;\n          }\n          /* istanbul ignore next */\n          return LOWEST_SEQ;\n        });\n      }\n      throw err;\n    });\n  }).catch(function (err) {\n    if (err.status !== 404) {\n      throw err;\n    }\n    return LOWEST_SEQ;\n  });\n};\n// This checkpoint comparison is ported from CouchDBs source\n// they come from here:\n// https://github.com/apache/couchdb-couch-replicator/blob/master/src/couch_replicator.erl#L863-L906\n\nfunction compareReplicationLogs(srcDoc, tgtDoc) {\n  if (srcDoc.session_id === tgtDoc.session_id) {\n    return {\n      last_seq: srcDoc.last_seq,\n      history: srcDoc.history\n    };\n  }\n\n  return compareReplicationHistory(srcDoc.history, tgtDoc.history);\n}\n\nfunction compareReplicationHistory(sourceHistory, targetHistory) {\n  // the erlang loop via function arguments is not so easy to repeat in JS\n  // therefore, doing this as recursion\n  var S = sourceHistory[0];\n  var sourceRest = sourceHistory.slice(1);\n  var T = targetHistory[0];\n  var targetRest = targetHistory.slice(1);\n\n  if (!S || targetHistory.length === 0) {\n    return {\n      last_seq: LOWEST_SEQ,\n      history: []\n    };\n  }\n\n  var sourceId = S.session_id;\n  /* istanbul ignore if */\n  if (hasSessionId(sourceId, targetHistory)) {\n    return {\n      last_seq: S.last_seq,\n      history: sourceHistory\n    };\n  }\n\n  var targetId = T.session_id;\n  if (hasSessionId(targetId, sourceRest)) {\n    return {\n      last_seq: T.last_seq,\n      history: targetRest\n    };\n  }\n\n  return compareReplicationHistory(sourceRest, targetRest);\n}\n\nfunction hasSessionId(sessionId, history) {\n  var props = history[0];\n  var rest = history.slice(1);\n\n  if (!sessionId || history.length === 0) {\n    return false;\n  }\n\n  if (sessionId === props.session_id) {\n    return true;\n  }\n\n  return hasSessionId(sessionId, rest);\n}\n\nfunction isForbiddenError(err) {\n  return typeof err.status === 'number' && Math.floor(err.status / 100) === 4;\n}\n\nvar STARTING_BACK_OFF = 0;\n\nfunction backOff(opts, returnValue, error, callback) {\n  if (opts.retry === false) {\n    returnValue.emit('error', error);\n    returnValue.removeAllListeners();\n    return;\n  }\n  if (typeof opts.back_off_function !== 'function') {\n    opts.back_off_function = defaultBackOff;\n  }\n  returnValue.emit('requestError', error);\n  if (returnValue.state === 'active' || returnValue.state === 'pending') {\n    returnValue.emit('paused', error);\n    returnValue.state = 'stopped';\n    var backOffSet = function backoffTimeSet() {\n      opts.current_back_off = STARTING_BACK_OFF;\n    };\n    var removeBackOffSetter = function removeBackOffTimeSet() {\n      returnValue.removeListener('active', backOffSet);\n    };\n    returnValue.once('paused', removeBackOffSetter);\n    returnValue.once('active', backOffSet);\n  }\n\n  opts.current_back_off = opts.current_back_off || STARTING_BACK_OFF;\n  opts.current_back_off = opts.back_off_function(opts.current_back_off);\n  setTimeout(callback, opts.current_back_off);\n}\n\nfunction sortObjectPropertiesByKey(queryParams) {\n  return Object.keys(queryParams).sort(collate).reduce(function (result, key) {\n    result[key] = queryParams[key];\n    return result;\n  }, {});\n}\n\n// Generate a unique id particular to this replication.\n// Not guaranteed to align perfectly with CouchDB's rep ids.\nfunction generateReplicationId(src, target, opts) {\n  var docIds = opts.doc_ids ? opts.doc_ids.sort(collate) : '';\n  var filterFun = opts.filter ? opts.filter.toString() : '';\n  var queryParams = '';\n  var filterViewName =  '';\n  var selector = '';\n\n  // possibility for checkpoints to be lost here as behaviour of\n  // JSON.stringify is not stable (see #6226)\n  /* istanbul ignore if */\n  if (opts.selector) {\n    selector = JSON.stringify(opts.selector);\n  }\n\n  if (opts.filter && opts.query_params) {\n    queryParams = JSON.stringify(sortObjectPropertiesByKey(opts.query_params));\n  }\n\n  if (opts.filter && opts.filter === '_view') {\n    filterViewName = opts.view.toString();\n  }\n\n  return PouchPromise$1.all([src.id(), target.id()]).then(function (res) {\n    var queryData = res[0] + res[1] + filterFun + filterViewName +\n      queryParams + docIds + selector;\n    return new PouchPromise$1(function (resolve) {\n      binaryMd5(queryData, resolve);\n    });\n  }).then(function (md5sum) {\n    // can't use straight-up md5 alphabet, because\n    // the char '/' is interpreted as being for attachments,\n    // and + is also not url-safe\n    md5sum = md5sum.replace(/\\//g, '.').replace(/\\+/g, '_');\n    return '_local/' + md5sum;\n  });\n}\n\nfunction replicate(src, target, opts, returnValue, result) {\n  var batches = [];               // list of batches to be processed\n  var currentBatch;               // the batch currently being processed\n  var pendingBatch = {\n    seq: 0,\n    changes: [],\n    docs: []\n  }; // next batch, not yet ready to be processed\n  var writingCheckpoint = false;  // true while checkpoint is being written\n  var changesCompleted = false;   // true when all changes received\n  var replicationCompleted = false; // true when replication has completed\n  var last_seq = 0;\n  var continuous = opts.continuous || opts.live || false;\n  var batch_size = opts.batch_size || 100;\n  var batches_limit = opts.batches_limit || 10;\n  var changesPending = false;     // true while src.changes is running\n  var doc_ids = opts.doc_ids;\n  var selector = opts.selector;\n  var repId;\n  var checkpointer;\n  var changedDocs = [];\n  // Like couchdb, every replication gets a unique session id\n  var session = uuid();\n\n  result = result || {\n    ok: true,\n    start_time: new Date(),\n    docs_read: 0,\n    docs_written: 0,\n    doc_write_failures: 0,\n    errors: []\n  };\n\n  var changesOpts = {};\n  returnValue.ready(src, target);\n\n  function initCheckpointer() {\n    if (checkpointer) {\n      return PouchPromise$1.resolve();\n    }\n    return generateReplicationId(src, target, opts).then(function (res) {\n      repId = res;\n\n      var checkpointOpts = {};\n      if (opts.checkpoint === false) {\n        checkpointOpts = { writeSourceCheckpoint: false, writeTargetCheckpoint: false };\n      } else if (opts.checkpoint === 'source') {\n        checkpointOpts = { writeSourceCheckpoint: true, writeTargetCheckpoint: false };\n      } else if (opts.checkpoint === 'target') {\n        checkpointOpts = { writeSourceCheckpoint: false, writeTargetCheckpoint: true };\n      } else {\n        checkpointOpts = { writeSourceCheckpoint: true, writeTargetCheckpoint: true };\n      }\n\n      checkpointer = new Checkpointer(src, target, repId, returnValue, checkpointOpts);\n    });\n  }\n\n  function writeDocs() {\n    changedDocs = [];\n\n    if (currentBatch.docs.length === 0) {\n      return;\n    }\n    var docs = currentBatch.docs;\n    var bulkOpts = {timeout: opts.timeout};\n    return target.bulkDocs({docs: docs, new_edits: false}, bulkOpts).then(function (res) {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n\n      // `res` doesn't include full documents (which live in `docs`), so we create a map of \n      // (id -> error), and check for errors while iterating over `docs`\n      var errorsById = Object.create(null);\n      res.forEach(function (res) {\n        if (res.error) {\n          errorsById[res.id] = res;\n        }\n      });\n\n      var errorsNo = Object.keys(errorsById).length;\n      result.doc_write_failures += errorsNo;\n      result.docs_written += docs.length - errorsNo;\n\n      docs.forEach(function (doc) {\n        var error = errorsById[doc._id];\n        if (error) {\n          result.errors.push(error);\n          if (error.name === 'unauthorized' || error.name === 'forbidden') {\n            returnValue.emit('denied', clone(error));\n          } else {\n            throw error;\n          }\n        } else {\n          changedDocs.push(doc);\n        }\n      });\n\n    }, function (err) {\n      result.doc_write_failures += docs.length;\n      throw err;\n    });\n  }\n\n  function finishBatch() {\n    if (currentBatch.error) {\n      throw new Error('There was a problem getting docs.');\n    }\n    result.last_seq = last_seq = currentBatch.seq;\n    var outResult = clone(result);\n    if (changedDocs.length) {\n      outResult.docs = changedDocs;\n      returnValue.emit('change', outResult);\n    }\n    writingCheckpoint = true;\n    return checkpointer.writeCheckpoint(currentBatch.seq,\n        session).then(function () {\n      writingCheckpoint = false;\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n      currentBatch = undefined;\n      getChanges();\n    }).catch(function (err) {\n      onCheckpointError(err);\n      throw err;\n    });\n  }\n\n  function getDiffs() {\n    var diff = {};\n    currentBatch.changes.forEach(function (change) {\n      // Couchbase Sync Gateway emits these, but we can ignore them\n      /* istanbul ignore if */\n      if (change.id === \"_user/\") {\n        return;\n      }\n      diff[change.id] = change.changes.map(function (x) {\n        return x.rev;\n      });\n    });\n    return target.revsDiff(diff).then(function (diffs) {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n      // currentBatch.diffs elements are deleted as the documents are written\n      currentBatch.diffs = diffs;\n    });\n  }\n\n  function getBatchDocs() {\n    return getDocs(src, target, currentBatch.diffs, returnValue).then(function (got) {\n      currentBatch.error = !got.ok;\n      got.docs.forEach(function (doc) {\n        delete currentBatch.diffs[doc._id];\n        result.docs_read++;\n        currentBatch.docs.push(doc);\n      });\n    });\n  }\n\n  function startNextBatch() {\n    if (returnValue.cancelled || currentBatch) {\n      return;\n    }\n    if (batches.length === 0) {\n      processPendingBatch(true);\n      return;\n    }\n    currentBatch = batches.shift();\n    getDiffs()\n      .then(getBatchDocs)\n      .then(writeDocs)\n      .then(finishBatch)\n      .then(startNextBatch)\n      .catch(function (err) {\n        abortReplication('batch processing terminated with error', err);\n      });\n  }\n\n\n  function processPendingBatch(immediate) {\n    if (pendingBatch.changes.length === 0) {\n      if (batches.length === 0 && !currentBatch) {\n        if ((continuous && changesOpts.live) || changesCompleted) {\n          returnValue.state = 'pending';\n          returnValue.emit('paused');\n        }\n        if (changesCompleted) {\n          completeReplication();\n        }\n      }\n      return;\n    }\n    if (\n      immediate ||\n      changesCompleted ||\n      pendingBatch.changes.length >= batch_size\n    ) {\n      batches.push(pendingBatch);\n      pendingBatch = {\n        seq: 0,\n        changes: [],\n        docs: []\n      };\n      if (returnValue.state === 'pending' || returnValue.state === 'stopped') {\n        returnValue.state = 'active';\n        returnValue.emit('active');\n      }\n      startNextBatch();\n    }\n  }\n\n\n  function abortReplication(reason, err) {\n    if (replicationCompleted) {\n      return;\n    }\n    if (!err.message) {\n      err.message = reason;\n    }\n    result.ok = false;\n    result.status = 'aborting';\n    batches = [];\n    pendingBatch = {\n      seq: 0,\n      changes: [],\n      docs: []\n    };\n    completeReplication(err);\n  }\n\n\n  function completeReplication(fatalError) {\n    if (replicationCompleted) {\n      return;\n    }\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      result.status = 'cancelled';\n      if (writingCheckpoint) {\n        return;\n      }\n    }\n    result.status = result.status || 'complete';\n    result.end_time = new Date();\n    result.last_seq = last_seq;\n    replicationCompleted = true;\n\n    if (fatalError) {\n      // need to extend the error because Firefox considers \".result\" read-only\n      fatalError = createError(fatalError);\n      fatalError.result = result;\n\n      if (fatalError.name === 'unauthorized' || fatalError.name === 'forbidden') {\n        returnValue.emit('error', fatalError);\n        returnValue.removeAllListeners();\n      } else {\n        backOff(opts, returnValue, fatalError, function () {\n          replicate(src, target, opts, returnValue);\n        });\n      }\n    } else {\n      returnValue.emit('complete', result);\n      returnValue.removeAllListeners();\n    }\n  }\n\n\n  function onChange(change) {\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n    var filter = filterChange(opts)(change);\n    if (!filter) {\n      return;\n    }\n    pendingBatch.seq = change.seq;\n    pendingBatch.changes.push(change);\n    processPendingBatch(batches.length === 0 && changesOpts.live);\n  }\n\n\n  function onChangesComplete(changes) {\n    changesPending = false;\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n\n    // if no results were returned then we're done,\n    // else fetch more\n    if (changes.results.length > 0) {\n      changesOpts.since = changes.last_seq;\n      getChanges();\n      processPendingBatch(true);\n    } else {\n\n      var complete = function () {\n        if (continuous) {\n          changesOpts.live = true;\n          getChanges();\n        } else {\n          changesCompleted = true;\n        }\n        processPendingBatch(true);\n      };\n\n      // update the checkpoint so we start from the right seq next time\n      if (!currentBatch && changes.results.length === 0) {\n        writingCheckpoint = true;\n        checkpointer.writeCheckpoint(changes.last_seq,\n            session).then(function () {\n          writingCheckpoint = false;\n          result.last_seq = last_seq = changes.last_seq;\n          complete();\n        })\n        .catch(onCheckpointError);\n      } else {\n        complete();\n      }\n    }\n  }\n\n\n  function onChangesError(err) {\n    changesPending = false;\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n    abortReplication('changes rejected', err);\n  }\n\n\n  function getChanges() {\n    if (!(\n      !changesPending &&\n      !changesCompleted &&\n      batches.length < batches_limit\n      )) {\n      return;\n    }\n    changesPending = true;\n    function abortChanges() {\n      changes.cancel();\n    }\n    function removeListener() {\n      returnValue.removeListener('cancel', abortChanges);\n    }\n\n    if (returnValue._changes) { // remove old changes() and listeners\n      returnValue.removeListener('cancel', returnValue._abortChanges);\n      returnValue._changes.cancel();\n    }\n    returnValue.once('cancel', abortChanges);\n\n    var changes = src.changes(changesOpts)\n      .on('change', onChange);\n    changes.then(removeListener, removeListener);\n    changes.then(onChangesComplete)\n      .catch(onChangesError);\n\n    if (opts.retry) {\n      // save for later so we can cancel if necessary\n      returnValue._changes = changes;\n      returnValue._abortChanges = abortChanges;\n    }\n  }\n\n\n  function startChanges() {\n    initCheckpointer().then(function () {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        return;\n      }\n      return checkpointer.getCheckpoint().then(function (checkpoint) {\n        last_seq = checkpoint;\n        changesOpts = {\n          since: last_seq,\n          limit: batch_size,\n          batch_size: batch_size,\n          style: 'all_docs',\n          doc_ids: doc_ids,\n          selector: selector,\n          return_docs: true // required so we know when we're done\n        };\n        if (opts.filter) {\n          if (typeof opts.filter !== 'string') {\n            // required for the client-side filter in onChange\n            changesOpts.include_docs = true;\n          } else { // ddoc filter\n            changesOpts.filter = opts.filter;\n          }\n        }\n        if ('heartbeat' in opts) {\n          changesOpts.heartbeat = opts.heartbeat;\n        }\n        if ('timeout' in opts) {\n          changesOpts.timeout = opts.timeout;\n        }\n        if (opts.query_params) {\n          changesOpts.query_params = opts.query_params;\n        }\n        if (opts.view) {\n          changesOpts.view = opts.view;\n        }\n        getChanges();\n      });\n    }).catch(function (err) {\n      abortReplication('getCheckpoint rejected with ', err);\n    });\n  }\n\n  /* istanbul ignore next */\n  function onCheckpointError(err) {\n    writingCheckpoint = false;\n    abortReplication('writeCheckpoint completed with error', err);\n  }\n\n  /* istanbul ignore if */\n  if (returnValue.cancelled) { // cancelled immediately\n    completeReplication();\n    return;\n  }\n\n  if (!returnValue._addedListeners) {\n    returnValue.once('cancel', completeReplication);\n\n    if (typeof opts.complete === 'function') {\n      returnValue.once('error', opts.complete);\n      returnValue.once('complete', function (result) {\n        opts.complete(null, result);\n      });\n    }\n    returnValue._addedListeners = true;\n  }\n\n  if (typeof opts.since === 'undefined') {\n    startChanges();\n  } else {\n    initCheckpointer().then(function () {\n      writingCheckpoint = true;\n      return checkpointer.writeCheckpoint(opts.since, session);\n    }).then(function () {\n      writingCheckpoint = false;\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        return;\n      }\n      last_seq = opts.since;\n      startChanges();\n    }).catch(onCheckpointError);\n  }\n}\n\n// We create a basic promise so the caller can cancel the replication possibly\n// before we have actually started listening to changes etc\ninherits(Replication, EventEmitter);\nfunction Replication() {\n  EventEmitter.call(this);\n  this.cancelled = false;\n  this.state = 'pending';\n  var self = this;\n  var promise = new PouchPromise$1(function (fulfill, reject) {\n    self.once('complete', fulfill);\n    self.once('error', reject);\n  });\n  self.then = function (resolve, reject) {\n    return promise.then(resolve, reject);\n  };\n  self.catch = function (reject) {\n    return promise.catch(reject);\n  };\n  // As we allow error handling via \"error\" event as well,\n  // put a stub in here so that rejecting never throws UnhandledError.\n  self.catch(function () {});\n}\n\nReplication.prototype.cancel = function () {\n  this.cancelled = true;\n  this.state = 'cancelled';\n  this.emit('cancel');\n};\n\nReplication.prototype.ready = function (src, target) {\n  var self = this;\n  if (self._readyCalled) {\n    return;\n  }\n  self._readyCalled = true;\n\n  function onDestroy() {\n    self.cancel();\n  }\n  src.once('destroyed', onDestroy);\n  target.once('destroyed', onDestroy);\n  function cleanup() {\n    src.removeListener('destroyed', onDestroy);\n    target.removeListener('destroyed', onDestroy);\n  }\n  self.once('complete', cleanup);\n};\n\nfunction toPouch(db, opts) {\n  var PouchConstructor = opts.PouchConstructor;\n  if (typeof db === 'string') {\n    return new PouchConstructor(db, opts);\n  } else {\n    return db;\n  }\n}\n\nfunction replicateWrapper(src, target, opts, callback) {\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof opts === 'undefined') {\n    opts = {};\n  }\n\n  if (opts.doc_ids && !Array.isArray(opts.doc_ids)) {\n    throw createError(BAD_REQUEST,\n                       \"`doc_ids` filter parameter is not a list.\");\n  }\n\n  opts.complete = callback;\n  opts = clone(opts);\n  opts.continuous = opts.continuous || opts.live;\n  opts.retry = ('retry' in opts) ? opts.retry : false;\n  /*jshint validthis:true */\n  opts.PouchConstructor = opts.PouchConstructor || this;\n  var replicateRet = new Replication(opts);\n  var srcPouch = toPouch(src, opts);\n  var targetPouch = toPouch(target, opts);\n  replicate(srcPouch, targetPouch, opts, replicateRet);\n  return replicateRet;\n}\n\ninherits(Sync, EventEmitter);\nfunction sync$1(src, target, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof opts === 'undefined') {\n    opts = {};\n  }\n  opts = clone(opts);\n  /*jshint validthis:true */\n  opts.PouchConstructor = opts.PouchConstructor || this;\n  src = toPouch(src, opts);\n  target = toPouch(target, opts);\n  return new Sync(src, target, opts, callback);\n}\n\nfunction Sync(src, target, opts, callback) {\n  var self = this;\n  this.canceled = false;\n\n  var optsPush = opts.push ? $inject_Object_assign({}, opts, opts.push) : opts;\n  var optsPull = opts.pull ? $inject_Object_assign({}, opts, opts.pull) : opts;\n\n  this.push = replicateWrapper(src, target, optsPush);\n  this.pull = replicateWrapper(target, src, optsPull);\n\n  this.pushPaused = true;\n  this.pullPaused = true;\n\n  function pullChange(change) {\n    self.emit('change', {\n      direction: 'pull',\n      change: change\n    });\n  }\n  function pushChange(change) {\n    self.emit('change', {\n      direction: 'push',\n      change: change\n    });\n  }\n  function pushDenied(doc) {\n    self.emit('denied', {\n      direction: 'push',\n      doc: doc\n    });\n  }\n  function pullDenied(doc) {\n    self.emit('denied', {\n      direction: 'pull',\n      doc: doc\n    });\n  }\n  function pushPaused() {\n    self.pushPaused = true;\n    /* istanbul ignore if */\n    if (self.pullPaused) {\n      self.emit('paused');\n    }\n  }\n  function pullPaused() {\n    self.pullPaused = true;\n    /* istanbul ignore if */\n    if (self.pushPaused) {\n      self.emit('paused');\n    }\n  }\n  function pushActive() {\n    self.pushPaused = false;\n    /* istanbul ignore if */\n    if (self.pullPaused) {\n      self.emit('active', {\n        direction: 'push'\n      });\n    }\n  }\n  function pullActive() {\n    self.pullPaused = false;\n    /* istanbul ignore if */\n    if (self.pushPaused) {\n      self.emit('active', {\n        direction: 'pull'\n      });\n    }\n  }\n\n  var removed = {};\n\n  function removeAll(type) { // type is 'push' or 'pull'\n    return function (event, func) {\n      var isChange = event === 'change' &&\n        (func === pullChange || func === pushChange);\n      var isDenied = event === 'denied' &&\n        (func === pullDenied || func === pushDenied);\n      var isPaused = event === 'paused' &&\n        (func === pullPaused || func === pushPaused);\n      var isActive = event === 'active' &&\n        (func === pullActive || func === pushActive);\n\n      if (isChange || isDenied || isPaused || isActive) {\n        if (!(event in removed)) {\n          removed[event] = {};\n        }\n        removed[event][type] = true;\n        if (Object.keys(removed[event]).length === 2) {\n          // both push and pull have asked to be removed\n          self.removeAllListeners(event);\n        }\n      }\n    };\n  }\n\n  if (opts.live) {\n    this.push.on('complete', self.pull.cancel.bind(self.pull));\n    this.pull.on('complete', self.push.cancel.bind(self.push));\n  }\n\n  function addOneListener(ee, event, listener) {\n    if (ee.listeners(event).indexOf(listener) == -1) {\n      ee.on(event, listener);\n    }\n  }\n\n  this.on('newListener', function (event) {\n    if (event === 'change') {\n      addOneListener(self.pull, 'change', pullChange);\n      addOneListener(self.push, 'change', pushChange);\n    } else if (event === 'denied') {\n      addOneListener(self.pull, 'denied', pullDenied);\n      addOneListener(self.push, 'denied', pushDenied);\n    } else if (event === 'active') {\n      addOneListener(self.pull, 'active', pullActive);\n      addOneListener(self.push, 'active', pushActive);\n    } else if (event === 'paused') {\n      addOneListener(self.pull, 'paused', pullPaused);\n      addOneListener(self.push, 'paused', pushPaused);\n    }\n  });\n\n  this.on('removeListener', function (event) {\n    if (event === 'change') {\n      self.pull.removeListener('change', pullChange);\n      self.push.removeListener('change', pushChange);\n    } else if (event === 'denied') {\n      self.pull.removeListener('denied', pullDenied);\n      self.push.removeListener('denied', pushDenied);\n    } else if (event === 'active') {\n      self.pull.removeListener('active', pullActive);\n      self.push.removeListener('active', pushActive);\n    } else if (event === 'paused') {\n      self.pull.removeListener('paused', pullPaused);\n      self.push.removeListener('paused', pushPaused);\n    }\n  });\n\n  this.pull.on('removeListener', removeAll('pull'));\n  this.push.on('removeListener', removeAll('push'));\n\n  var promise = PouchPromise$1.all([\n    this.push,\n    this.pull\n  ]).then(function (resp) {\n    var out = {\n      push: resp[0],\n      pull: resp[1]\n    };\n    self.emit('complete', out);\n    if (callback) {\n      callback(null, out);\n    }\n    self.removeAllListeners();\n    return out;\n  }, function (err) {\n    self.cancel();\n    if (callback) {\n      // if there's a callback, then the callback can receive\n      // the error event\n      callback(err);\n    } else {\n      // if there's no callback, then we're safe to emit an error\n      // event, which would otherwise throw an unhandled error\n      // due to 'error' being a special event in EventEmitters\n      self.emit('error', err);\n    }\n    self.removeAllListeners();\n    if (callback) {\n      // no sense throwing if we're already emitting an 'error' event\n      throw err;\n    }\n  });\n\n  this.then = function (success, err) {\n    return promise.then(success, err);\n  };\n\n  this.catch = function (err) {\n    return promise.catch(err);\n  };\n}\n\nSync.prototype.cancel = function () {\n  if (!this.canceled) {\n    this.canceled = true;\n    this.push.cancel();\n    this.pull.cancel();\n  }\n};\n\nfunction replication(PouchDB) {\n  PouchDB.replicate = replicateWrapper;\n  PouchDB.sync = sync$1;\n\n  Object.defineProperty(PouchDB.prototype, 'replicate', {\n    get: function () {\n      var self = this;\n      return {\n        from: function (other, opts, callback) {\n          return self.constructor.replicate(other, self, opts, callback);\n        },\n        to: function (other, opts, callback) {\n          return self.constructor.replicate(self, other, opts, callback);\n        }\n      };\n    }\n  });\n\n  PouchDB.prototype.sync = function (dbName, opts, callback) {\n    return this.constructor.sync(this, dbName, opts, callback);\n  };\n}\n\nPouchDB$5.plugin(IDBPouch)\n  .plugin(WebSqlPouch)\n  .plugin(HttpPouch$1)\n  .plugin(mapreduce)\n  .plugin(replication);\n\n// Pull from src because pouchdb-node/pouchdb-browser themselves\n// are aggressively optimized and jsnext:main would normally give us this\n// aggressive bundle.\n\nexport default PouchDB$5;\n\n\n\n// WEBPACK FOOTER //\n// ../~/pouchdb/lib/index-browser.es.js","(function (factory) {\n    if (typeof exports === 'object') {\n        // Node/CommonJS\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(factory);\n    } else {\n        // Browser globals (with support for web workers)\n        var glob;\n\n        try {\n            glob = window;\n        } catch (e) {\n            glob = self;\n        }\n\n        glob.SparkMD5 = factory();\n    }\n}(function (undefined) {\n\n    'use strict';\n\n    /*\n     * Fastest md5 implementation around (JKM md5).\n     * Credits: Joseph Myers\n     *\n     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html\n     * @see http://jsperf.com/md5-shootout/7\n     */\n\n    /* this function is much faster,\n      so if possible we use it. Some IEs\n      are the only ones I know of that\n      need the idiotic second function,\n      generated by an if clause.  */\n    var add32 = function (a, b) {\n        return (a + b) & 0xFFFFFFFF;\n    },\n        hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n\n\n    function cmn(q, a, b, x, s, t) {\n        a = add32(add32(a, q), add32(x, t));\n        return add32((a << s) | (a >>> (32 - s)), b);\n    }\n\n    function md5cycle(x, k) {\n        var a = x[0],\n            b = x[1],\n            c = x[2],\n            d = x[3];\n\n        a += (b & c | ~b & d) + k[0] - 680876936 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[1] - 389564586 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[2] + 606105819 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[4] - 176418897 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[7] - 45705983 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[10] - 42063 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[13] - 40341101 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n\n        a += (b & d | c & ~d) + k[1] - 165796510 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[11] + 643717713 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[0] - 373897302 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[5] - 701558691 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[10] + 38016083 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[15] - 660478335 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[4] - 405537848 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[9] + 568446438 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[3] - 187363961 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[2] - 51403784 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n\n        a += (b ^ c ^ d) + k[5] - 378558 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[14] - 35309556 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[7] - 155497632 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[13] + 681279174 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[0] - 358537222 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[3] - 722521979 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[6] + 76029189 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[9] - 640364487 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[12] - 421815835 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[15] + 530742520 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[2] - 995338651 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n\n        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;\n        b  = (b << 21 |b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;\n        b  = (b << 21 |b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;\n        b  = (b << 21 |b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;\n        b  = (b << 21 | b >>> 11) + c | 0;\n\n        x[0] = a + x[0] | 0;\n        x[1] = b + x[1] | 0;\n        x[2] = c + x[2] | 0;\n        x[3] = d + x[3] | 0;\n    }\n\n    function md5blk(s) {\n        var md5blks = [],\n            i; /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);\n        }\n        return md5blks;\n    }\n\n    function md5blk_array(a) {\n        var md5blks = [],\n            i; /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);\n        }\n        return md5blks;\n    }\n\n    function md51(s) {\n        var n = s.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n            md5cycle(state, md5blk(s.substring(i - 64, i)));\n        }\n        s = s.substring(i - 64);\n        length = s.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);\n        }\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Beware that the final length might not fit in 32 bits so we take care of that\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n\n        md5cycle(state, tail);\n        return state;\n    }\n\n    function md51_array(a) {\n        var n = a.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));\n        }\n\n        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1\n        // containing the last element of the parent array if the sub array specified starts\n        // beyond the length of the parent array - weird.\n        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue\n        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);\n\n        length = a.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= a[i] << ((i % 4) << 3);\n        }\n\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Beware that the final length might not fit in 32 bits so we take care of that\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n\n        md5cycle(state, tail);\n\n        return state;\n    }\n\n    function rhex(n) {\n        var s = '',\n            j;\n        for (j = 0; j < 4; j += 1) {\n            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];\n        }\n        return s;\n    }\n\n    function hex(x) {\n        var i;\n        for (i = 0; i < x.length; i += 1) {\n            x[i] = rhex(x[i]);\n        }\n        return x.join('');\n    }\n\n    // In some cases the fast add32 function cannot be used..\n    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') {\n        add32 = function (x, y) {\n            var lsw = (x & 0xFFFF) + (y & 0xFFFF),\n                msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n            return (msw << 16) | (lsw & 0xFFFF);\n        };\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * ArrayBuffer slice polyfill.\n     *\n     * @see https://github.com/ttaubert/node-arraybuffer-slice\n     */\n\n    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {\n        (function () {\n            function clamp(val, length) {\n                val = (val | 0) || 0;\n\n                if (val < 0) {\n                    return Math.max(val + length, 0);\n                }\n\n                return Math.min(val, length);\n            }\n\n            ArrayBuffer.prototype.slice = function (from, to) {\n                var length = this.byteLength,\n                    begin = clamp(from, length),\n                    end = length,\n                    num,\n                    target,\n                    targetArray,\n                    sourceArray;\n\n                if (to !== undefined) {\n                    end = clamp(to, length);\n                }\n\n                if (begin > end) {\n                    return new ArrayBuffer(0);\n                }\n\n                num = end - begin;\n                target = new ArrayBuffer(num);\n                targetArray = new Uint8Array(target);\n\n                sourceArray = new Uint8Array(this, begin, num);\n                targetArray.set(sourceArray);\n\n                return target;\n            };\n        })();\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * Helpers.\n     */\n\n    function toUtf8(str) {\n        if (/[\\u0080-\\uFFFF]/.test(str)) {\n            str = unescape(encodeURIComponent(str));\n        }\n\n        return str;\n    }\n\n    function utf8Str2ArrayBuffer(str, returnUInt8Array) {\n        var length = str.length,\n           buff = new ArrayBuffer(length),\n           arr = new Uint8Array(buff),\n           i;\n\n        for (i = 0; i < length; i += 1) {\n            arr[i] = str.charCodeAt(i);\n        }\n\n        return returnUInt8Array ? arr : buff;\n    }\n\n    function arrayBuffer2Utf8Str(buff) {\n        return String.fromCharCode.apply(null, new Uint8Array(buff));\n    }\n\n    function concatenateArrayBuffers(first, second, returnUInt8Array) {\n        var result = new Uint8Array(first.byteLength + second.byteLength);\n\n        result.set(new Uint8Array(first));\n        result.set(new Uint8Array(second), first.byteLength);\n\n        return returnUInt8Array ? result : result.buffer;\n    }\n\n    function hexToBinaryString(hex) {\n        var bytes = [],\n            length = hex.length,\n            x;\n\n        for (x = 0; x < length - 1; x += 2) {\n            bytes.push(parseInt(hex.substr(x, 2), 16));\n        }\n\n        return String.fromCharCode.apply(String, bytes);\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * SparkMD5 OOP implementation.\n     *\n     * Use this class to perform an incremental md5, otherwise use the\n     * static methods instead.\n     */\n\n    function SparkMD5() {\n        // call reset to init the instance\n        this.reset();\n    }\n\n    /**\n     * Appends a string.\n     * A conversion will be applied if an utf8 string is detected.\n     *\n     * @param {String} str The string to be appended\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.append = function (str) {\n        // Converts the string to utf8 bytes if necessary\n        // Then append as binary\n        this.appendBinary(toUtf8(str));\n\n        return this;\n    };\n\n    /**\n     * Appends a binary string.\n     *\n     * @param {String} contents The binary string to be appended\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.appendBinary = function (contents) {\n        this._buff += contents;\n        this._length += contents.length;\n\n        var length = this._buff.length,\n            i;\n\n        for (i = 64; i <= length; i += 64) {\n            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));\n        }\n\n        this._buff = this._buff.substring(i - 64);\n\n        return this;\n    };\n\n    /**\n     * Finishes the incremental computation, reseting the internal state and\n     * returning the result.\n     *\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            i,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);\n        }\n\n        this._finish(tail, length);\n        ret = hex(this._hash);\n\n        if (raw) {\n            ret = hexToBinaryString(ret);\n        }\n\n        this.reset();\n\n        return ret;\n    };\n\n    /**\n     * Resets the internal state of the computation.\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.reset = function () {\n        this._buff = '';\n        this._length = 0;\n        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\n        return this;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @return {Object} The state\n     */\n    SparkMD5.prototype.getState = function () {\n        return {\n            buff: this._buff,\n            length: this._length,\n            hash: this._hash\n        };\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @param {Object} state The state\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.setState = function (state) {\n        this._buff = state.buff;\n        this._length = state.length;\n        this._hash = state.hash;\n\n        return this;\n    };\n\n    /**\n     * Releases memory used by the incremental buffer and other additional\n     * resources. If you plan to use the instance again, use reset instead.\n     */\n    SparkMD5.prototype.destroy = function () {\n        delete this._hash;\n        delete this._buff;\n        delete this._length;\n    };\n\n    /**\n     * Finish the final calculation based on the tail.\n     *\n     * @param {Array}  tail   The tail (will be modified)\n     * @param {Number} length The length of the remaining buffer\n     */\n    SparkMD5.prototype._finish = function (tail, length) {\n        var i = length,\n            tmp,\n            lo,\n            hi;\n\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(this._hash, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Do the final computation based on the tail and length\n        // Beware that the final length may not fit in 32 bits so we take care of that\n        tmp = this._length * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n        md5cycle(this._hash, tail);\n    };\n\n    /**\n     * Performs the md5 hash on a string.\n     * A conversion will be applied if utf8 string is detected.\n     *\n     * @param {String}  str The string\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.hash = function (str, raw) {\n        // Converts the string to utf8 bytes if necessary\n        // Then compute it using the binary function\n        return SparkMD5.hashBinary(toUtf8(str), raw);\n    };\n\n    /**\n     * Performs the md5 hash on a binary string.\n     *\n     * @param {String}  content The binary string\n     * @param {Boolean} raw     True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.hashBinary = function (content, raw) {\n        var hash = md51(content),\n            ret = hex(hash);\n\n        return raw ? hexToBinaryString(ret) : ret;\n    };\n\n    // ---------------------------------------------------\n\n    /**\n     * SparkMD5 OOP implementation for array buffers.\n     *\n     * Use this class to perform an incremental md5 ONLY for array buffers.\n     */\n    SparkMD5.ArrayBuffer = function () {\n        // call reset to init the instance\n        this.reset();\n    };\n\n    /**\n     * Appends an array buffer.\n     *\n     * @param {ArrayBuffer} arr The array to be appended\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.append = function (arr) {\n        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),\n            length = buff.length,\n            i;\n\n        this._length += arr.byteLength;\n\n        for (i = 64; i <= length; i += 64) {\n            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));\n        }\n\n        this._buff = (i - 64) < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);\n\n        return this;\n    };\n\n    /**\n     * Finishes the incremental computation, reseting the internal state and\n     * returning the result.\n     *\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.ArrayBuffer.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            i,\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= buff[i] << ((i % 4) << 3);\n        }\n\n        this._finish(tail, length);\n        ret = hex(this._hash);\n\n        if (raw) {\n            ret = hexToBinaryString(ret);\n        }\n\n        this.reset();\n\n        return ret;\n    };\n\n    /**\n     * Resets the internal state of the computation.\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.reset = function () {\n        this._buff = new Uint8Array(0);\n        this._length = 0;\n        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\n        return this;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @return {Object} The state\n     */\n    SparkMD5.ArrayBuffer.prototype.getState = function () {\n        var state = SparkMD5.prototype.getState.call(this);\n\n        // Convert buffer to a string\n        state.buff = arrayBuffer2Utf8Str(state.buff);\n\n        return state;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @param {Object} state The state\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.setState = function (state) {\n        // Convert string to buffer\n        state.buff = utf8Str2ArrayBuffer(state.buff, true);\n\n        return SparkMD5.prototype.setState.call(this, state);\n    };\n\n    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;\n\n    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;\n\n    /**\n     * Performs the md5 hash on an array buffer.\n     *\n     * @param {ArrayBuffer} arr The array buffer\n     * @param {Boolean}     raw True to get the raw string, false to get the hex one\n     *\n     * @return {String} The result\n     */\n    SparkMD5.ArrayBuffer.hash = function (arr, raw) {\n        var hash = md51_array(new Uint8Array(arr)),\n            ret = hex(hash);\n\n        return raw ? hexToBinaryString(ret) : ret;\n    };\n\n    return SparkMD5;\n}));\n\n\n\n// WEBPACK FOOTER //\n// ../~/spark-md5/spark-md5.js","function pad(str, padWith, upToLength) {\n  var padding = '';\n  var targetLength = upToLength - str.length;\n  /* istanbul ignore next */\n  while (padding.length < targetLength) {\n    padding += padWith;\n  }\n  return padding;\n}\n\nfunction padLeft(str, padWith, upToLength) {\n  var padding = pad(str, padWith, upToLength);\n  return padding + str;\n}\n\nvar MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE\nvar MAGNITUDE_DIGITS = 3; // ditto\nvar SEP = ''; // set to '_' for easier debugging \n\nfunction collate(a, b) {\n\n  if (a === b) {\n    return 0;\n  }\n\n  a = normalizeKey(a);\n  b = normalizeKey(b);\n\n  var ai = collationIndex(a);\n  var bi = collationIndex(b);\n  if ((ai - bi) !== 0) {\n    return ai - bi;\n  }\n  switch (typeof a) {\n    case 'number':\n      return a - b;\n    case 'boolean':\n      return a < b ? -1 : 1;\n    case 'string':\n      return stringCollate(a, b);\n  }\n  return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);\n}\n\n// couch considers null/NaN/Infinity/-Infinity === undefined,\n// for the purposes of mapreduce indexes. also, dates get stringified.\nfunction normalizeKey(key) {\n  switch (typeof key) {\n    case 'undefined':\n      return null;\n    case 'number':\n      if (key === Infinity || key === -Infinity || isNaN(key)) {\n        return null;\n      }\n      return key;\n    case 'object':\n      var origKey = key;\n      if (Array.isArray(key)) {\n        var len = key.length;\n        key = new Array(len);\n        for (var i = 0; i < len; i++) {\n          key[i] = normalizeKey(origKey[i]);\n        }\n      /* istanbul ignore next */\n      } else if (key instanceof Date) {\n        return key.toJSON();\n      } else if (key !== null) { // generic object\n        key = {};\n        for (var k in origKey) {\n          if (origKey.hasOwnProperty(k)) {\n            var val = origKey[k];\n            if (typeof val !== 'undefined') {\n              key[k] = normalizeKey(val);\n            }\n          }\n        }\n      }\n  }\n  return key;\n}\n\nfunction indexify(key) {\n  if (key !== null) {\n    switch (typeof key) {\n      case 'boolean':\n        return key ? 1 : 0;\n      case 'number':\n        return numToIndexableString(key);\n      case 'string':\n        // We've to be sure that key does not contain \\u0000\n        // Do order-preserving replacements:\n        // 0 -> 1, 1\n        // 1 -> 1, 2\n        // 2 -> 2, 2\n        return key\n          .replace(/\\u0002/g, '\\u0002\\u0002')\n          .replace(/\\u0001/g, '\\u0001\\u0002')\n          .replace(/\\u0000/g, '\\u0001\\u0001');\n      case 'object':\n        var isArray = Array.isArray(key);\n        var arr = isArray ? key : Object.keys(key);\n        var i = -1;\n        var len = arr.length;\n        var result = '';\n        if (isArray) {\n          while (++i < len) {\n            result += toIndexableString(arr[i]);\n          }\n        } else {\n          while (++i < len) {\n            var objKey = arr[i];\n            result += toIndexableString(objKey) +\n                toIndexableString(key[objKey]);\n          }\n        }\n        return result;\n    }\n  }\n  return '';\n}\n\n// convert the given key to a string that would be appropriate\n// for lexical sorting, e.g. within a database, where the\n// sorting is the same given by the collate() function.\nfunction toIndexableString(key) {\n  var zero = '\\u0000';\n  key = normalizeKey(key);\n  return collationIndex(key) + SEP + indexify(key) + zero;\n}\n\nfunction parseNumber(str, i) {\n  var originalIdx = i;\n  var num;\n  var zero = str[i] === '1';\n  if (zero) {\n    num = 0;\n    i++;\n  } else {\n    var neg = str[i] === '0';\n    i++;\n    var numAsString = '';\n    var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);\n    var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;\n    /* istanbul ignore next */\n    if (neg) {\n      magnitude = -magnitude;\n    }\n    i += MAGNITUDE_DIGITS;\n    while (true) {\n      var ch = str[i];\n      if (ch === '\\u0000') {\n        break;\n      } else {\n        numAsString += ch;\n      }\n      i++;\n    }\n    numAsString = numAsString.split('.');\n    if (numAsString.length === 1) {\n      num = parseInt(numAsString, 10);\n    } else {\n      /* istanbul ignore next */\n      num = parseFloat(numAsString[0] + '.' + numAsString[1]);\n    }\n    /* istanbul ignore next */\n    if (neg) {\n      num = num - 10;\n    }\n    /* istanbul ignore next */\n    if (magnitude !== 0) {\n      // parseFloat is more reliable than pow due to rounding errors\n      // e.g. Number.MAX_VALUE would return Infinity if we did\n      // num * Math.pow(10, magnitude);\n      num = parseFloat(num + 'e' + magnitude);\n    }\n  }\n  return {num: num, length : i - originalIdx};\n}\n\n// move up the stack while parsing\n// this function moved outside of parseIndexableString for performance\nfunction pop(stack, metaStack) {\n  var obj = stack.pop();\n\n  if (metaStack.length) {\n    var lastMetaElement = metaStack[metaStack.length - 1];\n    if (obj === lastMetaElement.element) {\n      // popping a meta-element, e.g. an object whose value is another object\n      metaStack.pop();\n      lastMetaElement = metaStack[metaStack.length - 1];\n    }\n    var element = lastMetaElement.element;\n    var lastElementIndex = lastMetaElement.index;\n    if (Array.isArray(element)) {\n      element.push(obj);\n    } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n      var key = stack.pop();\n      element[key] = obj;\n    } else {\n      stack.push(obj); // obj with key only\n    }\n  }\n}\n\nfunction parseIndexableString(str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n\n  /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n  while (true) {\n    var collationIndex = str[i++];\n    if (collationIndex === '\\u0000') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case '1':\n        stack.push(null);\n        break;\n      case '2':\n        stack.push(str[i] === '1');\n        i++;\n        break;\n      case '3':\n        var parsedNum = parseNumber(str, i);\n        stack.push(parsedNum.num);\n        i += parsedNum.length;\n        break;\n      case '4':\n        var parsedStr = '';\n        /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n        while (true) {\n          var ch = str[i];\n          if (ch === '\\u0000') {\n            break;\n          }\n          parsedStr += ch;\n          i++;\n        }\n        // perform the reverse of the order-preserving replacement\n        // algorithm (see above)\n        parsedStr = parsedStr.replace(/\\u0001\\u0001/g, '\\u0000')\n          .replace(/\\u0001\\u0002/g, '\\u0001')\n          .replace(/\\u0002\\u0002/g, '\\u0002');\n        stack.push(parsedStr);\n        break;\n      case '5':\n        var arrayElement = { element: [], index: stack.length };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '6':\n        var objElement = { element: {}, index: stack.length };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      /* istanbul ignore next */\n      default:\n        throw new Error(\n          'bad collationIndex or unexpectedly reached end of input: ' +\n            collationIndex);\n    }\n  }\n}\n\nfunction arrayCollate(a, b) {\n  var len = Math.min(a.length, b.length);\n  for (var i = 0; i < len; i++) {\n    var sort = collate(a[i], b[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n  }\n  return (a.length === b.length) ? 0 :\n    (a.length > b.length) ? 1 : -1;\n}\nfunction stringCollate(a, b) {\n  // See: https://github.com/daleharvey/pouchdb/issues/40\n  // This is incompatible with the CouchDB implementation, but its the\n  // best we can do for now\n  return (a === b) ? 0 : ((a > b) ? 1 : -1);\n}\nfunction objectCollate(a, b) {\n  var ak = Object.keys(a), bk = Object.keys(b);\n  var len = Math.min(ak.length, bk.length);\n  for (var i = 0; i < len; i++) {\n    // First sort the keys\n    var sort = collate(ak[i], bk[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n    // if the keys are equal sort the values\n    sort = collate(a[ak[i]], b[bk[i]]);\n    if (sort !== 0) {\n      return sort;\n    }\n\n  }\n  return (ak.length === bk.length) ? 0 :\n    (ak.length > bk.length) ? 1 : -1;\n}\n// The collation is defined by erlangs ordered terms\n// the atoms null, true, false come first, then numbers, strings,\n// arrays, then objects\n// null/undefined/NaN/Infinity/-Infinity are all considered null\nfunction collationIndex(x) {\n  var id = ['boolean', 'number', 'string', 'object'];\n  var idx = id.indexOf(typeof x);\n  //false if -1 otherwise true, but fast!!!!1\n  if (~idx) {\n    if (x === null) {\n      return 1;\n    }\n    if (Array.isArray(x)) {\n      return 5;\n    }\n    return idx < 3 ? (idx + 2) : (idx + 3);\n  }\n  /* istanbul ignore next */\n  if (Array.isArray(x)) {\n    return 5;\n  }\n}\n\n// conversion:\n// x yyy zz...zz\n// x = 0 for negative, 1 for 0, 2 for positive\n// y = exponent (for negative numbers negated) moved so that it's >= 0\n// z = mantisse\nfunction numToIndexableString(num) {\n\n  if (num === 0) {\n    return '1';\n  }\n\n  // convert number to exponential format for easier and\n  // more succinct string sorting\n  var expFormat = num.toExponential().split(/e\\+?/);\n  var magnitude = parseInt(expFormat[1], 10);\n\n  var neg = num < 0;\n\n  var result = neg ? '0' : '2';\n\n  // first sort by magnitude\n  // it's easier if all magnitudes are positive\n  var magForComparison = ((neg ? -magnitude : magnitude) - MIN_MAGNITUDE);\n  var magString = padLeft((magForComparison).toString(), '0', MAGNITUDE_DIGITS);\n\n  result += SEP + magString;\n\n  // then sort by the factor\n  var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)\n  /* istanbul ignore next */\n  if (neg) { // for negative reverse ordering\n    factor = 10 - factor;\n  }\n\n  var factorStr = factor.toFixed(20);\n\n  // strip zeros from the end\n  factorStr = factorStr.replace(/\\.?0+$/, '');\n\n  result += SEP + factorStr;\n\n  return result;\n}\n\nexport { collate, normalizeKey, toIndexableString, parseIndexableString };\n\n\n\n// WEBPACK FOOTER //\n// ../~/pouchdb-collate/lib/index.es.js","\"use strict\";\n\nclass ShoppingListRepository {\n\n  put(shoppingList) { }\n\n  putBulk(shoppingLists) { }\n\n  get(shoppingListId) { }\n\n  find(request) {}\n\n  delete(shoppingList) { }\n\n  putItem(shoppingListItem) { }\n\n  putItemsBulk(shoppingListItems) { }\n\n  getItem(shoppingListItemId) { }\n\n  findItems(request) {}\n\n  findItemsCountByList(request) {}\n\n  deleteItem(shoppingListItem) { }\n\n}\n\nexports.ShoppingListRepository = ShoppingListRepository;\n\n\n\n// WEBPACK FOOTER //\n// ../~/ibm-shopping-list-model/src/ShoppingListRepository.js","'use strict';\n\nmodule.exports = argsArray;\n\nfunction argsArray(fun) {\n  return function () {\n    var len = arguments.length;\n    if (len) {\n      var args = [];\n      var i = -1;\n      while (++i < len) {\n        args[i] = arguments[i];\n      }\n      return fun.call(this, args);\n    } else {\n      return fun.call(this, []);\n    }\n  };\n}\n\n\n// WEBPACK FOOTER //\n// ../~/argsarray/index.js","/**\n * cuid.js\n * Collision-resistant UID generator for browsers and node.\n * Sequential for fast db lookups and recency sorting.\n * Safe for element IDs and server-side lookups.\n *\n * Extracted from CLCTR\n *\n * Copyright (c) Eric Elliott 2012\n * MIT License\n */\n\n/*global window, navigator, document, require, process, module */\n(function (app) {\n  'use strict';\n  var namespace = 'cuid',\n    c = 0,\n    blockSize = 4,\n    base = 36,\n    discreteValues = Math.pow(base, blockSize),\n\n    pad = function pad(num, size) {\n      var s = \"000000000\" + num;\n      return s.substr(s.length-size);\n    },\n\n    randomBlock = function randomBlock() {\n      return pad((Math.random() *\n            discreteValues << 0)\n            .toString(base), blockSize);\n    },\n\n    safeCounter = function () {\n      c = (c < discreteValues) ? c : 0;\n      c++; // this is not subliminal\n      return c - 1;\n    },\n\n    api = function cuid() {\n      // Starting with a lowercase letter makes\n      // it HTML element ID friendly.\n      var letter = 'c', // hard-coded allows for sequential access\n\n        // timestamp\n        // warning: this exposes the exact date and time\n        // that the uid was created.\n        timestamp = (new Date().getTime()).toString(base),\n\n        // Prevent same-machine collisions.\n        counter,\n\n        // A few chars to generate distinct ids for different\n        // clients (so different computers are far less\n        // likely to generate the same id)\n        fingerprint = api.fingerprint(),\n\n        // Grab some more chars from Math.random()\n        random = randomBlock() + randomBlock();\n\n        counter = pad(safeCounter().toString(base), blockSize);\n\n      return  (letter + timestamp + counter + fingerprint + random);\n    };\n\n  api.slug = function slug() {\n    var date = new Date().getTime().toString(36),\n      counter,\n      print = api.fingerprint().slice(0,1) +\n        api.fingerprint().slice(-1),\n      random = randomBlock().slice(-2);\n\n      counter = safeCounter().toString(36).slice(-4);\n\n    return date.slice(-2) +\n      counter + print + random;\n  };\n\n  api.globalCount = function globalCount() {\n    // We want to cache the results of this\n    var cache = (function calc() {\n        var i,\n          count = 0;\n\n        for (i in window) {\n          count++;\n        }\n\n        return count;\n      }());\n\n    api.globalCount = function () { return cache; };\n    return cache;\n  };\n\n  api.fingerprint = function browserPrint() {\n    return pad((navigator.mimeTypes.length +\n      navigator.userAgent.length).toString(36) +\n      api.globalCount().toString(36), 4);\n  };\n\n  // don't change anything from here down.\n  if (app.register) {\n    app.register(namespace, api);\n  } else if (typeof module !== 'undefined') {\n    module.exports = api;\n  } else {\n    app[namespace] = api;\n  }\n\n}(this.applitude || this));\n\n\n\n// WEBPACK FOOTER //\n// ../~/cuid/dist/browser-cuid.js","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../~/inherits/inherits_browser.js","import lie from 'lie';\n\n/* istanbul ignore next */\nvar PouchPromise = typeof Promise === 'function' ? Promise : lie;\n\nexport default PouchPromise;\n\n\n\n// WEBPACK FOOTER //\n// ../~/pouchdb-promise/lib/index.es.js","/**\n * Helpers.\n */\n\nvar s = 1000\nvar m = s * 60\nvar h = m * 60\nvar d = h * 24\nvar y = d * 365.25\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {}\n  var type = typeof val\n  if (type === 'string' && val.length > 0) {\n    return parse(val)\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ?\n\t\t\tfmtLong(val) :\n\t\t\tfmtShort(val)\n  }\n  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val))\n}\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str)\n  if (str.length > 10000) {\n    return\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str)\n  if (!match) {\n    return\n  }\n  var n = parseFloat(match[1])\n  var type = (match[2] || 'ms').toLowerCase()\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n\n    default:\n      return undefined\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd'\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h'\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm'\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's'\n  }\n  return ms + 'ms'\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms'\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's'\n}\n\n\n\n// WEBPACK FOOTER //\n// ../~/ms/index.js","var thisAtob = function (str) {\n  return atob(str);\n};\n\nvar thisBtoa = function (str) {\n  return btoa(str);\n};\n\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor (e.g.\n// old QtWebKit versions, Android < 4.4).\nfunction createBlob(parts, properties) {\n  /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n  parts = parts || [];\n  properties = properties || {};\n  try {\n    return new Blob(parts, properties);\n  } catch (e) {\n    if (e.name !== \"TypeError\") {\n      throw e;\n    }\n    var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :\n                  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :\n                  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder :\n                  WebKitBlobBuilder;\n    var builder = new Builder();\n    for (var i = 0; i < parts.length; i += 1) {\n      builder.append(parts[i]);\n    }\n    return builder.getBlob(properties.type);\n  }\n}\n\n// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n// encode-decode-image-with-base64-breaks-image (2013-04-21)\nfunction binaryStringToArrayBuffer(bin) {\n  var length = bin.length;\n  var buf = new ArrayBuffer(length);\n  var arr = new Uint8Array(buf);\n  for (var i = 0; i < length; i++) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return buf;\n}\n\nfunction binStringToBluffer(binString, type) {\n  return createBlob([binaryStringToArrayBuffer(binString)], {type: type});\n}\n\nfunction b64ToBluffer(b64, type) {\n  return binStringToBluffer(thisAtob(b64), type);\n}\n\n//Can't find original post, but this is close\n//http://stackoverflow.com/questions/6965107/ (continues on next line)\n//converting-between-strings-and-arraybuffers\nfunction arrayBufferToBinaryString(buffer) {\n  var binary = '';\n  var bytes = new Uint8Array(buffer);\n  var length = bytes.byteLength;\n  for (var i = 0; i < length; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return binary;\n}\n\n// shim for browsers that don't support it\nfunction readAsBinaryString(blob, callback) {\n  if (typeof FileReader === 'undefined') {\n    // fix for Firefox in a web worker\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n    return callback(arrayBufferToBinaryString(\n      new FileReaderSync().readAsArrayBuffer(blob)));\n  }\n\n  var reader = new FileReader();\n  var hasBinaryString = typeof reader.readAsBinaryString === 'function';\n  reader.onloadend = function (e) {\n    var result = e.target.result || '';\n    if (hasBinaryString) {\n      return callback(result);\n    }\n    callback(arrayBufferToBinaryString(result));\n  };\n  if (hasBinaryString) {\n    reader.readAsBinaryString(blob);\n  } else {\n    reader.readAsArrayBuffer(blob);\n  }\n}\n\nfunction blobToBinaryString(blobOrBuffer, callback) {\n  readAsBinaryString(blobOrBuffer, function (bin) {\n    callback(bin);\n  });\n}\n\nfunction blobToBase64(blobOrBuffer, callback) {\n  blobToBinaryString(blobOrBuffer, function (base64) {\n    callback(thisBtoa(base64));\n  });\n}\n\n// simplified API. universal browser support is assumed\nfunction readAsArrayBuffer(blob, callback) {\n  if (typeof FileReader === 'undefined') {\n    // fix for Firefox in a web worker:\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n    return callback(new FileReaderSync().readAsArrayBuffer(blob));\n  }\n\n  var reader = new FileReader();\n  reader.onloadend = function (e) {\n    var result = e.target.result || new ArrayBuffer(0);\n    callback(result);\n  };\n  reader.readAsArrayBuffer(blob);\n}\n\n// this is not used in the browser\nfunction typedBuffer() {\n}\n\nexport { thisAtob as atob, thisBtoa as btoa, b64ToBluffer as base64StringToBlobOrBuffer, binaryStringToArrayBuffer, binStringToBluffer as binaryStringToBlobOrBuffer, createBlob as blob, blobToBase64 as blobOrBufferToBase64, blobToBinaryString as blobOrBufferToBinaryString, readAsArrayBuffer, readAsBinaryString, typedBuffer };\n\n\n\n// WEBPACK FOOTER //\n// ../~/pouchdb-binary-utils/lib/index-browser.es.js","const Credentials = {\n  \"cloudant_url\": \"https://disheserentleaveratedgai:928a6f0a42cd1079d9846604913131d6d5b25ee9@rajsingh.cloudant.com/preact-pwa\"\n}\n\nexport default Credentials;\n\n\n\n// WEBPACK FOOTER //\n// ./secret.js","import { clone } from 'pouchdb-utils';\nimport { collate } from 'pouchdb-collate';\n\n// this would just be \"return doc[field]\", but fields\n// can be \"deep\" due to dot notation\nfunction getFieldFromDoc(doc, parsedField) {\n  var value = doc;\n  for (var i = 0, len = parsedField.length; i < len; i++) {\n    var key = parsedField[i];\n    value = value[key];\n    if (!value) {\n      break;\n    }\n  }\n  return value;\n}\n\nfunction setFieldInDoc(doc, parsedField, value) {\n  for (var i = 0, len = parsedField.length; i < len-1; i++) {\n    var elem = parsedField[i];\n    doc = doc[elem] = {};\n  }\n  doc[parsedField[len-1]] = value;\n}\n\nfunction compare(left, right) {\n  return left < right ? -1 : left > right ? 1 : 0;\n}\n\n// Converts a string in dot notation to an array of its components, with backslash escaping\nfunction parseField(fieldName) {\n  // fields may be deep (e.g. \"foo.bar.baz\"), so parse\n  var fields = [];\n  var current = '';\n  for (var i = 0, len = fieldName.length; i < len; i++) {\n    var ch = fieldName[i];\n    if (ch === '.') {\n      if (i > 0 && fieldName[i - 1] === '\\\\') { // escaped delimiter\n        current = current.substring(0, current.length - 1) + '.';\n      } else { // not escaped, so delimiter\n        fields.push(current);\n        current = '';\n      }\n    } else { // normal character\n      current += ch;\n    }\n  }\n  fields.push(current);\n  return fields;\n}\n\nvar combinationFields = ['$or', '$nor', '$not'];\nfunction isCombinationalField(field) {\n  return combinationFields.indexOf(field) > -1;\n}\n\nfunction getKey(obj) {\n  return Object.keys(obj)[0];\n}\n\nfunction getValue(obj) {\n  return obj[getKey(obj)];\n}\n\n\n// flatten an array of selectors joined by an $and operator\nfunction mergeAndedSelectors(selectors) {\n\n  // sort to ensure that e.g. if the user specified\n  // $and: [{$gt: 'a'}, {$gt: 'b'}], then it's collapsed into\n  // just {$gt: 'b'}\n  var res = {};\n\n  selectors.forEach(function (selector) {\n    Object.keys(selector).forEach(function (field) {\n      var matcher = selector[field];\n      if (typeof matcher !== 'object') {\n        matcher = {$eq: matcher};\n      }\n\n      if (isCombinationalField(field)) {\n        if (matcher instanceof Array) {\n          res[field] = matcher.map(function (m) {\n            return mergeAndedSelectors([m]);\n          });\n        } else {\n          res[field] = mergeAndedSelectors([matcher]);\n        }\n      } else {\n        var fieldMatchers = res[field] = res[field] || {};\n        Object.keys(matcher).forEach(function (operator) {\n          var value = matcher[operator];\n\n          if (operator === '$gt' || operator === '$gte') {\n            return mergeGtGte(operator, value, fieldMatchers);\n          } else if (operator === '$lt' || operator === '$lte') {\n            return mergeLtLte(operator, value, fieldMatchers);\n          } else if (operator === '$ne') {\n            return mergeNe(value, fieldMatchers);\n          } else if (operator === '$eq') {\n            return mergeEq(value, fieldMatchers);\n          }\n          fieldMatchers[operator] = value;\n        });\n      }\n    });\n  });\n\n  return res;\n}\n\n\n\n// collapse logically equivalent gt/gte values\nfunction mergeGtGte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$gte !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gte) { // more specificity\n        fieldMatchers.$gte = value;\n      }\n    } else { // operator === '$gt'\n      if (value >= fieldMatchers.$gte) { // more specificity\n        delete fieldMatchers.$gte;\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$gt !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gt) { // more specificity\n        delete fieldMatchers.$gt;\n        fieldMatchers.$gte = value;\n      }\n    } else { // operator === '$gt'\n      if (value > fieldMatchers.$gt) { // more specificity\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// collapse logically equivalent lt/lte values\nfunction mergeLtLte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$lte !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lte) { // more specificity\n        fieldMatchers.$lte = value;\n      }\n    } else { // operator === '$gt'\n      if (value <= fieldMatchers.$lte) { // more specificity\n        delete fieldMatchers.$lte;\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$lt !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lt) { // more specificity\n        delete fieldMatchers.$lt;\n        fieldMatchers.$lte = value;\n      }\n    } else { // operator === '$gt'\n      if (value < fieldMatchers.$lt) { // more specificity\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// combine $ne values into one array\nfunction mergeNe(value, fieldMatchers) {\n  if ('$ne' in fieldMatchers) {\n    // there are many things this could \"not\" be\n    fieldMatchers.$ne.push(value);\n  } else { // doesn't exist yet\n    fieldMatchers.$ne = [value];\n  }\n}\n\n// add $eq into the mix\nfunction mergeEq(value, fieldMatchers) {\n  // these all have less specificity than the $eq\n  // TODO: check for user errors here\n  delete fieldMatchers.$gt;\n  delete fieldMatchers.$gte;\n  delete fieldMatchers.$lt;\n  delete fieldMatchers.$lte;\n  delete fieldMatchers.$ne;\n  fieldMatchers.$eq = value;\n}\n\n\n//\n// normalize the selector\n//\nfunction massageSelector(input) {\n  var result = clone(input);\n  var wasAnded = false;\n  if ('$and' in result) {\n    result = mergeAndedSelectors(result['$and']);\n    wasAnded = true;\n  }\n\n  ['$or', '$nor'].forEach(function (orOrNor) {\n    if (orOrNor in result) {\n      // message each individual selector\n      // e.g. {foo: 'bar'} becomes {foo: {$eq: 'bar'}}\n      result[orOrNor].forEach(function (subSelector) {\n        var fields = Object.keys(subSelector);\n        for (var i = 0; i < fields.length; i++) {\n          var field = fields[i];\n          var matcher = subSelector[field];\n          if (typeof matcher !== 'object' || matcher === null) {\n            subSelector[field] = {$eq: matcher};\n          }\n        }\n      });\n    }\n  });\n\n  if ('$not' in result) {\n    //This feels a little like forcing, but it will work for now,\n    //I would like to come back to this and make the merging of selectors a little more generic\n    result['$not'] = mergeAndedSelectors([result['$not']]);\n  }\n\n  var fields = Object.keys(result);\n\n  for (var i = 0; i < fields.length; i++) {\n    var field = fields[i];\n    var matcher = result[field];\n\n    if (typeof matcher !== 'object' || matcher === null) {\n      matcher = {$eq: matcher};\n    } else if ('$ne' in matcher && !wasAnded) {\n      // I put these in an array, since there may be more than one\n      // but in the \"mergeAnded\" operation, I already take care of that\n      matcher.$ne = [matcher.$ne];\n    }\n    result[field] = matcher;\n  }\n\n  return result;\n}\n\n// create a comparator based on the sort object\nfunction createFieldSorter(sort) {\n\n  function getFieldValuesAsArray(doc) {\n    return sort.map(function (sorting) {\n      var fieldName = getKey(sorting);\n      var parsedField = parseField(fieldName);\n      var docFieldValue = getFieldFromDoc(doc, parsedField);\n      return docFieldValue;\n    });\n  }\n\n  return function (aRow, bRow) {\n    var aFieldValues = getFieldValuesAsArray(aRow.doc);\n    var bFieldValues = getFieldValuesAsArray(bRow.doc);\n    var collation = collate(aFieldValues, bFieldValues);\n    if (collation !== 0) {\n      return collation;\n    }\n    // this is what mango seems to do\n    return compare(aRow.doc._id, bRow.doc._id);\n  };\n}\n\nfunction filterInMemoryFields(rows, requestDef, inMemoryFields) {\n  rows = rows.filter(function (row) {\n    return rowFilter(row.doc, requestDef.selector, inMemoryFields);\n  });\n\n  if (requestDef.sort) {\n    // in-memory sort\n    var fieldSorter = createFieldSorter(requestDef.sort);\n    rows = rows.sort(fieldSorter);\n    if (typeof requestDef.sort[0] !== 'string' &&\n        getValue(requestDef.sort[0]) === 'desc') {\n      rows = rows.reverse();\n    }\n  }\n\n  if ('limit' in requestDef || 'skip' in requestDef) {\n    // have to do the limit in-memory\n    var skip = requestDef.skip || 0;\n    var limit = ('limit' in requestDef ? requestDef.limit : rows.length) + skip;\n    rows = rows.slice(skip, limit);\n  }\n  return rows;\n}\n\nfunction rowFilter(doc, selector, inMemoryFields) {\n  return inMemoryFields.every(function (field) {\n    var matcher = selector[field];\n    var parsedField = parseField(field);\n    var docFieldValue = getFieldFromDoc(doc, parsedField);\n    if (isCombinationalField(field)) {\n      return matchCominationalSelector(field, matcher, doc);\n    }\n\n    return matchSelector(matcher, doc, parsedField, docFieldValue);\n  });\n}\n\nfunction matchSelector(matcher, doc, parsedField, docFieldValue) {\n  if (!matcher) {\n    // no filtering necessary; this field is just needed for sorting\n    return true;\n  }\n\n  return Object.keys(matcher).every(function (userOperator) {\n    var userValue = matcher[userOperator];\n    return match(userOperator, doc, userValue, parsedField, docFieldValue);\n  });\n}\n\nfunction matchCominationalSelector(field, matcher, doc) {\n\n  if (field === '$or') {\n    return matcher.some(function (orMatchers) {\n      return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n    });\n  }\n\n  if (field === '$not') {\n    return !rowFilter(doc, matcher, Object.keys(matcher));\n  }\n\n  //`$nor`\n  return !matcher.find(function (orMatchers) {\n    return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n  });\n\n}\n\nfunction match(userOperator, doc, userValue, parsedField, docFieldValue) {\n  if (!matchers[userOperator]) {\n    throw new Error('unknown operator \"' + userOperator +\n      '\" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, ' +\n      '$nin, $size, $mod, $regex, $elemMatch, $type, $allMatch or $all');\n  }\n  return matchers[userOperator](doc, userValue, parsedField, docFieldValue);\n}\n\nfunction fieldExists(docFieldValue) {\n  return typeof docFieldValue !== 'undefined' && docFieldValue !== null;\n}\n\nfunction fieldIsNotUndefined(docFieldValue) {\n  return typeof docFieldValue !== 'undefined';\n}\n\nfunction modField(docFieldValue, userValue) {\n  var divisor = userValue[0];\n  var mod = userValue[1];\n  if (divisor === 0) {\n    throw new Error('Bad divisor, cannot divide by zero');\n  }\n\n  if (parseInt(divisor, 10) !== divisor ) {\n    throw new Error('Divisor is not an integer');\n  }\n\n  if (parseInt(mod, 10) !== mod ) {\n    throw new Error('Modulus is not an integer');\n  }\n\n  if (parseInt(docFieldValue, 10) !== docFieldValue) {\n    return false;\n  }\n\n  return docFieldValue % divisor === mod;\n}\n\nfunction arrayContainsValue(docFieldValue, userValue) {\n  return userValue.some(function (val) {\n    if (docFieldValue instanceof Array) {\n      return docFieldValue.indexOf(val) > -1;\n    }\n\n    return docFieldValue === val;\n  });\n}\n\nfunction arrayContainsAllValues(docFieldValue, userValue) {\n  return userValue.every(function (val) {\n    return docFieldValue.indexOf(val) > -1;\n  });\n}\n\nfunction arraySize(docFieldValue, userValue) {\n  return docFieldValue.length === userValue;\n}\n\nfunction regexMatch(docFieldValue, userValue) {\n  var re = new RegExp(userValue);\n\n  return re.test(docFieldValue);\n}\n\nfunction typeMatch(docFieldValue, userValue) {\n\n  switch (userValue) {\n    case 'null':\n      return docFieldValue === null;\n    case 'boolean':\n      return typeof (docFieldValue) === 'boolean';\n    case 'number':\n      return typeof (docFieldValue) === 'number';\n    case 'string':\n      return typeof (docFieldValue) === 'string';\n    case 'array':\n      return docFieldValue instanceof Array;\n    case 'object':\n      return ({}).toString.call(docFieldValue) === '[object Object]';\n  }\n\n  throw new Error(userValue + ' not supported as a type.' +\n                  'Please use one of object, string, array, number, boolean or null.');\n\n}\n\nvar matchers = {\n\n  '$elemMatch': function (doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object') {\n      return docFieldValue.some(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.some(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n\n  '$allMatch': function (doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n\n    /* istanbul ignore next */\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object') {\n      return docFieldValue.every(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.every(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n\n  '$eq': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) === 0;\n  },\n\n  '$gte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) >= 0;\n  },\n\n  '$gt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) > 0;\n  },\n\n  '$lte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) <= 0;\n  },\n\n  '$lt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) < 0;\n  },\n\n  '$exists': function (doc, userValue, parsedField, docFieldValue) {\n    //a field that is null is still considered to exist\n    if (userValue) {\n      return fieldIsNotUndefined(docFieldValue);\n    }\n\n    return !fieldIsNotUndefined(docFieldValue);\n  },\n\n  '$mod': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && modField(docFieldValue, userValue);\n  },\n\n  '$ne': function (doc, userValue, parsedField, docFieldValue) {\n    return userValue.every(function (neValue) {\n      return collate(docFieldValue, neValue) !== 0;\n    });\n  },\n  '$in': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$nin': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && !arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$size': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arraySize(docFieldValue, userValue);\n  },\n\n  '$all': function (doc, userValue, parsedField, docFieldValue) {\n    return Array.isArray(docFieldValue) && arrayContainsAllValues(docFieldValue, userValue);\n  },\n\n  '$regex': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && regexMatch(docFieldValue, userValue);\n  },\n\n  '$type': function (doc, userValue, parsedField, docFieldValue) {\n    return typeMatch(docFieldValue, userValue);\n  }\n};\n\n// return true if the given doc matches the supplied selector\nfunction matchesSelector(doc, selector) {\n  /* istanbul ignore if */\n  if (typeof selector !== 'object') {\n    // match the CouchDB error message\n    throw new Error('Selector error: expected a JSON object');\n  }\n\n  selector = massageSelector(selector);\n  var row = {\n    'doc': doc\n  };\n\n  var rowsMatched = filterInMemoryFields([row], { 'selector': selector }, Object.keys(selector));\n  return rowsMatched && rowsMatched.length === 1;\n}\n\nexport { massageSelector, matchesSelector, filterInMemoryFields, createFieldSorter, rowFilter, isCombinationalField, getKey, getValue, getFieldFromDoc, setFieldInDoc, compare, parseField };\n\n\n\n// WEBPACK FOOTER //\n// ../~/pouchdb-selector-core/lib/index.es.js","import {h, Component} from 'preact';\n\nclass ShoppingLists extends Component {\n  /* all state actions are for handling the renaming dialog */\n  state = {\n    editingName: false,\n    activeListId: '', \n    oldName: '',\n    newName: ''\n  };\n\n  componentDidUpdate() {\n    if ( this.state.editingName === true ) {\n      this.nameInput.focus();\n    }\n  }\n\n  handleEditingStart = (listid, listtitle) => {\n    this.setState({editingName: true, activeListId: listid, oldName: listtitle});\n  };\n\n  handleEditingDone = () => {\n    this.setState({editingName: false});\n  };\n\n  handleEditingSubmit = (e) => {\n    this.props.renameListFunc(this.state.activeListId, this.state.newName);\n    this.handleEditingDone();\n  };\n\n  updateName = (e) => {\n    this.setState({newName: e.target.value});\n  }\n\n  renderEditNameUI = () => {\n    return (\n        <div className=\"editing\">\n          <div className=\"col s9\">\n            <form onSubmit={this.handleEditingSubmit}>\n              <div class=\"input-field\" \n                style={{\"margin-top\":\"0.5rem\",\"background-color\":\"aliceblue\"}}>\n                  <input type=\"text\" id=\"input-name\" \n                    ref={(inp)=>{this.nameInput=inp;}} \n                    value={this.state.oldName} \n                    onChange={this.updateName} \n                    style={{height:\"unset\",\"font-size\":\"18pt\",\"margin-bottom\":\"8px\"}}/>\n              </div>\n            </form>\n          </div>\n          <div className=\"col s3\">\n            <a className=\"btn-flat btn-large\" style={{padding:\"0 0.5rem\"}} style={{padding:\"0px\"}} \n              onClick={this.handleEditingDone}>\n              <i className=\"material-icons\">close</i>\n            </a>\n          </div>\n        </div>\n    );\n  }\n\n  render() {\n    let listItems = [];\n    for(let list of this.props.shoppingLists) {\n      listItems.push(\n      <div className=\"shoppinglist\" key={list._id} style={{margin:\"12px 0\",padding:\"12px\"}}>\n        <div class=\"row\" style=\"margin-bottom: 0px\">\n          { this.state.editingName && this.state.activeListId===list._id ? \n            this.renderEditNameUI() : \n            <div className=\"notediting\">\n              <div className=\"col s7\">\n                <h5><a href=\"#\" onClick={()=>this.props.openListFunc(list._id)}>{list.title}</a></h5>\n              </div>\n              <div className=\"col s5 right-align\">\n                <a className=\"btn-flat btn-large\" style={{padding:\"0 0.5rem\"}} \n                  onClick={()=>this.props.openListFunc(list._id)}>\n                  <i className=\"material-icons\">play_arrow</i>\n                </a>\n                <a className=\"btn-flat btn-large\" style={{padding:\"0 0.5rem\"}} \n                  onClick={()=>this.handleEditingStart(list._id, list.title)}>\n                  <i className=\"material-icons\">mode_edit</i>\n                </a>\n                <a className=\"btn-flat btn-large\" style={{padding:\"0 0.5rem\"}} \n                  onClick={()=>this.props.deleteListFunc(list._id)}>\n                  <i className=\"material-icons\">delete_forever</i>\n                </a>\n              </div>\n            </div>\n          }\n        </div>\n        <div className=\"row\">\n          <div className=\"col s1\">\n            <input type=\"checkbox\" id={\"cb_\"+list._id} \n              onChange={()=>this.props.checkAllFunc(list._id)} \n              defaultChecked={false}></input>\n              <label for={\"cb_\"+list._id} >&nbsp;</label>\n          </div>\n          <div className=\"col s11\">\n            { (this.props.checkedCounts.get(list._id) || 0)+' of '+(this.props.totalCounts.get(list._id) || 0)+' items checked' }\n          </div>\n        </div>\n      </div>\n    );\n  }\n  return (\n    <div>\n      <div>{listItems}</div>\n    </div>\n  )\n  }\n}\n\nexport default ShoppingLists;\n\n\n// WEBPACK FOOTER //\n// ./components/ShoppingLists.js","\"use strict\";\n\nconst { ShoppingListFactory } = require(\"./ShoppingListFactory\");\nconst { ShoppingListRepository } = require(\"./ShoppingListRepository\");\nconst { ShoppingListRepositoryPouchDB } = require(\"./ShoppingListRepositoryPouchDB\");\n\nexports.ShoppingListFactory = ShoppingListFactory;\nexports.ShoppingListRepository = ShoppingListRepository;\nexports.ShoppingListRepositoryPouchDB = ShoppingListRepositoryPouchDB;\n\n\n\n// WEBPACK FOOTER //\n// ../~/ibm-shopping-list-model/src/index.js","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n\n\n// WEBPACK FOOTER //\n// /usr/local/lib/~/preact-cli/~/path-browserify/index.js","import {h, render, Component} from 'preact';\nimport { ShoppingListFactory, ShoppingListRepositoryPouchDB } from 'ibm-shopping-list-model';\nimport PouchDB from 'pouchdb';\nimport PouchDBFind from 'pouchdb-find';\nimport Credentials from './secret';\nimport './material-icons.css';\nimport './materialize.min.css';\n// import './materialize.min.js';\nimport './App.css';\n\n\nPouchDB.plugin(PouchDBFind);\nconst localDB = new PouchDB('shopping_list_react');\nconst remoteDB = new PouchDB(Credentials.cloudant_url);\nconst shoppingListFactory = new ShoppingListFactory();\nconst shoppingListRepository = new ShoppingListRepositoryPouchDB(localDB);\n\nimport App from './App';\n\nshoppingListRepository.ensureIndexes().then(\n  render(<App \n    shoppingListFactory={shoppingListFactory} \n    shoppingListRepository={shoppingListRepository} \n    localDB={localDB} remoteDB={remoteDB} />, \n    document.body)\n).catch( err => {\n  console.log(\"ERROR in ensureIndexes\");\n  console.log(err);\n});\n\n\n\n// WEBPACK FOOTER //\n// ./index.js","!function(){\"use strict\";function e(){}function t(t,n){var o,r,i,l,a=E;for(l=arguments.length;l-- >2;)W.push(arguments[l]);n&&null!=n.children&&(W.length||W.push(n.children),delete n.children);while(W.length)if((r=W.pop())&&void 0!==r.pop)for(l=r.length;l--;)W.push(r[l]);else\"boolean\"==typeof r&&(r=null),(i=\"function\"!=typeof t)&&(null==r?r=\"\":\"number\"==typeof r?r+=\"\":\"string\"!=typeof r&&(i=!1)),i&&o?a[a.length-1]+=r:a===E?a=[r]:a.push(r),o=i;var u=new e;return u.nodeName=t,u.children=a,u.attributes=null==n?void 0:n,u.key=null==n?void 0:n.key,void 0!==S.vnode&&S.vnode(u),u}function n(e,t){for(var n in t)e[n]=t[n];return e}function o(e,o){return t(e.nodeName,n(n({},e.attributes),o),arguments.length>2?[].slice.call(arguments,2):e.children)}function r(e){!e.__d&&(e.__d=!0)&&1==A.push(e)&&(S.debounceRendering||P)(i)}function i(){var e,t=A;A=[];while(e=t.pop())e.__d&&k(e)}function l(e,t,n){return\"string\"==typeof t||\"number\"==typeof t?void 0!==e.splitText:\"string\"==typeof t.nodeName?!e._componentConstructor&&a(e,t.nodeName):n||e._componentConstructor===t.nodeName}function a(e,t){return e.__n===t||e.nodeName.toLowerCase()===t.toLowerCase()}function u(e){var t=n({},e.attributes);t.children=e.children;var o=e.nodeName.defaultProps;if(void 0!==o)for(var r in o)void 0===t[r]&&(t[r]=o[r]);return t}function _(e,t){var n=t?document.createElementNS(\"http://www.w3.org/2000/svg\",e):document.createElement(e);return n.__n=e,n}function p(e){var t=e.parentNode;t&&t.removeChild(e)}function c(e,t,n,o,r){if(\"className\"===t&&(t=\"class\"),\"key\"===t);else if(\"ref\"===t)n&&n(null),o&&o(e);else if(\"class\"!==t||r)if(\"style\"===t){if(o&&\"string\"!=typeof o&&\"string\"!=typeof n||(e.style.cssText=o||\"\"),o&&\"object\"==typeof o){if(\"string\"!=typeof n)for(var i in n)i in o||(e.style[i]=\"\");for(var i in o)e.style[i]=\"number\"==typeof o[i]&&!1===V.test(i)?o[i]+\"px\":o[i]}}else if(\"dangerouslySetInnerHTML\"===t)o&&(e.innerHTML=o.__html||\"\");else if(\"o\"==t[0]&&\"n\"==t[1]){var l=t!==(t=t.replace(/Capture$/,\"\"));t=t.toLowerCase().substring(2),o?n||e.addEventListener(t,f,l):e.removeEventListener(t,f,l),(e.__l||(e.__l={}))[t]=o}else if(\"list\"!==t&&\"type\"!==t&&!r&&t in e)s(e,t,null==o?\"\":o),null!=o&&!1!==o||e.removeAttribute(t);else{var a=r&&t!==(t=t.replace(/^xlink\\:?/,\"\"));null==o||!1===o?a?e.removeAttributeNS(\"http://www.w3.org/1999/xlink\",t.toLowerCase()):e.removeAttribute(t):\"function\"!=typeof o&&(a?e.setAttributeNS(\"http://www.w3.org/1999/xlink\",t.toLowerCase(),o):e.setAttribute(t,o))}else e.className=o||\"\"}function s(e,t,n){try{e[t]=n}catch(e){}}function f(e){return this.__l[e.type](S.event&&S.event(e)||e)}function d(){var e;while(e=D.pop())S.afterMount&&S.afterMount(e),e.componentDidMount&&e.componentDidMount()}function h(e,t,n,o,r,i){H++||(R=null!=r&&void 0!==r.ownerSVGElement,j=null!=e&&!(\"__preactattr_\"in e));var l=m(e,t,n,o,i);return r&&l.parentNode!==r&&r.appendChild(l),--H||(j=!1,i||d()),l}function m(e,t,n,o,r){var i=e,l=R;if(null!=t&&\"boolean\"!=typeof t||(t=\"\"),\"string\"==typeof t||\"number\"==typeof t)return e&&void 0!==e.splitText&&e.parentNode&&(!e._component||r)?e.nodeValue!=t&&(e.nodeValue=t):(i=document.createTextNode(t),e&&(e.parentNode&&e.parentNode.replaceChild(i,e),b(e,!0))),i.__preactattr_=!0,i;var u=t.nodeName;if(\"function\"==typeof u)return U(e,t,n,o);if(R=\"svg\"===u||\"foreignObject\"!==u&&R,u+=\"\",(!e||!a(e,u))&&(i=_(u,R),e)){while(e.firstChild)i.appendChild(e.firstChild);e.parentNode&&e.parentNode.replaceChild(i,e),b(e,!0)}var p=i.firstChild,c=i.__preactattr_,s=t.children;if(null==c){c=i.__preactattr_={};for(var f=i.attributes,d=f.length;d--;)c[f[d].name]=f[d].value}return!j&&s&&1===s.length&&\"string\"==typeof s[0]&&null!=p&&void 0!==p.splitText&&null==p.nextSibling?p.nodeValue!=s[0]&&(p.nodeValue=s[0]):(s&&s.length||null!=p)&&v(i,s,n,o,j||null!=c.dangerouslySetInnerHTML),g(i,t.attributes,c),R=l,i}function v(e,t,n,o,r){var i,a,u,_,c,s=e.childNodes,f=[],d={},h=0,v=0,y=s.length,g=0,w=t?t.length:0;if(0!==y)for(var C=0;C<y;C++){var x=s[C],N=x.__preactattr_,k=w&&N?x._component?x._component.__k:N.key:null;null!=k?(h++,d[k]=x):(N||(void 0!==x.splitText?!r||x.nodeValue.trim():r))&&(f[g++]=x)}if(0!==w)for(var C=0;C<w;C++){_=t[C],c=null;var k=_.key;if(null!=k)h&&void 0!==d[k]&&(c=d[k],d[k]=void 0,h--);else if(!c&&v<g)for(i=v;i<g;i++)if(void 0!==f[i]&&l(a=f[i],_,r)){c=a,f[i]=void 0,i===g-1&&g--,i===v&&v++;break}c=m(c,_,n,o),u=s[C],c&&c!==e&&c!==u&&(null==u?e.appendChild(c):c===u.nextSibling?p(u):e.insertBefore(c,u))}if(h)for(var C in d)void 0!==d[C]&&b(d[C],!1);while(v<=g)void 0!==(c=f[g--])&&b(c,!1)}function b(e,t){var n=e._component;n?L(n):(null!=e.__preactattr_&&e.__preactattr_.ref&&e.__preactattr_.ref(null),!1!==t&&null!=e.__preactattr_||p(e),y(e))}function y(e){e=e.lastChild;while(e){var t=e.previousSibling;b(e,!0),e=t}}function g(e,t,n){var o;for(o in n)t&&null!=t[o]||null==n[o]||c(e,o,n[o],n[o]=void 0,R);for(o in t)\"children\"===o||\"innerHTML\"===o||o in n&&t[o]===(\"value\"===o||\"checked\"===o?e[o]:n[o])||c(e,o,n[o],n[o]=t[o],R)}function w(e){var t=e.constructor.name;(I[t]||(I[t]=[])).push(e)}function C(e,t,n){var o,r=I[e.name];if(e.prototype&&e.prototype.render?(o=new e(t,n),T.call(o,t,n)):(o=new T(t,n),o.constructor=e,o.render=x),r)for(var i=r.length;i--;)if(r[i].constructor===e){o.__b=r[i].__b,r.splice(i,1);break}return o}function x(e,t,n){return this.constructor(e,n)}function N(e,t,n,o,i){e.__x||(e.__x=!0,(e.__r=t.ref)&&delete t.ref,(e.__k=t.key)&&delete t.key,!e.base||i?e.componentWillMount&&e.componentWillMount():e.componentWillReceiveProps&&e.componentWillReceiveProps(t,o),o&&o!==e.context&&(e.__c||(e.__c=e.context),e.context=o),e.__p||(e.__p=e.props),e.props=t,e.__x=!1,0!==n&&(1!==n&&!1===S.syncComponentUpdates&&e.base?r(e):k(e,1,i)),e.__r&&e.__r(e))}function k(e,t,o,r){if(!e.__x){var i,l,a,_=e.props,p=e.state,c=e.context,s=e.__p||_,f=e.__s||p,m=e.__c||c,v=e.base,y=e.__b,g=v||y,w=e._component,x=!1;if(v&&(e.props=s,e.state=f,e.context=m,2!==t&&e.shouldComponentUpdate&&!1===e.shouldComponentUpdate(_,p,c)?x=!0:e.componentWillUpdate&&e.componentWillUpdate(_,p,c),e.props=_,e.state=p,e.context=c),e.__p=e.__s=e.__c=e.__b=null,e.__d=!1,!x){i=e.render(_,p,c),e.getChildContext&&(c=n(n({},c),e.getChildContext()));var U,T,M=i&&i.nodeName;if(\"function\"==typeof M){var W=u(i);l=w,l&&l.constructor===M&&W.key==l.__k?N(l,W,1,c,!1):(U=l,e._component=l=C(M,W,c),l.__b=l.__b||y,l.__u=e,N(l,W,0,c,!1),k(l,1,o,!0)),T=l.base}else a=g,U=w,U&&(a=e._component=null),(g||1===t)&&(a&&(a._component=null),T=h(a,i,c,o||!v,g&&g.parentNode,!0));if(g&&T!==g&&l!==w){var E=g.parentNode;E&&T!==E&&(E.replaceChild(T,g),U||(g._component=null,b(g,!1)))}if(U&&L(U),e.base=T,T&&!r){var P=e,V=e;while(V=V.__u)(P=V).base=T;T._component=P,T._componentConstructor=P.constructor}}if(!v||o?D.unshift(e):x||(e.componentDidUpdate&&e.componentDidUpdate(s,f,m),S.afterUpdate&&S.afterUpdate(e)),null!=e.__h)while(e.__h.length)e.__h.pop().call(e);H||r||d()}}function U(e,t,n,o){var r=e&&e._component,i=r,l=e,a=r&&e._componentConstructor===t.nodeName,_=a,p=u(t);while(r&&!_&&(r=r.__u))_=r.constructor===t.nodeName;return r&&_&&(!o||r._component)?(N(r,p,3,n,o),e=r.base):(i&&!a&&(L(i),e=l=null),r=C(t.nodeName,p,n),e&&!r.__b&&(r.__b=e,l=null),N(r,p,1,n,o),e=r.base,l&&e!==l&&(l._component=null,b(l,!1))),e}function L(e){S.beforeUnmount&&S.beforeUnmount(e);var t=e.base;e.__x=!0,e.componentWillUnmount&&e.componentWillUnmount(),e.base=null;var n=e._component;n?L(n):t&&(t.__preactattr_&&t.__preactattr_.ref&&t.__preactattr_.ref(null),e.__b=t,p(t),w(e),y(t)),e.__r&&e.__r(null)}function T(e,t){this.__d=!0,this.context=t,this.props=e,this.state=this.state||{}}function M(e,t,n){return h(n,e,{},!1,t,!1)}var S={},W=[],E=[],P=\"function\"==typeof Promise?Promise.resolve().then.bind(Promise.resolve()):setTimeout,V=/acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i,A=[],D=[],H=0,R=!1,j=!1,I={};n(T.prototype,{setState:function(e,t){var o=this.state;this.__s||(this.__s=n({},o)),n(o,\"function\"==typeof e?e(o,this.props):e),t&&(this.__h=this.__h||[]).push(t),r(this)},forceUpdate:function(e){e&&(this.__h=this.__h||[]).push(e),k(this,2)},render:function(){}});var $={h:t,createElement:t,cloneElement:o,Component:T,render:M,rerender:i,options:S};\"undefined\"!=typeof module?module.exports=$:self.preact=$}();\n//# sourceMappingURL=preact.min.js.map\n\n\n// WEBPACK FOOTER //\n// ../~/preact/dist/preact.min.js","import { h, Component } from 'preact';\n\nclass ShoppingList extends Component {\n  /* all state actions are for handling the renaming dialog */\n  state = {\n    editingName: false,\n    activeItemId: '', \n    oldName: '',\n    newName: ''\n  };\n\n  componentDidUpdate() {\n    if ( this.state.editingName === true ) {\n      this.nameInput.focus();\n    }\n  }\n\n  handleEditingStart = (itemid, itemtitle) => {\n    this.setState({editingName: true, activeItemId: itemid, oldName: itemtitle});\n  };\n\n  handleEditingDone = () => {\n    this.setState({editingName: false});\n  };\n\n  handleEditingSubmit = (e) => {\n    this.props.renameItemFunc(this.state.activeItemId, this.state.newName);\n    this.handleEditingDone();\n  };\n\n  updateName = (e) => {\n    this.setState({newName: e.target.value});\n  }\n\n  renderEditNameUI = () => {\n    return (\n      <div>\n        <div className=\"col s6\">\n          <form onSubmit={this.handleEditingSubmit}>\n            <div class=\"input-field\" \n              style={{\"margin-top\":\"0.5rem\",\"background-color\":\"aliceblue\"}}>\n                <input type=\"text\" id=\"input-name\" \n                  ref={(inp)=>{this.nameInput=inp;}} \n                  value={this.state.oldName} \n                  onChange={this.updateName} \n                  style={{height:\"unset\",\"margin-bottom\":\"8px\"}}/>\n            </div>\n          </form>\n        </div>\n        <div className=\"col s1\">\n          <a className=\"btn-flat\" onClick={this.handleEditingDone} style={{padding:\"0px\"}}>\n            <i className=\"material-icons\">close</i>\n          </a>\n        </div>\n      </div>\n    );\n  }\n\n  render() {\n    let items = [];\n    for(let item of this.props.shoppingListItems) {\n      items.push(\n        <div>\n        <div className=\"row\" key={'listitem_'+item._id} style={{margin:\"0.5rem 0 0.5rem 0\"}}>\n          <div className=\"col s1\">\n            <input type=\"checkbox\" id={\"cb_\"+item._id} \n                onChange={()=>this.props.toggleItemCheckFunc(item._id)} \n                defaultChecked={item.checked}></input>\n                <label for={\"cb_\"+item._id} >&nbsp;</label>\n          </div>\n\n          {this.state.editingName && this.state.activeItemId===item._id ? \n            this.renderEditNameUI() : \n            <div className=\"col s7\"><span className={item.checked?\"checkeditem\":\"uci\"}>{item.title}</span></div> }\n\n          <div className=\"col s4 right-align \">\n            <a class=\"btn-flat itemactionbutton\" onClick={()=>this.handleEditingStart(item._id, item.title)}>\n              <i className=\"material-icons\">mode_edit</i>\n            </a>\n            <a class=\"btn-flat itemactionbutton\" onClick={()=>this.props.deleteFunc(item._id)}>\n              <i className=\"material-icons\">delete_forever</i>\n            </a>\n          </div>\n      </div>\n\n      <div className=\"divider\" />\n      </div>);\n    }\n      \n    return (\n      <div>\n        <div>{items}</div>\n      </div>\n    )\n  }\n}\n\nexport default ShoppingList;\n\n\n// WEBPACK FOOTER //\n// ./components/ShoppingList.js","import { Set } from 'pouchdb-collections';\nimport argsarray from 'argsarray';\nimport { nextTick } from 'pouchdb-utils';\nimport inherits from 'inherits';\n\nfunction QueryParseError(message) {\n  this.status = 400;\n  this.name = 'query_parse_error';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, QueryParseError);\n  } catch (e) {}\n}\n\ninherits(QueryParseError, Error);\n\nfunction NotFoundError(message) {\n  this.status = 404;\n  this.name = 'not_found';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, NotFoundError);\n  } catch (e) {}\n}\n\ninherits(NotFoundError, Error);\n\nfunction BuiltInError(message) {\n  this.status = 500;\n  this.name = 'invalid_value';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, BuiltInError);\n  } catch (e) {}\n}\n\ninherits(BuiltInError, Error);\n\nfunction promisedCallback(promise, callback) {\n  if (callback) {\n    promise.then(function (res) {\n      nextTick(function () {\n        callback(null, res);\n      });\n    }, function (reason) {\n      nextTick(function () {\n        callback(reason);\n      });\n    });\n  }\n  return promise;\n}\n\nfunction callbackify(fun) {\n  return argsarray(function (args) {\n    var cb = args.pop();\n    var promise = fun.apply(this, args);\n    if (typeof cb === 'function') {\n      promisedCallback(promise, cb);\n    }\n    return promise;\n  });\n}\n\n// Promise finally util similar to Q.finally\nfunction fin(promise, finalPromiseFactory) {\n  return promise.then(function (res) {\n    return finalPromiseFactory().then(function () {\n      return res;\n    });\n  }, function (reason) {\n    return finalPromiseFactory().then(function () {\n      throw reason;\n    });\n  });\n}\n\nfunction sequentialize(queue, promiseFactory) {\n  return function () {\n    var args = arguments;\n    var that = this;\n    return queue.add(function () {\n      return promiseFactory.apply(that, args);\n    });\n  };\n}\n\n// uniq an array of strings, order not guaranteed\n// similar to underscore/lodash _.uniq\nfunction uniq(arr) {\n  var theSet = new Set(arr);\n  var result = new Array(theSet.size);\n  var index = -1;\n  theSet.forEach(function (value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nfunction mapToKeysArray(map) {\n  var result = new Array(map.size);\n  var index = -1;\n  map.forEach(function (value, key) {\n    result[++index] = key;\n  });\n  return result;\n}\n\nexport { uniq, sequentialize, fin, callbackify, promisedCallback, mapToKeysArray, QueryParseError, NotFoundError, BuiltInError };\n\n\n\n// WEBPACK FOOTER //\n// ../~/pouchdb-mapreduce-utils/lib/index.es.js","import {h, Component} from \"preact\";\nimport {List} from \"immutable\";\nimport {ShoppingListFactory, ShoppingListRepositoryPouchDB} from \"ibm-shopping-list-model\";\nimport ShoppingList from \"./components/ShoppingList\";\nimport ShoppingLists from \"./components/ShoppingLists\";\n\nconst NOLISTMSG = \"Click the + sign above to create a shopping list.\"\nconst NOITEMSMSG = \"Click the + sign above to create a shopping list item.\"\n\nconst appBarStyle = {\n  width: \"100%\", \n};\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      shoppingList: null, \n      shoppingLists: [], \n      totalShoppingListItemCount: List(), //Immutable.js List with list ids as keys\n      checkedTotalShoppingListItemCount: List(), //Immutable.js List with list ids as keys\n      shoppingListItems: null, \n      adding: false, \n      view: \"lists\",\n      newName: \"\"\n    }\n  }\n\n  componentDidMount = () => {\n      this.getShoppingLists();\n      this.props.localDB.sync(this.props.remoteDB, {live: true, retry: true})\n        .on(\"change\", change => {\n          // console.log(\"something changed!\");\n          this.getPouchDocs();\n        })\n        // .on(\"paused\", info => console.log(\"replication paused.\"))\n        // .on(\"active\", info => console.log(\"replication resumed.\"))\n        .on(\"error\", err => console.log(\"uh oh! an error occured.\"));\n  }\n\n  getShoppingLists = () => {\n    let checkedCount = List();\n    let totalCount = List();\n    let lists = null;\n    this.props.shoppingListRepository.find().then( foundLists => {\n      lists = foundLists;\n      return foundLists;\n    }).then( foundLists => {\n      return this.props.shoppingListRepository.findItemsCountByList();\n    }).then( countsList => { \n      totalCount = countsList;\n      return this.props.shoppingListRepository.findItemsCountByList({\n        selector: {\n          type: \"item\", \n          checked: true\n        },\n        fields: [\"list\"]\n      });\n    }).then( checkedList => {\n      checkedCount = checkedList;\n      this.setState({\n        view: \"lists\", \n        shoppingLists: lists, \n        shoppingList: null,\n        shoppingListItems: null, \n        checkedTotalShoppingListItemCount: checkedCount, \n        totalShoppingListItemCount: totalCount\n      });\n    }).catch( err => {\n      console.log(\"ERROR in getShoppingLists\");\n      console.log(err);\n    });\n  }\n\n  openShoppingList = (listid) => {\n    this.props.shoppingListRepository.get(listid).then( list => {\n      return list;\n    }).then(list => {\n      this.getShoppingListItems(listid).then(items => {\n        this.setState({\n          view: \"items\", \n          shoppingList: list,\n          shoppingListItems: items\n        });\n      });\n    });\n  }\n\n  getShoppingListItems = (listid) => {\n    return this.props.shoppingListRepository.findItems({\n      selector: {\n        type: \"item\", \n        list: listid\n      }\n    });\n  }\n\n  refreshShoppingListItems = (listid) => {\n    this.props.shoppingListRepository.findItems({\n      selector: {\n        type: \"item\", \n        list: listid\n      }\n    }).then(items => {\n      this.setState({\n        view: \"items\", \n        shoppingListItems: items\n      });\n    });\n  }\n\n  renameShoppingListItem = (itemid, newname) => {\n    console.log(\"IN renameShoppingListItem with id=\"+itemid+\", name=\"+newname);\n    this.props.shoppingListRepository.getItem(itemid).then(item => {\n      item = item.set(\"title\", newname);\n      return this.props.shoppingListRepository.putItem(item);\n    }).then(this.refreshShoppingListItems(this.state.shoppingList._id));\n  }\n\n  deleteShoppingListItem = (itemid) => {\n    this.props.shoppingListRepository.getItem(itemid).then(item => {\n      return this.props.shoppingListRepository.deleteItem(item);\n    }).then(this.refreshShoppingListItems(this.state.shoppingList._id));\n  }\n\n  toggleItemCheck = (itemid) => {\n    this.props.shoppingListRepository.getItem(itemid).then(item => {\n      item = item.set(\"checked\", !item.checked);\n      return this.props.shoppingListRepository.putItem(item);\n    }).then(this.refreshShoppingListItems(this.state.shoppingList._id));\n  }\n\n  checkAllListItems = (listid) => {\n    let listcheck = true;\n    this.getShoppingListItems(listid).then( items => {\n      let newitems = [];\n      items.forEach(item => {\n        if (!item.checked) {\n          newitems.push( item.mergeDeep({checked:true}) );\n        }\n      }, this);\n      // if all items were already checked let's uncheck them all\n      if (newitems.length == 0) {\n        listcheck = false;\n        items.forEach(item => {\n          newitems.push( item.mergeDeep({checked:false}) );\n        }, this);\n      }\n      let listOfShoppingListItems = this.props.shoppingListFactory.newListOfShoppingListItems(newitems);\n      return this.props.shoppingListRepository.putItemsBulk(listOfShoppingListItems);\n    }).then(newitemsresponse => {\n      return this.props.shoppingListRepository.get(listid);\n    }).then(shoppingList => {\n      shoppingList = shoppingList.set(\"checked\", listcheck);\n      return this.props.shoppingListRepository.put(shoppingList);\n    }).then(shoppingList => {\n      this.getShoppingLists();\n    });\n  }\n\n  deleteShoppingList = (listid) => {\n    this.props.shoppingListRepository.get(listid).then(shoppingList => {\n      shoppingList = shoppingList.set(\"_deleted\", true);\n      return this.props.shoppingListRepository.put(shoppingList);\n    }).then(result => {\n      this.getShoppingLists();\n    });\n  }\n\n  renameShoppingList = (listid, newname) => {\n    console.log(\"HERE IN renameShoppingList with id=\"+listid+\", title=\"+newname);\n    this.props.shoppingListRepository.get(listid).then(shoppingList => {\n      shoppingList = shoppingList.set(\"title\", newname);\n      return this.props.shoppingListRepository.put(shoppingList);\n    }).then(this.getShoppingLists);\n  }\n\n  createNewShoppingListOrItem = (e) => {\n    e.preventDefault();\n    this.setState({adding: false});\n    \n    if (this.state.view === \"lists\") {\n      let shoppingList = this.props.shoppingListFactory.newShoppingList({\n        title: this.state.newName\n      });\n      this.props.shoppingListRepository.put(shoppingList).then(this.getShoppingLists);\n\n    } else if (this.state.view === \"items\") {\n      let item = this.props.shoppingListFactory.newShoppingListItem({\n        title: this.state.newName\n      }, this.state.shoppingList);\n      this.props.shoppingListRepository.putItem(item).then(item => {\n        this.getShoppingListItems(this.state.shoppingList._id).then(items => {\n          this.setState({\n            view: \"items\", \n            shoppingListItems: items\n          });\n        });\n      });\n    }\n  }\n\n  updateName = (e) => {\n    this.setState({newName: e.target.value});\n  }\n\n  displayAddingUI = () => {\n    this.setState({adding: true});\n  }\n\n  renderNewNameUI = () => {\n    return (\n      <form onSubmit={this.createNewShoppingListOrItem} style={{marginTop:\"12px\"}}>\n        <div class=\"input-field\">\n            <input className=\"validate\" type=\"text\" \n              placeholder=\"Name...\" id=\"input-name\" \n              onChange={this.updateName} \n              fullWidth={false} \n              style={{padding:\"0px 12px\",width:\"calc(100% - 24px)\"}}\n              underlineStyle={{width:\"calc(100% - 24px)\"}}/>\n            {/* <label for=\"input-name\">Name</label> */}\n        </div>\n      </form>\n    );\n  }\n\n  renderShoppingLists = () => {\n    if (this.state.shoppingLists.length < 1)\n      return ( <h5>{NOLISTMSG}</h5> );\n    return (\n      <ShoppingLists \n        shoppingLists={this.state.shoppingLists} \n        openListFunc={this.openShoppingList} \n        deleteListFunc={this.deleteShoppingList} \n        renameListFunc={this.renameShoppingList} \n        checkAllFunc={this.checkAllListItems}\n        totalCounts={this.state.totalShoppingListItemCount}\n        checkedCounts={this.state.checkedTotalShoppingListItemCount} /> \n    )\n  }\n\n  renderShoppingListItems = () => {\n    if (this.state.shoppingListItems.size < 1) \n      return ( <h5>{NOITEMSMSG}</h5> );\n    return (\n      <ShoppingList \n        shoppingListItems={this.state.shoppingListItems} \n        deleteFunc={this.deleteShoppingListItem} \n        toggleItemCheckFunc={this.toggleItemCheck} \n        renameItemFunc={this.renameShoppingListItem} /> \n    )\n  }\n\n  renderBackButton = () => {\n    if (this.state.view === \"items\") \n      return (\n        <a className=\"btn-flat btn-large white-text\" onClick={this.getShoppingLists} style={{\"padding\":\"0px\",\"vertical-align\":\"middle\"}}>\n          <i className=\"material-icons\">keyboard_backspace</i>\n        </a>)\n    else \n      return <span/>;\n  }\n\n  render() {\n    let screenname = \"Shopping Lists\";\n    if (this.state.view === \"items\") screenname = this.state.shoppingList.title;\n    return (\n      <div className=\"App\">\n        <nav>\n          <div className=\"nav-wrapper\">\n            <div className=\"brand-logo left\">\n                {this.renderBackButton()}\n                <span className=\"hide-on-small-only\">{screenname}</span>\n                <span className=\"show-on-medium-and-up\" style={{\"font-size\":\"14pt\"}}>{screenname}</span>\n            </div>\n            <div className=\"right\">\n              <a className=\"btn-floating\" style={{\"margin-right\":\"8px\"}}\n                onClick={this.displayAddingUI}>\n                <i className=\"material-icons\" style={{\"line-height\":\"unset\"}}>add</i>\n              </a>\n            </div>\n          </div>\n        </nav>\n        <div className=\"listsanditems container\" style={{margin:\"8px\"}}>\n          {this.state.adding ? this.renderNewNameUI() : <span/>}\n          {this.state.view === \"lists\" ? this.renderShoppingLists() : this.renderShoppingListItems()}\n        </div>\n      </div>\n    )\n  }\n}\n\nexport default App;\n\n\n// WEBPACK FOOTER //\n// ./App.js","\"use strict\";\n\nconst cuid = require(\"cuid\");\n\nconst { Record, List } = require(\"immutable\");\n\nclass ShoppingListFactory {\n\n  constructor() {\n    this._ShoppingList = Record({\n      _id: undefined,\n      _rev: undefined,\n      _deleted: false,\n      type: \"list\",\n      version: 1,\n      title: undefined,\n      checked: false,\n      place: undefined,\n      createdAt: undefined,\n      updatedAt: undefined\n    });\n    this._ShoppingListItem = Record({\n      _id: undefined,\n      _rev: undefined,\n      _deleted: false,\n      type: \"item\",\n      version: 1,\n      list: undefined,\n      title: undefined,\n      checked: false,\n      createdAt: undefined,\n      updatedAt: undefined\n    });\n  }\n\n  _guardShoppingList(shoppingList) {\n    if (!Record.isRecord(shoppingList)) {\n      throw new Error(\"Shopping List must be a Record\");\n    }\n    if (shoppingList.type != \"list\") {\n      throw new Error(\"Shopping List type must be list\");\n    }\n  }\n\n  _guardListOfShoppingLists(listOfShoppingLists) {\n    listOfShoppingLists.forEach(shoppingList => this._guardShoppingList(shoppingList));\n  }\n\n  _guardShoppingListItem(shoppingListItem) {\n    if (!Record.isRecord(shoppingListItem)) {\n      throw new Error(\"Shopping List Item must be a Record\");\n    }\n    if (shoppingListItem.type != \"item\") {\n      throw new Error(\"Shopping List Item type must be item\");\n    }\n  }\n\n  _guardListOfShoppingListItems(listOfShoppingListItems) {\n    listOfShoppingListItems.forEach(shoppingListItem => this._guardShoppingListItem(shoppingListItem));\n  }\n\n  newShoppingList(values) {\n    let shoppingList = new this._ShoppingList(values);\n    if (shoppingList._id === undefined) {\n      shoppingList = shoppingList.set(\"_id\", \"list:\" + cuid());\n    }\n    return shoppingList;\n  }\n\n  newListOfShoppingLists(shoppingLists) {\n    let listOfShoppingLists = new List(shoppingLists);\n    this._guardListOfShoppingLists(listOfShoppingLists);\n    return listOfShoppingLists;\n  }\n\n  newShoppingListItem(values, shoppingList) {\n    let shoppingListItem = new this._ShoppingListItem(values);\n    if (shoppingListItem._id === undefined) {\n      shoppingListItem = shoppingListItem.set(\"_id\", \"item:\" + cuid());\n    }\n    if (shoppingListItem.list === undefined && shoppingList) {\n      shoppingListItem = shoppingListItem.set(\"list\", shoppingList._id);\n    }\n    return shoppingListItem;\n  }\n\n  newListOfShoppingListItems(shoppingListItems) {\n    let listOfShoppingListItems = new List(shoppingListItems);\n    this._guardListOfShoppingListItems(listOfShoppingListItems);\n    return listOfShoppingListItems;\n  }\n\n}\n\nexports.ShoppingListFactory = ShoppingListFactory;\n\n\n\n// WEBPACK FOOTER //\n// ../~/ibm-shopping-list-model/src/ShoppingListFactory.js","import { btoa, readAsArrayBuffer } from 'pouchdb-binary-utils';\nimport Md5 from 'spark-md5';\n\nvar setImmediateShim = global.setImmediate || global.setTimeout;\nvar MD5_CHUNK_SIZE = 32768;\n\nfunction rawToBase64(raw) {\n  return btoa(raw);\n}\n\nfunction sliceBlob(blob, start, end) {\n  if (blob.webkitSlice) {\n    return blob.webkitSlice(start, end);\n  }\n  return blob.slice(start, end);\n}\n\nfunction appendBlob(buffer, blob, start, end, callback) {\n  if (start > 0 || end < blob.size) {\n    // only slice blob if we really need to\n    blob = sliceBlob(blob, start, end);\n  }\n  readAsArrayBuffer(blob, function (arrayBuffer) {\n    buffer.append(arrayBuffer);\n    callback();\n  });\n}\n\nfunction appendString(buffer, string, start, end, callback) {\n  if (start > 0 || end < string.length) {\n    // only create a substring if we really need to\n    string = string.substring(start, end);\n  }\n  buffer.appendBinary(string);\n  callback();\n}\n\nfunction binaryMd5(data, callback) {\n  var inputIsString = typeof data === 'string';\n  var len = inputIsString ? data.length : data.size;\n  var chunkSize = Math.min(MD5_CHUNK_SIZE, len);\n  var chunks = Math.ceil(len / chunkSize);\n  var currentChunk = 0;\n  var buffer = inputIsString ? new Md5() : new Md5.ArrayBuffer();\n\n  var append = inputIsString ? appendString : appendBlob;\n\n  function next() {\n    setImmediateShim(loadNextChunk);\n  }\n\n  function done() {\n    var raw = buffer.end(true);\n    var base64 = rawToBase64(raw);\n    callback(base64);\n    buffer.destroy();\n  }\n\n  function loadNextChunk() {\n    var start = currentChunk * chunkSize;\n    var end = start + chunkSize;\n    currentChunk++;\n    if (currentChunk < chunks) {\n      append(buffer, data, start, end, next);\n    } else {\n      append(buffer, data, start, end, done);\n    }\n  }\n  loadNextChunk();\n}\n\nfunction stringMd5(string) {\n  return Md5.hash(string);\n}\n\nexport { binaryMd5, stringMd5 };\n\n\n\n// WEBPACK FOOTER //\n// ../~/pouchdb-md5/lib/index-browser.es.js","/**\n *  Copyright (c) 2014-2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.Immutable = factory());\n}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;\n\n  function createClass(ctor, superClass) {\n    if (superClass) {\n      ctor.prototype = Object.create(superClass.prototype);\n    }\n    ctor.prototype.constructor = ctor;\n  }\n\n  function Iterable(value) {\n      return isIterable(value) ? value : Seq(value);\n    }\n\n\n  createClass(KeyedIterable, Iterable);\n    function KeyedIterable(value) {\n      return isKeyed(value) ? value : KeyedSeq(value);\n    }\n\n\n  createClass(IndexedIterable, Iterable);\n    function IndexedIterable(value) {\n      return isIndexed(value) ? value : IndexedSeq(value);\n    }\n\n\n  createClass(SetIterable, Iterable);\n    function SetIterable(value) {\n      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);\n    }\n\n\n\n  function isIterable(maybeIterable) {\n    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);\n  }\n\n  function isKeyed(maybeKeyed) {\n    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);\n  }\n\n  function isIndexed(maybeIndexed) {\n    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);\n  }\n\n  function isAssociative(maybeAssociative) {\n    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);\n  }\n\n  function isOrdered(maybeOrdered) {\n    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);\n  }\n\n  Iterable.isIterable = isIterable;\n  Iterable.isKeyed = isKeyed;\n  Iterable.isIndexed = isIndexed;\n  Iterable.isAssociative = isAssociative;\n  Iterable.isOrdered = isOrdered;\n\n  Iterable.Keyed = KeyedIterable;\n  Iterable.Indexed = IndexedIterable;\n  Iterable.Set = SetIterable;\n\n\n  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\n  // Used for setting prototype methods that IE8 chokes on.\n  var DELETE = 'delete';\n\n  // Constants describing the size of trie nodes.\n  var SHIFT = 5; // Resulted in best performance after ______?\n  var SIZE = 1 << SHIFT;\n  var MASK = SIZE - 1;\n\n  // A consistent shared value representing \"not set\" which equals nothing other\n  // than itself, and nothing that could be provided externally.\n  var NOT_SET = {};\n\n  // Boolean references, Rough equivalent of `bool &`.\n  var CHANGE_LENGTH = { value: false };\n  var DID_ALTER = { value: false };\n\n  function MakeRef(ref) {\n    ref.value = false;\n    return ref;\n  }\n\n  function SetRef(ref) {\n    ref && (ref.value = true);\n  }\n\n  // A function which returns a value representing an \"owner\" for transient writes\n  // to tries. The return value will only ever equal itself, and will not equal\n  // the return of any subsequent call of this function.\n  function OwnerID() {}\n\n  // http://jsperf.com/copy-array-inline\n  function arrCopy(arr, offset) {\n    offset = offset || 0;\n    var len = Math.max(0, arr.length - offset);\n    var newArr = new Array(len);\n    for (var ii = 0; ii < len; ii++) {\n      newArr[ii] = arr[ii + offset];\n    }\n    return newArr;\n  }\n\n  function ensureSize(iter) {\n    if (iter.size === undefined) {\n      iter.size = iter.__iterate(returnTrue);\n    }\n    return iter.size;\n  }\n\n  function wrapIndex(iter, index) {\n    // This implements \"is array index\" which the ECMAString spec defines as:\n    //\n    //     A String property name P is an array index if and only if\n    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal\n    //     to 2^32−1.\n    //\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects\n    if (typeof index !== 'number') {\n      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32\n      if ('' + uint32Index !== index || uint32Index === 4294967295) {\n        return NaN;\n      }\n      index = uint32Index;\n    }\n    return index < 0 ? ensureSize(iter) + index : index;\n  }\n\n  function returnTrue() {\n    return true;\n  }\n\n  function wholeSlice(begin, end, size) {\n    return (begin === 0 || (size !== undefined && begin <= -size)) &&\n      (end === undefined || (size !== undefined && end >= size));\n  }\n\n  function resolveBegin(begin, size) {\n    return resolveIndex(begin, size, 0);\n  }\n\n  function resolveEnd(end, size) {\n    return resolveIndex(end, size, size);\n  }\n\n  function resolveIndex(index, size, defaultIndex) {\n    return index === undefined ?\n      defaultIndex :\n      index < 0 ?\n        Math.max(0, size + index) :\n        size === undefined ?\n          index :\n          Math.min(size, index);\n  }\n\n  /* global Symbol */\n\n  var ITERATE_KEYS = 0;\n  var ITERATE_VALUES = 1;\n  var ITERATE_ENTRIES = 2;\n\n  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator';\n\n  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;\n\n\n  function Iterator(next) {\n      this.next = next;\n    }\n\n    Iterator.prototype.toString = function() {\n      return '[Iterator]';\n    };\n\n\n  Iterator.KEYS = ITERATE_KEYS;\n  Iterator.VALUES = ITERATE_VALUES;\n  Iterator.ENTRIES = ITERATE_ENTRIES;\n\n  Iterator.prototype.inspect =\n  Iterator.prototype.toSource = function () { return this.toString(); }\n  Iterator.prototype[ITERATOR_SYMBOL] = function () {\n    return this;\n  };\n\n\n  function iteratorValue(type, k, v, iteratorResult) {\n    var value = type === 0 ? k : type === 1 ? v : [k, v];\n    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {\n      value: value, done: false\n    });\n    return iteratorResult;\n  }\n\n  function iteratorDone() {\n    return { value: undefined, done: true };\n  }\n\n  function hasIterator(maybeIterable) {\n    return !!getIteratorFn(maybeIterable);\n  }\n\n  function isIterator(maybeIterator) {\n    return maybeIterator && typeof maybeIterator.next === 'function';\n  }\n\n  function getIterator(iterable) {\n    var iteratorFn = getIteratorFn(iterable);\n    return iteratorFn && iteratorFn.call(iterable);\n  }\n\n  function getIteratorFn(iterable) {\n    var iteratorFn = iterable && (\n      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||\n      iterable[FAUX_ITERATOR_SYMBOL]\n    );\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  function isArrayLike(value) {\n    return value && typeof value.length === 'number';\n  }\n\n  createClass(Seq, Iterable);\n    function Seq(value) {\n      return value === null || value === undefined ? emptySequence() :\n        isIterable(value) ? value.toSeq() : seqFromValue(value);\n    }\n\n    Seq.of = function(/*...values*/) {\n      return Seq(arguments);\n    };\n\n    Seq.prototype.toSeq = function() {\n      return this;\n    };\n\n    Seq.prototype.toString = function() {\n      return this.__toString('Seq {', '}');\n    };\n\n    Seq.prototype.cacheResult = function() {\n      if (!this._cache && this.__iterateUncached) {\n        this._cache = this.entrySeq().toArray();\n        this.size = this._cache.length;\n      }\n      return this;\n    };\n\n    // abstract __iterateUncached(fn, reverse)\n\n    Seq.prototype.__iterate = function(fn, reverse) {\n      return seqIterate(this, fn, reverse, true);\n    };\n\n    // abstract __iteratorUncached(type, reverse)\n\n    Seq.prototype.__iterator = function(type, reverse) {\n      return seqIterator(this, type, reverse, true);\n    };\n\n\n\n  createClass(KeyedSeq, Seq);\n    function KeyedSeq(value) {\n      return value === null || value === undefined ?\n        emptySequence().toKeyedSeq() :\n        isIterable(value) ?\n          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :\n          keyedSeqFromValue(value);\n    }\n\n    KeyedSeq.prototype.toKeyedSeq = function() {\n      return this;\n    };\n\n\n\n  createClass(IndexedSeq, Seq);\n    function IndexedSeq(value) {\n      return value === null || value === undefined ? emptySequence() :\n        !isIterable(value) ? indexedSeqFromValue(value) :\n        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();\n    }\n\n    IndexedSeq.of = function(/*...values*/) {\n      return IndexedSeq(arguments);\n    };\n\n    IndexedSeq.prototype.toIndexedSeq = function() {\n      return this;\n    };\n\n    IndexedSeq.prototype.toString = function() {\n      return this.__toString('Seq [', ']');\n    };\n\n    IndexedSeq.prototype.__iterate = function(fn, reverse) {\n      return seqIterate(this, fn, reverse, false);\n    };\n\n    IndexedSeq.prototype.__iterator = function(type, reverse) {\n      return seqIterator(this, type, reverse, false);\n    };\n\n\n\n  createClass(SetSeq, Seq);\n    function SetSeq(value) {\n      return (\n        value === null || value === undefined ? emptySequence() :\n        !isIterable(value) ? indexedSeqFromValue(value) :\n        isKeyed(value) ? value.entrySeq() : value\n      ).toSetSeq();\n    }\n\n    SetSeq.of = function(/*...values*/) {\n      return SetSeq(arguments);\n    };\n\n    SetSeq.prototype.toSetSeq = function() {\n      return this;\n    };\n\n\n\n  Seq.isSeq = isSeq;\n  Seq.Keyed = KeyedSeq;\n  Seq.Set = SetSeq;\n  Seq.Indexed = IndexedSeq;\n\n  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';\n\n  Seq.prototype[IS_SEQ_SENTINEL] = true;\n\n\n\n  createClass(ArraySeq, IndexedSeq);\n    function ArraySeq(array) {\n      this._array = array;\n      this.size = array.length;\n    }\n\n    ArraySeq.prototype.get = function(index, notSetValue) {\n      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;\n    };\n\n    ArraySeq.prototype.__iterate = function(fn, reverse) {\n      var array = this._array;\n      var maxIndex = array.length - 1;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    };\n\n    ArraySeq.prototype.__iterator = function(type, reverse) {\n      var array = this._array;\n      var maxIndex = array.length - 1;\n      var ii = 0;\n      return new Iterator(function() \n        {return ii > maxIndex ?\n          iteratorDone() :\n          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}\n      );\n    };\n\n\n\n  createClass(ObjectSeq, KeyedSeq);\n    function ObjectSeq(object) {\n      var keys = Object.keys(object);\n      this._object = object;\n      this._keys = keys;\n      this.size = keys.length;\n    }\n\n    ObjectSeq.prototype.get = function(key, notSetValue) {\n      if (notSetValue !== undefined && !this.has(key)) {\n        return notSetValue;\n      }\n      return this._object[key];\n    };\n\n    ObjectSeq.prototype.has = function(key) {\n      return this._object.hasOwnProperty(key);\n    };\n\n    ObjectSeq.prototype.__iterate = function(fn, reverse) {\n      var object = this._object;\n      var keys = this._keys;\n      var maxIndex = keys.length - 1;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        var key = keys[reverse ? maxIndex - ii : ii];\n        if (fn(object[key], key, this) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    };\n\n    ObjectSeq.prototype.__iterator = function(type, reverse) {\n      var object = this._object;\n      var keys = this._keys;\n      var maxIndex = keys.length - 1;\n      var ii = 0;\n      return new Iterator(function()  {\n        var key = keys[reverse ? maxIndex - ii : ii];\n        return ii++ > maxIndex ?\n          iteratorDone() :\n          iteratorValue(type, key, object[key]);\n      });\n    };\n\n  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;\n\n\n  createClass(IterableSeq, IndexedSeq);\n    function IterableSeq(iterable) {\n      this._iterable = iterable;\n      this.size = iterable.length || iterable.size;\n    }\n\n    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterable = this._iterable;\n      var iterator = getIterator(iterable);\n      var iterations = 0;\n      if (isIterator(iterator)) {\n        var step;\n        while (!(step = iterator.next()).done) {\n          if (fn(step.value, iterations++, this) === false) {\n            break;\n          }\n        }\n      }\n      return iterations;\n    };\n\n    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterable = this._iterable;\n      var iterator = getIterator(iterable);\n      if (!isIterator(iterator)) {\n        return new Iterator(iteratorDone);\n      }\n      var iterations = 0;\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step : iteratorValue(type, iterations++, step.value);\n      });\n    };\n\n\n\n  createClass(IteratorSeq, IndexedSeq);\n    function IteratorSeq(iterator) {\n      this._iterator = iterator;\n      this._iteratorCache = [];\n    }\n\n    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterator = this._iterator;\n      var cache = this._iteratorCache;\n      var iterations = 0;\n      while (iterations < cache.length) {\n        if (fn(cache[iterations], iterations++, this) === false) {\n          return iterations;\n        }\n      }\n      var step;\n      while (!(step = iterator.next()).done) {\n        var val = step.value;\n        cache[iterations] = val;\n        if (fn(val, iterations++, this) === false) {\n          break;\n        }\n      }\n      return iterations;\n    };\n\n    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = this._iterator;\n      var cache = this._iteratorCache;\n      var iterations = 0;\n      return new Iterator(function()  {\n        if (iterations >= cache.length) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          cache[iterations] = step.value;\n        }\n        return iteratorValue(type, iterations, cache[iterations++]);\n      });\n    };\n\n\n\n\n  // # pragma Helper functions\n\n  function isSeq(maybeSeq) {\n    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);\n  }\n\n  var EMPTY_SEQ;\n\n  function emptySequence() {\n    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));\n  }\n\n  function keyedSeqFromValue(value) {\n    var seq =\n      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :\n      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :\n      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :\n      typeof value === 'object' ? new ObjectSeq(value) :\n      undefined;\n    if (!seq) {\n      throw new TypeError(\n        'Expected Array or iterable object of [k, v] entries, '+\n        'or keyed object: ' + value\n      );\n    }\n    return seq;\n  }\n\n  function indexedSeqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value);\n    if (!seq) {\n      throw new TypeError(\n        'Expected Array or iterable object of values: ' + value\n      );\n    }\n    return seq;\n  }\n\n  function seqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value) ||\n      (typeof value === 'object' && new ObjectSeq(value));\n    if (!seq) {\n      throw new TypeError(\n        'Expected Array or iterable object of values, or keyed object: ' + value\n      );\n    }\n    return seq;\n  }\n\n  function maybeIndexedSeqFromValue(value) {\n    return (\n      isArrayLike(value) ? new ArraySeq(value) :\n      isIterator(value) ? new IteratorSeq(value) :\n      hasIterator(value) ? new IterableSeq(value) :\n      undefined\n    );\n  }\n\n  function seqIterate(seq, fn, reverse, useKeys) {\n    var cache = seq._cache;\n    if (cache) {\n      var maxIndex = cache.length - 1;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        var entry = cache[reverse ? maxIndex - ii : ii];\n        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    }\n    return seq.__iterateUncached(fn, reverse);\n  }\n\n  function seqIterator(seq, type, reverse, useKeys) {\n    var cache = seq._cache;\n    if (cache) {\n      var maxIndex = cache.length - 1;\n      var ii = 0;\n      return new Iterator(function()  {\n        var entry = cache[reverse ? maxIndex - ii : ii];\n        return ii++ > maxIndex ?\n          iteratorDone() :\n          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);\n      });\n    }\n    return seq.__iteratorUncached(type, reverse);\n  }\n\n  function fromJS(json, converter) {\n    return converter ?\n      fromJSWith(converter, json, '', {'': json}) :\n      fromJSDefault(json);\n  }\n\n  function fromJSWith(converter, json, key, parentJSON) {\n    if (Array.isArray(json)) {\n      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));\n    }\n    if (isPlainObj(json)) {\n      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));\n    }\n    return json;\n  }\n\n  function fromJSDefault(json) {\n    if (Array.isArray(json)) {\n      return IndexedSeq(json).map(fromJSDefault).toList();\n    }\n    if (isPlainObj(json)) {\n      return KeyedSeq(json).map(fromJSDefault).toMap();\n    }\n    return json;\n  }\n\n  function isPlainObj(value) {\n    return value && (value.constructor === Object || value.constructor === undefined);\n  }\n\n  /**\n   * An extension of the \"same-value\" algorithm as [described for use by ES6 Map\n   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)\n   *\n   * NaN is considered the same as NaN, however -0 and 0 are considered the same\n   * value, which is different from the algorithm described by\n   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n   *\n   * This is extended further to allow Objects to describe the values they\n   * represent, by way of `valueOf` or `equals` (and `hashCode`).\n   *\n   * Note: because of this extension, the key equality of Immutable.Map and the\n   * value equality of Immutable.Set will differ from ES6 Map and Set.\n   *\n   * ### Defining custom values\n   *\n   * The easiest way to describe the value an object represents is by implementing\n   * `valueOf`. For example, `Date` represents a value by returning a unix\n   * timestamp for `valueOf`:\n   *\n   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...\n   *     var date2 = new Date(1234567890000);\n   *     date1.valueOf(); // 1234567890000\n   *     assert( date1 !== date2 );\n   *     assert( Immutable.is( date1, date2 ) );\n   *\n   * Note: overriding `valueOf` may have other implications if you use this object\n   * where JavaScript expects a primitive, such as implicit string coercion.\n   *\n   * For more complex types, especially collections, implementing `valueOf` may\n   * not be performant. An alternative is to implement `equals` and `hashCode`.\n   *\n   * `equals` takes another object, presumably of similar type, and returns true\n   * if the it is equal. Equality is symmetrical, so the same result should be\n   * returned if this and the argument are flipped.\n   *\n   *     assert( a.equals(b) === b.equals(a) );\n   *\n   * `hashCode` returns a 32bit integer number representing the object which will\n   * be used to determine how to store the value object in a Map or Set. You must\n   * provide both or neither methods, one must not exist without the other.\n   *\n   * Also, an important relationship between these methods must be upheld: if two\n   * values are equal, they *must* return the same hashCode. If the values are not\n   * equal, they might have the same hashCode; this is called a hash collision,\n   * and while undesirable for performance reasons, it is acceptable.\n   *\n   *     if (a.equals(b)) {\n   *       assert( a.hashCode() === b.hashCode() );\n   *     }\n   *\n   * All Immutable collections implement `equals` and `hashCode`.\n   *\n   */\n  function is(valueA, valueB) {\n    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n      return true;\n    }\n    if (!valueA || !valueB) {\n      return false;\n    }\n    if (typeof valueA.valueOf === 'function' &&\n        typeof valueB.valueOf === 'function') {\n      valueA = valueA.valueOf();\n      valueB = valueB.valueOf();\n      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n        return true;\n      }\n      if (!valueA || !valueB) {\n        return false;\n      }\n    }\n    if (typeof valueA.equals === 'function' &&\n        typeof valueB.equals === 'function' &&\n        valueA.equals(valueB)) {\n      return true;\n    }\n    return false;\n  }\n\n  function deepEqual(a, b) {\n    if (a === b) {\n      return true;\n    }\n\n    if (\n      !isIterable(b) ||\n      a.size !== undefined && b.size !== undefined && a.size !== b.size ||\n      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||\n      isKeyed(a) !== isKeyed(b) ||\n      isIndexed(a) !== isIndexed(b) ||\n      isOrdered(a) !== isOrdered(b)\n    ) {\n      return false;\n    }\n\n    if (a.size === 0 && b.size === 0) {\n      return true;\n    }\n\n    var notAssociative = !isAssociative(a);\n\n    if (isOrdered(a)) {\n      var entries = a.entries();\n      return b.every(function(v, k)  {\n        var entry = entries.next().value;\n        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));\n      }) && entries.next().done;\n    }\n\n    var flipped = false;\n\n    if (a.size === undefined) {\n      if (b.size === undefined) {\n        if (typeof a.cacheResult === 'function') {\n          a.cacheResult();\n        }\n      } else {\n        flipped = true;\n        var _ = a;\n        a = b;\n        b = _;\n      }\n    }\n\n    var allEqual = true;\n    var bSize = b.__iterate(function(v, k)  {\n      if (notAssociative ? !a.has(v) :\n          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {\n        allEqual = false;\n        return false;\n      }\n    });\n\n    return allEqual && a.size === bSize;\n  }\n\n  createClass(Repeat, IndexedSeq);\n\n    function Repeat(value, times) {\n      if (!(this instanceof Repeat)) {\n        return new Repeat(value, times);\n      }\n      this._value = value;\n      this.size = times === undefined ? Infinity : Math.max(0, times);\n      if (this.size === 0) {\n        if (EMPTY_REPEAT) {\n          return EMPTY_REPEAT;\n        }\n        EMPTY_REPEAT = this;\n      }\n    }\n\n    Repeat.prototype.toString = function() {\n      if (this.size === 0) {\n        return 'Repeat []';\n      }\n      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';\n    };\n\n    Repeat.prototype.get = function(index, notSetValue) {\n      return this.has(index) ? this._value : notSetValue;\n    };\n\n    Repeat.prototype.includes = function(searchValue) {\n      return is(this._value, searchValue);\n    };\n\n    Repeat.prototype.slice = function(begin, end) {\n      var size = this.size;\n      return wholeSlice(begin, end, size) ? this :\n        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));\n    };\n\n    Repeat.prototype.reverse = function() {\n      return this;\n    };\n\n    Repeat.prototype.indexOf = function(searchValue) {\n      if (is(this._value, searchValue)) {\n        return 0;\n      }\n      return -1;\n    };\n\n    Repeat.prototype.lastIndexOf = function(searchValue) {\n      if (is(this._value, searchValue)) {\n        return this.size;\n      }\n      return -1;\n    };\n\n    Repeat.prototype.__iterate = function(fn, reverse) {\n      for (var ii = 0; ii < this.size; ii++) {\n        if (fn(this._value, ii, this) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    };\n\n    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;\n      var ii = 0;\n      return new Iterator(function() \n        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}\n      );\n    };\n\n    Repeat.prototype.equals = function(other) {\n      return other instanceof Repeat ?\n        is(this._value, other._value) :\n        deepEqual(other);\n    };\n\n\n  var EMPTY_REPEAT;\n\n  function invariant(condition, error) {\n    if (!condition) throw new Error(error);\n  }\n\n  createClass(Range, IndexedSeq);\n\n    function Range(start, end, step) {\n      if (!(this instanceof Range)) {\n        return new Range(start, end, step);\n      }\n      invariant(step !== 0, 'Cannot step a Range by 0');\n      start = start || 0;\n      if (end === undefined) {\n        end = Infinity;\n      }\n      step = step === undefined ? 1 : Math.abs(step);\n      if (end < start) {\n        step = -step;\n      }\n      this._start = start;\n      this._end = end;\n      this._step = step;\n      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);\n      if (this.size === 0) {\n        if (EMPTY_RANGE) {\n          return EMPTY_RANGE;\n        }\n        EMPTY_RANGE = this;\n      }\n    }\n\n    Range.prototype.toString = function() {\n      if (this.size === 0) {\n        return 'Range []';\n      }\n      return 'Range [ ' +\n        this._start + '...' + this._end +\n        (this._step !== 1 ? ' by ' + this._step : '') +\n      ' ]';\n    };\n\n    Range.prototype.get = function(index, notSetValue) {\n      return this.has(index) ?\n        this._start + wrapIndex(this, index) * this._step :\n        notSetValue;\n    };\n\n    Range.prototype.includes = function(searchValue) {\n      var possibleIndex = (searchValue - this._start) / this._step;\n      return possibleIndex >= 0 &&\n        possibleIndex < this.size &&\n        possibleIndex === Math.floor(possibleIndex);\n    };\n\n    Range.prototype.slice = function(begin, end) {\n      if (wholeSlice(begin, end, this.size)) {\n        return this;\n      }\n      begin = resolveBegin(begin, this.size);\n      end = resolveEnd(end, this.size);\n      if (end <= begin) {\n        return new Range(0, 0);\n      }\n      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);\n    };\n\n    Range.prototype.indexOf = function(searchValue) {\n      var offsetValue = searchValue - this._start;\n      if (offsetValue % this._step === 0) {\n        var index = offsetValue / this._step;\n        if (index >= 0 && index < this.size) {\n          return index\n        }\n      }\n      return -1;\n    };\n\n    Range.prototype.lastIndexOf = function(searchValue) {\n      return this.indexOf(searchValue);\n    };\n\n    Range.prototype.__iterate = function(fn, reverse) {\n      var maxIndex = this.size - 1;\n      var step = this._step;\n      var value = reverse ? this._start + maxIndex * step : this._start;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        if (fn(value, ii, this) === false) {\n          return ii + 1;\n        }\n        value += reverse ? -step : step;\n      }\n      return ii;\n    };\n\n    Range.prototype.__iterator = function(type, reverse) {\n      var maxIndex = this.size - 1;\n      var step = this._step;\n      var value = reverse ? this._start + maxIndex * step : this._start;\n      var ii = 0;\n      return new Iterator(function()  {\n        var v = value;\n        value += reverse ? -step : step;\n        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);\n      });\n    };\n\n    Range.prototype.equals = function(other) {\n      return other instanceof Range ?\n        this._start === other._start &&\n        this._end === other._end &&\n        this._step === other._step :\n        deepEqual(this, other);\n    };\n\n\n  var EMPTY_RANGE;\n\n  createClass(Collection, Iterable);\n    function Collection() {\n      throw TypeError('Abstract');\n    }\n\n\n  createClass(KeyedCollection, Collection);function KeyedCollection() {}\n\n  createClass(IndexedCollection, Collection);function IndexedCollection() {}\n\n  createClass(SetCollection, Collection);function SetCollection() {}\n\n\n  Collection.Keyed = KeyedCollection;\n  Collection.Indexed = IndexedCollection;\n  Collection.Set = SetCollection;\n\n  var imul =\n    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?\n    Math.imul :\n    function imul(a, b) {\n      a = a | 0; // int\n      b = b | 0; // int\n      var c = a & 0xffff;\n      var d = b & 0xffff;\n      // Shift by 0 fixes the sign on the high part.\n      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int\n    };\n\n  // v8 has an optimization for storing 31-bit signed numbers.\n  // Values which have either 00 or 11 as the high order bits qualify.\n  // This function drops the highest order bit in a signed number, maintaining\n  // the sign bit.\n  function smi(i32) {\n    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);\n  }\n\n  function hash(o) {\n    if (o === false || o === null || o === undefined) {\n      return 0;\n    }\n    if (typeof o.valueOf === 'function') {\n      o = o.valueOf();\n      if (o === false || o === null || o === undefined) {\n        return 0;\n      }\n    }\n    if (o === true) {\n      return 1;\n    }\n    var type = typeof o;\n    if (type === 'number') {\n      if (o !== o || o === Infinity) {\n        return 0;\n      }\n      var h = o | 0;\n      if (h !== o) {\n        h ^= o * 0xFFFFFFFF;\n      }\n      while (o > 0xFFFFFFFF) {\n        o /= 0xFFFFFFFF;\n        h ^= o;\n      }\n      return smi(h);\n    }\n    if (type === 'string') {\n      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);\n    }\n    if (typeof o.hashCode === 'function') {\n      return o.hashCode();\n    }\n    if (type === 'object') {\n      return hashJSObj(o);\n    }\n    if (typeof o.toString === 'function') {\n      return hashString(o.toString());\n    }\n    throw new Error('Value type ' + type + ' cannot be hashed.');\n  }\n\n  function cachedHashString(string) {\n    var hash = stringHashCache[string];\n    if (hash === undefined) {\n      hash = hashString(string);\n      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {\n        STRING_HASH_CACHE_SIZE = 0;\n        stringHashCache = {};\n      }\n      STRING_HASH_CACHE_SIZE++;\n      stringHashCache[string] = hash;\n    }\n    return hash;\n  }\n\n  // http://jsperf.com/hashing-strings\n  function hashString(string) {\n    // This is the hash from JVM\n    // The hash code for a string is computed as\n    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\n    // where s[i] is the ith character of the string and n is the length of\n    // the string. We \"mod\" the result to make it between 0 (inclusive) and 2^31\n    // (exclusive) by dropping high bits.\n    var hash = 0;\n    for (var ii = 0; ii < string.length; ii++) {\n      hash = 31 * hash + string.charCodeAt(ii) | 0;\n    }\n    return smi(hash);\n  }\n\n  function hashJSObj(obj) {\n    var hash;\n    if (usingWeakMap) {\n      hash = weakMap.get(obj);\n      if (hash !== undefined) {\n        return hash;\n      }\n    }\n\n    hash = obj[UID_HASH_KEY];\n    if (hash !== undefined) {\n      return hash;\n    }\n\n    if (!canDefineProperty) {\n      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];\n      if (hash !== undefined) {\n        return hash;\n      }\n\n      hash = getIENodeHash(obj);\n      if (hash !== undefined) {\n        return hash;\n      }\n    }\n\n    hash = ++objHashUID;\n    if (objHashUID & 0x40000000) {\n      objHashUID = 0;\n    }\n\n    if (usingWeakMap) {\n      weakMap.set(obj, hash);\n    } else if (isExtensible !== undefined && isExtensible(obj) === false) {\n      throw new Error('Non-extensible objects are not allowed as keys.');\n    } else if (canDefineProperty) {\n      Object.defineProperty(obj, UID_HASH_KEY, {\n        'enumerable': false,\n        'configurable': false,\n        'writable': false,\n        'value': hash\n      });\n    } else if (obj.propertyIsEnumerable !== undefined &&\n               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {\n      // Since we can't define a non-enumerable property on the object\n      // we'll hijack one of the less-used non-enumerable properties to\n      // save our hash on it. Since this is a function it will not show up in\n      // `JSON.stringify` which is what we want.\n      obj.propertyIsEnumerable = function() {\n        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);\n      };\n      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;\n    } else if (obj.nodeType !== undefined) {\n      // At this point we couldn't get the IE `uniqueID` to use as a hash\n      // and we couldn't use a non-enumerable property to exploit the\n      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node\n      // itself.\n      obj[UID_HASH_KEY] = hash;\n    } else {\n      throw new Error('Unable to set a non-enumerable property on object.');\n    }\n\n    return hash;\n  }\n\n  // Get references to ES5 object methods.\n  var isExtensible = Object.isExtensible;\n\n  // True if Object.defineProperty works as expected. IE8 fails this test.\n  var canDefineProperty = (function() {\n    try {\n      Object.defineProperty({}, '@', {});\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }());\n\n  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it\n  // and avoid memory leaks from the IE cloneNode bug.\n  function getIENodeHash(node) {\n    if (node && node.nodeType > 0) {\n      switch (node.nodeType) {\n        case 1: // Element\n          return node.uniqueID;\n        case 9: // Document\n          return node.documentElement && node.documentElement.uniqueID;\n      }\n    }\n  }\n\n  // If possible, use a WeakMap.\n  var usingWeakMap = typeof WeakMap === 'function';\n  var weakMap;\n  if (usingWeakMap) {\n    weakMap = new WeakMap();\n  }\n\n  var objHashUID = 0;\n\n  var UID_HASH_KEY = '__immutablehash__';\n  if (typeof Symbol === 'function') {\n    UID_HASH_KEY = Symbol(UID_HASH_KEY);\n  }\n\n  var STRING_HASH_CACHE_MIN_STRLEN = 16;\n  var STRING_HASH_CACHE_MAX_SIZE = 255;\n  var STRING_HASH_CACHE_SIZE = 0;\n  var stringHashCache = {};\n\n  function assertNotInfinite(size) {\n    invariant(\n      size !== Infinity,\n      'Cannot perform this action with an infinite size.'\n    );\n  }\n\n  createClass(Map, KeyedCollection);\n\n    // @pragma Construction\n\n    function Map(value) {\n      return value === null || value === undefined ? emptyMap() :\n        isMap(value) && !isOrdered(value) ? value :\n        emptyMap().withMutations(function(map ) {\n          var iter = KeyedIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v, k)  {return map.set(k, v)});\n        });\n    }\n\n    Map.of = function() {var keyValues = SLICE$0.call(arguments, 0);\n      return emptyMap().withMutations(function(map ) {\n        for (var i = 0; i < keyValues.length; i += 2) {\n          if (i + 1 >= keyValues.length) {\n            throw new Error('Missing value for key: ' + keyValues[i]);\n          }\n          map.set(keyValues[i], keyValues[i + 1]);\n        }\n      });\n    };\n\n    Map.prototype.toString = function() {\n      return this.__toString('Map {', '}');\n    };\n\n    // @pragma Access\n\n    Map.prototype.get = function(k, notSetValue) {\n      return this._root ?\n        this._root.get(0, undefined, k, notSetValue) :\n        notSetValue;\n    };\n\n    // @pragma Modification\n\n    Map.prototype.set = function(k, v) {\n      return updateMap(this, k, v);\n    };\n\n    Map.prototype.setIn = function(keyPath, v) {\n      return this.updateIn(keyPath, NOT_SET, function()  {return v});\n    };\n\n    Map.prototype.remove = function(k) {\n      return updateMap(this, k, NOT_SET);\n    };\n\n    Map.prototype.deleteIn = function(keyPath) {\n      return this.updateIn(keyPath, function()  {return NOT_SET});\n    };\n\n    Map.prototype.update = function(k, notSetValue, updater) {\n      return arguments.length === 1 ?\n        k(this) :\n        this.updateIn([k], notSetValue, updater);\n    };\n\n    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {\n      if (!updater) {\n        updater = notSetValue;\n        notSetValue = undefined;\n      }\n      var updatedValue = updateInDeepMap(\n        this,\n        forceIterator(keyPath),\n        notSetValue,\n        updater\n      );\n      return updatedValue === NOT_SET ? undefined : updatedValue;\n    };\n\n    Map.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._root = null;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyMap();\n    };\n\n    // @pragma Composition\n\n    Map.prototype.merge = function(/*...iters*/) {\n      return mergeIntoMapWith(this, undefined, arguments);\n    };\n\n    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoMapWith(this, merger, iters);\n    };\n\n    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);\n      return this.updateIn(\n        keyPath,\n        emptyMap(),\n        function(m ) {return typeof m.merge === 'function' ?\n          m.merge.apply(m, iters) :\n          iters[iters.length - 1]}\n      );\n    };\n\n    Map.prototype.mergeDeep = function(/*...iters*/) {\n      return mergeIntoMapWith(this, deepMerger, arguments);\n    };\n\n    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoMapWith(this, deepMergerWith(merger), iters);\n    };\n\n    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);\n      return this.updateIn(\n        keyPath,\n        emptyMap(),\n        function(m ) {return typeof m.mergeDeep === 'function' ?\n          m.mergeDeep.apply(m, iters) :\n          iters[iters.length - 1]}\n      );\n    };\n\n    Map.prototype.sort = function(comparator) {\n      // Late binding\n      return OrderedMap(sortFactory(this, comparator));\n    };\n\n    Map.prototype.sortBy = function(mapper, comparator) {\n      // Late binding\n      return OrderedMap(sortFactory(this, comparator, mapper));\n    };\n\n    // @pragma Mutability\n\n    Map.prototype.withMutations = function(fn) {\n      var mutable = this.asMutable();\n      fn(mutable);\n      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;\n    };\n\n    Map.prototype.asMutable = function() {\n      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());\n    };\n\n    Map.prototype.asImmutable = function() {\n      return this.__ensureOwner();\n    };\n\n    Map.prototype.wasAltered = function() {\n      return this.__altered;\n    };\n\n    Map.prototype.__iterator = function(type, reverse) {\n      return new MapIterator(this, type, reverse);\n    };\n\n    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      this._root && this._root.iterate(function(entry ) {\n        iterations++;\n        return fn(entry[1], entry[0], this$0);\n      }, reverse);\n      return iterations;\n    };\n\n    Map.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeMap(this.size, this._root, ownerID, this.__hash);\n    };\n\n\n  function isMap(maybeMap) {\n    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);\n  }\n\n  Map.isMap = isMap;\n\n  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';\n\n  var MapPrototype = Map.prototype;\n  MapPrototype[IS_MAP_SENTINEL] = true;\n  MapPrototype[DELETE] = MapPrototype.remove;\n  MapPrototype.removeIn = MapPrototype.deleteIn;\n\n\n  // #pragma Trie Nodes\n\n\n\n    function ArrayMapNode(ownerID, entries) {\n      this.ownerID = ownerID;\n      this.entries = entries;\n    }\n\n    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      var entries = this.entries;\n      for (var ii = 0, len = entries.length; ii < len; ii++) {\n        if (is(key, entries[ii][0])) {\n          return entries[ii][1];\n        }\n      }\n      return notSetValue;\n    };\n\n    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      var removed = value === NOT_SET;\n\n      var entries = this.entries;\n      var idx = 0;\n      for (var len = entries.length; idx < len; idx++) {\n        if (is(key, entries[idx][0])) {\n          break;\n        }\n      }\n      var exists = idx < len;\n\n      if (exists ? entries[idx][1] === value : removed) {\n        return this;\n      }\n\n      SetRef(didAlter);\n      (removed || !exists) && SetRef(didChangeSize);\n\n      if (removed && entries.length === 1) {\n        return; // undefined\n      }\n\n      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {\n        return createNodes(ownerID, entries, key, value);\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newEntries = isEditable ? entries : arrCopy(entries);\n\n      if (exists) {\n        if (removed) {\n          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());\n        } else {\n          newEntries[idx] = [key, value];\n        }\n      } else {\n        newEntries.push([key, value]);\n      }\n\n      if (isEditable) {\n        this.entries = newEntries;\n        return this;\n      }\n\n      return new ArrayMapNode(ownerID, newEntries);\n    };\n\n\n\n\n    function BitmapIndexedNode(ownerID, bitmap, nodes) {\n      this.ownerID = ownerID;\n      this.bitmap = bitmap;\n      this.nodes = nodes;\n    }\n\n    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));\n      var bitmap = this.bitmap;\n      return (bitmap & bit) === 0 ? notSetValue :\n        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);\n    };\n\n    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var bit = 1 << keyHashFrag;\n      var bitmap = this.bitmap;\n      var exists = (bitmap & bit) !== 0;\n\n      if (!exists && value === NOT_SET) {\n        return this;\n      }\n\n      var idx = popCount(bitmap & (bit - 1));\n      var nodes = this.nodes;\n      var node = exists ? nodes[idx] : undefined;\n      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n\n      if (newNode === node) {\n        return this;\n      }\n\n      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {\n        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);\n      }\n\n      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {\n        return nodes[idx ^ 1];\n      }\n\n      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {\n        return newNode;\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;\n      var newNodes = exists ? newNode ?\n        setIn(nodes, idx, newNode, isEditable) :\n        spliceOut(nodes, idx, isEditable) :\n        spliceIn(nodes, idx, newNode, isEditable);\n\n      if (isEditable) {\n        this.bitmap = newBitmap;\n        this.nodes = newNodes;\n        return this;\n      }\n\n      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);\n    };\n\n\n\n\n    function HashArrayMapNode(ownerID, count, nodes) {\n      this.ownerID = ownerID;\n      this.count = count;\n      this.nodes = nodes;\n    }\n\n    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var node = this.nodes[idx];\n      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;\n    };\n\n    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var removed = value === NOT_SET;\n      var nodes = this.nodes;\n      var node = nodes[idx];\n\n      if (removed && !node) {\n        return this;\n      }\n\n      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n      if (newNode === node) {\n        return this;\n      }\n\n      var newCount = this.count;\n      if (!node) {\n        newCount++;\n      } else if (!newNode) {\n        newCount--;\n        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {\n          return packNodes(ownerID, nodes, newCount, idx);\n        }\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newNodes = setIn(nodes, idx, newNode, isEditable);\n\n      if (isEditable) {\n        this.count = newCount;\n        this.nodes = newNodes;\n        return this;\n      }\n\n      return new HashArrayMapNode(ownerID, newCount, newNodes);\n    };\n\n\n\n\n    function HashCollisionNode(ownerID, keyHash, entries) {\n      this.ownerID = ownerID;\n      this.keyHash = keyHash;\n      this.entries = entries;\n    }\n\n    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      var entries = this.entries;\n      for (var ii = 0, len = entries.length; ii < len; ii++) {\n        if (is(key, entries[ii][0])) {\n          return entries[ii][1];\n        }\n      }\n      return notSetValue;\n    };\n\n    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n\n      var removed = value === NOT_SET;\n\n      if (keyHash !== this.keyHash) {\n        if (removed) {\n          return this;\n        }\n        SetRef(didAlter);\n        SetRef(didChangeSize);\n        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);\n      }\n\n      var entries = this.entries;\n      var idx = 0;\n      for (var len = entries.length; idx < len; idx++) {\n        if (is(key, entries[idx][0])) {\n          break;\n        }\n      }\n      var exists = idx < len;\n\n      if (exists ? entries[idx][1] === value : removed) {\n        return this;\n      }\n\n      SetRef(didAlter);\n      (removed || !exists) && SetRef(didChangeSize);\n\n      if (removed && len === 2) {\n        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newEntries = isEditable ? entries : arrCopy(entries);\n\n      if (exists) {\n        if (removed) {\n          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());\n        } else {\n          newEntries[idx] = [key, value];\n        }\n      } else {\n        newEntries.push([key, value]);\n      }\n\n      if (isEditable) {\n        this.entries = newEntries;\n        return this;\n      }\n\n      return new HashCollisionNode(ownerID, this.keyHash, newEntries);\n    };\n\n\n\n\n    function ValueNode(ownerID, keyHash, entry) {\n      this.ownerID = ownerID;\n      this.keyHash = keyHash;\n      this.entry = entry;\n    }\n\n    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;\n    };\n\n    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      var removed = value === NOT_SET;\n      var keyMatch = is(key, this.entry[0]);\n      if (keyMatch ? value === this.entry[1] : removed) {\n        return this;\n      }\n\n      SetRef(didAlter);\n\n      if (removed) {\n        SetRef(didChangeSize);\n        return; // undefined\n      }\n\n      if (keyMatch) {\n        if (ownerID && ownerID === this.ownerID) {\n          this.entry[1] = value;\n          return this;\n        }\n        return new ValueNode(ownerID, this.keyHash, [key, value]);\n      }\n\n      SetRef(didChangeSize);\n      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);\n    };\n\n\n\n  // #pragma Iterators\n\n  ArrayMapNode.prototype.iterate =\n  HashCollisionNode.prototype.iterate = function (fn, reverse) {\n    var entries = this.entries;\n    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {\n      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {\n        return false;\n      }\n    }\n  }\n\n  BitmapIndexedNode.prototype.iterate =\n  HashArrayMapNode.prototype.iterate = function (fn, reverse) {\n    var nodes = this.nodes;\n    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {\n      var node = nodes[reverse ? maxIndex - ii : ii];\n      if (node && node.iterate(fn, reverse) === false) {\n        return false;\n      }\n    }\n  }\n\n  ValueNode.prototype.iterate = function (fn, reverse) {\n    return fn(this.entry);\n  }\n\n  createClass(MapIterator, Iterator);\n\n    function MapIterator(map, type, reverse) {\n      this._type = type;\n      this._reverse = reverse;\n      this._stack = map._root && mapIteratorFrame(map._root);\n    }\n\n    MapIterator.prototype.next = function() {\n      var type = this._type;\n      var stack = this._stack;\n      while (stack) {\n        var node = stack.node;\n        var index = stack.index++;\n        var maxIndex;\n        if (node.entry) {\n          if (index === 0) {\n            return mapIteratorValue(type, node.entry);\n          }\n        } else if (node.entries) {\n          maxIndex = node.entries.length - 1;\n          if (index <= maxIndex) {\n            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);\n          }\n        } else {\n          maxIndex = node.nodes.length - 1;\n          if (index <= maxIndex) {\n            var subNode = node.nodes[this._reverse ? maxIndex - index : index];\n            if (subNode) {\n              if (subNode.entry) {\n                return mapIteratorValue(type, subNode.entry);\n              }\n              stack = this._stack = mapIteratorFrame(subNode, stack);\n            }\n            continue;\n          }\n        }\n        stack = this._stack = this._stack.__prev;\n      }\n      return iteratorDone();\n    };\n\n\n  function mapIteratorValue(type, entry) {\n    return iteratorValue(type, entry[0], entry[1]);\n  }\n\n  function mapIteratorFrame(node, prev) {\n    return {\n      node: node,\n      index: 0,\n      __prev: prev\n    };\n  }\n\n  function makeMap(size, root, ownerID, hash) {\n    var map = Object.create(MapPrototype);\n    map.size = size;\n    map._root = root;\n    map.__ownerID = ownerID;\n    map.__hash = hash;\n    map.__altered = false;\n    return map;\n  }\n\n  var EMPTY_MAP;\n  function emptyMap() {\n    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));\n  }\n\n  function updateMap(map, k, v) {\n    var newRoot;\n    var newSize;\n    if (!map._root) {\n      if (v === NOT_SET) {\n        return map;\n      }\n      newSize = 1;\n      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);\n    } else {\n      var didChangeSize = MakeRef(CHANGE_LENGTH);\n      var didAlter = MakeRef(DID_ALTER);\n      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);\n      if (!didAlter.value) {\n        return map;\n      }\n      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);\n    }\n    if (map.__ownerID) {\n      map.size = newSize;\n      map._root = newRoot;\n      map.__hash = undefined;\n      map.__altered = true;\n      return map;\n    }\n    return newRoot ? makeMap(newSize, newRoot) : emptyMap();\n  }\n\n  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (!node) {\n      if (value === NOT_SET) {\n        return node;\n      }\n      SetRef(didAlter);\n      SetRef(didChangeSize);\n      return new ValueNode(ownerID, keyHash, [key, value]);\n    }\n    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);\n  }\n\n  function isLeafNode(node) {\n    return node.constructor === ValueNode || node.constructor === HashCollisionNode;\n  }\n\n  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {\n    if (node.keyHash === keyHash) {\n      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);\n    }\n\n    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;\n    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\n    var newNode;\n    var nodes = idx1 === idx2 ?\n      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :\n      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);\n\n    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);\n  }\n\n  function createNodes(ownerID, entries, key, value) {\n    if (!ownerID) {\n      ownerID = new OwnerID();\n    }\n    var node = new ValueNode(ownerID, hash(key), [key, value]);\n    for (var ii = 0; ii < entries.length; ii++) {\n      var entry = entries[ii];\n      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);\n    }\n    return node;\n  }\n\n  function packNodes(ownerID, nodes, count, excluding) {\n    var bitmap = 0;\n    var packedII = 0;\n    var packedNodes = new Array(count);\n    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {\n      var node = nodes[ii];\n      if (node !== undefined && ii !== excluding) {\n        bitmap |= bit;\n        packedNodes[packedII++] = node;\n      }\n    }\n    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);\n  }\n\n  function expandNodes(ownerID, nodes, bitmap, including, node) {\n    var count = 0;\n    var expandedNodes = new Array(SIZE);\n    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {\n      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;\n    }\n    expandedNodes[including] = node;\n    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);\n  }\n\n  function mergeIntoMapWith(map, merger, iterables) {\n    var iters = [];\n    for (var ii = 0; ii < iterables.length; ii++) {\n      var value = iterables[ii];\n      var iter = KeyedIterable(value);\n      if (!isIterable(value)) {\n        iter = iter.map(function(v ) {return fromJS(v)});\n      }\n      iters.push(iter);\n    }\n    return mergeIntoCollectionWith(map, merger, iters);\n  }\n\n  function deepMerger(existing, value, key) {\n    return existing && existing.mergeDeep && isIterable(value) ?\n      existing.mergeDeep(value) :\n      is(existing, value) ? existing : value;\n  }\n\n  function deepMergerWith(merger) {\n    return function(existing, value, key)  {\n      if (existing && existing.mergeDeepWith && isIterable(value)) {\n        return existing.mergeDeepWith(merger, value);\n      }\n      var nextValue = merger(existing, value, key);\n      return is(existing, nextValue) ? existing : nextValue;\n    };\n  }\n\n  function mergeIntoCollectionWith(collection, merger, iters) {\n    iters = iters.filter(function(x ) {return x.size !== 0});\n    if (iters.length === 0) {\n      return collection;\n    }\n    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {\n      return collection.constructor(iters[0]);\n    }\n    return collection.withMutations(function(collection ) {\n      var mergeIntoMap = merger ?\n        function(value, key)  {\n          collection.update(key, NOT_SET, function(existing )\n            {return existing === NOT_SET ? value : merger(existing, value, key)}\n          );\n        } :\n        function(value, key)  {\n          collection.set(key, value);\n        }\n      for (var ii = 0; ii < iters.length; ii++) {\n        iters[ii].forEach(mergeIntoMap);\n      }\n    });\n  }\n\n  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {\n    var isNotSet = existing === NOT_SET;\n    var step = keyPathIter.next();\n    if (step.done) {\n      var existingValue = isNotSet ? notSetValue : existing;\n      var newValue = updater(existingValue);\n      return newValue === existingValue ? existing : newValue;\n    }\n    invariant(\n      isNotSet || (existing && existing.set),\n      'invalid keyPath'\n    );\n    var key = step.value;\n    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);\n    var nextUpdated = updateInDeepMap(\n      nextExisting,\n      keyPathIter,\n      notSetValue,\n      updater\n    );\n    return nextUpdated === nextExisting ? existing :\n      nextUpdated === NOT_SET ? existing.remove(key) :\n      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);\n  }\n\n  function popCount(x) {\n    x = x - ((x >> 1) & 0x55555555);\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n    x = (x + (x >> 4)) & 0x0f0f0f0f;\n    x = x + (x >> 8);\n    x = x + (x >> 16);\n    return x & 0x7f;\n  }\n\n  function setIn(array, idx, val, canEdit) {\n    var newArray = canEdit ? array : arrCopy(array);\n    newArray[idx] = val;\n    return newArray;\n  }\n\n  function spliceIn(array, idx, val, canEdit) {\n    var newLen = array.length + 1;\n    if (canEdit && idx + 1 === newLen) {\n      array[idx] = val;\n      return array;\n    }\n    var newArray = new Array(newLen);\n    var after = 0;\n    for (var ii = 0; ii < newLen; ii++) {\n      if (ii === idx) {\n        newArray[ii] = val;\n        after = -1;\n      } else {\n        newArray[ii] = array[ii + after];\n      }\n    }\n    return newArray;\n  }\n\n  function spliceOut(array, idx, canEdit) {\n    var newLen = array.length - 1;\n    if (canEdit && idx === newLen) {\n      array.pop();\n      return array;\n    }\n    var newArray = new Array(newLen);\n    var after = 0;\n    for (var ii = 0; ii < newLen; ii++) {\n      if (ii === idx) {\n        after = 1;\n      }\n      newArray[ii] = array[ii + after];\n    }\n    return newArray;\n  }\n\n  var MAX_ARRAY_MAP_SIZE = SIZE / 4;\n  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;\n  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;\n\n  createClass(List, IndexedCollection);\n\n    // @pragma Construction\n\n    function List(value) {\n      var empty = emptyList();\n      if (value === null || value === undefined) {\n        return empty;\n      }\n      if (isList(value)) {\n        return value;\n      }\n      var iter = IndexedIterable(value);\n      var size = iter.size;\n      if (size === 0) {\n        return empty;\n      }\n      assertNotInfinite(size);\n      if (size > 0 && size < SIZE) {\n        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));\n      }\n      return empty.withMutations(function(list ) {\n        list.setSize(size);\n        iter.forEach(function(v, i)  {return list.set(i, v)});\n      });\n    }\n\n    List.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    List.prototype.toString = function() {\n      return this.__toString('List [', ']');\n    };\n\n    // @pragma Access\n\n    List.prototype.get = function(index, notSetValue) {\n      index = wrapIndex(this, index);\n      if (index >= 0 && index < this.size) {\n        index += this._origin;\n        var node = listNodeFor(this, index);\n        return node && node.array[index & MASK];\n      }\n      return notSetValue;\n    };\n\n    // @pragma Modification\n\n    List.prototype.set = function(index, value) {\n      return updateList(this, index, value);\n    };\n\n    List.prototype.remove = function(index) {\n      return !this.has(index) ? this :\n        index === 0 ? this.shift() :\n        index === this.size - 1 ? this.pop() :\n        this.splice(index, 1);\n    };\n\n    List.prototype.insert = function(index, value) {\n      return this.splice(index, 0, value);\n    };\n\n    List.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = this._origin = this._capacity = 0;\n        this._level = SHIFT;\n        this._root = this._tail = null;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyList();\n    };\n\n    List.prototype.push = function(/*...values*/) {\n      var values = arguments;\n      var oldSize = this.size;\n      return this.withMutations(function(list ) {\n        setListBounds(list, 0, oldSize + values.length);\n        for (var ii = 0; ii < values.length; ii++) {\n          list.set(oldSize + ii, values[ii]);\n        }\n      });\n    };\n\n    List.prototype.pop = function() {\n      return setListBounds(this, 0, -1);\n    };\n\n    List.prototype.unshift = function(/*...values*/) {\n      var values = arguments;\n      return this.withMutations(function(list ) {\n        setListBounds(list, -values.length);\n        for (var ii = 0; ii < values.length; ii++) {\n          list.set(ii, values[ii]);\n        }\n      });\n    };\n\n    List.prototype.shift = function() {\n      return setListBounds(this, 1);\n    };\n\n    // @pragma Composition\n\n    List.prototype.merge = function(/*...iters*/) {\n      return mergeIntoListWith(this, undefined, arguments);\n    };\n\n    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoListWith(this, merger, iters);\n    };\n\n    List.prototype.mergeDeep = function(/*...iters*/) {\n      return mergeIntoListWith(this, deepMerger, arguments);\n    };\n\n    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoListWith(this, deepMergerWith(merger), iters);\n    };\n\n    List.prototype.setSize = function(size) {\n      return setListBounds(this, 0, size);\n    };\n\n    // @pragma Iteration\n\n    List.prototype.slice = function(begin, end) {\n      var size = this.size;\n      if (wholeSlice(begin, end, size)) {\n        return this;\n      }\n      return setListBounds(\n        this,\n        resolveBegin(begin, size),\n        resolveEnd(end, size)\n      );\n    };\n\n    List.prototype.__iterator = function(type, reverse) {\n      var index = 0;\n      var values = iterateList(this, reverse);\n      return new Iterator(function()  {\n        var value = values();\n        return value === DONE ?\n          iteratorDone() :\n          iteratorValue(type, index++, value);\n      });\n    };\n\n    List.prototype.__iterate = function(fn, reverse) {\n      var index = 0;\n      var values = iterateList(this, reverse);\n      var value;\n      while ((value = values()) !== DONE) {\n        if (fn(value, index++, this) === false) {\n          break;\n        }\n      }\n      return index;\n    };\n\n    List.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        return this;\n      }\n      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);\n    };\n\n\n  function isList(maybeList) {\n    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);\n  }\n\n  List.isList = isList;\n\n  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';\n\n  var ListPrototype = List.prototype;\n  ListPrototype[IS_LIST_SENTINEL] = true;\n  ListPrototype[DELETE] = ListPrototype.remove;\n  ListPrototype.setIn = MapPrototype.setIn;\n  ListPrototype.deleteIn =\n  ListPrototype.removeIn = MapPrototype.removeIn;\n  ListPrototype.update = MapPrototype.update;\n  ListPrototype.updateIn = MapPrototype.updateIn;\n  ListPrototype.mergeIn = MapPrototype.mergeIn;\n  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n  ListPrototype.withMutations = MapPrototype.withMutations;\n  ListPrototype.asMutable = MapPrototype.asMutable;\n  ListPrototype.asImmutable = MapPrototype.asImmutable;\n  ListPrototype.wasAltered = MapPrototype.wasAltered;\n\n\n\n    function VNode(array, ownerID) {\n      this.array = array;\n      this.ownerID = ownerID;\n    }\n\n    // TODO: seems like these methods are very similar\n\n    VNode.prototype.removeBefore = function(ownerID, level, index) {\n      if (index === level ? 1 << level : 0 || this.array.length === 0) {\n        return this;\n      }\n      var originIndex = (index >>> level) & MASK;\n      if (originIndex >= this.array.length) {\n        return new VNode([], ownerID);\n      }\n      var removingFirst = originIndex === 0;\n      var newChild;\n      if (level > 0) {\n        var oldChild = this.array[originIndex];\n        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);\n        if (newChild === oldChild && removingFirst) {\n          return this;\n        }\n      }\n      if (removingFirst && !newChild) {\n        return this;\n      }\n      var editable = editableVNode(this, ownerID);\n      if (!removingFirst) {\n        for (var ii = 0; ii < originIndex; ii++) {\n          editable.array[ii] = undefined;\n        }\n      }\n      if (newChild) {\n        editable.array[originIndex] = newChild;\n      }\n      return editable;\n    };\n\n    VNode.prototype.removeAfter = function(ownerID, level, index) {\n      if (index === (level ? 1 << level : 0) || this.array.length === 0) {\n        return this;\n      }\n      var sizeIndex = ((index - 1) >>> level) & MASK;\n      if (sizeIndex >= this.array.length) {\n        return this;\n      }\n\n      var newChild;\n      if (level > 0) {\n        var oldChild = this.array[sizeIndex];\n        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);\n        if (newChild === oldChild && sizeIndex === this.array.length - 1) {\n          return this;\n        }\n      }\n\n      var editable = editableVNode(this, ownerID);\n      editable.array.splice(sizeIndex + 1);\n      if (newChild) {\n        editable.array[sizeIndex] = newChild;\n      }\n      return editable;\n    };\n\n\n\n  var DONE = {};\n\n  function iterateList(list, reverse) {\n    var left = list._origin;\n    var right = list._capacity;\n    var tailPos = getTailOffset(right);\n    var tail = list._tail;\n\n    return iterateNodeOrLeaf(list._root, list._level, 0);\n\n    function iterateNodeOrLeaf(node, level, offset) {\n      return level === 0 ?\n        iterateLeaf(node, offset) :\n        iterateNode(node, level, offset);\n    }\n\n    function iterateLeaf(node, offset) {\n      var array = offset === tailPos ? tail && tail.array : node && node.array;\n      var from = offset > left ? 0 : left - offset;\n      var to = right - offset;\n      if (to > SIZE) {\n        to = SIZE;\n      }\n      return function()  {\n        if (from === to) {\n          return DONE;\n        }\n        var idx = reverse ? --to : from++;\n        return array && array[idx];\n      };\n    }\n\n    function iterateNode(node, level, offset) {\n      var values;\n      var array = node && node.array;\n      var from = offset > left ? 0 : (left - offset) >> level;\n      var to = ((right - offset) >> level) + 1;\n      if (to > SIZE) {\n        to = SIZE;\n      }\n      return function()  {\n        do {\n          if (values) {\n            var value = values();\n            if (value !== DONE) {\n              return value;\n            }\n            values = null;\n          }\n          if (from === to) {\n            return DONE;\n          }\n          var idx = reverse ? --to : from++;\n          values = iterateNodeOrLeaf(\n            array && array[idx], level - SHIFT, offset + (idx << level)\n          );\n        } while (true);\n      };\n    }\n  }\n\n  function makeList(origin, capacity, level, root, tail, ownerID, hash) {\n    var list = Object.create(ListPrototype);\n    list.size = capacity - origin;\n    list._origin = origin;\n    list._capacity = capacity;\n    list._level = level;\n    list._root = root;\n    list._tail = tail;\n    list.__ownerID = ownerID;\n    list.__hash = hash;\n    list.__altered = false;\n    return list;\n  }\n\n  var EMPTY_LIST;\n  function emptyList() {\n    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));\n  }\n\n  function updateList(list, index, value) {\n    index = wrapIndex(list, index);\n\n    if (index !== index) {\n      return list;\n    }\n\n    if (index >= list.size || index < 0) {\n      return list.withMutations(function(list ) {\n        index < 0 ?\n          setListBounds(list, index).set(0, value) :\n          setListBounds(list, 0, index + 1).set(index, value)\n      });\n    }\n\n    index += list._origin;\n\n    var newTail = list._tail;\n    var newRoot = list._root;\n    var didAlter = MakeRef(DID_ALTER);\n    if (index >= getTailOffset(list._capacity)) {\n      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);\n    } else {\n      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);\n    }\n\n    if (!didAlter.value) {\n      return list;\n    }\n\n    if (list.__ownerID) {\n      list._root = newRoot;\n      list._tail = newTail;\n      list.__hash = undefined;\n      list.__altered = true;\n      return list;\n    }\n    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);\n  }\n\n  function updateVNode(node, ownerID, level, index, value, didAlter) {\n    var idx = (index >>> level) & MASK;\n    var nodeHas = node && idx < node.array.length;\n    if (!nodeHas && value === undefined) {\n      return node;\n    }\n\n    var newNode;\n\n    if (level > 0) {\n      var lowerNode = node && node.array[idx];\n      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);\n      if (newLowerNode === lowerNode) {\n        return node;\n      }\n      newNode = editableVNode(node, ownerID);\n      newNode.array[idx] = newLowerNode;\n      return newNode;\n    }\n\n    if (nodeHas && node.array[idx] === value) {\n      return node;\n    }\n\n    SetRef(didAlter);\n\n    newNode = editableVNode(node, ownerID);\n    if (value === undefined && idx === newNode.array.length - 1) {\n      newNode.array.pop();\n    } else {\n      newNode.array[idx] = value;\n    }\n    return newNode;\n  }\n\n  function editableVNode(node, ownerID) {\n    if (ownerID && node && ownerID === node.ownerID) {\n      return node;\n    }\n    return new VNode(node ? node.array.slice() : [], ownerID);\n  }\n\n  function listNodeFor(list, rawIndex) {\n    if (rawIndex >= getTailOffset(list._capacity)) {\n      return list._tail;\n    }\n    if (rawIndex < 1 << (list._level + SHIFT)) {\n      var node = list._root;\n      var level = list._level;\n      while (node && level > 0) {\n        node = node.array[(rawIndex >>> level) & MASK];\n        level -= SHIFT;\n      }\n      return node;\n    }\n  }\n\n  function setListBounds(list, begin, end) {\n    // Sanitize begin & end using this shorthand for ToInt32(argument)\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n    if (begin !== undefined) {\n      begin = begin | 0;\n    }\n    if (end !== undefined) {\n      end = end | 0;\n    }\n    var owner = list.__ownerID || new OwnerID();\n    var oldOrigin = list._origin;\n    var oldCapacity = list._capacity;\n    var newOrigin = oldOrigin + begin;\n    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;\n    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {\n      return list;\n    }\n\n    // If it's going to end after it starts, it's empty.\n    if (newOrigin >= newCapacity) {\n      return list.clear();\n    }\n\n    var newLevel = list._level;\n    var newRoot = list._root;\n\n    // New origin might need creating a higher root.\n    var offsetShift = 0;\n    while (newOrigin + offsetShift < 0) {\n      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);\n      newLevel += SHIFT;\n      offsetShift += 1 << newLevel;\n    }\n    if (offsetShift) {\n      newOrigin += offsetShift;\n      oldOrigin += offsetShift;\n      newCapacity += offsetShift;\n      oldCapacity += offsetShift;\n    }\n\n    var oldTailOffset = getTailOffset(oldCapacity);\n    var newTailOffset = getTailOffset(newCapacity);\n\n    // New size might need creating a higher root.\n    while (newTailOffset >= 1 << (newLevel + SHIFT)) {\n      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);\n      newLevel += SHIFT;\n    }\n\n    // Locate or create the new tail.\n    var oldTail = list._tail;\n    var newTail = newTailOffset < oldTailOffset ?\n      listNodeFor(list, newCapacity - 1) :\n      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;\n\n    // Merge Tail into tree.\n    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {\n      newRoot = editableVNode(newRoot, owner);\n      var node = newRoot;\n      for (var level = newLevel; level > SHIFT; level -= SHIFT) {\n        var idx = (oldTailOffset >>> level) & MASK;\n        node = node.array[idx] = editableVNode(node.array[idx], owner);\n      }\n      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;\n    }\n\n    // If the size has been reduced, there's a chance the tail needs to be trimmed.\n    if (newCapacity < oldCapacity) {\n      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);\n    }\n\n    // If the new origin is within the tail, then we do not need a root.\n    if (newOrigin >= newTailOffset) {\n      newOrigin -= newTailOffset;\n      newCapacity -= newTailOffset;\n      newLevel = SHIFT;\n      newRoot = null;\n      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);\n\n    // Otherwise, if the root has been trimmed, garbage collect.\n    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {\n      offsetShift = 0;\n\n      // Identify the new top root node of the subtree of the old root.\n      while (newRoot) {\n        var beginIndex = (newOrigin >>> newLevel) & MASK;\n        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {\n          break;\n        }\n        if (beginIndex) {\n          offsetShift += (1 << newLevel) * beginIndex;\n        }\n        newLevel -= SHIFT;\n        newRoot = newRoot.array[beginIndex];\n      }\n\n      // Trim the new sides of the new root.\n      if (newRoot && newOrigin > oldOrigin) {\n        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);\n      }\n      if (newRoot && newTailOffset < oldTailOffset) {\n        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);\n      }\n      if (offsetShift) {\n        newOrigin -= offsetShift;\n        newCapacity -= offsetShift;\n      }\n    }\n\n    if (list.__ownerID) {\n      list.size = newCapacity - newOrigin;\n      list._origin = newOrigin;\n      list._capacity = newCapacity;\n      list._level = newLevel;\n      list._root = newRoot;\n      list._tail = newTail;\n      list.__hash = undefined;\n      list.__altered = true;\n      return list;\n    }\n    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);\n  }\n\n  function mergeIntoListWith(list, merger, iterables) {\n    var iters = [];\n    var maxSize = 0;\n    for (var ii = 0; ii < iterables.length; ii++) {\n      var value = iterables[ii];\n      var iter = IndexedIterable(value);\n      if (iter.size > maxSize) {\n        maxSize = iter.size;\n      }\n      if (!isIterable(value)) {\n        iter = iter.map(function(v ) {return fromJS(v)});\n      }\n      iters.push(iter);\n    }\n    if (maxSize > list.size) {\n      list = list.setSize(maxSize);\n    }\n    return mergeIntoCollectionWith(list, merger, iters);\n  }\n\n  function getTailOffset(size) {\n    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);\n  }\n\n  createClass(OrderedMap, Map);\n\n    // @pragma Construction\n\n    function OrderedMap(value) {\n      return value === null || value === undefined ? emptyOrderedMap() :\n        isOrderedMap(value) ? value :\n        emptyOrderedMap().withMutations(function(map ) {\n          var iter = KeyedIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v, k)  {return map.set(k, v)});\n        });\n    }\n\n    OrderedMap.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    OrderedMap.prototype.toString = function() {\n      return this.__toString('OrderedMap {', '}');\n    };\n\n    // @pragma Access\n\n    OrderedMap.prototype.get = function(k, notSetValue) {\n      var index = this._map.get(k);\n      return index !== undefined ? this._list.get(index)[1] : notSetValue;\n    };\n\n    // @pragma Modification\n\n    OrderedMap.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._map.clear();\n        this._list.clear();\n        return this;\n      }\n      return emptyOrderedMap();\n    };\n\n    OrderedMap.prototype.set = function(k, v) {\n      return updateOrderedMap(this, k, v);\n    };\n\n    OrderedMap.prototype.remove = function(k) {\n      return updateOrderedMap(this, k, NOT_SET);\n    };\n\n    OrderedMap.prototype.wasAltered = function() {\n      return this._map.wasAltered() || this._list.wasAltered();\n    };\n\n    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._list.__iterate(\n        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},\n        reverse\n      );\n    };\n\n    OrderedMap.prototype.__iterator = function(type, reverse) {\n      return this._list.fromEntrySeq().__iterator(type, reverse);\n    };\n\n    OrderedMap.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map.__ensureOwner(ownerID);\n      var newList = this._list.__ensureOwner(ownerID);\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        this._list = newList;\n        return this;\n      }\n      return makeOrderedMap(newMap, newList, ownerID, this.__hash);\n    };\n\n\n  function isOrderedMap(maybeOrderedMap) {\n    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);\n  }\n\n  OrderedMap.isOrderedMap = isOrderedMap;\n\n  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;\n  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;\n\n\n\n  function makeOrderedMap(map, list, ownerID, hash) {\n    var omap = Object.create(OrderedMap.prototype);\n    omap.size = map ? map.size : 0;\n    omap._map = map;\n    omap._list = list;\n    omap.__ownerID = ownerID;\n    omap.__hash = hash;\n    return omap;\n  }\n\n  var EMPTY_ORDERED_MAP;\n  function emptyOrderedMap() {\n    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));\n  }\n\n  function updateOrderedMap(omap, k, v) {\n    var map = omap._map;\n    var list = omap._list;\n    var i = map.get(k);\n    var has = i !== undefined;\n    var newMap;\n    var newList;\n    if (v === NOT_SET) { // removed\n      if (!has) {\n        return omap;\n      }\n      if (list.size >= SIZE && list.size >= map.size * 2) {\n        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});\n        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();\n        if (omap.__ownerID) {\n          newMap.__ownerID = newList.__ownerID = omap.__ownerID;\n        }\n      } else {\n        newMap = map.remove(k);\n        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);\n      }\n    } else {\n      if (has) {\n        if (v === list.get(i)[1]) {\n          return omap;\n        }\n        newMap = map;\n        newList = list.set(i, [k, v]);\n      } else {\n        newMap = map.set(k, list.size);\n        newList = list.set(list.size, [k, v]);\n      }\n    }\n    if (omap.__ownerID) {\n      omap.size = newMap.size;\n      omap._map = newMap;\n      omap._list = newList;\n      omap.__hash = undefined;\n      return omap;\n    }\n    return makeOrderedMap(newMap, newList);\n  }\n\n  createClass(ToKeyedSequence, KeyedSeq);\n    function ToKeyedSequence(indexed, useKeys) {\n      this._iter = indexed;\n      this._useKeys = useKeys;\n      this.size = indexed.size;\n    }\n\n    ToKeyedSequence.prototype.get = function(key, notSetValue) {\n      return this._iter.get(key, notSetValue);\n    };\n\n    ToKeyedSequence.prototype.has = function(key) {\n      return this._iter.has(key);\n    };\n\n    ToKeyedSequence.prototype.valueSeq = function() {\n      return this._iter.valueSeq();\n    };\n\n    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;\n      var reversedSequence = reverseFactory(this, true);\n      if (!this._useKeys) {\n        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};\n      }\n      return reversedSequence;\n    };\n\n    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;\n      var mappedSequence = mapFactory(this, mapper, context);\n      if (!this._useKeys) {\n        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};\n      }\n      return mappedSequence;\n    };\n\n    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      var ii;\n      return this._iter.__iterate(\n        this._useKeys ?\n          function(v, k)  {return fn(v, k, this$0)} :\n          ((ii = reverse ? resolveSize(this) : 0),\n            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),\n        reverse\n      );\n    };\n\n    ToKeyedSequence.prototype.__iterator = function(type, reverse) {\n      if (this._useKeys) {\n        return this._iter.__iterator(type, reverse);\n      }\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      var ii = reverse ? resolveSize(this) : 0;\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step :\n          iteratorValue(type, reverse ? --ii : ii++, step.value, step);\n      });\n    };\n\n  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;\n\n\n  createClass(ToIndexedSequence, IndexedSeq);\n    function ToIndexedSequence(iter) {\n      this._iter = iter;\n      this.size = iter.size;\n    }\n\n    ToIndexedSequence.prototype.includes = function(value) {\n      return this._iter.includes(value);\n    };\n\n    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);\n    };\n\n    ToIndexedSequence.prototype.__iterator = function(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      var iterations = 0;\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step :\n          iteratorValue(type, iterations++, step.value, step)\n      });\n    };\n\n\n\n  createClass(ToSetSequence, SetSeq);\n    function ToSetSequence(iter) {\n      this._iter = iter;\n      this.size = iter.size;\n    }\n\n    ToSetSequence.prototype.has = function(key) {\n      return this._iter.includes(key);\n    };\n\n    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);\n    };\n\n    ToSetSequence.prototype.__iterator = function(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step :\n          iteratorValue(type, step.value, step.value, step);\n      });\n    };\n\n\n\n  createClass(FromEntriesSequence, KeyedSeq);\n    function FromEntriesSequence(entries) {\n      this._iter = entries;\n      this.size = entries.size;\n    }\n\n    FromEntriesSequence.prototype.entrySeq = function() {\n      return this._iter.toSeq();\n    };\n\n    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._iter.__iterate(function(entry ) {\n        // Check if entry exists first so array access doesn't throw for holes\n        // in the parent iteration.\n        if (entry) {\n          validateEntry(entry);\n          var indexedIterable = isIterable(entry);\n          return fn(\n            indexedIterable ? entry.get(1) : entry[1],\n            indexedIterable ? entry.get(0) : entry[0],\n            this$0\n          );\n        }\n      }, reverse);\n    };\n\n    FromEntriesSequence.prototype.__iterator = function(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      return new Iterator(function()  {\n        while (true) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          var entry = step.value;\n          // Check if entry exists first so array access doesn't throw for holes\n          // in the parent iteration.\n          if (entry) {\n            validateEntry(entry);\n            var indexedIterable = isIterable(entry);\n            return iteratorValue(\n              type,\n              indexedIterable ? entry.get(0) : entry[0],\n              indexedIterable ? entry.get(1) : entry[1],\n              step\n            );\n          }\n        }\n      });\n    };\n\n\n  ToIndexedSequence.prototype.cacheResult =\n  ToKeyedSequence.prototype.cacheResult =\n  ToSetSequence.prototype.cacheResult =\n  FromEntriesSequence.prototype.cacheResult =\n    cacheResultThrough;\n\n\n  function flipFactory(iterable) {\n    var flipSequence = makeSequence(iterable);\n    flipSequence._iter = iterable;\n    flipSequence.size = iterable.size;\n    flipSequence.flip = function()  {return iterable};\n    flipSequence.reverse = function () {\n      var reversedSequence = iterable.reverse.apply(this); // super.reverse()\n      reversedSequence.flip = function()  {return iterable.reverse()};\n      return reversedSequence;\n    };\n    flipSequence.has = function(key ) {return iterable.includes(key)};\n    flipSequence.includes = function(key ) {return iterable.has(key)};\n    flipSequence.cacheResult = cacheResultThrough;\n    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);\n    }\n    flipSequence.__iteratorUncached = function(type, reverse) {\n      if (type === ITERATE_ENTRIES) {\n        var iterator = iterable.__iterator(type, reverse);\n        return new Iterator(function()  {\n          var step = iterator.next();\n          if (!step.done) {\n            var k = step.value[0];\n            step.value[0] = step.value[1];\n            step.value[1] = k;\n          }\n          return step;\n        });\n      }\n      return iterable.__iterator(\n        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,\n        reverse\n      );\n    }\n    return flipSequence;\n  }\n\n\n  function mapFactory(iterable, mapper, context) {\n    var mappedSequence = makeSequence(iterable);\n    mappedSequence.size = iterable.size;\n    mappedSequence.has = function(key ) {return iterable.has(key)};\n    mappedSequence.get = function(key, notSetValue)  {\n      var v = iterable.get(key, NOT_SET);\n      return v === NOT_SET ?\n        notSetValue :\n        mapper.call(context, v, key, iterable);\n    };\n    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      return iterable.__iterate(\n        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},\n        reverse\n      );\n    }\n    mappedSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      return new Iterator(function()  {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var key = entry[0];\n        return iteratorValue(\n          type,\n          key,\n          mapper.call(context, entry[1], key, iterable),\n          step\n        );\n      });\n    }\n    return mappedSequence;\n  }\n\n\n  function reverseFactory(iterable, useKeys) {\n    var reversedSequence = makeSequence(iterable);\n    reversedSequence._iter = iterable;\n    reversedSequence.size = iterable.size;\n    reversedSequence.reverse = function()  {return iterable};\n    if (iterable.flip) {\n      reversedSequence.flip = function () {\n        var flipSequence = flipFactory(iterable);\n        flipSequence.reverse = function()  {return iterable.flip()};\n        return flipSequence;\n      };\n    }\n    reversedSequence.get = function(key, notSetValue) \n      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};\n    reversedSequence.has = function(key )\n      {return iterable.has(useKeys ? key : -1 - key)};\n    reversedSequence.includes = function(value ) {return iterable.includes(value)};\n    reversedSequence.cacheResult = cacheResultThrough;\n    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;\n      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);\n    };\n    reversedSequence.__iterator =\n      function(type, reverse)  {return iterable.__iterator(type, !reverse)};\n    return reversedSequence;\n  }\n\n\n  function filterFactory(iterable, predicate, context, useKeys) {\n    var filterSequence = makeSequence(iterable);\n    if (useKeys) {\n      filterSequence.has = function(key ) {\n        var v = iterable.get(key, NOT_SET);\n        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);\n      };\n      filterSequence.get = function(key, notSetValue)  {\n        var v = iterable.get(key, NOT_SET);\n        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?\n          v : notSetValue;\n      };\n    }\n    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      iterable.__iterate(function(v, k, c)  {\n        if (predicate.call(context, v, k, c)) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$0);\n        }\n      }, reverse);\n      return iterations;\n    };\n    filterSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      var iterations = 0;\n      return new Iterator(function()  {\n        while (true) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          var entry = step.value;\n          var key = entry[0];\n          var value = entry[1];\n          if (predicate.call(context, value, key, iterable)) {\n            return iteratorValue(type, useKeys ? key : iterations++, value, step);\n          }\n        }\n      });\n    }\n    return filterSequence;\n  }\n\n\n  function countByFactory(iterable, grouper, context) {\n    var groups = Map().asMutable();\n    iterable.__iterate(function(v, k)  {\n      groups.update(\n        grouper.call(context, v, k, iterable),\n        0,\n        function(a ) {return a + 1}\n      );\n    });\n    return groups.asImmutable();\n  }\n\n\n  function groupByFactory(iterable, grouper, context) {\n    var isKeyedIter = isKeyed(iterable);\n    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();\n    iterable.__iterate(function(v, k)  {\n      groups.update(\n        grouper.call(context, v, k, iterable),\n        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}\n      );\n    });\n    var coerce = iterableClass(iterable);\n    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});\n  }\n\n\n  function sliceFactory(iterable, begin, end, useKeys) {\n    var originalSize = iterable.size;\n\n    // Sanitize begin & end using this shorthand for ToInt32(argument)\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n    if (begin !== undefined) {\n      begin = begin | 0;\n    }\n    if (end !== undefined) {\n      if (end === Infinity) {\n        end = originalSize;\n      } else {\n        end = end | 0;\n      }\n    }\n\n    if (wholeSlice(begin, end, originalSize)) {\n      return iterable;\n    }\n\n    var resolvedBegin = resolveBegin(begin, originalSize);\n    var resolvedEnd = resolveEnd(end, originalSize);\n\n    // begin or end will be NaN if they were provided as negative numbers and\n    // this iterable's size is unknown. In that case, cache first so there is\n    // a known size and these do not resolve to NaN.\n    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {\n      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);\n    }\n\n    // Note: resolvedEnd is undefined when the original sequence's length is\n    // unknown and this slice did not supply an end and should contain all\n    // elements after resolvedBegin.\n    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.\n    var resolvedSize = resolvedEnd - resolvedBegin;\n    var sliceSize;\n    if (resolvedSize === resolvedSize) {\n      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;\n    }\n\n    var sliceSeq = makeSequence(iterable);\n\n    // If iterable.size is undefined, the size of the realized sliceSeq is\n    // unknown at this point unless the number of items to slice is 0\n    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;\n\n    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {\n      sliceSeq.get = function (index, notSetValue) {\n        index = wrapIndex(this, index);\n        return index >= 0 && index < sliceSize ?\n          iterable.get(index + resolvedBegin, notSetValue) :\n          notSetValue;\n      }\n    }\n\n    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;\n      if (sliceSize === 0) {\n        return 0;\n      }\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var skipped = 0;\n      var isSkipping = true;\n      var iterations = 0;\n      iterable.__iterate(function(v, k)  {\n        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&\n                 iterations !== sliceSize;\n        }\n      });\n      return iterations;\n    };\n\n    sliceSeq.__iteratorUncached = function(type, reverse) {\n      if (sliceSize !== 0 && reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      // Don't bother instantiating parent iterator if taking 0.\n      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);\n      var skipped = 0;\n      var iterations = 0;\n      return new Iterator(function()  {\n        while (skipped++ < resolvedBegin) {\n          iterator.next();\n        }\n        if (++iterations > sliceSize) {\n          return iteratorDone();\n        }\n        var step = iterator.next();\n        if (useKeys || type === ITERATE_VALUES) {\n          return step;\n        } else if (type === ITERATE_KEYS) {\n          return iteratorValue(type, iterations - 1, undefined, step);\n        } else {\n          return iteratorValue(type, iterations - 1, step.value[1], step);\n        }\n      });\n    }\n\n    return sliceSeq;\n  }\n\n\n  function takeWhileFactory(iterable, predicate, context) {\n    var takeSequence = makeSequence(iterable);\n    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterations = 0;\n      iterable.__iterate(function(v, k, c) \n        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}\n      );\n      return iterations;\n    };\n    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      var iterating = true;\n      return new Iterator(function()  {\n        if (!iterating) {\n          return iteratorDone();\n        }\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var k = entry[0];\n        var v = entry[1];\n        if (!predicate.call(context, v, k, this$0)) {\n          iterating = false;\n          return iteratorDone();\n        }\n        return type === ITERATE_ENTRIES ? step :\n          iteratorValue(type, k, v, step);\n      });\n    };\n    return takeSequence;\n  }\n\n\n  function skipWhileFactory(iterable, predicate, context, useKeys) {\n    var skipSequence = makeSequence(iterable);\n    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var isSkipping = true;\n      var iterations = 0;\n      iterable.__iterate(function(v, k, c)  {\n        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$0);\n        }\n      });\n      return iterations;\n    };\n    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      var skipping = true;\n      var iterations = 0;\n      return new Iterator(function()  {\n        var step, k, v;\n        do {\n          step = iterator.next();\n          if (step.done) {\n            if (useKeys || type === ITERATE_VALUES) {\n              return step;\n            } else if (type === ITERATE_KEYS) {\n              return iteratorValue(type, iterations++, undefined, step);\n            } else {\n              return iteratorValue(type, iterations++, step.value[1], step);\n            }\n          }\n          var entry = step.value;\n          k = entry[0];\n          v = entry[1];\n          skipping && (skipping = predicate.call(context, v, k, this$0));\n        } while (skipping);\n        return type === ITERATE_ENTRIES ? step :\n          iteratorValue(type, k, v, step);\n      });\n    };\n    return skipSequence;\n  }\n\n\n  function concatFactory(iterable, values) {\n    var isKeyedIterable = isKeyed(iterable);\n    var iters = [iterable].concat(values).map(function(v ) {\n      if (!isIterable(v)) {\n        v = isKeyedIterable ?\n          keyedSeqFromValue(v) :\n          indexedSeqFromValue(Array.isArray(v) ? v : [v]);\n      } else if (isKeyedIterable) {\n        v = KeyedIterable(v);\n      }\n      return v;\n    }).filter(function(v ) {return v.size !== 0});\n\n    if (iters.length === 0) {\n      return iterable;\n    }\n\n    if (iters.length === 1) {\n      var singleton = iters[0];\n      if (singleton === iterable ||\n          isKeyedIterable && isKeyed(singleton) ||\n          isIndexed(iterable) && isIndexed(singleton)) {\n        return singleton;\n      }\n    }\n\n    var concatSeq = new ArraySeq(iters);\n    if (isKeyedIterable) {\n      concatSeq = concatSeq.toKeyedSeq();\n    } else if (!isIndexed(iterable)) {\n      concatSeq = concatSeq.toSetSeq();\n    }\n    concatSeq = concatSeq.flatten(true);\n    concatSeq.size = iters.reduce(\n      function(sum, seq)  {\n        if (sum !== undefined) {\n          var size = seq.size;\n          if (size !== undefined) {\n            return sum + size;\n          }\n        }\n      },\n      0\n    );\n    return concatSeq;\n  }\n\n\n  function flattenFactory(iterable, depth, useKeys) {\n    var flatSequence = makeSequence(iterable);\n    flatSequence.__iterateUncached = function(fn, reverse) {\n      var iterations = 0;\n      var stopped = false;\n      function flatDeep(iter, currentDepth) {var this$0 = this;\n        iter.__iterate(function(v, k)  {\n          if ((!depth || currentDepth < depth) && isIterable(v)) {\n            flatDeep(v, currentDepth + 1);\n          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {\n            stopped = true;\n          }\n          return !stopped;\n        }, reverse);\n      }\n      flatDeep(iterable, 0);\n      return iterations;\n    }\n    flatSequence.__iteratorUncached = function(type, reverse) {\n      var iterator = iterable.__iterator(type, reverse);\n      var stack = [];\n      var iterations = 0;\n      return new Iterator(function()  {\n        while (iterator) {\n          var step = iterator.next();\n          if (step.done !== false) {\n            iterator = stack.pop();\n            continue;\n          }\n          var v = step.value;\n          if (type === ITERATE_ENTRIES) {\n            v = v[1];\n          }\n          if ((!depth || stack.length < depth) && isIterable(v)) {\n            stack.push(iterator);\n            iterator = v.__iterator(type, reverse);\n          } else {\n            return useKeys ? step : iteratorValue(type, iterations++, v, step);\n          }\n        }\n        return iteratorDone();\n      });\n    }\n    return flatSequence;\n  }\n\n\n  function flatMapFactory(iterable, mapper, context) {\n    var coerce = iterableClass(iterable);\n    return iterable.toSeq().map(\n      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}\n    ).flatten(true);\n  }\n\n\n  function interposeFactory(iterable, separator) {\n    var interposedSequence = makeSequence(iterable);\n    interposedSequence.size = iterable.size && iterable.size * 2 -1;\n    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      iterable.__iterate(function(v, k) \n        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&\n        fn(v, iterations++, this$0) !== false},\n        reverse\n      );\n      return iterations;\n    };\n    interposedSequence.__iteratorUncached = function(type, reverse) {\n      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);\n      var iterations = 0;\n      var step;\n      return new Iterator(function()  {\n        if (!step || iterations % 2) {\n          step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n        }\n        return iterations % 2 ?\n          iteratorValue(type, iterations++, separator) :\n          iteratorValue(type, iterations++, step.value, step);\n      });\n    };\n    return interposedSequence;\n  }\n\n\n  function sortFactory(iterable, comparator, mapper) {\n    if (!comparator) {\n      comparator = defaultComparator;\n    }\n    var isKeyedIterable = isKeyed(iterable);\n    var index = 0;\n    var entries = iterable.toSeq().map(\n      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}\n    ).toArray();\n    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(\n      isKeyedIterable ?\n      function(v, i)  { entries[i].length = 2; } :\n      function(v, i)  { entries[i] = v[1]; }\n    );\n    return isKeyedIterable ? KeyedSeq(entries) :\n      isIndexed(iterable) ? IndexedSeq(entries) :\n      SetSeq(entries);\n  }\n\n\n  function maxFactory(iterable, comparator, mapper) {\n    if (!comparator) {\n      comparator = defaultComparator;\n    }\n    if (mapper) {\n      var entry = iterable.toSeq()\n        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})\n        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});\n      return entry && entry[0];\n    } else {\n      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});\n    }\n  }\n\n  function maxCompare(comparator, a, b) {\n    var comp = comparator(b, a);\n    // b is considered the new max if the comparator declares them equal, but\n    // they are not equal and b is in fact a nullish value.\n    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;\n  }\n\n\n  function zipWithFactory(keyIter, zipper, iters) {\n    var zipSequence = makeSequence(keyIter);\n    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();\n    // Note: this a generic base implementation of __iterate in terms of\n    // __iterator which may be more generically useful in the future.\n    zipSequence.__iterate = function(fn, reverse) {\n      /* generic:\n      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);\n      var step;\n      var iterations = 0;\n      while (!(step = iterator.next()).done) {\n        iterations++;\n        if (fn(step.value[1], step.value[0], this) === false) {\n          break;\n        }\n      }\n      return iterations;\n      */\n      // indexed:\n      var iterator = this.__iterator(ITERATE_VALUES, reverse);\n      var step;\n      var iterations = 0;\n      while (!(step = iterator.next()).done) {\n        if (fn(step.value, iterations++, this) === false) {\n          break;\n        }\n      }\n      return iterations;\n    };\n    zipSequence.__iteratorUncached = function(type, reverse) {\n      var iterators = iters.map(function(i )\n        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}\n      );\n      var iterations = 0;\n      var isDone = false;\n      return new Iterator(function()  {\n        var steps;\n        if (!isDone) {\n          steps = iterators.map(function(i ) {return i.next()});\n          isDone = steps.some(function(s ) {return s.done});\n        }\n        if (isDone) {\n          return iteratorDone();\n        }\n        return iteratorValue(\n          type,\n          iterations++,\n          zipper.apply(null, steps.map(function(s ) {return s.value}))\n        );\n      });\n    };\n    return zipSequence\n  }\n\n\n  // #pragma Helper Functions\n\n  function reify(iter, seq) {\n    return isSeq(iter) ? seq : iter.constructor(seq);\n  }\n\n  function validateEntry(entry) {\n    if (entry !== Object(entry)) {\n      throw new TypeError('Expected [K, V] tuple: ' + entry);\n    }\n  }\n\n  function resolveSize(iter) {\n    assertNotInfinite(iter.size);\n    return ensureSize(iter);\n  }\n\n  function iterableClass(iterable) {\n    return isKeyed(iterable) ? KeyedIterable :\n      isIndexed(iterable) ? IndexedIterable :\n      SetIterable;\n  }\n\n  function makeSequence(iterable) {\n    return Object.create(\n      (\n        isKeyed(iterable) ? KeyedSeq :\n        isIndexed(iterable) ? IndexedSeq :\n        SetSeq\n      ).prototype\n    );\n  }\n\n  function cacheResultThrough() {\n    if (this._iter.cacheResult) {\n      this._iter.cacheResult();\n      this.size = this._iter.size;\n      return this;\n    } else {\n      return Seq.prototype.cacheResult.call(this);\n    }\n  }\n\n  function defaultComparator(a, b) {\n    return a > b ? 1 : a < b ? -1 : 0;\n  }\n\n  function forceIterator(keyPath) {\n    var iter = getIterator(keyPath);\n    if (!iter) {\n      // Array might not be iterable in this environment, so we need a fallback\n      // to our wrapped type.\n      if (!isArrayLike(keyPath)) {\n        throw new TypeError('Expected iterable or array-like: ' + keyPath);\n      }\n      iter = getIterator(Iterable(keyPath));\n    }\n    return iter;\n  }\n\n  createClass(Record, KeyedCollection);\n\n    function Record(defaultValues, name) {\n      var hasInitialized;\n\n      var RecordType = function Record(values) {\n        if (values instanceof RecordType) {\n          return values;\n        }\n        if (!(this instanceof RecordType)) {\n          return new RecordType(values);\n        }\n        if (!hasInitialized) {\n          hasInitialized = true;\n          var keys = Object.keys(defaultValues);\n          setProps(RecordTypePrototype, keys);\n          RecordTypePrototype.size = keys.length;\n          RecordTypePrototype._name = name;\n          RecordTypePrototype._keys = keys;\n          RecordTypePrototype._defaultValues = defaultValues;\n        }\n        this._map = Map(values);\n      };\n\n      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);\n      RecordTypePrototype.constructor = RecordType;\n\n      return RecordType;\n    }\n\n    Record.prototype.toString = function() {\n      return this.__toString(recordName(this) + ' {', '}');\n    };\n\n    // @pragma Access\n\n    Record.prototype.has = function(k) {\n      return this._defaultValues.hasOwnProperty(k);\n    };\n\n    Record.prototype.get = function(k, notSetValue) {\n      if (!this.has(k)) {\n        return notSetValue;\n      }\n      var defaultVal = this._defaultValues[k];\n      return this._map ? this._map.get(k, defaultVal) : defaultVal;\n    };\n\n    // @pragma Modification\n\n    Record.prototype.clear = function() {\n      if (this.__ownerID) {\n        this._map && this._map.clear();\n        return this;\n      }\n      var RecordType = this.constructor;\n      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));\n    };\n\n    Record.prototype.set = function(k, v) {\n      if (!this.has(k)) {\n        throw new Error('Cannot set unknown key \"' + k + '\" on ' + recordName(this));\n      }\n      if (this._map && !this._map.has(k)) {\n        var defaultVal = this._defaultValues[k];\n        if (v === defaultVal) {\n          return this;\n        }\n      }\n      var newMap = this._map && this._map.set(k, v);\n      if (this.__ownerID || newMap === this._map) {\n        return this;\n      }\n      return makeRecord(this, newMap);\n    };\n\n    Record.prototype.remove = function(k) {\n      if (!this.has(k)) {\n        return this;\n      }\n      var newMap = this._map && this._map.remove(k);\n      if (this.__ownerID || newMap === this._map) {\n        return this;\n      }\n      return makeRecord(this, newMap);\n    };\n\n    Record.prototype.wasAltered = function() {\n      return this._map.wasAltered();\n    };\n\n    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;\n      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);\n    };\n\n    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);\n    };\n\n    Record.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map && this._map.__ensureOwner(ownerID);\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        return this;\n      }\n      return makeRecord(this, newMap, ownerID);\n    };\n\n\n  var RecordPrototype = Record.prototype;\n  RecordPrototype[DELETE] = RecordPrototype.remove;\n  RecordPrototype.deleteIn =\n  RecordPrototype.removeIn = MapPrototype.removeIn;\n  RecordPrototype.merge = MapPrototype.merge;\n  RecordPrototype.mergeWith = MapPrototype.mergeWith;\n  RecordPrototype.mergeIn = MapPrototype.mergeIn;\n  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;\n  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;\n  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n  RecordPrototype.setIn = MapPrototype.setIn;\n  RecordPrototype.update = MapPrototype.update;\n  RecordPrototype.updateIn = MapPrototype.updateIn;\n  RecordPrototype.withMutations = MapPrototype.withMutations;\n  RecordPrototype.asMutable = MapPrototype.asMutable;\n  RecordPrototype.asImmutable = MapPrototype.asImmutable;\n\n\n  function makeRecord(likeRecord, map, ownerID) {\n    var record = Object.create(Object.getPrototypeOf(likeRecord));\n    record._map = map;\n    record.__ownerID = ownerID;\n    return record;\n  }\n\n  function recordName(record) {\n    return record._name || record.constructor.name || 'Record';\n  }\n\n  function setProps(prototype, names) {\n    try {\n      names.forEach(setProp.bind(undefined, prototype));\n    } catch (error) {\n      // Object.defineProperty failed. Probably IE8.\n    }\n  }\n\n  function setProp(prototype, name) {\n    Object.defineProperty(prototype, name, {\n      get: function() {\n        return this.get(name);\n      },\n      set: function(value) {\n        invariant(this.__ownerID, 'Cannot set on an immutable record.');\n        this.set(name, value);\n      }\n    });\n  }\n\n  createClass(Set, SetCollection);\n\n    // @pragma Construction\n\n    function Set(value) {\n      return value === null || value === undefined ? emptySet() :\n        isSet(value) && !isOrdered(value) ? value :\n        emptySet().withMutations(function(set ) {\n          var iter = SetIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v ) {return set.add(v)});\n        });\n    }\n\n    Set.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    Set.fromKeys = function(value) {\n      return this(KeyedIterable(value).keySeq());\n    };\n\n    Set.prototype.toString = function() {\n      return this.__toString('Set {', '}');\n    };\n\n    // @pragma Access\n\n    Set.prototype.has = function(value) {\n      return this._map.has(value);\n    };\n\n    // @pragma Modification\n\n    Set.prototype.add = function(value) {\n      return updateSet(this, this._map.set(value, true));\n    };\n\n    Set.prototype.remove = function(value) {\n      return updateSet(this, this._map.remove(value));\n    };\n\n    Set.prototype.clear = function() {\n      return updateSet(this, this._map.clear());\n    };\n\n    // @pragma Composition\n\n    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);\n      iters = iters.filter(function(x ) {return x.size !== 0});\n      if (iters.length === 0) {\n        return this;\n      }\n      if (this.size === 0 && !this.__ownerID && iters.length === 1) {\n        return this.constructor(iters[0]);\n      }\n      return this.withMutations(function(set ) {\n        for (var ii = 0; ii < iters.length; ii++) {\n          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});\n        }\n      });\n    };\n\n    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);\n      if (iters.length === 0) {\n        return this;\n      }\n      iters = iters.map(function(iter ) {return SetIterable(iter)});\n      var originalSet = this;\n      return this.withMutations(function(set ) {\n        originalSet.forEach(function(value ) {\n          if (!iters.every(function(iter ) {return iter.includes(value)})) {\n            set.remove(value);\n          }\n        });\n      });\n    };\n\n    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);\n      if (iters.length === 0) {\n        return this;\n      }\n      iters = iters.map(function(iter ) {return SetIterable(iter)});\n      var originalSet = this;\n      return this.withMutations(function(set ) {\n        originalSet.forEach(function(value ) {\n          if (iters.some(function(iter ) {return iter.includes(value)})) {\n            set.remove(value);\n          }\n        });\n      });\n    };\n\n    Set.prototype.merge = function() {\n      return this.union.apply(this, arguments);\n    };\n\n    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return this.union.apply(this, iters);\n    };\n\n    Set.prototype.sort = function(comparator) {\n      // Late binding\n      return OrderedSet(sortFactory(this, comparator));\n    };\n\n    Set.prototype.sortBy = function(mapper, comparator) {\n      // Late binding\n      return OrderedSet(sortFactory(this, comparator, mapper));\n    };\n\n    Set.prototype.wasAltered = function() {\n      return this._map.wasAltered();\n    };\n\n    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);\n    };\n\n    Set.prototype.__iterator = function(type, reverse) {\n      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);\n    };\n\n    Set.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map.__ensureOwner(ownerID);\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        return this;\n      }\n      return this.__make(newMap, ownerID);\n    };\n\n\n  function isSet(maybeSet) {\n    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);\n  }\n\n  Set.isSet = isSet;\n\n  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';\n\n  var SetPrototype = Set.prototype;\n  SetPrototype[IS_SET_SENTINEL] = true;\n  SetPrototype[DELETE] = SetPrototype.remove;\n  SetPrototype.mergeDeep = SetPrototype.merge;\n  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;\n  SetPrototype.withMutations = MapPrototype.withMutations;\n  SetPrototype.asMutable = MapPrototype.asMutable;\n  SetPrototype.asImmutable = MapPrototype.asImmutable;\n\n  SetPrototype.__empty = emptySet;\n  SetPrototype.__make = makeSet;\n\n  function updateSet(set, newMap) {\n    if (set.__ownerID) {\n      set.size = newMap.size;\n      set._map = newMap;\n      return set;\n    }\n    return newMap === set._map ? set :\n      newMap.size === 0 ? set.__empty() :\n      set.__make(newMap);\n  }\n\n  function makeSet(map, ownerID) {\n    var set = Object.create(SetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n  }\n\n  var EMPTY_SET;\n  function emptySet() {\n    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));\n  }\n\n  createClass(OrderedSet, Set);\n\n    // @pragma Construction\n\n    function OrderedSet(value) {\n      return value === null || value === undefined ? emptyOrderedSet() :\n        isOrderedSet(value) ? value :\n        emptyOrderedSet().withMutations(function(set ) {\n          var iter = SetIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v ) {return set.add(v)});\n        });\n    }\n\n    OrderedSet.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    OrderedSet.fromKeys = function(value) {\n      return this(KeyedIterable(value).keySeq());\n    };\n\n    OrderedSet.prototype.toString = function() {\n      return this.__toString('OrderedSet {', '}');\n    };\n\n\n  function isOrderedSet(maybeOrderedSet) {\n    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);\n  }\n\n  OrderedSet.isOrderedSet = isOrderedSet;\n\n  var OrderedSetPrototype = OrderedSet.prototype;\n  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;\n\n  OrderedSetPrototype.__empty = emptyOrderedSet;\n  OrderedSetPrototype.__make = makeOrderedSet;\n\n  function makeOrderedSet(map, ownerID) {\n    var set = Object.create(OrderedSetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n  }\n\n  var EMPTY_ORDERED_SET;\n  function emptyOrderedSet() {\n    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));\n  }\n\n  createClass(Stack, IndexedCollection);\n\n    // @pragma Construction\n\n    function Stack(value) {\n      return value === null || value === undefined ? emptyStack() :\n        isStack(value) ? value :\n        emptyStack().unshiftAll(value);\n    }\n\n    Stack.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    Stack.prototype.toString = function() {\n      return this.__toString('Stack [', ']');\n    };\n\n    // @pragma Access\n\n    Stack.prototype.get = function(index, notSetValue) {\n      var head = this._head;\n      index = wrapIndex(this, index);\n      while (head && index--) {\n        head = head.next;\n      }\n      return head ? head.value : notSetValue;\n    };\n\n    Stack.prototype.peek = function() {\n      return this._head && this._head.value;\n    };\n\n    // @pragma Modification\n\n    Stack.prototype.push = function(/*...values*/) {\n      if (arguments.length === 0) {\n        return this;\n      }\n      var newSize = this.size + arguments.length;\n      var head = this._head;\n      for (var ii = arguments.length - 1; ii >= 0; ii--) {\n        head = {\n          value: arguments[ii],\n          next: head\n        };\n      }\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    Stack.prototype.pushAll = function(iter) {\n      iter = IndexedIterable(iter);\n      if (iter.size === 0) {\n        return this;\n      }\n      assertNotInfinite(iter.size);\n      var newSize = this.size;\n      var head = this._head;\n      iter.reverse().forEach(function(value ) {\n        newSize++;\n        head = {\n          value: value,\n          next: head\n        };\n      });\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    Stack.prototype.pop = function() {\n      return this.slice(1);\n    };\n\n    Stack.prototype.unshift = function(/*...values*/) {\n      return this.push.apply(this, arguments);\n    };\n\n    Stack.prototype.unshiftAll = function(iter) {\n      return this.pushAll(iter);\n    };\n\n    Stack.prototype.shift = function() {\n      return this.pop.apply(this, arguments);\n    };\n\n    Stack.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._head = undefined;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyStack();\n    };\n\n    Stack.prototype.slice = function(begin, end) {\n      if (wholeSlice(begin, end, this.size)) {\n        return this;\n      }\n      var resolvedBegin = resolveBegin(begin, this.size);\n      var resolvedEnd = resolveEnd(end, this.size);\n      if (resolvedEnd !== this.size) {\n        // super.slice(begin, end);\n        return IndexedCollection.prototype.slice.call(this, begin, end);\n      }\n      var newSize = this.size - resolvedBegin;\n      var head = this._head;\n      while (resolvedBegin--) {\n        head = head.next;\n      }\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    // @pragma Mutability\n\n    Stack.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeStack(this.size, this._head, ownerID, this.__hash);\n    };\n\n    // @pragma Iteration\n\n    Stack.prototype.__iterate = function(fn, reverse) {\n      if (reverse) {\n        return this.reverse().__iterate(fn);\n      }\n      var iterations = 0;\n      var node = this._head;\n      while (node) {\n        if (fn(node.value, iterations++, this) === false) {\n          break;\n        }\n        node = node.next;\n      }\n      return iterations;\n    };\n\n    Stack.prototype.__iterator = function(type, reverse) {\n      if (reverse) {\n        return this.reverse().__iterator(type);\n      }\n      var iterations = 0;\n      var node = this._head;\n      return new Iterator(function()  {\n        if (node) {\n          var value = node.value;\n          node = node.next;\n          return iteratorValue(type, iterations++, value);\n        }\n        return iteratorDone();\n      });\n    };\n\n\n  function isStack(maybeStack) {\n    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);\n  }\n\n  Stack.isStack = isStack;\n\n  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';\n\n  var StackPrototype = Stack.prototype;\n  StackPrototype[IS_STACK_SENTINEL] = true;\n  StackPrototype.withMutations = MapPrototype.withMutations;\n  StackPrototype.asMutable = MapPrototype.asMutable;\n  StackPrototype.asImmutable = MapPrototype.asImmutable;\n  StackPrototype.wasAltered = MapPrototype.wasAltered;\n\n\n  function makeStack(size, head, ownerID, hash) {\n    var map = Object.create(StackPrototype);\n    map.size = size;\n    map._head = head;\n    map.__ownerID = ownerID;\n    map.__hash = hash;\n    map.__altered = false;\n    return map;\n  }\n\n  var EMPTY_STACK;\n  function emptyStack() {\n    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));\n  }\n\n  /**\n   * Contributes additional methods to a constructor\n   */\n  function mixin(ctor, methods) {\n    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };\n    Object.keys(methods).forEach(keyCopier);\n    Object.getOwnPropertySymbols &&\n      Object.getOwnPropertySymbols(methods).forEach(keyCopier);\n    return ctor;\n  }\n\n  Iterable.Iterator = Iterator;\n\n  mixin(Iterable, {\n\n    // ### Conversion to other types\n\n    toArray: function() {\n      assertNotInfinite(this.size);\n      var array = new Array(this.size || 0);\n      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });\n      return array;\n    },\n\n    toIndexedSeq: function() {\n      return new ToIndexedSequence(this);\n    },\n\n    toJS: function() {\n      return this.toSeq().map(\n        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}\n      ).__toJS();\n    },\n\n    toJSON: function() {\n      return this.toSeq().map(\n        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}\n      ).__toJS();\n    },\n\n    toKeyedSeq: function() {\n      return new ToKeyedSequence(this, true);\n    },\n\n    toMap: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return Map(this.toKeyedSeq());\n    },\n\n    toObject: function() {\n      assertNotInfinite(this.size);\n      var object = {};\n      this.__iterate(function(v, k)  { object[k] = v; });\n      return object;\n    },\n\n    toOrderedMap: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return OrderedMap(this.toKeyedSeq());\n    },\n\n    toOrderedSet: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toSet: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return Set(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toSetSeq: function() {\n      return new ToSetSequence(this);\n    },\n\n    toSeq: function() {\n      return isIndexed(this) ? this.toIndexedSeq() :\n        isKeyed(this) ? this.toKeyedSeq() :\n        this.toSetSeq();\n    },\n\n    toStack: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return Stack(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toList: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return List(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n\n    // ### Common JavaScript methods and properties\n\n    toString: function() {\n      return '[Iterable]';\n    },\n\n    __toString: function(head, tail) {\n      if (this.size === 0) {\n        return head + tail;\n      }\n      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;\n    },\n\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    concat: function() {var values = SLICE$0.call(arguments, 0);\n      return reify(this, concatFactory(this, values));\n    },\n\n    includes: function(searchValue) {\n      return this.some(function(value ) {return is(value, searchValue)});\n    },\n\n    entries: function() {\n      return this.__iterator(ITERATE_ENTRIES);\n    },\n\n    every: function(predicate, context) {\n      assertNotInfinite(this.size);\n      var returnValue = true;\n      this.__iterate(function(v, k, c)  {\n        if (!predicate.call(context, v, k, c)) {\n          returnValue = false;\n          return false;\n        }\n      });\n      return returnValue;\n    },\n\n    filter: function(predicate, context) {\n      return reify(this, filterFactory(this, predicate, context, true));\n    },\n\n    find: function(predicate, context, notSetValue) {\n      var entry = this.findEntry(predicate, context);\n      return entry ? entry[1] : notSetValue;\n    },\n\n    forEach: function(sideEffect, context) {\n      assertNotInfinite(this.size);\n      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);\n    },\n\n    join: function(separator) {\n      assertNotInfinite(this.size);\n      separator = separator !== undefined ? '' + separator : ',';\n      var joined = '';\n      var isFirst = true;\n      this.__iterate(function(v ) {\n        isFirst ? (isFirst = false) : (joined += separator);\n        joined += v !== null && v !== undefined ? v.toString() : '';\n      });\n      return joined;\n    },\n\n    keys: function() {\n      return this.__iterator(ITERATE_KEYS);\n    },\n\n    map: function(mapper, context) {\n      return reify(this, mapFactory(this, mapper, context));\n    },\n\n    reduce: function(reducer, initialReduction, context) {\n      assertNotInfinite(this.size);\n      var reduction;\n      var useFirst;\n      if (arguments.length < 2) {\n        useFirst = true;\n      } else {\n        reduction = initialReduction;\n      }\n      this.__iterate(function(v, k, c)  {\n        if (useFirst) {\n          useFirst = false;\n          reduction = v;\n        } else {\n          reduction = reducer.call(context, reduction, v, k, c);\n        }\n      });\n      return reduction;\n    },\n\n    reduceRight: function(reducer, initialReduction, context) {\n      var reversed = this.toKeyedSeq().reverse();\n      return reversed.reduce.apply(reversed, arguments);\n    },\n\n    reverse: function() {\n      return reify(this, reverseFactory(this, true));\n    },\n\n    slice: function(begin, end) {\n      return reify(this, sliceFactory(this, begin, end, true));\n    },\n\n    some: function(predicate, context) {\n      return !this.every(not(predicate), context);\n    },\n\n    sort: function(comparator) {\n      return reify(this, sortFactory(this, comparator));\n    },\n\n    values: function() {\n      return this.__iterator(ITERATE_VALUES);\n    },\n\n\n    // ### More sequential methods\n\n    butLast: function() {\n      return this.slice(0, -1);\n    },\n\n    isEmpty: function() {\n      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});\n    },\n\n    count: function(predicate, context) {\n      return ensureSize(\n        predicate ? this.toSeq().filter(predicate, context) : this\n      );\n    },\n\n    countBy: function(grouper, context) {\n      return countByFactory(this, grouper, context);\n    },\n\n    equals: function(other) {\n      return deepEqual(this, other);\n    },\n\n    entrySeq: function() {\n      var iterable = this;\n      if (iterable._cache) {\n        // We cache as an entries array, so we can just return the cache!\n        return new ArraySeq(iterable._cache);\n      }\n      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();\n      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};\n      return entriesSequence;\n    },\n\n    filterNot: function(predicate, context) {\n      return this.filter(not(predicate), context);\n    },\n\n    findEntry: function(predicate, context, notSetValue) {\n      var found = notSetValue;\n      this.__iterate(function(v, k, c)  {\n        if (predicate.call(context, v, k, c)) {\n          found = [k, v];\n          return false;\n        }\n      });\n      return found;\n    },\n\n    findKey: function(predicate, context) {\n      var entry = this.findEntry(predicate, context);\n      return entry && entry[0];\n    },\n\n    findLast: function(predicate, context, notSetValue) {\n      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);\n    },\n\n    findLastEntry: function(predicate, context, notSetValue) {\n      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);\n    },\n\n    findLastKey: function(predicate, context) {\n      return this.toKeyedSeq().reverse().findKey(predicate, context);\n    },\n\n    first: function() {\n      return this.find(returnTrue);\n    },\n\n    flatMap: function(mapper, context) {\n      return reify(this, flatMapFactory(this, mapper, context));\n    },\n\n    flatten: function(depth) {\n      return reify(this, flattenFactory(this, depth, true));\n    },\n\n    fromEntrySeq: function() {\n      return new FromEntriesSequence(this);\n    },\n\n    get: function(searchKey, notSetValue) {\n      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);\n    },\n\n    getIn: function(searchKeyPath, notSetValue) {\n      var nested = this;\n      // Note: in an ES6 environment, we would prefer:\n      // for (var key of searchKeyPath) {\n      var iter = forceIterator(searchKeyPath);\n      var step;\n      while (!(step = iter.next()).done) {\n        var key = step.value;\n        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;\n        if (nested === NOT_SET) {\n          return notSetValue;\n        }\n      }\n      return nested;\n    },\n\n    groupBy: function(grouper, context) {\n      return groupByFactory(this, grouper, context);\n    },\n\n    has: function(searchKey) {\n      return this.get(searchKey, NOT_SET) !== NOT_SET;\n    },\n\n    hasIn: function(searchKeyPath) {\n      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;\n    },\n\n    isSubset: function(iter) {\n      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);\n      return this.every(function(value ) {return iter.includes(value)});\n    },\n\n    isSuperset: function(iter) {\n      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);\n      return iter.isSubset(this);\n    },\n\n    keyOf: function(searchValue) {\n      return this.findKey(function(value ) {return is(value, searchValue)});\n    },\n\n    keySeq: function() {\n      return this.toSeq().map(keyMapper).toIndexedSeq();\n    },\n\n    last: function() {\n      return this.toSeq().reverse().first();\n    },\n\n    lastKeyOf: function(searchValue) {\n      return this.toKeyedSeq().reverse().keyOf(searchValue);\n    },\n\n    max: function(comparator) {\n      return maxFactory(this, comparator);\n    },\n\n    maxBy: function(mapper, comparator) {\n      return maxFactory(this, comparator, mapper);\n    },\n\n    min: function(comparator) {\n      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);\n    },\n\n    minBy: function(mapper, comparator) {\n      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);\n    },\n\n    rest: function() {\n      return this.slice(1);\n    },\n\n    skip: function(amount) {\n      return this.slice(Math.max(0, amount));\n    },\n\n    skipLast: function(amount) {\n      return reify(this, this.toSeq().reverse().skip(amount).reverse());\n    },\n\n    skipWhile: function(predicate, context) {\n      return reify(this, skipWhileFactory(this, predicate, context, true));\n    },\n\n    skipUntil: function(predicate, context) {\n      return this.skipWhile(not(predicate), context);\n    },\n\n    sortBy: function(mapper, comparator) {\n      return reify(this, sortFactory(this, comparator, mapper));\n    },\n\n    take: function(amount) {\n      return this.slice(0, Math.max(0, amount));\n    },\n\n    takeLast: function(amount) {\n      return reify(this, this.toSeq().reverse().take(amount).reverse());\n    },\n\n    takeWhile: function(predicate, context) {\n      return reify(this, takeWhileFactory(this, predicate, context));\n    },\n\n    takeUntil: function(predicate, context) {\n      return this.takeWhile(not(predicate), context);\n    },\n\n    valueSeq: function() {\n      return this.toIndexedSeq();\n    },\n\n\n    // ### Hashable Object\n\n    hashCode: function() {\n      return this.__hash || (this.__hash = hashIterable(this));\n    }\n\n\n    // ### Internal\n\n    // abstract __iterate(fn, reverse)\n\n    // abstract __iterator(type, reverse)\n  });\n\n  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\n  var IterablePrototype = Iterable.prototype;\n  IterablePrototype[IS_ITERABLE_SENTINEL] = true;\n  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;\n  IterablePrototype.__toJS = IterablePrototype.toArray;\n  IterablePrototype.__toStringMapper = quoteString;\n  IterablePrototype.inspect =\n  IterablePrototype.toSource = function() { return this.toString(); };\n  IterablePrototype.chain = IterablePrototype.flatMap;\n  IterablePrototype.contains = IterablePrototype.includes;\n\n  mixin(KeyedIterable, {\n\n    // ### More sequential methods\n\n    flip: function() {\n      return reify(this, flipFactory(this));\n    },\n\n    mapEntries: function(mapper, context) {var this$0 = this;\n      var iterations = 0;\n      return reify(this,\n        this.toSeq().map(\n          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}\n        ).fromEntrySeq()\n      );\n    },\n\n    mapKeys: function(mapper, context) {var this$0 = this;\n      return reify(this,\n        this.toSeq().flip().map(\n          function(k, v)  {return mapper.call(context, k, v, this$0)}\n        ).flip()\n      );\n    }\n\n  });\n\n  var KeyedIterablePrototype = KeyedIterable.prototype;\n  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;\n  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;\n  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;\n  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};\n\n\n\n  mixin(IndexedIterable, {\n\n    // ### Conversion to other types\n\n    toKeyedSeq: function() {\n      return new ToKeyedSequence(this, false);\n    },\n\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    filter: function(predicate, context) {\n      return reify(this, filterFactory(this, predicate, context, false));\n    },\n\n    findIndex: function(predicate, context) {\n      var entry = this.findEntry(predicate, context);\n      return entry ? entry[0] : -1;\n    },\n\n    indexOf: function(searchValue) {\n      var key = this.keyOf(searchValue);\n      return key === undefined ? -1 : key;\n    },\n\n    lastIndexOf: function(searchValue) {\n      var key = this.lastKeyOf(searchValue);\n      return key === undefined ? -1 : key;\n    },\n\n    reverse: function() {\n      return reify(this, reverseFactory(this, false));\n    },\n\n    slice: function(begin, end) {\n      return reify(this, sliceFactory(this, begin, end, false));\n    },\n\n    splice: function(index, removeNum /*, ...values*/) {\n      var numArgs = arguments.length;\n      removeNum = Math.max(removeNum | 0, 0);\n      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {\n        return this;\n      }\n      // If index is negative, it should resolve relative to the size of the\n      // collection. However size may be expensive to compute if not cached, so\n      // only call count() if the number is in fact negative.\n      index = resolveBegin(index, index < 0 ? this.count() : this.size);\n      var spliced = this.slice(0, index);\n      return reify(\n        this,\n        numArgs === 1 ?\n          spliced :\n          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))\n      );\n    },\n\n\n    // ### More collection methods\n\n    findLastIndex: function(predicate, context) {\n      var entry = this.findLastEntry(predicate, context);\n      return entry ? entry[0] : -1;\n    },\n\n    first: function() {\n      return this.get(0);\n    },\n\n    flatten: function(depth) {\n      return reify(this, flattenFactory(this, depth, false));\n    },\n\n    get: function(index, notSetValue) {\n      index = wrapIndex(this, index);\n      return (index < 0 || (this.size === Infinity ||\n          (this.size !== undefined && index > this.size))) ?\n        notSetValue :\n        this.find(function(_, key)  {return key === index}, undefined, notSetValue);\n    },\n\n    has: function(index) {\n      index = wrapIndex(this, index);\n      return index >= 0 && (this.size !== undefined ?\n        this.size === Infinity || index < this.size :\n        this.indexOf(index) !== -1\n      );\n    },\n\n    interpose: function(separator) {\n      return reify(this, interposeFactory(this, separator));\n    },\n\n    interleave: function(/*...iterables*/) {\n      var iterables = [this].concat(arrCopy(arguments));\n      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);\n      var interleaved = zipped.flatten(true);\n      if (zipped.size) {\n        interleaved.size = zipped.size * iterables.length;\n      }\n      return reify(this, interleaved);\n    },\n\n    keySeq: function() {\n      return Range(0, this.size);\n    },\n\n    last: function() {\n      return this.get(-1);\n    },\n\n    skipWhile: function(predicate, context) {\n      return reify(this, skipWhileFactory(this, predicate, context, false));\n    },\n\n    zip: function(/*, ...iterables */) {\n      var iterables = [this].concat(arrCopy(arguments));\n      return reify(this, zipWithFactory(this, defaultZipper, iterables));\n    },\n\n    zipWith: function(zipper/*, ...iterables */) {\n      var iterables = arrCopy(arguments);\n      iterables[0] = this;\n      return reify(this, zipWithFactory(this, zipper, iterables));\n    }\n\n  });\n\n  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;\n  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;\n\n\n\n  mixin(SetIterable, {\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    get: function(value, notSetValue) {\n      return this.has(value) ? value : notSetValue;\n    },\n\n    includes: function(value) {\n      return this.has(value);\n    },\n\n\n    // ### More sequential methods\n\n    keySeq: function() {\n      return this.valueSeq();\n    }\n\n  });\n\n  SetIterable.prototype.has = IterablePrototype.includes;\n  SetIterable.prototype.contains = SetIterable.prototype.includes;\n\n\n  // Mixin subclasses\n\n  mixin(KeyedSeq, KeyedIterable.prototype);\n  mixin(IndexedSeq, IndexedIterable.prototype);\n  mixin(SetSeq, SetIterable.prototype);\n\n  mixin(KeyedCollection, KeyedIterable.prototype);\n  mixin(IndexedCollection, IndexedIterable.prototype);\n  mixin(SetCollection, SetIterable.prototype);\n\n\n  // #pragma Helper functions\n\n  function keyMapper(v, k) {\n    return k;\n  }\n\n  function entryMapper(v, k) {\n    return [k, v];\n  }\n\n  function not(predicate) {\n    return function() {\n      return !predicate.apply(this, arguments);\n    }\n  }\n\n  function neg(predicate) {\n    return function() {\n      return -predicate.apply(this, arguments);\n    }\n  }\n\n  function quoteString(value) {\n    return typeof value === 'string' ? JSON.stringify(value) : String(value);\n  }\n\n  function defaultZipper() {\n    return arrCopy(arguments);\n  }\n\n  function defaultNegComparator(a, b) {\n    return a < b ? 1 : a > b ? -1 : 0;\n  }\n\n  function hashIterable(iterable) {\n    if (iterable.size === Infinity) {\n      return 0;\n    }\n    var ordered = isOrdered(iterable);\n    var keyed = isKeyed(iterable);\n    var h = ordered ? 1 : 0;\n    var size = iterable.__iterate(\n      keyed ?\n        ordered ?\n          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :\n          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :\n        ordered ?\n          function(v ) { h = 31 * h + hash(v) | 0; } :\n          function(v ) { h = h + hash(v) | 0; }\n    );\n    return murmurHashOfSize(size, h);\n  }\n\n  function murmurHashOfSize(size, h) {\n    h = imul(h, 0xCC9E2D51);\n    h = imul(h << 15 | h >>> -15, 0x1B873593);\n    h = imul(h << 13 | h >>> -13, 5);\n    h = (h + 0xE6546B64 | 0) ^ size;\n    h = imul(h ^ h >>> 16, 0x85EBCA6B);\n    h = imul(h ^ h >>> 13, 0xC2B2AE35);\n    h = smi(h ^ h >>> 16);\n    return h;\n  }\n\n  function hashMerge(a, b) {\n    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int\n  }\n\n  var Immutable = {\n\n    Iterable: Iterable,\n\n    Seq: Seq,\n    Collection: Collection,\n    Map: Map,\n    OrderedMap: OrderedMap,\n    List: List,\n    Stack: Stack,\n    Set: Set,\n    OrderedSet: OrderedSet,\n\n    Record: Record,\n    Range: Range,\n    Repeat: Repeat,\n\n    is: is,\n    fromJS: fromJS\n\n  };\n\n  return Immutable;\n\n}));\n\n\n// WEBPACK FOOTER //\n// ../~/immutable/dist/immutable.js","'use strict';\n\n/**\n * Stringify/parse functions that don't operate\n * recursively, so they avoid call stack exceeded\n * errors.\n */\nexports.stringify = function stringify(input) {\n  var queue = [];\n  queue.push({obj: input});\n\n  var res = '';\n  var next, obj, prefix, val, i, arrayPrefix, keys, k, key, value, objPrefix;\n  while ((next = queue.pop())) {\n    obj = next.obj;\n    prefix = next.prefix || '';\n    val = next.val || '';\n    res += prefix;\n    if (val) {\n      res += val;\n    } else if (typeof obj !== 'object') {\n      res += typeof obj === 'undefined' ? null : JSON.stringify(obj);\n    } else if (obj === null) {\n      res += 'null';\n    } else if (Array.isArray(obj)) {\n      queue.push({val: ']'});\n      for (i = obj.length - 1; i >= 0; i--) {\n        arrayPrefix = i === 0 ? '' : ',';\n        queue.push({obj: obj[i], prefix: arrayPrefix});\n      }\n      queue.push({val: '['});\n    } else { // object\n      keys = [];\n      for (k in obj) {\n        if (obj.hasOwnProperty(k)) {\n          keys.push(k);\n        }\n      }\n      queue.push({val: '}'});\n      for (i = keys.length - 1; i >= 0; i--) {\n        key = keys[i];\n        value = obj[key];\n        objPrefix = (i > 0 ? ',' : '');\n        objPrefix += JSON.stringify(key) + ':';\n        queue.push({obj: value, prefix: objPrefix});\n      }\n      queue.push({val: '{'});\n    }\n  }\n  return res;\n};\n\n// Convenience function for the parse function.\n// This pop function is basically copied from\n// pouchCollate.parseIndexableString\nfunction pop(obj, stack, metaStack) {\n  var lastMetaElement = metaStack[metaStack.length - 1];\n  if (obj === lastMetaElement.element) {\n    // popping a meta-element, e.g. an object whose value is another object\n    metaStack.pop();\n    lastMetaElement = metaStack[metaStack.length - 1];\n  }\n  var element = lastMetaElement.element;\n  var lastElementIndex = lastMetaElement.index;\n  if (Array.isArray(element)) {\n    element.push(obj);\n  } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n    var key = stack.pop();\n    element[key] = obj;\n  } else {\n    stack.push(obj); // obj with key only\n  }\n}\n\nexports.parse = function (str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n  var collationIndex,parsedNum,numChar;\n  var parsedString,lastCh,numConsecutiveSlashes,ch;\n  var arrayElement, objElement;\n  while (true) {\n    collationIndex = str[i++];\n    if (collationIndex === '}' ||\n        collationIndex === ']' ||\n        typeof collationIndex === 'undefined') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack.pop(), stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case ' ':\n      case '\\t':\n      case '\\n':\n      case ':':\n      case ',':\n        break;\n      case 'n':\n        i += 3; // 'ull'\n        pop(null, stack, metaStack);\n        break;\n      case 't':\n        i += 3; // 'rue'\n        pop(true, stack, metaStack);\n        break;\n      case 'f':\n        i += 4; // 'alse'\n        pop(false, stack, metaStack);\n        break;\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n      case '-':\n        parsedNum = '';\n        i--;\n        while (true) {\n          numChar = str[i++];\n          if (/[\\d\\.\\-e\\+]/.test(numChar)) {\n            parsedNum += numChar;\n          } else {\n            i--;\n            break;\n          }\n        }\n        pop(parseFloat(parsedNum), stack, metaStack);\n        break;\n      case '\"':\n        parsedString = '';\n        lastCh = void 0;\n        numConsecutiveSlashes = 0;\n        while (true) {\n          ch = str[i++];\n          if (ch !== '\"' || (lastCh === '\\\\' &&\n              numConsecutiveSlashes % 2 === 1)) {\n            parsedString += ch;\n            lastCh = ch;\n            if (lastCh === '\\\\') {\n              numConsecutiveSlashes++;\n            } else {\n              numConsecutiveSlashes = 0;\n            }\n          } else {\n            break;\n          }\n        }\n        pop(JSON.parse('\"' + parsedString + '\"'), stack, metaStack);\n        break;\n      case '[':\n        arrayElement = { element: [], index: stack.length };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '{':\n        objElement = { element: {}, index: stack.length };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      default:\n        throw new Error(\n          'unexpectedly reached end of input: ' + collationIndex);\n    }\n  }\n};\n\n\n\n// WEBPACK FOOTER //\n// ../~/vuvuzela/index.js","/**\n *  Copyright (c) 2014-2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.Immutable = global.Immutable || {})));\n}(this, (function (exports) { 'use strict';\n\n// Used for setting prototype methods that IE8 chokes on.\nvar DELETE = 'delete';\n\n// Constants describing the size of trie nodes.\nvar SHIFT = 5; // Resulted in best performance after ______?\nvar SIZE = 1 << SHIFT;\nvar MASK = SIZE - 1;\n\n// A consistent shared value representing \"not set\" which equals nothing other\n// than itself, and nothing that could be provided externally.\nvar NOT_SET = {};\n\n// Boolean references, Rough equivalent of `bool &`.\nvar CHANGE_LENGTH = { value: false };\nvar DID_ALTER = { value: false };\n\nfunction MakeRef(ref) {\n  ref.value = false;\n  return ref;\n}\n\nfunction SetRef(ref) {\n  ref && (ref.value = true);\n}\n\n// A function which returns a value representing an \"owner\" for transient writes\n// to tries. The return value will only ever equal itself, and will not equal\n// the return of any subsequent call of this function.\nfunction OwnerID() {}\n\n// http://jsperf.com/copy-array-inline\nfunction arrCopy(arr, offset) {\n  offset = offset || 0;\n  var len = Math.max(0, arr.length - offset);\n  var newArr = new Array(len);\n  for (var ii = 0; ii < len; ii++) {\n    newArr[ii] = arr[ii + offset];\n  }\n  return newArr;\n}\n\nfunction ensureSize(iter) {\n  if (iter.size === undefined) {\n    iter.size = iter.__iterate(returnTrue);\n  }\n  return iter.size;\n}\n\nfunction wrapIndex(iter, index) {\n  // This implements \"is array index\" which the ECMAString spec defines as:\n  //\n  //     A String property name P is an array index if and only if\n  //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal\n  //     to 2^32−1.\n  //\n  // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects\n  if (typeof index !== 'number') {\n    var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32\n    if ('' + uint32Index !== index || uint32Index === 4294967295) {\n      return NaN;\n    }\n    index = uint32Index;\n  }\n  return index < 0 ? ensureSize(iter) + index : index;\n}\n\nfunction returnTrue() {\n  return true;\n}\n\nfunction wholeSlice(begin, end, size) {\n  return (begin === 0 || (size !== undefined && begin <= -size)) &&\n    (end === undefined || (size !== undefined && end >= size));\n}\n\nfunction resolveBegin(begin, size) {\n  return resolveIndex(begin, size, 0);\n}\n\nfunction resolveEnd(end, size) {\n  return resolveIndex(end, size, size);\n}\n\nfunction resolveIndex(index, size, defaultIndex) {\n  // Sanitize indices using this shorthand for ToInt32(argument)\n  // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n  return index === undefined\n    ? defaultIndex\n    : index < 0\n        ? size === Infinity ? size : Math.max(0, size + index) | 0\n        : size === undefined || size === index\n            ? index\n            : Math.min(size, index) | 0;\n}\n\nfunction isImmutable(maybeImmutable) {\n  return (isCollection(maybeImmutable) || isRecord(maybeImmutable)) &&\n    !maybeImmutable.__ownerID;\n}\n\nfunction isCollection(maybeCollection) {\n  return !!(maybeCollection && maybeCollection[IS_ITERABLE_SENTINEL]);\n}\n\nfunction isKeyed(maybeKeyed) {\n  return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);\n}\n\nfunction isIndexed(maybeIndexed) {\n  return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);\n}\n\nfunction isAssociative(maybeAssociative) {\n  return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);\n}\n\nfunction isOrdered(maybeOrdered) {\n  return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);\n}\n\nfunction isRecord(maybeRecord) {\n  return !!(maybeRecord && maybeRecord[IS_RECORD_SENTINEL]);\n}\n\nfunction isValueObject(maybeValue) {\n  return !!(maybeValue &&\n    typeof maybeValue.equals === 'function' &&\n    typeof maybeValue.hashCode === 'function');\n}\n\nvar IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\nvar IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\nvar IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\nvar IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\nvar IS_RECORD_SENTINEL = '@@__IMMUTABLE_RECORD__@@';\n\nvar Collection = function Collection(value) {\n  return isCollection(value) ? value : Seq(value);\n};\n\nvar KeyedCollection = (function (Collection) {\n  function KeyedCollection(value) {\n    return isKeyed(value) ? value : KeyedSeq(value);\n  }\n\n  if ( Collection ) KeyedCollection.__proto__ = Collection;\n  KeyedCollection.prototype = Object.create( Collection && Collection.prototype );\n  KeyedCollection.prototype.constructor = KeyedCollection;\n\n  return KeyedCollection;\n}(Collection));\n\nvar IndexedCollection = (function (Collection) {\n  function IndexedCollection(value) {\n    return isIndexed(value) ? value : IndexedSeq(value);\n  }\n\n  if ( Collection ) IndexedCollection.__proto__ = Collection;\n  IndexedCollection.prototype = Object.create( Collection && Collection.prototype );\n  IndexedCollection.prototype.constructor = IndexedCollection;\n\n  return IndexedCollection;\n}(Collection));\n\nvar SetCollection = (function (Collection) {\n  function SetCollection(value) {\n    return isCollection(value) && !isAssociative(value) ? value : SetSeq(value);\n  }\n\n  if ( Collection ) SetCollection.__proto__ = Collection;\n  SetCollection.prototype = Object.create( Collection && Collection.prototype );\n  SetCollection.prototype.constructor = SetCollection;\n\n  return SetCollection;\n}(Collection));\n\nCollection.Keyed = KeyedCollection;\nCollection.Indexed = IndexedCollection;\nCollection.Set = SetCollection;\n\nvar ITERATE_KEYS = 0;\nvar ITERATE_VALUES = 1;\nvar ITERATE_ENTRIES = 2;\n\nvar REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nvar ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;\n\nvar Iterator = function Iterator(next) {\n  this.next = next;\n};\n\nIterator.prototype.toString = function toString () {\n  return '[Iterator]';\n};\n\nIterator.KEYS = ITERATE_KEYS;\nIterator.VALUES = ITERATE_VALUES;\nIterator.ENTRIES = ITERATE_ENTRIES;\n\nIterator.prototype.inspect = (Iterator.prototype.toSource = function() {\n  return this.toString();\n});\nIterator.prototype[ITERATOR_SYMBOL] = function() {\n  return this;\n};\n\nfunction iteratorValue(type, k, v, iteratorResult) {\n  var value = type === 0 ? k : type === 1 ? v : [k, v];\n  iteratorResult\n    ? (iteratorResult.value = value)\n    : (iteratorResult = {\n        value: value,\n        done: false\n      });\n  return iteratorResult;\n}\n\nfunction iteratorDone() {\n  return { value: undefined, done: true };\n}\n\nfunction hasIterator(maybeIterable) {\n  return !!getIteratorFn(maybeIterable);\n}\n\nfunction isIterator(maybeIterator) {\n  return maybeIterator && typeof maybeIterator.next === 'function';\n}\n\nfunction getIterator(iterable) {\n  var iteratorFn = getIteratorFn(iterable);\n  return iteratorFn && iteratorFn.call(iterable);\n}\n\nfunction getIteratorFn(iterable) {\n  var iteratorFn = iterable &&\n    ((REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||\n      iterable[FAUX_ITERATOR_SYMBOL]);\n  if (typeof iteratorFn === 'function') {\n    return iteratorFn;\n  }\n}\n\nfunction isArrayLike(value) {\n  return value && typeof value.length === 'number';\n}\n\nvar Seq = (function (Collection$$1) {\n  function Seq(value) {\n    return value === null || value === undefined\n      ? emptySequence()\n      : isCollection(value) || isRecord(value)\n          ? value.toSeq()\n          : seqFromValue(value);\n  }\n\n  if ( Collection$$1 ) Seq.__proto__ = Collection$$1;\n  Seq.prototype = Object.create( Collection$$1 && Collection$$1.prototype );\n  Seq.prototype.constructor = Seq;\n\n  Seq.of = function of (/*...values*/) {\n    return Seq(arguments);\n  };\n\n  Seq.prototype.toSeq = function toSeq () {\n    return this;\n  };\n\n  Seq.prototype.toString = function toString () {\n    return this.__toString('Seq {', '}');\n  };\n\n  Seq.prototype.cacheResult = function cacheResult () {\n    if (!this._cache && this.__iterateUncached) {\n      this._cache = this.entrySeq().toArray();\n      this.size = this._cache.length;\n    }\n    return this;\n  };\n\n  // abstract __iterateUncached(fn, reverse)\n\n  Seq.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    var cache = this._cache;\n    if (cache) {\n      var size = cache.length;\n      var i = 0;\n      while (i !== size) {\n        var entry = cache[reverse ? size - ++i : i++];\n        if (fn(entry[1], entry[0], this$1) === false) {\n          break;\n        }\n      }\n      return i;\n    }\n    return this.__iterateUncached(fn, reverse);\n  };\n\n  // abstract __iteratorUncached(type, reverse)\n\n  Seq.prototype.__iterator = function __iterator (type, reverse) {\n    var cache = this._cache;\n    if (cache) {\n      var size = cache.length;\n      var i = 0;\n      return new Iterator(function () {\n        if (i === size) {\n          return iteratorDone();\n        }\n        var entry = cache[reverse ? size - ++i : i++];\n        return iteratorValue(type, entry[0], entry[1]);\n      });\n    }\n    return this.__iteratorUncached(type, reverse);\n  };\n\n  return Seq;\n}(Collection));\n\nvar KeyedSeq = (function (Seq) {\n  function KeyedSeq(value) {\n    return value === null || value === undefined\n      ? emptySequence().toKeyedSeq()\n      : isCollection(value)\n          ? isKeyed(value) ? value.toSeq() : value.fromEntrySeq()\n          : isRecord(value) ? value.toSeq() : keyedSeqFromValue(value);\n  }\n\n  if ( Seq ) KeyedSeq.__proto__ = Seq;\n  KeyedSeq.prototype = Object.create( Seq && Seq.prototype );\n  KeyedSeq.prototype.constructor = KeyedSeq;\n\n  KeyedSeq.prototype.toKeyedSeq = function toKeyedSeq () {\n    return this;\n  };\n\n  return KeyedSeq;\n}(Seq));\n\nvar IndexedSeq = (function (Seq) {\n  function IndexedSeq(value) {\n    return value === null || value === undefined\n      ? emptySequence()\n      : isCollection(value)\n          ? isKeyed(value) ? value.entrySeq() : value.toIndexedSeq()\n          : isRecord(value)\n              ? value.toSeq().entrySeq()\n              : indexedSeqFromValue(value);\n  }\n\n  if ( Seq ) IndexedSeq.__proto__ = Seq;\n  IndexedSeq.prototype = Object.create( Seq && Seq.prototype );\n  IndexedSeq.prototype.constructor = IndexedSeq;\n\n  IndexedSeq.of = function of (/*...values*/) {\n    return IndexedSeq(arguments);\n  };\n\n  IndexedSeq.prototype.toIndexedSeq = function toIndexedSeq () {\n    return this;\n  };\n\n  IndexedSeq.prototype.toString = function toString () {\n    return this.__toString('Seq [', ']');\n  };\n\n  return IndexedSeq;\n}(Seq));\n\nvar SetSeq = (function (Seq) {\n  function SetSeq(value) {\n    return (isCollection(value) && !isAssociative(value)\n      ? value\n      : IndexedSeq(value)).toSetSeq();\n  }\n\n  if ( Seq ) SetSeq.__proto__ = Seq;\n  SetSeq.prototype = Object.create( Seq && Seq.prototype );\n  SetSeq.prototype.constructor = SetSeq;\n\n  SetSeq.of = function of (/*...values*/) {\n    return SetSeq(arguments);\n  };\n\n  SetSeq.prototype.toSetSeq = function toSetSeq () {\n    return this;\n  };\n\n  return SetSeq;\n}(Seq));\n\nSeq.isSeq = isSeq;\nSeq.Keyed = KeyedSeq;\nSeq.Set = SetSeq;\nSeq.Indexed = IndexedSeq;\n\nvar IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';\n\nSeq.prototype[IS_SEQ_SENTINEL] = true;\n\n// #pragma Root Sequences\n\nvar ArraySeq = (function (IndexedSeq) {\n  function ArraySeq(array) {\n    this._array = array;\n    this.size = array.length;\n  }\n\n  if ( IndexedSeq ) ArraySeq.__proto__ = IndexedSeq;\n  ArraySeq.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );\n  ArraySeq.prototype.constructor = ArraySeq;\n\n  ArraySeq.prototype.get = function get (index, notSetValue) {\n    return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;\n  };\n\n  ArraySeq.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    var array = this._array;\n    var size = array.length;\n    var i = 0;\n    while (i !== size) {\n      var ii = reverse ? size - ++i : i++;\n      if (fn(array[ii], ii, this$1) === false) {\n        break;\n      }\n    }\n    return i;\n  };\n\n  ArraySeq.prototype.__iterator = function __iterator (type, reverse) {\n    var array = this._array;\n    var size = array.length;\n    var i = 0;\n    return new Iterator(function () {\n      if (i === size) {\n        return iteratorDone();\n      }\n      var ii = reverse ? size - ++i : i++;\n      return iteratorValue(type, ii, array[ii]);\n    });\n  };\n\n  return ArraySeq;\n}(IndexedSeq));\n\nvar ObjectSeq = (function (KeyedSeq) {\n  function ObjectSeq(object) {\n    var keys = Object.keys(object);\n    this._object = object;\n    this._keys = keys;\n    this.size = keys.length;\n  }\n\n  if ( KeyedSeq ) ObjectSeq.__proto__ = KeyedSeq;\n  ObjectSeq.prototype = Object.create( KeyedSeq && KeyedSeq.prototype );\n  ObjectSeq.prototype.constructor = ObjectSeq;\n\n  ObjectSeq.prototype.get = function get (key, notSetValue) {\n    if (notSetValue !== undefined && !this.has(key)) {\n      return notSetValue;\n    }\n    return this._object[key];\n  };\n\n  ObjectSeq.prototype.has = function has (key) {\n    return this._object.hasOwnProperty(key);\n  };\n\n  ObjectSeq.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    var object = this._object;\n    var keys = this._keys;\n    var size = keys.length;\n    var i = 0;\n    while (i !== size) {\n      var key = keys[reverse ? size - ++i : i++];\n      if (fn(object[key], key, this$1) === false) {\n        break;\n      }\n    }\n    return i;\n  };\n\n  ObjectSeq.prototype.__iterator = function __iterator (type, reverse) {\n    var object = this._object;\n    var keys = this._keys;\n    var size = keys.length;\n    var i = 0;\n    return new Iterator(function () {\n      if (i === size) {\n        return iteratorDone();\n      }\n      var key = keys[reverse ? size - ++i : i++];\n      return iteratorValue(type, key, object[key]);\n    });\n  };\n\n  return ObjectSeq;\n}(KeyedSeq));\nObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;\n\nvar CollectionSeq = (function (IndexedSeq) {\n  function CollectionSeq(collection) {\n    this._collection = collection;\n    this.size = collection.length || collection.size;\n  }\n\n  if ( IndexedSeq ) CollectionSeq.__proto__ = IndexedSeq;\n  CollectionSeq.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );\n  CollectionSeq.prototype.constructor = CollectionSeq;\n\n  CollectionSeq.prototype.__iterateUncached = function __iterateUncached (fn, reverse) {\n    var this$1 = this;\n\n    if (reverse) {\n      return this.cacheResult().__iterate(fn, reverse);\n    }\n    var collection = this._collection;\n    var iterator = getIterator(collection);\n    var iterations = 0;\n    if (isIterator(iterator)) {\n      var step;\n      while (!(step = iterator.next()).done) {\n        if (fn(step.value, iterations++, this$1) === false) {\n          break;\n        }\n      }\n    }\n    return iterations;\n  };\n\n  CollectionSeq.prototype.__iteratorUncached = function __iteratorUncached (type, reverse) {\n    if (reverse) {\n      return this.cacheResult().__iterator(type, reverse);\n    }\n    var collection = this._collection;\n    var iterator = getIterator(collection);\n    if (!isIterator(iterator)) {\n      return new Iterator(iteratorDone);\n    }\n    var iterations = 0;\n    return new Iterator(function () {\n      var step = iterator.next();\n      return step.done ? step : iteratorValue(type, iterations++, step.value);\n    });\n  };\n\n  return CollectionSeq;\n}(IndexedSeq));\n\nvar IteratorSeq = (function (IndexedSeq) {\n  function IteratorSeq(iterator) {\n    this._iterator = iterator;\n    this._iteratorCache = [];\n  }\n\n  if ( IndexedSeq ) IteratorSeq.__proto__ = IndexedSeq;\n  IteratorSeq.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );\n  IteratorSeq.prototype.constructor = IteratorSeq;\n\n  IteratorSeq.prototype.__iterateUncached = function __iterateUncached (fn, reverse) {\n    var this$1 = this;\n\n    if (reverse) {\n      return this.cacheResult().__iterate(fn, reverse);\n    }\n    var iterator = this._iterator;\n    var cache = this._iteratorCache;\n    var iterations = 0;\n    while (iterations < cache.length) {\n      if (fn(cache[iterations], iterations++, this$1) === false) {\n        return iterations;\n      }\n    }\n    var step;\n    while (!(step = iterator.next()).done) {\n      var val = step.value;\n      cache[iterations] = val;\n      if (fn(val, iterations++, this$1) === false) {\n        break;\n      }\n    }\n    return iterations;\n  };\n\n  IteratorSeq.prototype.__iteratorUncached = function __iteratorUncached (type, reverse) {\n    if (reverse) {\n      return this.cacheResult().__iterator(type, reverse);\n    }\n    var iterator = this._iterator;\n    var cache = this._iteratorCache;\n    var iterations = 0;\n    return new Iterator(function () {\n      if (iterations >= cache.length) {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        cache[iterations] = step.value;\n      }\n      return iteratorValue(type, iterations, cache[iterations++]);\n    });\n  };\n\n  return IteratorSeq;\n}(IndexedSeq));\n\n// # pragma Helper functions\n\nfunction isSeq(maybeSeq) {\n  return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);\n}\n\nvar EMPTY_SEQ;\n\nfunction emptySequence() {\n  return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));\n}\n\nfunction keyedSeqFromValue(value) {\n  var seq = Array.isArray(value)\n    ? new ArraySeq(value)\n    : isIterator(value)\n        ? new IteratorSeq(value)\n        : hasIterator(value) ? new CollectionSeq(value) : undefined;\n  if (seq) {\n    return seq.fromEntrySeq();\n  }\n  if (typeof value === 'object') {\n    return new ObjectSeq(value);\n  }\n  throw new TypeError(\n    'Expected Array or collection object of [k, v] entries, or keyed object: ' +\n      value\n  );\n}\n\nfunction indexedSeqFromValue(value) {\n  var seq = maybeIndexedSeqFromValue(value);\n  if (seq) {\n    return seq;\n  }\n  throw new TypeError(\n    'Expected Array or collection object of values: ' + value\n  );\n}\n\nfunction seqFromValue(value) {\n  var seq = maybeIndexedSeqFromValue(value);\n  if (seq) {\n    return seq;\n  }\n  if (typeof value === 'object') {\n    return new ObjectSeq(value);\n  }\n  throw new TypeError(\n    'Expected Array or collection object of values, or keyed object: ' + value\n  );\n}\n\nfunction maybeIndexedSeqFromValue(value) {\n  return isArrayLike(value)\n    ? new ArraySeq(value)\n    : isIterator(value)\n        ? new IteratorSeq(value)\n        : hasIterator(value) ? new CollectionSeq(value) : undefined;\n}\n\n/**\n * An extension of the \"same-value\" algorithm as [described for use by ES6 Map\n * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)\n *\n * NaN is considered the same as NaN, however -0 and 0 are considered the same\n * value, which is different from the algorithm described by\n * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n *\n * This is extended further to allow Objects to describe the values they\n * represent, by way of `valueOf` or `equals` (and `hashCode`).\n *\n * Note: because of this extension, the key equality of Immutable.Map and the\n * value equality of Immutable.Set will differ from ES6 Map and Set.\n *\n * ### Defining custom values\n *\n * The easiest way to describe the value an object represents is by implementing\n * `valueOf`. For example, `Date` represents a value by returning a unix\n * timestamp for `valueOf`:\n *\n *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...\n *     var date2 = new Date(1234567890000);\n *     date1.valueOf(); // 1234567890000\n *     assert( date1 !== date2 );\n *     assert( Immutable.is( date1, date2 ) );\n *\n * Note: overriding `valueOf` may have other implications if you use this object\n * where JavaScript expects a primitive, such as implicit string coercion.\n *\n * For more complex types, especially collections, implementing `valueOf` may\n * not be performant. An alternative is to implement `equals` and `hashCode`.\n *\n * `equals` takes another object, presumably of similar type, and returns true\n * if it is equal. Equality is symmetrical, so the same result should be\n * returned if this and the argument are flipped.\n *\n *     assert( a.equals(b) === b.equals(a) );\n *\n * `hashCode` returns a 32bit integer number representing the object which will\n * be used to determine how to store the value object in a Map or Set. You must\n * provide both or neither methods, one must not exist without the other.\n *\n * Also, an important relationship between these methods must be upheld: if two\n * values are equal, they *must* return the same hashCode. If the values are not\n * equal, they might have the same hashCode; this is called a hash collision,\n * and while undesirable for performance reasons, it is acceptable.\n *\n *     if (a.equals(b)) {\n *       assert( a.hashCode() === b.hashCode() );\n *     }\n *\n * All Immutable collections are Value Objects: they implement `equals()`\n * and `hashCode()`.\n */\nfunction is(valueA, valueB) {\n  if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n    return true;\n  }\n  if (!valueA || !valueB) {\n    return false;\n  }\n  if (\n    typeof valueA.valueOf === 'function' && typeof valueB.valueOf === 'function'\n  ) {\n    valueA = valueA.valueOf();\n    valueB = valueB.valueOf();\n    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n      return true;\n    }\n    if (!valueA || !valueB) {\n      return false;\n    }\n  }\n  return !!(isValueObject(valueA) &&\n    isValueObject(valueB) &&\n    valueA.equals(valueB));\n}\n\nfunction fromJS(value, converter) {\n  return fromJSWith(\n    [],\n    converter || defaultConverter,\n    value,\n    '',\n    converter && converter.length > 2 ? [] : undefined,\n    { '': value }\n  );\n}\n\nfunction fromJSWith(stack, converter, value, key, keyPath, parentValue) {\n  var toSeq = Array.isArray(value)\n    ? IndexedSeq\n    : isPlainObj(value) ? KeyedSeq : null;\n  if (toSeq) {\n    if (~stack.indexOf(value)) {\n      throw new TypeError('Cannot convert circular structure to Immutable');\n    }\n    stack.push(value);\n    keyPath && key !== '' && keyPath.push(key);\n    var converted = converter.call(\n      parentValue,\n      key,\n      toSeq(value).map(function (v, k) { return fromJSWith(stack, converter, v, k, keyPath, value); }),\n      keyPath && keyPath.slice()\n    );\n    stack.pop();\n    keyPath && keyPath.pop();\n    return converted;\n  }\n  return value;\n}\n\nfunction defaultConverter(k, v) {\n  return isKeyed(v) ? v.toMap() : v.toList();\n}\n\nfunction isPlainObj(value) {\n  return value &&\n    (value.constructor === Object || value.constructor === undefined);\n}\n\nvar imul = typeof Math.imul === 'function' &&\n  Math.imul(0xffffffff, 2) === -2\n  ? Math.imul\n  : function imul(a, b) {\n      a |= 0; // int\n      b |= 0; // int\n      var c = a & 0xffff;\n      var d = b & 0xffff;\n      // Shift by 0 fixes the sign on the high part.\n      return c * d + ((a >>> 16) * d + c * (b >>> 16) << 16 >>> 0) | 0; // int\n    };\n\n// v8 has an optimization for storing 31-bit signed numbers.\n// Values which have either 00 or 11 as the high order bits qualify.\n// This function drops the highest order bit in a signed number, maintaining\n// the sign bit.\nfunction smi(i32) {\n  return i32 >>> 1 & 0x40000000 | i32 & 0xbfffffff;\n}\n\nfunction hash(o) {\n  if (o === false || o === null || o === undefined) {\n    return 0;\n  }\n  if (typeof o.valueOf === 'function') {\n    o = o.valueOf();\n    if (o === false || o === null || o === undefined) {\n      return 0;\n    }\n  }\n  if (o === true) {\n    return 1;\n  }\n  var type = typeof o;\n  if (type === 'number') {\n    if (o !== o || o === Infinity) {\n      return 0;\n    }\n    var h = o | 0;\n    if (h !== o) {\n      h ^= o * 0xffffffff;\n    }\n    while (o > 0xffffffff) {\n      o /= 0xffffffff;\n      h ^= o;\n    }\n    return smi(h);\n  }\n  if (type === 'string') {\n    return o.length > STRING_HASH_CACHE_MIN_STRLEN\n      ? cachedHashString(o)\n      : hashString(o);\n  }\n  if (typeof o.hashCode === 'function') {\n    return o.hashCode();\n  }\n  if (type === 'object') {\n    return hashJSObj(o);\n  }\n  if (typeof o.toString === 'function') {\n    return hashString(o.toString());\n  }\n  throw new Error('Value type ' + type + ' cannot be hashed.');\n}\n\nfunction cachedHashString(string) {\n  var hash = stringHashCache[string];\n  if (hash === undefined) {\n    hash = hashString(string);\n    if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {\n      STRING_HASH_CACHE_SIZE = 0;\n      stringHashCache = {};\n    }\n    STRING_HASH_CACHE_SIZE++;\n    stringHashCache[string] = hash;\n  }\n  return hash;\n}\n\n// http://jsperf.com/hashing-strings\nfunction hashString(string) {\n  // This is the hash from JVM\n  // The hash code for a string is computed as\n  // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\n  // where s[i] is the ith character of the string and n is the length of\n  // the string. We \"mod\" the result to make it between 0 (inclusive) and 2^31\n  // (exclusive) by dropping high bits.\n  var hash = 0;\n  for (var ii = 0; ii < string.length; ii++) {\n    hash = 31 * hash + string.charCodeAt(ii) | 0;\n  }\n  return smi(hash);\n}\n\nfunction hashJSObj(obj) {\n  var hash;\n  if (usingWeakMap) {\n    hash = weakMap.get(obj);\n    if (hash !== undefined) {\n      return hash;\n    }\n  }\n\n  hash = obj[UID_HASH_KEY];\n  if (hash !== undefined) {\n    return hash;\n  }\n\n  if (!canDefineProperty) {\n    hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];\n    if (hash !== undefined) {\n      return hash;\n    }\n\n    hash = getIENodeHash(obj);\n    if (hash !== undefined) {\n      return hash;\n    }\n  }\n\n  hash = ++objHashUID;\n  if (objHashUID & 0x40000000) {\n    objHashUID = 0;\n  }\n\n  if (usingWeakMap) {\n    weakMap.set(obj, hash);\n  } else if (isExtensible !== undefined && isExtensible(obj) === false) {\n    throw new Error('Non-extensible objects are not allowed as keys.');\n  } else if (canDefineProperty) {\n    Object.defineProperty(obj, UID_HASH_KEY, {\n      enumerable: false,\n      configurable: false,\n      writable: false,\n      value: hash\n    });\n  } else if (\n    obj.propertyIsEnumerable !== undefined &&\n    obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable\n  ) {\n    // Since we can't define a non-enumerable property on the object\n    // we'll hijack one of the less-used non-enumerable properties to\n    // save our hash on it. Since this is a function it will not show up in\n    // `JSON.stringify` which is what we want.\n    obj.propertyIsEnumerable = function() {\n      return this.constructor.prototype.propertyIsEnumerable.apply(\n        this,\n        arguments\n      );\n    };\n    obj.propertyIsEnumerable[UID_HASH_KEY] = hash;\n  } else if (obj.nodeType !== undefined) {\n    // At this point we couldn't get the IE `uniqueID` to use as a hash\n    // and we couldn't use a non-enumerable property to exploit the\n    // dontEnum bug so we simply add the `UID_HASH_KEY` on the node\n    // itself.\n    obj[UID_HASH_KEY] = hash;\n  } else {\n    throw new Error('Unable to set a non-enumerable property on object.');\n  }\n\n  return hash;\n}\n\n// Get references to ES5 object methods.\nvar isExtensible = Object.isExtensible;\n\n// True if Object.defineProperty works as expected. IE8 fails this test.\nvar canDefineProperty = (function() {\n  try {\n    Object.defineProperty({}, '@', {});\n    return true;\n  } catch (e) {\n    return false;\n  }\n})();\n\n// IE has a `uniqueID` property on DOM nodes. We can construct the hash from it\n// and avoid memory leaks from the IE cloneNode bug.\nfunction getIENodeHash(node) {\n  if (node && node.nodeType > 0) {\n    switch (node.nodeType) {\n      case 1: // Element\n        return node.uniqueID;\n      case 9: // Document\n        return node.documentElement && node.documentElement.uniqueID;\n    }\n  }\n}\n\n// If possible, use a WeakMap.\nvar usingWeakMap = typeof WeakMap === 'function';\nvar weakMap;\nif (usingWeakMap) {\n  weakMap = new WeakMap();\n}\n\nvar objHashUID = 0;\n\nvar UID_HASH_KEY = '__immutablehash__';\nif (typeof Symbol === 'function') {\n  UID_HASH_KEY = Symbol(UID_HASH_KEY);\n}\n\nvar STRING_HASH_CACHE_MIN_STRLEN = 16;\nvar STRING_HASH_CACHE_MAX_SIZE = 255;\nvar STRING_HASH_CACHE_SIZE = 0;\nvar stringHashCache = {};\n\nvar ToKeyedSequence = (function (KeyedSeq$$1) {\n  function ToKeyedSequence(indexed, useKeys) {\n    this._iter = indexed;\n    this._useKeys = useKeys;\n    this.size = indexed.size;\n  }\n\n  if ( KeyedSeq$$1 ) ToKeyedSequence.__proto__ = KeyedSeq$$1;\n  ToKeyedSequence.prototype = Object.create( KeyedSeq$$1 && KeyedSeq$$1.prototype );\n  ToKeyedSequence.prototype.constructor = ToKeyedSequence;\n\n  ToKeyedSequence.prototype.get = function get (key, notSetValue) {\n    return this._iter.get(key, notSetValue);\n  };\n\n  ToKeyedSequence.prototype.has = function has (key) {\n    return this._iter.has(key);\n  };\n\n  ToKeyedSequence.prototype.valueSeq = function valueSeq () {\n    return this._iter.valueSeq();\n  };\n\n  ToKeyedSequence.prototype.reverse = function reverse () {\n    var this$1 = this;\n\n    var reversedSequence = reverseFactory(this, true);\n    if (!this._useKeys) {\n      reversedSequence.valueSeq = function () { return this$1._iter.toSeq().reverse(); };\n    }\n    return reversedSequence;\n  };\n\n  ToKeyedSequence.prototype.map = function map (mapper, context) {\n    var this$1 = this;\n\n    var mappedSequence = mapFactory(this, mapper, context);\n    if (!this._useKeys) {\n      mappedSequence.valueSeq = function () { return this$1._iter.toSeq().map(mapper, context); };\n    }\n    return mappedSequence;\n  };\n\n  ToKeyedSequence.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    return this._iter.__iterate(function (v, k) { return fn(v, k, this$1); }, reverse);\n  };\n\n  ToKeyedSequence.prototype.__iterator = function __iterator (type, reverse) {\n    return this._iter.__iterator(type, reverse);\n  };\n\n  return ToKeyedSequence;\n}(KeyedSeq));\nToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;\n\nvar ToIndexedSequence = (function (IndexedSeq$$1) {\n  function ToIndexedSequence(iter) {\n    this._iter = iter;\n    this.size = iter.size;\n  }\n\n  if ( IndexedSeq$$1 ) ToIndexedSequence.__proto__ = IndexedSeq$$1;\n  ToIndexedSequence.prototype = Object.create( IndexedSeq$$1 && IndexedSeq$$1.prototype );\n  ToIndexedSequence.prototype.constructor = ToIndexedSequence;\n\n  ToIndexedSequence.prototype.includes = function includes (value) {\n    return this._iter.includes(value);\n  };\n\n  ToIndexedSequence.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    var i = 0;\n    reverse && ensureSize(this);\n    return this._iter.__iterate(\n      function (v) { return fn(v, reverse ? this$1.size - ++i : i++, this$1); },\n      reverse\n    );\n  };\n\n  ToIndexedSequence.prototype.__iterator = function __iterator (type, reverse) {\n    var this$1 = this;\n\n    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n    var i = 0;\n    reverse && ensureSize(this);\n    return new Iterator(function () {\n      var step = iterator.next();\n      return step.done\n        ? step\n        : iteratorValue(\n            type,\n            reverse ? this$1.size - ++i : i++,\n            step.value,\n            step\n          );\n    });\n  };\n\n  return ToIndexedSequence;\n}(IndexedSeq));\n\nvar ToSetSequence = (function (SetSeq$$1) {\n  function ToSetSequence(iter) {\n    this._iter = iter;\n    this.size = iter.size;\n  }\n\n  if ( SetSeq$$1 ) ToSetSequence.__proto__ = SetSeq$$1;\n  ToSetSequence.prototype = Object.create( SetSeq$$1 && SetSeq$$1.prototype );\n  ToSetSequence.prototype.constructor = ToSetSequence;\n\n  ToSetSequence.prototype.has = function has (key) {\n    return this._iter.includes(key);\n  };\n\n  ToSetSequence.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    return this._iter.__iterate(function (v) { return fn(v, v, this$1); }, reverse);\n  };\n\n  ToSetSequence.prototype.__iterator = function __iterator (type, reverse) {\n    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n    return new Iterator(function () {\n      var step = iterator.next();\n      return step.done\n        ? step\n        : iteratorValue(type, step.value, step.value, step);\n    });\n  };\n\n  return ToSetSequence;\n}(SetSeq));\n\nvar FromEntriesSequence = (function (KeyedSeq$$1) {\n  function FromEntriesSequence(entries) {\n    this._iter = entries;\n    this.size = entries.size;\n  }\n\n  if ( KeyedSeq$$1 ) FromEntriesSequence.__proto__ = KeyedSeq$$1;\n  FromEntriesSequence.prototype = Object.create( KeyedSeq$$1 && KeyedSeq$$1.prototype );\n  FromEntriesSequence.prototype.constructor = FromEntriesSequence;\n\n  FromEntriesSequence.prototype.entrySeq = function entrySeq () {\n    return this._iter.toSeq();\n  };\n\n  FromEntriesSequence.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    return this._iter.__iterate(\n      function (entry) {\n        // Check if entry exists first so array access doesn't throw for holes\n        // in the parent iteration.\n        if (entry) {\n          validateEntry(entry);\n          var indexedCollection = isCollection(entry);\n          return fn(\n            indexedCollection ? entry.get(1) : entry[1],\n            indexedCollection ? entry.get(0) : entry[0],\n            this$1\n          );\n        }\n      },\n      reverse\n    );\n  };\n\n  FromEntriesSequence.prototype.__iterator = function __iterator (type, reverse) {\n    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n    return new Iterator(function () {\n      while (true) {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        // Check if entry exists first so array access doesn't throw for holes\n        // in the parent iteration.\n        if (entry) {\n          validateEntry(entry);\n          var indexedCollection = isCollection(entry);\n          return iteratorValue(\n            type,\n            indexedCollection ? entry.get(0) : entry[0],\n            indexedCollection ? entry.get(1) : entry[1],\n            step\n          );\n        }\n      }\n    });\n  };\n\n  return FromEntriesSequence;\n}(KeyedSeq));\n\nToIndexedSequence.prototype.cacheResult = (ToKeyedSequence.prototype.cacheResult = (ToSetSequence.prototype.cacheResult = (FromEntriesSequence.prototype.cacheResult = cacheResultThrough)));\n\nfunction flipFactory(collection) {\n  var flipSequence = makeSequence(collection);\n  flipSequence._iter = collection;\n  flipSequence.size = collection.size;\n  flipSequence.flip = function () { return collection; };\n  flipSequence.reverse = function() {\n    var reversedSequence = collection.reverse.apply(this); // super.reverse()\n    reversedSequence.flip = function () { return collection.reverse(); };\n    return reversedSequence;\n  };\n  flipSequence.has = function (key) { return collection.includes(key); };\n  flipSequence.includes = function (key) { return collection.has(key); };\n  flipSequence.cacheResult = cacheResultThrough;\n  flipSequence.__iterateUncached = function(fn, reverse) {\n    var this$1 = this;\n\n    return collection.__iterate(function (v, k) { return fn(k, v, this$1) !== false; }, reverse);\n  };\n  flipSequence.__iteratorUncached = function(type, reverse) {\n    if (type === ITERATE_ENTRIES) {\n      var iterator = collection.__iterator(type, reverse);\n      return new Iterator(function () {\n        var step = iterator.next();\n        if (!step.done) {\n          var k = step.value[0];\n          step.value[0] = step.value[1];\n          step.value[1] = k;\n        }\n        return step;\n      });\n    }\n    return collection.__iterator(\n      type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,\n      reverse\n    );\n  };\n  return flipSequence;\n}\n\nfunction mapFactory(collection, mapper, context) {\n  var mappedSequence = makeSequence(collection);\n  mappedSequence.size = collection.size;\n  mappedSequence.has = function (key) { return collection.has(key); };\n  mappedSequence.get = function (key, notSetValue) {\n    var v = collection.get(key, NOT_SET);\n    return v === NOT_SET\n      ? notSetValue\n      : mapper.call(context, v, key, collection);\n  };\n  mappedSequence.__iterateUncached = function(fn, reverse) {\n    var this$1 = this;\n\n    return collection.__iterate(\n      function (v, k, c) { return fn(mapper.call(context, v, k, c), k, this$1) !== false; },\n      reverse\n    );\n  };\n  mappedSequence.__iteratorUncached = function(type, reverse) {\n    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n    return new Iterator(function () {\n      var step = iterator.next();\n      if (step.done) {\n        return step;\n      }\n      var entry = step.value;\n      var key = entry[0];\n      return iteratorValue(\n        type,\n        key,\n        mapper.call(context, entry[1], key, collection),\n        step\n      );\n    });\n  };\n  return mappedSequence;\n}\n\nfunction reverseFactory(collection, useKeys) {\n  var this$1 = this;\n\n  var reversedSequence = makeSequence(collection);\n  reversedSequence._iter = collection;\n  reversedSequence.size = collection.size;\n  reversedSequence.reverse = function () { return collection; };\n  if (collection.flip) {\n    reversedSequence.flip = function() {\n      var flipSequence = flipFactory(collection);\n      flipSequence.reverse = function () { return collection.flip(); };\n      return flipSequence;\n    };\n  }\n  reversedSequence.get = function (key, notSetValue) { return collection.get(useKeys ? key : -1 - key, notSetValue); };\n  reversedSequence.has = function (key) { return collection.has(useKeys ? key : -1 - key); };\n  reversedSequence.includes = function (value) { return collection.includes(value); };\n  reversedSequence.cacheResult = cacheResultThrough;\n  reversedSequence.__iterate = function(fn, reverse) {\n    var this$1 = this;\n\n    var i = 0;\n    reverse && ensureSize(collection);\n    return collection.__iterate(\n      function (v, k) { return fn(v, useKeys ? k : reverse ? this$1.size - ++i : i++, this$1); },\n      !reverse\n    );\n  };\n  reversedSequence.__iterator = function (type, reverse) {\n    var i = 0;\n    reverse && ensureSize(collection);\n    var iterator = collection.__iterator(ITERATE_ENTRIES, !reverse);\n    return new Iterator(function () {\n      var step = iterator.next();\n      if (step.done) {\n        return step;\n      }\n      var entry = step.value;\n      return iteratorValue(\n        type,\n        useKeys ? entry[0] : reverse ? this$1.size - ++i : i++,\n        entry[1],\n        step\n      );\n    });\n  };\n  return reversedSequence;\n}\n\nfunction filterFactory(collection, predicate, context, useKeys) {\n  var filterSequence = makeSequence(collection);\n  if (useKeys) {\n    filterSequence.has = function (key) {\n      var v = collection.get(key, NOT_SET);\n      return v !== NOT_SET && !!predicate.call(context, v, key, collection);\n    };\n    filterSequence.get = function (key, notSetValue) {\n      var v = collection.get(key, NOT_SET);\n      return v !== NOT_SET && predicate.call(context, v, key, collection)\n        ? v\n        : notSetValue;\n    };\n  }\n  filterSequence.__iterateUncached = function(fn, reverse) {\n    var this$1 = this;\n\n    var iterations = 0;\n    collection.__iterate(\n      function (v, k, c) {\n        if (predicate.call(context, v, k, c)) {\n          return fn(v, useKeys ? k : iterations++, this$1);\n        }\n      },\n      reverse\n    );\n    return iterations;\n  };\n  filterSequence.__iteratorUncached = function(type, reverse) {\n    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n    var iterations = 0;\n    return new Iterator(function () {\n      while (true) {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var key = entry[0];\n        var value = entry[1];\n        if (predicate.call(context, value, key, collection)) {\n          return iteratorValue(type, useKeys ? key : iterations++, value, step);\n        }\n      }\n    });\n  };\n  return filterSequence;\n}\n\nfunction countByFactory(collection, grouper, context) {\n  var groups = Map().asMutable();\n  collection.__iterate(function (v, k) {\n    groups.update(grouper.call(context, v, k, collection), 0, function (a) { return a + 1; });\n  });\n  return groups.asImmutable();\n}\n\nfunction groupByFactory(collection, grouper, context) {\n  var isKeyedIter = isKeyed(collection);\n  var groups = (isOrdered(collection) ? OrderedMap() : Map()).asMutable();\n  collection.__iterate(function (v, k) {\n    groups.update(\n      grouper.call(context, v, k, collection),\n      function (a) { return ((a = a || []), a.push(isKeyedIter ? [k, v] : v), a); }\n    );\n  });\n  var coerce = collectionClass(collection);\n  return groups.map(function (arr) { return reify(collection, coerce(arr)); });\n}\n\nfunction sliceFactory(collection, begin, end, useKeys) {\n  var originalSize = collection.size;\n\n  if (wholeSlice(begin, end, originalSize)) {\n    return collection;\n  }\n\n  var resolvedBegin = resolveBegin(begin, originalSize);\n  var resolvedEnd = resolveEnd(end, originalSize);\n\n  // begin or end will be NaN if they were provided as negative numbers and\n  // this collection's size is unknown. In that case, cache first so there is\n  // a known size and these do not resolve to NaN.\n  if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {\n    return sliceFactory(collection.toSeq().cacheResult(), begin, end, useKeys);\n  }\n\n  // Note: resolvedEnd is undefined when the original sequence's length is\n  // unknown and this slice did not supply an end and should contain all\n  // elements after resolvedBegin.\n  // In that case, resolvedSize will be NaN and sliceSize will remain undefined.\n  var resolvedSize = resolvedEnd - resolvedBegin;\n  var sliceSize;\n  if (resolvedSize === resolvedSize) {\n    sliceSize = resolvedSize < 0 ? 0 : resolvedSize;\n  }\n\n  var sliceSeq = makeSequence(collection);\n\n  // If collection.size is undefined, the size of the realized sliceSeq is\n  // unknown at this point unless the number of items to slice is 0\n  sliceSeq.size = sliceSize === 0\n    ? sliceSize\n    : (collection.size && sliceSize) || undefined;\n\n  if (!useKeys && isSeq(collection) && sliceSize >= 0) {\n    sliceSeq.get = function(index, notSetValue) {\n      index = wrapIndex(this, index);\n      return index >= 0 && index < sliceSize\n        ? collection.get(index + resolvedBegin, notSetValue)\n        : notSetValue;\n    };\n  }\n\n  sliceSeq.__iterateUncached = function(fn, reverse) {\n    var this$1 = this;\n\n    if (sliceSize === 0) {\n      return 0;\n    }\n    if (reverse) {\n      return this.cacheResult().__iterate(fn, reverse);\n    }\n    var skipped = 0;\n    var isSkipping = true;\n    var iterations = 0;\n    collection.__iterate(function (v, k) {\n      if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {\n        iterations++;\n        return fn(v, useKeys ? k : iterations - 1, this$1) !== false &&\n          iterations !== sliceSize;\n      }\n    });\n    return iterations;\n  };\n\n  sliceSeq.__iteratorUncached = function(type, reverse) {\n    if (sliceSize !== 0 && reverse) {\n      return this.cacheResult().__iterator(type, reverse);\n    }\n    // Don't bother instantiating parent iterator if taking 0.\n    var iterator = sliceSize !== 0 && collection.__iterator(type, reverse);\n    var skipped = 0;\n    var iterations = 0;\n    return new Iterator(function () {\n      while (skipped++ < resolvedBegin) {\n        iterator.next();\n      }\n      if (++iterations > sliceSize) {\n        return iteratorDone();\n      }\n      var step = iterator.next();\n      if (useKeys || type === ITERATE_VALUES) {\n        return step;\n      }\n      if (type === ITERATE_KEYS) {\n        return iteratorValue(type, iterations - 1, undefined, step);\n      }\n      return iteratorValue(type, iterations - 1, step.value[1], step);\n    });\n  };\n\n  return sliceSeq;\n}\n\nfunction takeWhileFactory(collection, predicate, context) {\n  var takeSequence = makeSequence(collection);\n  takeSequence.__iterateUncached = function(fn, reverse) {\n    var this$1 = this;\n\n    if (reverse) {\n      return this.cacheResult().__iterate(fn, reverse);\n    }\n    var iterations = 0;\n    collection.__iterate(\n      function (v, k, c) { return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$1); }\n    );\n    return iterations;\n  };\n  takeSequence.__iteratorUncached = function(type, reverse) {\n    var this$1 = this;\n\n    if (reverse) {\n      return this.cacheResult().__iterator(type, reverse);\n    }\n    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n    var iterating = true;\n    return new Iterator(function () {\n      if (!iterating) {\n        return iteratorDone();\n      }\n      var step = iterator.next();\n      if (step.done) {\n        return step;\n      }\n      var entry = step.value;\n      var k = entry[0];\n      var v = entry[1];\n      if (!predicate.call(context, v, k, this$1)) {\n        iterating = false;\n        return iteratorDone();\n      }\n      return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);\n    });\n  };\n  return takeSequence;\n}\n\nfunction skipWhileFactory(collection, predicate, context, useKeys) {\n  var skipSequence = makeSequence(collection);\n  skipSequence.__iterateUncached = function(fn, reverse) {\n    var this$1 = this;\n\n    if (reverse) {\n      return this.cacheResult().__iterate(fn, reverse);\n    }\n    var isSkipping = true;\n    var iterations = 0;\n    collection.__iterate(function (v, k, c) {\n      if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {\n        iterations++;\n        return fn(v, useKeys ? k : iterations - 1, this$1);\n      }\n    });\n    return iterations;\n  };\n  skipSequence.__iteratorUncached = function(type, reverse) {\n    var this$1 = this;\n\n    if (reverse) {\n      return this.cacheResult().__iterator(type, reverse);\n    }\n    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n    var skipping = true;\n    var iterations = 0;\n    return new Iterator(function () {\n      var step;\n      var k;\n      var v;\n      do {\n        step = iterator.next();\n        if (step.done) {\n          if (useKeys || type === ITERATE_VALUES) {\n            return step;\n          }\n          if (type === ITERATE_KEYS) {\n            return iteratorValue(type, iterations++, undefined, step);\n          }\n          return iteratorValue(type, iterations++, step.value[1], step);\n        }\n        var entry = step.value;\n        k = entry[0];\n        v = entry[1];\n        skipping && (skipping = predicate.call(context, v, k, this$1));\n      } while (skipping);\n      return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);\n    });\n  };\n  return skipSequence;\n}\n\nfunction concatFactory(collection, values) {\n  var isKeyedCollection = isKeyed(collection);\n  var iters = [collection]\n    .concat(values)\n    .map(function (v) {\n      if (!isCollection(v)) {\n        v = isKeyedCollection\n          ? keyedSeqFromValue(v)\n          : indexedSeqFromValue(Array.isArray(v) ? v : [v]);\n      } else if (isKeyedCollection) {\n        v = KeyedCollection(v);\n      }\n      return v;\n    })\n    .filter(function (v) { return v.size !== 0; });\n\n  if (iters.length === 0) {\n    return collection;\n  }\n\n  if (iters.length === 1) {\n    var singleton = iters[0];\n    if (\n      singleton === collection ||\n      (isKeyedCollection && isKeyed(singleton)) ||\n      (isIndexed(collection) && isIndexed(singleton))\n    ) {\n      return singleton;\n    }\n  }\n\n  var concatSeq = new ArraySeq(iters);\n  if (isKeyedCollection) {\n    concatSeq = concatSeq.toKeyedSeq();\n  } else if (!isIndexed(collection)) {\n    concatSeq = concatSeq.toSetSeq();\n  }\n  concatSeq = concatSeq.flatten(true);\n  concatSeq.size = iters.reduce(\n    function (sum, seq) {\n      if (sum !== undefined) {\n        var size = seq.size;\n        if (size !== undefined) {\n          return sum + size;\n        }\n      }\n    },\n    0\n  );\n  return concatSeq;\n}\n\nfunction flattenFactory(collection, depth, useKeys) {\n  var flatSequence = makeSequence(collection);\n  flatSequence.__iterateUncached = function(fn, reverse) {\n    if (reverse) {\n      return this.cacheResult().__iterate(fn, reverse);\n    }\n    var iterations = 0;\n    var stopped = false;\n    function flatDeep(iter, currentDepth) {\n      iter.__iterate(\n        function (v, k) {\n          if ((!depth || currentDepth < depth) && isCollection(v)) {\n            flatDeep(v, currentDepth + 1);\n          } else if (\n            fn(v, useKeys ? k : iterations++, flatSequence) === false\n          ) {\n            stopped = true;\n          }\n          return !stopped;\n        },\n        reverse\n      );\n    }\n    flatDeep(collection, 0);\n    return iterations;\n  };\n  flatSequence.__iteratorUncached = function(type, reverse) {\n    if (reverse) {\n      return this.cacheResult().__iterator(type, reverse);\n    }\n    var iterator = collection.__iterator(type, reverse);\n    var stack = [];\n    var iterations = 0;\n    return new Iterator(function () {\n      while (iterator) {\n        var step = iterator.next();\n        if (step.done !== false) {\n          iterator = stack.pop();\n          continue;\n        }\n        var v = step.value;\n        if (type === ITERATE_ENTRIES) {\n          v = v[1];\n        }\n        if ((!depth || stack.length < depth) && isCollection(v)) {\n          stack.push(iterator);\n          iterator = v.__iterator(type, reverse);\n        } else {\n          return useKeys ? step : iteratorValue(type, iterations++, v, step);\n        }\n      }\n      return iteratorDone();\n    });\n  };\n  return flatSequence;\n}\n\nfunction flatMapFactory(collection, mapper, context) {\n  var coerce = collectionClass(collection);\n  return collection\n    .toSeq()\n    .map(function (v, k) { return coerce(mapper.call(context, v, k, collection)); })\n    .flatten(true);\n}\n\nfunction interposeFactory(collection, separator) {\n  var interposedSequence = makeSequence(collection);\n  interposedSequence.size = collection.size && collection.size * 2 - 1;\n  interposedSequence.__iterateUncached = function(fn, reverse) {\n    var this$1 = this;\n\n    var iterations = 0;\n    collection.__iterate(\n      function (v) { return (!iterations || fn(separator, iterations++, this$1) !== false) &&\n        fn(v, iterations++, this$1) !== false; },\n      reverse\n    );\n    return iterations;\n  };\n  interposedSequence.__iteratorUncached = function(type, reverse) {\n    var iterator = collection.__iterator(ITERATE_VALUES, reverse);\n    var iterations = 0;\n    var step;\n    return new Iterator(function () {\n      if (!step || iterations % 2) {\n        step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n      }\n      return iterations % 2\n        ? iteratorValue(type, iterations++, separator)\n        : iteratorValue(type, iterations++, step.value, step);\n    });\n  };\n  return interposedSequence;\n}\n\nfunction sortFactory(collection, comparator, mapper) {\n  if (!comparator) {\n    comparator = defaultComparator;\n  }\n  var isKeyedCollection = isKeyed(collection);\n  var index = 0;\n  var entries = collection\n    .toSeq()\n    .map(function (v, k) { return [k, v, index++, mapper ? mapper(v, k, collection) : v]; })\n    .toArray();\n  entries.sort(function (a, b) { return comparator(a[3], b[3]) || a[2] - b[2]; }).forEach(\n    isKeyedCollection\n      ? function (v, i) {\n          entries[i].length = 2;\n        }\n      : function (v, i) {\n          entries[i] = v[1];\n        }\n  );\n  return isKeyedCollection\n    ? KeyedSeq(entries)\n    : isIndexed(collection) ? IndexedSeq(entries) : SetSeq(entries);\n}\n\nfunction maxFactory(collection, comparator, mapper) {\n  if (!comparator) {\n    comparator = defaultComparator;\n  }\n  if (mapper) {\n    var entry = collection\n      .toSeq()\n      .map(function (v, k) { return [v, mapper(v, k, collection)]; })\n      .reduce(function (a, b) { return maxCompare(comparator, a[1], b[1]) ? b : a; });\n    return entry && entry[0];\n  }\n  return collection.reduce(function (a, b) { return maxCompare(comparator, a, b) ? b : a; });\n}\n\nfunction maxCompare(comparator, a, b) {\n  var comp = comparator(b, a);\n  // b is considered the new max if the comparator declares them equal, but\n  // they are not equal and b is in fact a nullish value.\n  return (comp === 0 &&\n    b !== a &&\n    (b === undefined || b === null || b !== b)) ||\n    comp > 0;\n}\n\nfunction zipWithFactory(keyIter, zipper, iters) {\n  var zipSequence = makeSequence(keyIter);\n  zipSequence.size = new ArraySeq(iters).map(function (i) { return i.size; }).min();\n  // Note: this a generic base implementation of __iterate in terms of\n  // __iterator which may be more generically useful in the future.\n  zipSequence.__iterate = function(fn, reverse) {\n    var this$1 = this;\n\n    /* generic:\n    var iterator = this.__iterator(ITERATE_ENTRIES, reverse);\n    var step;\n    var iterations = 0;\n    while (!(step = iterator.next()).done) {\n      iterations++;\n      if (fn(step.value[1], step.value[0], this) === false) {\n        break;\n      }\n    }\n    return iterations;\n    */\n    // indexed:\n    var iterator = this.__iterator(ITERATE_VALUES, reverse);\n    var step;\n    var iterations = 0;\n    while (!(step = iterator.next()).done) {\n      if (fn(step.value, iterations++, this$1) === false) {\n        break;\n      }\n    }\n    return iterations;\n  };\n  zipSequence.__iteratorUncached = function(type, reverse) {\n    var iterators = iters.map(\n      function (i) { return ((i = Collection(i)), getIterator(reverse ? i.reverse() : i)); }\n    );\n    var iterations = 0;\n    var isDone = false;\n    return new Iterator(function () {\n      var steps;\n      if (!isDone) {\n        steps = iterators.map(function (i) { return i.next(); });\n        isDone = steps.some(function (s) { return s.done; });\n      }\n      if (isDone) {\n        return iteratorDone();\n      }\n      return iteratorValue(\n        type,\n        iterations++,\n        zipper.apply(null, steps.map(function (s) { return s.value; }))\n      );\n    });\n  };\n  return zipSequence;\n}\n\n// #pragma Helper Functions\n\nfunction reify(iter, seq) {\n  return iter === seq ? iter : isSeq(iter) ? seq : iter.constructor(seq);\n}\n\nfunction validateEntry(entry) {\n  if (entry !== Object(entry)) {\n    throw new TypeError('Expected [K, V] tuple: ' + entry);\n  }\n}\n\nfunction collectionClass(collection) {\n  return isKeyed(collection)\n    ? KeyedCollection\n    : isIndexed(collection) ? IndexedCollection : SetCollection;\n}\n\nfunction makeSequence(collection) {\n  return Object.create(\n    (isKeyed(collection)\n      ? KeyedSeq\n      : isIndexed(collection) ? IndexedSeq : SetSeq).prototype\n  );\n}\n\nfunction cacheResultThrough() {\n  if (this._iter.cacheResult) {\n    this._iter.cacheResult();\n    this.size = this._iter.size;\n    return this;\n  }\n  return Seq.prototype.cacheResult.call(this);\n}\n\nfunction defaultComparator(a, b) {\n  if (a === undefined && b === undefined) {\n    return 0;\n  }\n\n  if (a === undefined) {\n    return 1;\n  }\n\n  if (b === undefined) {\n    return -1;\n  }\n\n  return a > b ? 1 : a < b ? -1 : 0;\n}\n\nfunction coerceKeyPath(keyPath) {\n  if (isArrayLike(keyPath) && typeof keyPath !== 'string') {\n    return keyPath;\n  }\n  if (isOrdered(keyPath)) {\n    return keyPath.toArray();\n  }\n  throw new TypeError(\n    'Invalid keyPath: expected Ordered Collection or Array: ' + keyPath\n  );\n}\n\nfunction invariant(condition, error) {\n  if (!condition) { throw new Error(error); }\n}\n\nfunction assertNotInfinite(size) {\n  invariant(\n    size !== Infinity,\n    'Cannot perform this action with an infinite size.'\n  );\n}\n\n/**\n * Converts a value to a string, adding quotes if a string was provided.\n */\nfunction quoteString(value) {\n  return typeof value === 'string' ? JSON.stringify(value) : String(value);\n}\n\nvar Map = (function (KeyedCollection$$1) {\n  function Map(value) {\n    return value === null || value === undefined\n      ? emptyMap()\n      : isMap(value) && !isOrdered(value)\n          ? value\n          : emptyMap().withMutations(function (map) {\n              var iter = KeyedCollection$$1(value);\n              assertNotInfinite(iter.size);\n              iter.forEach(function (v, k) { return map.set(k, v); });\n            });\n  }\n\n  if ( KeyedCollection$$1 ) Map.__proto__ = KeyedCollection$$1;\n  Map.prototype = Object.create( KeyedCollection$$1 && KeyedCollection$$1.prototype );\n  Map.prototype.constructor = Map;\n\n  Map.of = function of () {\n    var keyValues = [], len = arguments.length;\n    while ( len-- ) keyValues[ len ] = arguments[ len ];\n\n    return emptyMap().withMutations(function (map) {\n      for (var i = 0; i < keyValues.length; i += 2) {\n        if (i + 1 >= keyValues.length) {\n          throw new Error('Missing value for key: ' + keyValues[i]);\n        }\n        map.set(keyValues[i], keyValues[i + 1]);\n      }\n    });\n  };\n\n  Map.prototype.toString = function toString () {\n    return this.__toString('Map {', '}');\n  };\n\n  // @pragma Access\n\n  Map.prototype.get = function get (k, notSetValue) {\n    return this._root\n      ? this._root.get(0, undefined, k, notSetValue)\n      : notSetValue;\n  };\n\n  // @pragma Modification\n\n  Map.prototype.set = function set (k, v) {\n    return updateMap(this, k, v);\n  };\n\n  Map.prototype.setIn = function setIn (keyPath, v) {\n    return this.updateIn(keyPath, NOT_SET, function () { return v; });\n  };\n\n  Map.prototype.remove = function remove (k) {\n    return updateMap(this, k, NOT_SET);\n  };\n\n  Map.prototype.deleteIn = function deleteIn (keyPath) {\n    keyPath = [].concat( coerceKeyPath(keyPath) );\n    if (keyPath.length) {\n      var lastKey = keyPath.pop();\n      return this.updateIn(keyPath, function (c) { return c && c.remove(lastKey); });\n    }\n  };\n\n  Map.prototype.deleteAll = function deleteAll (keys) {\n    var collection = Collection(keys);\n\n    if (collection.size === 0) {\n      return this;\n    }\n\n    return this.withMutations(function (map) {\n      collection.forEach(function (key) { return map.remove(key); });\n    });\n  };\n\n  Map.prototype.update = function update (k, notSetValue, updater) {\n    return arguments.length === 1\n      ? k(this)\n      : this.updateIn([k], notSetValue, updater);\n  };\n\n  Map.prototype.updateIn = function updateIn (keyPath, notSetValue, updater) {\n    if (!updater) {\n      updater = notSetValue;\n      notSetValue = undefined;\n    }\n    var updatedValue = updateInDeepMap(\n      this,\n      coerceKeyPath(keyPath),\n      0,\n      notSetValue,\n      updater\n    );\n    return updatedValue === NOT_SET ? notSetValue : updatedValue;\n  };\n\n  Map.prototype.clear = function clear () {\n    if (this.size === 0) {\n      return this;\n    }\n    if (this.__ownerID) {\n      this.size = 0;\n      this._root = null;\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return emptyMap();\n  };\n\n  // @pragma Composition\n\n  Map.prototype.merge = function merge (/*...iters*/) {\n    return mergeIntoMapWith(this, undefined, arguments);\n  };\n\n  Map.prototype.mergeWith = function mergeWith (merger) {\n    var iters = [], len = arguments.length - 1;\n    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n    return mergeIntoMapWith(this, merger, iters);\n  };\n\n  Map.prototype.mergeIn = function mergeIn (keyPath) {\n    var iters = [], len = arguments.length - 1;\n    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n    return this.updateIn(\n      keyPath,\n      emptyMap(),\n      function (m) { return typeof m.merge === 'function'\n          ? m.merge.apply(m, iters)\n          : iters[iters.length - 1]; }\n    );\n  };\n\n  Map.prototype.mergeDeep = function mergeDeep (/*...iters*/) {\n    return mergeIntoMapWith(this, deepMerger, arguments);\n  };\n\n  Map.prototype.mergeDeepWith = function mergeDeepWith (merger) {\n    var iters = [], len = arguments.length - 1;\n    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n    return mergeIntoMapWith(this, deepMergerWith(merger), iters);\n  };\n\n  Map.prototype.mergeDeepIn = function mergeDeepIn (keyPath) {\n    var iters = [], len = arguments.length - 1;\n    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n    return this.updateIn(\n      keyPath,\n      emptyMap(),\n      function (m) { return typeof m.mergeDeep === 'function'\n          ? m.mergeDeep.apply(m, iters)\n          : iters[iters.length - 1]; }\n    );\n  };\n\n  Map.prototype.sort = function sort (comparator) {\n    // Late binding\n    return OrderedMap(sortFactory(this, comparator));\n  };\n\n  Map.prototype.sortBy = function sortBy (mapper, comparator) {\n    // Late binding\n    return OrderedMap(sortFactory(this, comparator, mapper));\n  };\n\n  // @pragma Mutability\n\n  Map.prototype.withMutations = function withMutations (fn) {\n    var mutable = this.asMutable();\n    fn(mutable);\n    return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;\n  };\n\n  Map.prototype.asMutable = function asMutable () {\n    return this.__ownerID ? this : this.__ensureOwner(new OwnerID());\n  };\n\n  Map.prototype.asImmutable = function asImmutable () {\n    return this.__ensureOwner();\n  };\n\n  Map.prototype.wasAltered = function wasAltered () {\n    return this.__altered;\n  };\n\n  Map.prototype.__iterator = function __iterator (type, reverse) {\n    return new MapIterator(this, type, reverse);\n  };\n\n  Map.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    var iterations = 0;\n    this._root &&\n      this._root.iterate(\n        function (entry) {\n          iterations++;\n          return fn(entry[1], entry[0], this$1);\n        },\n        reverse\n      );\n    return iterations;\n  };\n\n  Map.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    if (!ownerID) {\n      if (this.size === 0) {\n        return emptyMap();\n      }\n      this.__ownerID = ownerID;\n      this.__altered = false;\n      return this;\n    }\n    return makeMap(this.size, this._root, ownerID, this.__hash);\n  };\n\n  return Map;\n}(KeyedCollection));\n\nfunction isMap(maybeMap) {\n  return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);\n}\n\nMap.isMap = isMap;\n\nvar IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';\n\nvar MapPrototype = Map.prototype;\nMapPrototype[IS_MAP_SENTINEL] = true;\nMapPrototype[DELETE] = MapPrototype.remove;\nMapPrototype.removeIn = MapPrototype.deleteIn;\nMapPrototype.removeAll = MapPrototype.deleteAll;\n\n// #pragma Trie Nodes\n\nvar ArrayMapNode = function ArrayMapNode(ownerID, entries) {\n  this.ownerID = ownerID;\n  this.entries = entries;\n};\n\nArrayMapNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n  var entries = this.entries;\n  for (var ii = 0, len = entries.length; ii < len; ii++) {\n    if (is(key, entries[ii][0])) {\n      return entries[ii][1];\n    }\n  }\n  return notSetValue;\n};\n\nArrayMapNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  var removed = value === NOT_SET;\n\n  var entries = this.entries;\n  var idx = 0;\n  var len = entries.length;\n  for (; idx < len; idx++) {\n    if (is(key, entries[idx][0])) {\n      break;\n    }\n  }\n  var exists = idx < len;\n\n  if (exists ? entries[idx][1] === value : removed) {\n    return this;\n  }\n\n  SetRef(didAlter);\n  (removed || !exists) && SetRef(didChangeSize);\n\n  if (removed && entries.length === 1) {\n    return; // undefined\n  }\n\n  if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {\n    return createNodes(ownerID, entries, key, value);\n  }\n\n  var isEditable = ownerID && ownerID === this.ownerID;\n  var newEntries = isEditable ? entries : arrCopy(entries);\n\n  if (exists) {\n    if (removed) {\n      idx === len - 1\n        ? newEntries.pop()\n        : (newEntries[idx] = newEntries.pop());\n    } else {\n      newEntries[idx] = [key, value];\n    }\n  } else {\n    newEntries.push([key, value]);\n  }\n\n  if (isEditable) {\n    this.entries = newEntries;\n    return this;\n  }\n\n  return new ArrayMapNode(ownerID, newEntries);\n};\n\nvar BitmapIndexedNode = function BitmapIndexedNode(ownerID, bitmap, nodes) {\n  this.ownerID = ownerID;\n  this.bitmap = bitmap;\n  this.nodes = nodes;\n};\n\nBitmapIndexedNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n  var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);\n  var bitmap = this.bitmap;\n  return (bitmap & bit) === 0\n    ? notSetValue\n    : this.nodes[popCount(bitmap & bit - 1)].get(\n        shift + SHIFT,\n        keyHash,\n        key,\n        notSetValue\n      );\n};\n\nBitmapIndexedNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n  var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n  var bit = 1 << keyHashFrag;\n  var bitmap = this.bitmap;\n  var exists = (bitmap & bit) !== 0;\n\n  if (!exists && value === NOT_SET) {\n    return this;\n  }\n\n  var idx = popCount(bitmap & bit - 1);\n  var nodes = this.nodes;\n  var node = exists ? nodes[idx] : undefined;\n  var newNode = updateNode(\n    node,\n    ownerID,\n    shift + SHIFT,\n    keyHash,\n    key,\n    value,\n    didChangeSize,\n    didAlter\n  );\n\n  if (newNode === node) {\n    return this;\n  }\n\n  if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {\n    return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);\n  }\n\n  if (\n    exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])\n  ) {\n    return nodes[idx ^ 1];\n  }\n\n  if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {\n    return newNode;\n  }\n\n  var isEditable = ownerID && ownerID === this.ownerID;\n  var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;\n  var newNodes = exists\n    ? newNode\n        ? setIn(nodes, idx, newNode, isEditable)\n        : spliceOut(nodes, idx, isEditable)\n    : spliceIn(nodes, idx, newNode, isEditable);\n\n  if (isEditable) {\n    this.bitmap = newBitmap;\n    this.nodes = newNodes;\n    return this;\n  }\n\n  return new BitmapIndexedNode(ownerID, newBitmap, newNodes);\n};\n\nvar HashArrayMapNode = function HashArrayMapNode(ownerID, count, nodes) {\n  this.ownerID = ownerID;\n  this.count = count;\n  this.nodes = nodes;\n};\n\nHashArrayMapNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n  var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n  var node = this.nodes[idx];\n  return node\n    ? node.get(shift + SHIFT, keyHash, key, notSetValue)\n    : notSetValue;\n};\n\nHashArrayMapNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n  var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n  var removed = value === NOT_SET;\n  var nodes = this.nodes;\n  var node = nodes[idx];\n\n  if (removed && !node) {\n    return this;\n  }\n\n  var newNode = updateNode(\n    node,\n    ownerID,\n    shift + SHIFT,\n    keyHash,\n    key,\n    value,\n    didChangeSize,\n    didAlter\n  );\n  if (newNode === node) {\n    return this;\n  }\n\n  var newCount = this.count;\n  if (!node) {\n    newCount++;\n  } else if (!newNode) {\n    newCount--;\n    if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {\n      return packNodes(ownerID, nodes, newCount, idx);\n    }\n  }\n\n  var isEditable = ownerID && ownerID === this.ownerID;\n  var newNodes = setIn(nodes, idx, newNode, isEditable);\n\n  if (isEditable) {\n    this.count = newCount;\n    this.nodes = newNodes;\n    return this;\n  }\n\n  return new HashArrayMapNode(ownerID, newCount, newNodes);\n};\n\nvar HashCollisionNode = function HashCollisionNode(ownerID, keyHash, entries) {\n  this.ownerID = ownerID;\n  this.keyHash = keyHash;\n  this.entries = entries;\n};\n\nHashCollisionNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n  var entries = this.entries;\n  for (var ii = 0, len = entries.length; ii < len; ii++) {\n    if (is(key, entries[ii][0])) {\n      return entries[ii][1];\n    }\n  }\n  return notSetValue;\n};\n\nHashCollisionNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  if (keyHash === undefined) {\n    keyHash = hash(key);\n  }\n\n  var removed = value === NOT_SET;\n\n  if (keyHash !== this.keyHash) {\n    if (removed) {\n      return this;\n    }\n    SetRef(didAlter);\n    SetRef(didChangeSize);\n    return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);\n  }\n\n  var entries = this.entries;\n  var idx = 0;\n  var len = entries.length;\n  for (; idx < len; idx++) {\n    if (is(key, entries[idx][0])) {\n      break;\n    }\n  }\n  var exists = idx < len;\n\n  if (exists ? entries[idx][1] === value : removed) {\n    return this;\n  }\n\n  SetRef(didAlter);\n  (removed || !exists) && SetRef(didChangeSize);\n\n  if (removed && len === 2) {\n    return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);\n  }\n\n  var isEditable = ownerID && ownerID === this.ownerID;\n  var newEntries = isEditable ? entries : arrCopy(entries);\n\n  if (exists) {\n    if (removed) {\n      idx === len - 1\n        ? newEntries.pop()\n        : (newEntries[idx] = newEntries.pop());\n    } else {\n      newEntries[idx] = [key, value];\n    }\n  } else {\n    newEntries.push([key, value]);\n  }\n\n  if (isEditable) {\n    this.entries = newEntries;\n    return this;\n  }\n\n  return new HashCollisionNode(ownerID, this.keyHash, newEntries);\n};\n\nvar ValueNode = function ValueNode(ownerID, keyHash, entry) {\n  this.ownerID = ownerID;\n  this.keyHash = keyHash;\n  this.entry = entry;\n};\n\nValueNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n  return is(key, this.entry[0]) ? this.entry[1] : notSetValue;\n};\n\nValueNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n  var removed = value === NOT_SET;\n  var keyMatch = is(key, this.entry[0]);\n  if (keyMatch ? value === this.entry[1] : removed) {\n    return this;\n  }\n\n  SetRef(didAlter);\n\n  if (removed) {\n    SetRef(didChangeSize);\n    return; // undefined\n  }\n\n  if (keyMatch) {\n    if (ownerID && ownerID === this.ownerID) {\n      this.entry[1] = value;\n      return this;\n    }\n    return new ValueNode(ownerID, this.keyHash, [key, value]);\n  }\n\n  SetRef(didChangeSize);\n  return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);\n};\n\n// #pragma Iterators\n\nArrayMapNode.prototype.iterate = (HashCollisionNode.prototype.iterate = function(\n  fn,\n  reverse\n) {\n  var entries = this.entries;\n  for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {\n    if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {\n      return false;\n    }\n  }\n});\n\nBitmapIndexedNode.prototype.iterate = (HashArrayMapNode.prototype.iterate = function(\n  fn,\n  reverse\n) {\n  var nodes = this.nodes;\n  for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {\n    var node = nodes[reverse ? maxIndex - ii : ii];\n    if (node && node.iterate(fn, reverse) === false) {\n      return false;\n    }\n  }\n});\n\n// eslint-disable-next-line no-unused-vars\nValueNode.prototype.iterate = function(fn, reverse) {\n  return fn(this.entry);\n};\n\nvar MapIterator = (function (Iterator$$1) {\n  function MapIterator(map, type, reverse) {\n    this._type = type;\n    this._reverse = reverse;\n    this._stack = map._root && mapIteratorFrame(map._root);\n  }\n\n  if ( Iterator$$1 ) MapIterator.__proto__ = Iterator$$1;\n  MapIterator.prototype = Object.create( Iterator$$1 && Iterator$$1.prototype );\n  MapIterator.prototype.constructor = MapIterator;\n\n  MapIterator.prototype.next = function next () {\n    var this$1 = this;\n\n    var type = this._type;\n    var stack = this._stack;\n    while (stack) {\n      var node = stack.node;\n      var index = stack.index++;\n      var maxIndex = (void 0);\n      if (node.entry) {\n        if (index === 0) {\n          return mapIteratorValue(type, node.entry);\n        }\n      } else if (node.entries) {\n        maxIndex = node.entries.length - 1;\n        if (index <= maxIndex) {\n          return mapIteratorValue(\n            type,\n            node.entries[this$1._reverse ? maxIndex - index : index]\n          );\n        }\n      } else {\n        maxIndex = node.nodes.length - 1;\n        if (index <= maxIndex) {\n          var subNode = node.nodes[this$1._reverse ? maxIndex - index : index];\n          if (subNode) {\n            if (subNode.entry) {\n              return mapIteratorValue(type, subNode.entry);\n            }\n            stack = (this$1._stack = mapIteratorFrame(subNode, stack));\n          }\n          continue;\n        }\n      }\n      stack = (this$1._stack = this$1._stack.__prev);\n    }\n    return iteratorDone();\n  };\n\n  return MapIterator;\n}(Iterator));\n\nfunction mapIteratorValue(type, entry) {\n  return iteratorValue(type, entry[0], entry[1]);\n}\n\nfunction mapIteratorFrame(node, prev) {\n  return {\n    node: node,\n    index: 0,\n    __prev: prev\n  };\n}\n\nfunction makeMap(size, root, ownerID, hash$$1) {\n  var map = Object.create(MapPrototype);\n  map.size = size;\n  map._root = root;\n  map.__ownerID = ownerID;\n  map.__hash = hash$$1;\n  map.__altered = false;\n  return map;\n}\n\nvar EMPTY_MAP;\nfunction emptyMap() {\n  return EMPTY_MAP || (EMPTY_MAP = makeMap(0));\n}\n\nfunction updateMap(map, k, v) {\n  var newRoot;\n  var newSize;\n  if (!map._root) {\n    if (v === NOT_SET) {\n      return map;\n    }\n    newSize = 1;\n    newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);\n  } else {\n    var didChangeSize = MakeRef(CHANGE_LENGTH);\n    var didAlter = MakeRef(DID_ALTER);\n    newRoot = updateNode(\n      map._root,\n      map.__ownerID,\n      0,\n      undefined,\n      k,\n      v,\n      didChangeSize,\n      didAlter\n    );\n    if (!didAlter.value) {\n      return map;\n    }\n    newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);\n  }\n  if (map.__ownerID) {\n    map.size = newSize;\n    map._root = newRoot;\n    map.__hash = undefined;\n    map.__altered = true;\n    return map;\n  }\n  return newRoot ? makeMap(newSize, newRoot) : emptyMap();\n}\n\nfunction updateNode(\n  node,\n  ownerID,\n  shift,\n  keyHash,\n  key,\n  value,\n  didChangeSize,\n  didAlter\n) {\n  if (!node) {\n    if (value === NOT_SET) {\n      return node;\n    }\n    SetRef(didAlter);\n    SetRef(didChangeSize);\n    return new ValueNode(ownerID, keyHash, [key, value]);\n  }\n  return node.update(\n    ownerID,\n    shift,\n    keyHash,\n    key,\n    value,\n    didChangeSize,\n    didAlter\n  );\n}\n\nfunction isLeafNode(node) {\n  return node.constructor === ValueNode ||\n    node.constructor === HashCollisionNode;\n}\n\nfunction mergeIntoNode(node, ownerID, shift, keyHash, entry) {\n  if (node.keyHash === keyHash) {\n    return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);\n  }\n\n  var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;\n  var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\n  var newNode;\n  var nodes = idx1 === idx2\n    ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)]\n    : ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2\n        ? [node, newNode]\n        : [newNode, node]);\n\n  return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);\n}\n\nfunction createNodes(ownerID, entries, key, value) {\n  if (!ownerID) {\n    ownerID = new OwnerID();\n  }\n  var node = new ValueNode(ownerID, hash(key), [key, value]);\n  for (var ii = 0; ii < entries.length; ii++) {\n    var entry = entries[ii];\n    node = node.update(ownerID, 0, undefined, entry[0], entry[1]);\n  }\n  return node;\n}\n\nfunction packNodes(ownerID, nodes, count, excluding) {\n  var bitmap = 0;\n  var packedII = 0;\n  var packedNodes = new Array(count);\n  for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, (bit <<= 1)) {\n    var node = nodes[ii];\n    if (node !== undefined && ii !== excluding) {\n      bitmap |= bit;\n      packedNodes[packedII++] = node;\n    }\n  }\n  return new BitmapIndexedNode(ownerID, bitmap, packedNodes);\n}\n\nfunction expandNodes(ownerID, nodes, bitmap, including, node) {\n  var count = 0;\n  var expandedNodes = new Array(SIZE);\n  for (var ii = 0; bitmap !== 0; ii++, (bitmap >>>= 1)) {\n    expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;\n  }\n  expandedNodes[including] = node;\n  return new HashArrayMapNode(ownerID, count + 1, expandedNodes);\n}\n\nfunction mergeIntoMapWith(map, merger, collections) {\n  var iters = [];\n  for (var ii = 0; ii < collections.length; ii++) {\n    var value = collections[ii];\n    var iter = KeyedCollection(value);\n    if (!isCollection(value)) {\n      iter = iter.map(function (v) { return fromJS(v); });\n    }\n    iters.push(iter);\n  }\n  return mergeIntoCollectionWith(map, merger, iters);\n}\n\nfunction deepMerger(oldVal, newVal) {\n  return oldVal && oldVal.mergeDeep && isCollection(newVal)\n    ? oldVal.mergeDeep(newVal)\n    : is(oldVal, newVal) ? oldVal : newVal;\n}\n\nfunction deepMergerWith(merger) {\n  return function (oldVal, newVal, key) {\n    if (oldVal && oldVal.mergeDeepWith && isCollection(newVal)) {\n      return oldVal.mergeDeepWith(merger, newVal);\n    }\n    var nextValue = merger(oldVal, newVal, key);\n    return is(oldVal, nextValue) ? oldVal : nextValue;\n  };\n}\n\nfunction mergeIntoCollectionWith(collection, merger, iters) {\n  iters = iters.filter(function (x) { return x.size !== 0; });\n  if (iters.length === 0) {\n    return collection;\n  }\n  if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {\n    return collection.constructor(iters[0]);\n  }\n  return collection.withMutations(function (collection) {\n    var mergeIntoMap = merger\n      ? function (value, key) {\n          collection.update(\n            key,\n            NOT_SET,\n            function (oldVal) { return oldVal === NOT_SET ? value : merger(oldVal, value, key); }\n          );\n        }\n      : function (value, key) {\n          collection.set(key, value);\n        };\n    for (var ii = 0; ii < iters.length; ii++) {\n      iters[ii].forEach(mergeIntoMap);\n    }\n  });\n}\n\nfunction updateInDeepMap(existing, keyPath, i, notSetValue, updater) {\n  var isNotSet = existing === NOT_SET;\n  if (i === keyPath.length) {\n    var existingValue = isNotSet ? notSetValue : existing;\n    var newValue = updater(existingValue);\n    return newValue === existingValue ? existing : newValue;\n  }\n  if (!(isNotSet || (existing && existing.set))) {\n    throw new TypeError(\n      'Invalid keyPath: Value at [' +\n        keyPath.slice(0, i).map(quoteString) +\n        '] does not have a .set() method and cannot be updated: ' +\n        existing\n    );\n  }\n  var key = keyPath[i];\n  var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);\n  var nextUpdated = updateInDeepMap(\n    nextExisting,\n    keyPath,\n    i + 1,\n    notSetValue,\n    updater\n  );\n  return nextUpdated === nextExisting\n    ? existing\n    : nextUpdated === NOT_SET\n        ? existing.remove(key)\n        : (isNotSet ? emptyMap() : existing).set(key, nextUpdated);\n}\n\nfunction popCount(x) {\n  x -= x >> 1 & 0x55555555;\n  x = (x & 0x33333333) + (x >> 2 & 0x33333333);\n  x = x + (x >> 4) & 0x0f0f0f0f;\n  x += x >> 8;\n  x += x >> 16;\n  return x & 0x7f;\n}\n\nfunction setIn(array, idx, val, canEdit) {\n  var newArray = canEdit ? array : arrCopy(array);\n  newArray[idx] = val;\n  return newArray;\n}\n\nfunction spliceIn(array, idx, val, canEdit) {\n  var newLen = array.length + 1;\n  if (canEdit && idx + 1 === newLen) {\n    array[idx] = val;\n    return array;\n  }\n  var newArray = new Array(newLen);\n  var after = 0;\n  for (var ii = 0; ii < newLen; ii++) {\n    if (ii === idx) {\n      newArray[ii] = val;\n      after = -1;\n    } else {\n      newArray[ii] = array[ii + after];\n    }\n  }\n  return newArray;\n}\n\nfunction spliceOut(array, idx, canEdit) {\n  var newLen = array.length - 1;\n  if (canEdit && idx === newLen) {\n    array.pop();\n    return array;\n  }\n  var newArray = new Array(newLen);\n  var after = 0;\n  for (var ii = 0; ii < newLen; ii++) {\n    if (ii === idx) {\n      after = 1;\n    }\n    newArray[ii] = array[ii + after];\n  }\n  return newArray;\n}\n\nvar MAX_ARRAY_MAP_SIZE = SIZE / 4;\nvar MAX_BITMAP_INDEXED_SIZE = SIZE / 2;\nvar MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;\n\nvar List = (function (IndexedCollection$$1) {\n  function List(value) {\n    var empty = emptyList();\n    if (value === null || value === undefined) {\n      return empty;\n    }\n    if (isList(value)) {\n      return value;\n    }\n    var iter = IndexedCollection$$1(value);\n    var size = iter.size;\n    if (size === 0) {\n      return empty;\n    }\n    assertNotInfinite(size);\n    if (size > 0 && size < SIZE) {\n      return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));\n    }\n    return empty.withMutations(function (list) {\n      list.setSize(size);\n      iter.forEach(function (v, i) { return list.set(i, v); });\n    });\n  }\n\n  if ( IndexedCollection$$1 ) List.__proto__ = IndexedCollection$$1;\n  List.prototype = Object.create( IndexedCollection$$1 && IndexedCollection$$1.prototype );\n  List.prototype.constructor = List;\n\n  List.of = function of (/*...values*/) {\n    return this(arguments);\n  };\n\n  List.prototype.toString = function toString () {\n    return this.__toString('List [', ']');\n  };\n\n  // @pragma Access\n\n  List.prototype.get = function get (index, notSetValue) {\n    index = wrapIndex(this, index);\n    if (index >= 0 && index < this.size) {\n      index += this._origin;\n      var node = listNodeFor(this, index);\n      return node && node.array[index & MASK];\n    }\n    return notSetValue;\n  };\n\n  // @pragma Modification\n\n  List.prototype.set = function set (index, value) {\n    return updateList(this, index, value);\n  };\n\n  List.prototype.remove = function remove (index) {\n    return !this.has(index)\n      ? this\n      : index === 0\n          ? this.shift()\n          : index === this.size - 1 ? this.pop() : this.splice(index, 1);\n  };\n\n  List.prototype.insert = function insert (index, value) {\n    return this.splice(index, 0, value);\n  };\n\n  List.prototype.clear = function clear () {\n    if (this.size === 0) {\n      return this;\n    }\n    if (this.__ownerID) {\n      this.size = (this._origin = (this._capacity = 0));\n      this._level = SHIFT;\n      this._root = (this._tail = null);\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return emptyList();\n  };\n\n  List.prototype.push = function push (/*...values*/) {\n    var values = arguments;\n    var oldSize = this.size;\n    return this.withMutations(function (list) {\n      setListBounds(list, 0, oldSize + values.length);\n      for (var ii = 0; ii < values.length; ii++) {\n        list.set(oldSize + ii, values[ii]);\n      }\n    });\n  };\n\n  List.prototype.pop = function pop () {\n    return setListBounds(this, 0, -1);\n  };\n\n  List.prototype.unshift = function unshift (/*...values*/) {\n    var values = arguments;\n    return this.withMutations(function (list) {\n      setListBounds(list, -values.length);\n      for (var ii = 0; ii < values.length; ii++) {\n        list.set(ii, values[ii]);\n      }\n    });\n  };\n\n  List.prototype.shift = function shift () {\n    return setListBounds(this, 1);\n  };\n\n  // @pragma Composition\n\n  List.prototype.merge = function merge (/*...iters*/) {\n    return mergeIntoListWith(this, undefined, arguments);\n  };\n\n  List.prototype.mergeWith = function mergeWith (merger) {\n    var iters = [], len = arguments.length - 1;\n    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n    return mergeIntoListWith(this, merger, iters);\n  };\n\n  List.prototype.mergeDeep = function mergeDeep (/*...iters*/) {\n    return mergeIntoListWith(this, deepMerger, arguments);\n  };\n\n  List.prototype.mergeDeepWith = function mergeDeepWith (merger) {\n    var iters = [], len = arguments.length - 1;\n    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n    return mergeIntoListWith(this, deepMergerWith(merger), iters);\n  };\n\n  List.prototype.setSize = function setSize (size) {\n    return setListBounds(this, 0, size);\n  };\n\n  // @pragma Iteration\n\n  List.prototype.slice = function slice (begin, end) {\n    var size = this.size;\n    if (wholeSlice(begin, end, size)) {\n      return this;\n    }\n    return setListBounds(\n      this,\n      resolveBegin(begin, size),\n      resolveEnd(end, size)\n    );\n  };\n\n  List.prototype.__iterator = function __iterator (type, reverse) {\n    var index = reverse ? this.size : 0;\n    var values = iterateList(this, reverse);\n    return new Iterator(function () {\n      var value = values();\n      return value === DONE\n        ? iteratorDone()\n        : iteratorValue(type, reverse ? --index : index++, value);\n    });\n  };\n\n  List.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    var index = reverse ? this.size : 0;\n    var values = iterateList(this, reverse);\n    var value;\n    while ((value = values()) !== DONE) {\n      if (fn(value, reverse ? --index : index++, this$1) === false) {\n        break;\n      }\n    }\n    return index;\n  };\n\n  List.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    if (!ownerID) {\n      if (this.size === 0) {\n        return emptyList();\n      }\n      this.__ownerID = ownerID;\n      return this;\n    }\n    return makeList(\n      this._origin,\n      this._capacity,\n      this._level,\n      this._root,\n      this._tail,\n      ownerID,\n      this.__hash\n    );\n  };\n\n  return List;\n}(IndexedCollection));\n\nfunction isList(maybeList) {\n  return !!(maybeList && maybeList[IS_LIST_SENTINEL]);\n}\n\nList.isList = isList;\n\nvar IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';\n\nvar ListPrototype = List.prototype;\nListPrototype[IS_LIST_SENTINEL] = true;\nListPrototype[DELETE] = ListPrototype.remove;\nListPrototype.setIn = MapPrototype.setIn;\nListPrototype.deleteIn = (ListPrototype.removeIn = MapPrototype.removeIn);\nListPrototype.update = MapPrototype.update;\nListPrototype.updateIn = MapPrototype.updateIn;\nListPrototype.mergeIn = MapPrototype.mergeIn;\nListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\nListPrototype.withMutations = MapPrototype.withMutations;\nListPrototype.asMutable = MapPrototype.asMutable;\nListPrototype.asImmutable = MapPrototype.asImmutable;\nListPrototype.wasAltered = MapPrototype.wasAltered;\n\nvar VNode = function VNode(array, ownerID) {\n  this.array = array;\n  this.ownerID = ownerID;\n};\n\n// TODO: seems like these methods are very similar\n\nVNode.prototype.removeBefore = function removeBefore (ownerID, level, index) {\n  if (index === level ? 1 << level : 0 || this.array.length === 0) {\n    return this;\n  }\n  var originIndex = index >>> level & MASK;\n  if (originIndex >= this.array.length) {\n    return new VNode([], ownerID);\n  }\n  var removingFirst = originIndex === 0;\n  var newChild;\n  if (level > 0) {\n    var oldChild = this.array[originIndex];\n    newChild = oldChild &&\n      oldChild.removeBefore(ownerID, level - SHIFT, index);\n    if (newChild === oldChild && removingFirst) {\n      return this;\n    }\n  }\n  if (removingFirst && !newChild) {\n    return this;\n  }\n  var editable = editableVNode(this, ownerID);\n  if (!removingFirst) {\n    for (var ii = 0; ii < originIndex; ii++) {\n      editable.array[ii] = undefined;\n    }\n  }\n  if (newChild) {\n    editable.array[originIndex] = newChild;\n  }\n  return editable;\n};\n\nVNode.prototype.removeAfter = function removeAfter (ownerID, level, index) {\n  if (index === (level ? 1 << level : 0) || this.array.length === 0) {\n    return this;\n  }\n  var sizeIndex = index - 1 >>> level & MASK;\n  if (sizeIndex >= this.array.length) {\n    return this;\n  }\n\n  var newChild;\n  if (level > 0) {\n    var oldChild = this.array[sizeIndex];\n    newChild = oldChild &&\n      oldChild.removeAfter(ownerID, level - SHIFT, index);\n    if (newChild === oldChild && sizeIndex === this.array.length - 1) {\n      return this;\n    }\n  }\n\n  var editable = editableVNode(this, ownerID);\n  editable.array.splice(sizeIndex + 1);\n  if (newChild) {\n    editable.array[sizeIndex] = newChild;\n  }\n  return editable;\n};\n\nvar DONE = {};\n\nfunction iterateList(list, reverse) {\n  var left = list._origin;\n  var right = list._capacity;\n  var tailPos = getTailOffset(right);\n  var tail = list._tail;\n\n  return iterateNodeOrLeaf(list._root, list._level, 0);\n\n  function iterateNodeOrLeaf(node, level, offset) {\n    return level === 0\n      ? iterateLeaf(node, offset)\n      : iterateNode(node, level, offset);\n  }\n\n  function iterateLeaf(node, offset) {\n    var array = offset === tailPos ? tail && tail.array : node && node.array;\n    var from = offset > left ? 0 : left - offset;\n    var to = right - offset;\n    if (to > SIZE) {\n      to = SIZE;\n    }\n    return function () {\n      if (from === to) {\n        return DONE;\n      }\n      var idx = reverse ? --to : from++;\n      return array && array[idx];\n    };\n  }\n\n  function iterateNode(node, level, offset) {\n    var values;\n    var array = node && node.array;\n    var from = offset > left ? 0 : left - offset >> level;\n    var to = (right - offset >> level) + 1;\n    if (to > SIZE) {\n      to = SIZE;\n    }\n    return function () {\n      while (true) {\n        if (values) {\n          var value = values();\n          if (value !== DONE) {\n            return value;\n          }\n          values = null;\n        }\n        if (from === to) {\n          return DONE;\n        }\n        var idx = reverse ? --to : from++;\n        values = iterateNodeOrLeaf(\n          array && array[idx],\n          level - SHIFT,\n          offset + (idx << level)\n        );\n      }\n    };\n  }\n}\n\nfunction makeList(origin, capacity, level, root, tail, ownerID, hash) {\n  var list = Object.create(ListPrototype);\n  list.size = capacity - origin;\n  list._origin = origin;\n  list._capacity = capacity;\n  list._level = level;\n  list._root = root;\n  list._tail = tail;\n  list.__ownerID = ownerID;\n  list.__hash = hash;\n  list.__altered = false;\n  return list;\n}\n\nvar EMPTY_LIST;\nfunction emptyList() {\n  return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));\n}\n\nfunction updateList(list, index, value) {\n  index = wrapIndex(list, index);\n\n  if (index !== index) {\n    return list;\n  }\n\n  if (index >= list.size || index < 0) {\n    return list.withMutations(function (list) {\n      index < 0\n        ? setListBounds(list, index).set(0, value)\n        : setListBounds(list, 0, index + 1).set(index, value);\n    });\n  }\n\n  index += list._origin;\n\n  var newTail = list._tail;\n  var newRoot = list._root;\n  var didAlter = MakeRef(DID_ALTER);\n  if (index >= getTailOffset(list._capacity)) {\n    newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);\n  } else {\n    newRoot = updateVNode(\n      newRoot,\n      list.__ownerID,\n      list._level,\n      index,\n      value,\n      didAlter\n    );\n  }\n\n  if (!didAlter.value) {\n    return list;\n  }\n\n  if (list.__ownerID) {\n    list._root = newRoot;\n    list._tail = newTail;\n    list.__hash = undefined;\n    list.__altered = true;\n    return list;\n  }\n  return makeList(list._origin, list._capacity, list._level, newRoot, newTail);\n}\n\nfunction updateVNode(node, ownerID, level, index, value, didAlter) {\n  var idx = index >>> level & MASK;\n  var nodeHas = node && idx < node.array.length;\n  if (!nodeHas && value === undefined) {\n    return node;\n  }\n\n  var newNode;\n\n  if (level > 0) {\n    var lowerNode = node && node.array[idx];\n    var newLowerNode = updateVNode(\n      lowerNode,\n      ownerID,\n      level - SHIFT,\n      index,\n      value,\n      didAlter\n    );\n    if (newLowerNode === lowerNode) {\n      return node;\n    }\n    newNode = editableVNode(node, ownerID);\n    newNode.array[idx] = newLowerNode;\n    return newNode;\n  }\n\n  if (nodeHas && node.array[idx] === value) {\n    return node;\n  }\n\n  SetRef(didAlter);\n\n  newNode = editableVNode(node, ownerID);\n  if (value === undefined && idx === newNode.array.length - 1) {\n    newNode.array.pop();\n  } else {\n    newNode.array[idx] = value;\n  }\n  return newNode;\n}\n\nfunction editableVNode(node, ownerID) {\n  if (ownerID && node && ownerID === node.ownerID) {\n    return node;\n  }\n  return new VNode(node ? node.array.slice() : [], ownerID);\n}\n\nfunction listNodeFor(list, rawIndex) {\n  if (rawIndex >= getTailOffset(list._capacity)) {\n    return list._tail;\n  }\n  if (rawIndex < 1 << list._level + SHIFT) {\n    var node = list._root;\n    var level = list._level;\n    while (node && level > 0) {\n      node = node.array[rawIndex >>> level & MASK];\n      level -= SHIFT;\n    }\n    return node;\n  }\n}\n\nfunction setListBounds(list, begin, end) {\n  // Sanitize begin & end using this shorthand for ToInt32(argument)\n  // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n  if (begin !== undefined) {\n    begin |= 0;\n  }\n  if (end !== undefined) {\n    end |= 0;\n  }\n  var owner = list.__ownerID || new OwnerID();\n  var oldOrigin = list._origin;\n  var oldCapacity = list._capacity;\n  var newOrigin = oldOrigin + begin;\n  var newCapacity = end === undefined\n    ? oldCapacity\n    : end < 0 ? oldCapacity + end : oldOrigin + end;\n  if (newOrigin === oldOrigin && newCapacity === oldCapacity) {\n    return list;\n  }\n\n  // If it's going to end after it starts, it's empty.\n  if (newOrigin >= newCapacity) {\n    return list.clear();\n  }\n\n  var newLevel = list._level;\n  var newRoot = list._root;\n\n  // New origin might need creating a higher root.\n  var offsetShift = 0;\n  while (newOrigin + offsetShift < 0) {\n    newRoot = new VNode(\n      newRoot && newRoot.array.length ? [undefined, newRoot] : [],\n      owner\n    );\n    newLevel += SHIFT;\n    offsetShift += 1 << newLevel;\n  }\n  if (offsetShift) {\n    newOrigin += offsetShift;\n    oldOrigin += offsetShift;\n    newCapacity += offsetShift;\n    oldCapacity += offsetShift;\n  }\n\n  var oldTailOffset = getTailOffset(oldCapacity);\n  var newTailOffset = getTailOffset(newCapacity);\n\n  // New size might need creating a higher root.\n  while (newTailOffset >= 1 << newLevel + SHIFT) {\n    newRoot = new VNode(\n      newRoot && newRoot.array.length ? [newRoot] : [],\n      owner\n    );\n    newLevel += SHIFT;\n  }\n\n  // Locate or create the new tail.\n  var oldTail = list._tail;\n  var newTail = newTailOffset < oldTailOffset\n    ? listNodeFor(list, newCapacity - 1)\n    : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;\n\n  // Merge Tail into tree.\n  if (\n    oldTail &&\n    newTailOffset > oldTailOffset &&\n    newOrigin < oldCapacity &&\n    oldTail.array.length\n  ) {\n    newRoot = editableVNode(newRoot, owner);\n    var node = newRoot;\n    for (var level = newLevel; level > SHIFT; level -= SHIFT) {\n      var idx = oldTailOffset >>> level & MASK;\n      node = (node.array[idx] = editableVNode(node.array[idx], owner));\n    }\n    node.array[oldTailOffset >>> SHIFT & MASK] = oldTail;\n  }\n\n  // If the size has been reduced, there's a chance the tail needs to be trimmed.\n  if (newCapacity < oldCapacity) {\n    newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);\n  }\n\n  // If the new origin is within the tail, then we do not need a root.\n  if (newOrigin >= newTailOffset) {\n    newOrigin -= newTailOffset;\n    newCapacity -= newTailOffset;\n    newLevel = SHIFT;\n    newRoot = null;\n    newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);\n\n    // Otherwise, if the root has been trimmed, garbage collect.\n  } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {\n    offsetShift = 0;\n\n    // Identify the new top root node of the subtree of the old root.\n    while (newRoot) {\n      var beginIndex = newOrigin >>> newLevel & MASK;\n      if (beginIndex !== newTailOffset >>> newLevel & MASK) {\n        break;\n      }\n      if (beginIndex) {\n        offsetShift += (1 << newLevel) * beginIndex;\n      }\n      newLevel -= SHIFT;\n      newRoot = newRoot.array[beginIndex];\n    }\n\n    // Trim the new sides of the new root.\n    if (newRoot && newOrigin > oldOrigin) {\n      newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);\n    }\n    if (newRoot && newTailOffset < oldTailOffset) {\n      newRoot = newRoot.removeAfter(\n        owner,\n        newLevel,\n        newTailOffset - offsetShift\n      );\n    }\n    if (offsetShift) {\n      newOrigin -= offsetShift;\n      newCapacity -= offsetShift;\n    }\n  }\n\n  if (list.__ownerID) {\n    list.size = newCapacity - newOrigin;\n    list._origin = newOrigin;\n    list._capacity = newCapacity;\n    list._level = newLevel;\n    list._root = newRoot;\n    list._tail = newTail;\n    list.__hash = undefined;\n    list.__altered = true;\n    return list;\n  }\n  return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);\n}\n\nfunction mergeIntoListWith(list, merger, collections) {\n  var iters = [];\n  var maxSize = 0;\n  for (var ii = 0; ii < collections.length; ii++) {\n    var value = collections[ii];\n    var iter = IndexedCollection(value);\n    if (iter.size > maxSize) {\n      maxSize = iter.size;\n    }\n    if (!isCollection(value)) {\n      iter = iter.map(function (v) { return fromJS(v); });\n    }\n    iters.push(iter);\n  }\n  if (maxSize > list.size) {\n    list = list.setSize(maxSize);\n  }\n  return mergeIntoCollectionWith(list, merger, iters);\n}\n\nfunction getTailOffset(size) {\n  return size < SIZE ? 0 : size - 1 >>> SHIFT << SHIFT;\n}\n\nvar OrderedMap = (function (Map$$1) {\n  function OrderedMap(value) {\n    return value === null || value === undefined\n      ? emptyOrderedMap()\n      : isOrderedMap(value)\n          ? value\n          : emptyOrderedMap().withMutations(function (map) {\n              var iter = KeyedCollection(value);\n              assertNotInfinite(iter.size);\n              iter.forEach(function (v, k) { return map.set(k, v); });\n            });\n  }\n\n  if ( Map$$1 ) OrderedMap.__proto__ = Map$$1;\n  OrderedMap.prototype = Object.create( Map$$1 && Map$$1.prototype );\n  OrderedMap.prototype.constructor = OrderedMap;\n\n  OrderedMap.of = function of (/*...values*/) {\n    return this(arguments);\n  };\n\n  OrderedMap.prototype.toString = function toString () {\n    return this.__toString('OrderedMap {', '}');\n  };\n\n  // @pragma Access\n\n  OrderedMap.prototype.get = function get (k, notSetValue) {\n    var index = this._map.get(k);\n    return index !== undefined ? this._list.get(index)[1] : notSetValue;\n  };\n\n  // @pragma Modification\n\n  OrderedMap.prototype.clear = function clear () {\n    if (this.size === 0) {\n      return this;\n    }\n    if (this.__ownerID) {\n      this.size = 0;\n      this._map.clear();\n      this._list.clear();\n      return this;\n    }\n    return emptyOrderedMap();\n  };\n\n  OrderedMap.prototype.set = function set (k, v) {\n    return updateOrderedMap(this, k, v);\n  };\n\n  OrderedMap.prototype.remove = function remove (k) {\n    return updateOrderedMap(this, k, NOT_SET);\n  };\n\n  OrderedMap.prototype.wasAltered = function wasAltered () {\n    return this._map.wasAltered() || this._list.wasAltered();\n  };\n\n  OrderedMap.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    return this._list.__iterate(\n      function (entry) { return entry && fn(entry[1], entry[0], this$1); },\n      reverse\n    );\n  };\n\n  OrderedMap.prototype.__iterator = function __iterator (type, reverse) {\n    return this._list.fromEntrySeq().__iterator(type, reverse);\n  };\n\n  OrderedMap.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    var newMap = this._map.__ensureOwner(ownerID);\n    var newList = this._list.__ensureOwner(ownerID);\n    if (!ownerID) {\n      if (this.size === 0) {\n        return emptyOrderedMap();\n      }\n      this.__ownerID = ownerID;\n      this._map = newMap;\n      this._list = newList;\n      return this;\n    }\n    return makeOrderedMap(newMap, newList, ownerID, this.__hash);\n  };\n\n  return OrderedMap;\n}(Map));\n\nfunction isOrderedMap(maybeOrderedMap) {\n  return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);\n}\n\nOrderedMap.isOrderedMap = isOrderedMap;\n\nOrderedMap.prototype[IS_ORDERED_SENTINEL] = true;\nOrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;\n\nfunction makeOrderedMap(map, list, ownerID, hash) {\n  var omap = Object.create(OrderedMap.prototype);\n  omap.size = map ? map.size : 0;\n  omap._map = map;\n  omap._list = list;\n  omap.__ownerID = ownerID;\n  omap.__hash = hash;\n  return omap;\n}\n\nvar EMPTY_ORDERED_MAP;\nfunction emptyOrderedMap() {\n  return EMPTY_ORDERED_MAP ||\n    (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));\n}\n\nfunction updateOrderedMap(omap, k, v) {\n  var map = omap._map;\n  var list = omap._list;\n  var i = map.get(k);\n  var has = i !== undefined;\n  var newMap;\n  var newList;\n  if (v === NOT_SET) {\n    // removed\n    if (!has) {\n      return omap;\n    }\n    if (list.size >= SIZE && list.size >= map.size * 2) {\n      newList = list.filter(function (entry, idx) { return entry !== undefined && i !== idx; });\n      newMap = newList.toKeyedSeq().map(function (entry) { return entry[0]; }).flip().toMap();\n      if (omap.__ownerID) {\n        newMap.__ownerID = (newList.__ownerID = omap.__ownerID);\n      }\n    } else {\n      newMap = map.remove(k);\n      newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);\n    }\n  } else if (has) {\n    if (v === list.get(i)[1]) {\n      return omap;\n    }\n    newMap = map;\n    newList = list.set(i, [k, v]);\n  } else {\n    newMap = map.set(k, list.size);\n    newList = list.set(list.size, [k, v]);\n  }\n  if (omap.__ownerID) {\n    omap.size = newMap.size;\n    omap._map = newMap;\n    omap._list = newList;\n    omap.__hash = undefined;\n    return omap;\n  }\n  return makeOrderedMap(newMap, newList);\n}\n\nvar Stack = (function (IndexedCollection$$1) {\n  function Stack(value) {\n    return value === null || value === undefined\n      ? emptyStack()\n      : isStack(value) ? value : emptyStack().pushAll(value);\n  }\n\n  if ( IndexedCollection$$1 ) Stack.__proto__ = IndexedCollection$$1;\n  Stack.prototype = Object.create( IndexedCollection$$1 && IndexedCollection$$1.prototype );\n  Stack.prototype.constructor = Stack;\n\n  Stack.of = function of (/*...values*/) {\n    return this(arguments);\n  };\n\n  Stack.prototype.toString = function toString () {\n    return this.__toString('Stack [', ']');\n  };\n\n  // @pragma Access\n\n  Stack.prototype.get = function get (index, notSetValue) {\n    var head = this._head;\n    index = wrapIndex(this, index);\n    while (head && index--) {\n      head = head.next;\n    }\n    return head ? head.value : notSetValue;\n  };\n\n  Stack.prototype.peek = function peek () {\n    return this._head && this._head.value;\n  };\n\n  // @pragma Modification\n\n  Stack.prototype.push = function push (/*...values*/) {\n    var arguments$1 = arguments;\n\n    if (arguments.length === 0) {\n      return this;\n    }\n    var newSize = this.size + arguments.length;\n    var head = this._head;\n    for (var ii = arguments.length - 1; ii >= 0; ii--) {\n      head = {\n        value: arguments$1[ii],\n        next: head\n      };\n    }\n    if (this.__ownerID) {\n      this.size = newSize;\n      this._head = head;\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return makeStack(newSize, head);\n  };\n\n  Stack.prototype.pushAll = function pushAll (iter) {\n    iter = IndexedCollection$$1(iter);\n    if (iter.size === 0) {\n      return this;\n    }\n    if (this.size === 0 && isStack(iter)) {\n      return iter;\n    }\n    assertNotInfinite(iter.size);\n    var newSize = this.size;\n    var head = this._head;\n    iter.__iterate(\n      function (value) {\n        newSize++;\n        head = {\n          value: value,\n          next: head\n        };\n      },\n      /* reverse */ true\n    );\n    if (this.__ownerID) {\n      this.size = newSize;\n      this._head = head;\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return makeStack(newSize, head);\n  };\n\n  Stack.prototype.pop = function pop () {\n    return this.slice(1);\n  };\n\n  Stack.prototype.clear = function clear () {\n    if (this.size === 0) {\n      return this;\n    }\n    if (this.__ownerID) {\n      this.size = 0;\n      this._head = undefined;\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return emptyStack();\n  };\n\n  Stack.prototype.slice = function slice (begin, end) {\n    if (wholeSlice(begin, end, this.size)) {\n      return this;\n    }\n    var resolvedBegin = resolveBegin(begin, this.size);\n    var resolvedEnd = resolveEnd(end, this.size);\n    if (resolvedEnd !== this.size) {\n      // super.slice(begin, end);\n      return IndexedCollection$$1.prototype.slice.call(this, begin, end);\n    }\n    var newSize = this.size - resolvedBegin;\n    var head = this._head;\n    while (resolvedBegin--) {\n      head = head.next;\n    }\n    if (this.__ownerID) {\n      this.size = newSize;\n      this._head = head;\n      this.__hash = undefined;\n      this.__altered = true;\n      return this;\n    }\n    return makeStack(newSize, head);\n  };\n\n  // @pragma Mutability\n\n  Stack.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    if (!ownerID) {\n      if (this.size === 0) {\n        return emptyStack();\n      }\n      this.__ownerID = ownerID;\n      this.__altered = false;\n      return this;\n    }\n    return makeStack(this.size, this._head, ownerID, this.__hash);\n  };\n\n  // @pragma Iteration\n\n  Stack.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    if (reverse) {\n      return new ArraySeq(this.toArray()).__iterate(\n        function (v, k) { return fn(v, k, this$1); },\n        reverse\n      );\n    }\n    var iterations = 0;\n    var node = this._head;\n    while (node) {\n      if (fn(node.value, iterations++, this$1) === false) {\n        break;\n      }\n      node = node.next;\n    }\n    return iterations;\n  };\n\n  Stack.prototype.__iterator = function __iterator (type, reverse) {\n    if (reverse) {\n      return new ArraySeq(this.toArray()).__iterator(type, reverse);\n    }\n    var iterations = 0;\n    var node = this._head;\n    return new Iterator(function () {\n      if (node) {\n        var value = node.value;\n        node = node.next;\n        return iteratorValue(type, iterations++, value);\n      }\n      return iteratorDone();\n    });\n  };\n\n  return Stack;\n}(IndexedCollection));\n\nfunction isStack(maybeStack) {\n  return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);\n}\n\nStack.isStack = isStack;\n\nvar IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';\n\nvar StackPrototype = Stack.prototype;\nStackPrototype[IS_STACK_SENTINEL] = true;\nStackPrototype.withMutations = MapPrototype.withMutations;\nStackPrototype.asMutable = MapPrototype.asMutable;\nStackPrototype.asImmutable = MapPrototype.asImmutable;\nStackPrototype.wasAltered = MapPrototype.wasAltered;\nStackPrototype.shift = StackPrototype.pop;\nStackPrototype.unshift = StackPrototype.push;\nStackPrototype.unshiftAll = StackPrototype.pushAll;\n\nfunction makeStack(size, head, ownerID, hash) {\n  var map = Object.create(StackPrototype);\n  map.size = size;\n  map._head = head;\n  map.__ownerID = ownerID;\n  map.__hash = hash;\n  map.__altered = false;\n  return map;\n}\n\nvar EMPTY_STACK;\nfunction emptyStack() {\n  return EMPTY_STACK || (EMPTY_STACK = makeStack(0));\n}\n\nfunction deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (\n    !isCollection(b) ||\n    (a.size !== undefined && b.size !== undefined && a.size !== b.size) ||\n    (a.__hash !== undefined &&\n      b.__hash !== undefined &&\n      a.__hash !== b.__hash) ||\n    isKeyed(a) !== isKeyed(b) ||\n    isIndexed(a) !== isIndexed(b) ||\n    isOrdered(a) !== isOrdered(b)\n  ) {\n    return false;\n  }\n\n  if (a.size === 0 && b.size === 0) {\n    return true;\n  }\n\n  var notAssociative = !isAssociative(a);\n\n  if (isOrdered(a)) {\n    var entries = a.entries();\n    return b.every(function (v, k) {\n      var entry = entries.next().value;\n      return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));\n    }) && entries.next().done;\n  }\n\n  var flipped = false;\n\n  if (a.size === undefined) {\n    if (b.size === undefined) {\n      if (typeof a.cacheResult === 'function') {\n        a.cacheResult();\n      }\n    } else {\n      flipped = true;\n      var _ = a;\n      a = b;\n      b = _;\n    }\n  }\n\n  var allEqual = true;\n  var bSize = b.__iterate(function (v, k) {\n    if (\n      notAssociative\n        ? !a.has(v)\n        : flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)\n    ) {\n      allEqual = false;\n      return false;\n    }\n  });\n\n  return allEqual && a.size === bSize;\n}\n\n/**\n * Contributes additional methods to a constructor\n */\nfunction mixin(ctor, methods) {\n  var keyCopier = function (key) {\n    ctor.prototype[key] = methods[key];\n  };\n  Object.keys(methods).forEach(keyCopier);\n  Object.getOwnPropertySymbols &&\n    Object.getOwnPropertySymbols(methods).forEach(keyCopier);\n  return ctor;\n}\n\nvar Set = (function (SetCollection$$1) {\n  function Set(value) {\n    return value === null || value === undefined\n      ? emptySet()\n      : isSet(value) && !isOrdered(value)\n          ? value\n          : emptySet().withMutations(function (set) {\n              var iter = SetCollection$$1(value);\n              assertNotInfinite(iter.size);\n              iter.forEach(function (v) { return set.add(v); });\n            });\n  }\n\n  if ( SetCollection$$1 ) Set.__proto__ = SetCollection$$1;\n  Set.prototype = Object.create( SetCollection$$1 && SetCollection$$1.prototype );\n  Set.prototype.constructor = Set;\n\n  Set.of = function of (/*...values*/) {\n    return this(arguments);\n  };\n\n  Set.fromKeys = function fromKeys (value) {\n    return this(KeyedCollection(value).keySeq());\n  };\n\n  Set.intersect = function intersect (sets) {\n    sets = Collection(sets).toArray();\n    return sets.length\n      ? SetPrototype.intersect.apply(Set(sets.pop()), sets)\n      : emptySet();\n  };\n\n  Set.union = function union (sets) {\n    sets = Collection(sets).toArray();\n    return sets.length\n      ? SetPrototype.union.apply(Set(sets.pop()), sets)\n      : emptySet();\n  };\n\n  Set.prototype.toString = function toString () {\n    return this.__toString('Set {', '}');\n  };\n\n  // @pragma Access\n\n  Set.prototype.has = function has (value) {\n    return this._map.has(value);\n  };\n\n  // @pragma Modification\n\n  Set.prototype.add = function add (value) {\n    return updateSet(this, this._map.set(value, true));\n  };\n\n  Set.prototype.remove = function remove (value) {\n    return updateSet(this, this._map.remove(value));\n  };\n\n  Set.prototype.clear = function clear () {\n    return updateSet(this, this._map.clear());\n  };\n\n  // @pragma Composition\n\n  Set.prototype.union = function union () {\n    var iters = [], len = arguments.length;\n    while ( len-- ) iters[ len ] = arguments[ len ];\n\n    iters = iters.filter(function (x) { return x.size !== 0; });\n    if (iters.length === 0) {\n      return this;\n    }\n    if (this.size === 0 && !this.__ownerID && iters.length === 1) {\n      return this.constructor(iters[0]);\n    }\n    return this.withMutations(function (set) {\n      for (var ii = 0; ii < iters.length; ii++) {\n        SetCollection$$1(iters[ii]).forEach(function (value) { return set.add(value); });\n      }\n    });\n  };\n\n  Set.prototype.intersect = function intersect () {\n    var iters = [], len = arguments.length;\n    while ( len-- ) iters[ len ] = arguments[ len ];\n\n    if (iters.length === 0) {\n      return this;\n    }\n    iters = iters.map(function (iter) { return SetCollection$$1(iter); });\n    var toRemove = [];\n    this.forEach(function (value) {\n      if (!iters.every(function (iter) { return iter.includes(value); })) {\n        toRemove.push(value);\n      }\n    });\n    return this.withMutations(function (set) {\n      toRemove.forEach(function (value) {\n        set.remove(value);\n      });\n    });\n  };\n\n  Set.prototype.subtract = function subtract () {\n    var iters = [], len = arguments.length;\n    while ( len-- ) iters[ len ] = arguments[ len ];\n\n    if (iters.length === 0) {\n      return this;\n    }\n    var toRemove = [];\n    this.forEach(function (value) {\n      if (iters.some(function (iter) { return iter.includes(value); })) {\n        toRemove.push(value);\n      }\n    });\n    return this.withMutations(function (set) {\n      toRemove.forEach(function (value) {\n        set.remove(value);\n      });\n    });\n  };\n\n  Set.prototype.merge = function merge () {\n    return this.union.apply(this, arguments);\n  };\n\n  Set.prototype.mergeWith = function mergeWith (merger) {\n    var iters = [], len = arguments.length - 1;\n    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n    return this.union.apply(this, iters);\n  };\n\n  Set.prototype.sort = function sort (comparator) {\n    // Late binding\n    return OrderedSet(sortFactory(this, comparator));\n  };\n\n  Set.prototype.sortBy = function sortBy (mapper, comparator) {\n    // Late binding\n    return OrderedSet(sortFactory(this, comparator, mapper));\n  };\n\n  Set.prototype.wasAltered = function wasAltered () {\n    return this._map.wasAltered();\n  };\n\n  Set.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    return this._map.__iterate(function (_, k) { return fn(k, k, this$1); }, reverse);\n  };\n\n  Set.prototype.__iterator = function __iterator (type, reverse) {\n    return this._map.map(function (_, k) { return k; }).__iterator(type, reverse);\n  };\n\n  Set.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    var newMap = this._map.__ensureOwner(ownerID);\n    if (!ownerID) {\n      if (this.size === 0) {\n        return emptySet();\n      }\n      this.__ownerID = ownerID;\n      this._map = newMap;\n      return this;\n    }\n    return this.__make(newMap, ownerID);\n  };\n\n  return Set;\n}(SetCollection));\n\nfunction isSet(maybeSet) {\n  return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);\n}\n\nSet.isSet = isSet;\n\nvar IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';\n\nvar SetPrototype = Set.prototype;\nSetPrototype[IS_SET_SENTINEL] = true;\nSetPrototype[DELETE] = SetPrototype.remove;\nSetPrototype.mergeDeep = SetPrototype.merge;\nSetPrototype.mergeDeepWith = SetPrototype.mergeWith;\nSetPrototype.withMutations = MapPrototype.withMutations;\nSetPrototype.asMutable = MapPrototype.asMutable;\nSetPrototype.asImmutable = MapPrototype.asImmutable;\n\nSetPrototype.__empty = emptySet;\nSetPrototype.__make = makeSet;\n\nfunction updateSet(set, newMap) {\n  if (set.__ownerID) {\n    set.size = newMap.size;\n    set._map = newMap;\n    return set;\n  }\n  return newMap === set._map\n    ? set\n    : newMap.size === 0 ? set.__empty() : set.__make(newMap);\n}\n\nfunction makeSet(map, ownerID) {\n  var set = Object.create(SetPrototype);\n  set.size = map ? map.size : 0;\n  set._map = map;\n  set.__ownerID = ownerID;\n  return set;\n}\n\nvar EMPTY_SET;\nfunction emptySet() {\n  return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));\n}\n\n/**\n * Returns a lazy seq of nums from start (inclusive) to end\n * (exclusive), by step, where start defaults to 0, step to 1, and end to\n * infinity. When start is equal to end, returns empty list.\n */\nvar Range = (function (IndexedSeq$$1) {\n  function Range(start, end, step) {\n    if (!(this instanceof Range)) {\n      return new Range(start, end, step);\n    }\n    invariant(step !== 0, 'Cannot step a Range by 0');\n    start = start || 0;\n    if (end === undefined) {\n      end = Infinity;\n    }\n    step = step === undefined ? 1 : Math.abs(step);\n    if (end < start) {\n      step = -step;\n    }\n    this._start = start;\n    this._end = end;\n    this._step = step;\n    this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);\n    if (this.size === 0) {\n      if (EMPTY_RANGE) {\n        return EMPTY_RANGE;\n      }\n      EMPTY_RANGE = this;\n    }\n  }\n\n  if ( IndexedSeq$$1 ) Range.__proto__ = IndexedSeq$$1;\n  Range.prototype = Object.create( IndexedSeq$$1 && IndexedSeq$$1.prototype );\n  Range.prototype.constructor = Range;\n\n  Range.prototype.toString = function toString () {\n    if (this.size === 0) {\n      return 'Range []';\n    }\n    return 'Range [ ' +\n      this._start +\n      '...' +\n      this._end +\n      (this._step !== 1 ? ' by ' + this._step : '') +\n      ' ]';\n  };\n\n  Range.prototype.get = function get (index, notSetValue) {\n    return this.has(index)\n      ? this._start + wrapIndex(this, index) * this._step\n      : notSetValue;\n  };\n\n  Range.prototype.includes = function includes (searchValue) {\n    var possibleIndex = (searchValue - this._start) / this._step;\n    return possibleIndex >= 0 &&\n      possibleIndex < this.size &&\n      possibleIndex === Math.floor(possibleIndex);\n  };\n\n  Range.prototype.slice = function slice (begin, end) {\n    if (wholeSlice(begin, end, this.size)) {\n      return this;\n    }\n    begin = resolveBegin(begin, this.size);\n    end = resolveEnd(end, this.size);\n    if (end <= begin) {\n      return new Range(0, 0);\n    }\n    return new Range(\n      this.get(begin, this._end),\n      this.get(end, this._end),\n      this._step\n    );\n  };\n\n  Range.prototype.indexOf = function indexOf (searchValue) {\n    var offsetValue = searchValue - this._start;\n    if (offsetValue % this._step === 0) {\n      var index = offsetValue / this._step;\n      if (index >= 0 && index < this.size) {\n        return index;\n      }\n    }\n    return -1;\n  };\n\n  Range.prototype.lastIndexOf = function lastIndexOf (searchValue) {\n    return this.indexOf(searchValue);\n  };\n\n  Range.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    var size = this.size;\n    var step = this._step;\n    var value = reverse ? this._start + (size - 1) * step : this._start;\n    var i = 0;\n    while (i !== size) {\n      if (fn(value, reverse ? size - ++i : i++, this$1) === false) {\n        break;\n      }\n      value += reverse ? -step : step;\n    }\n    return i;\n  };\n\n  Range.prototype.__iterator = function __iterator (type, reverse) {\n    var size = this.size;\n    var step = this._step;\n    var value = reverse ? this._start + (size - 1) * step : this._start;\n    var i = 0;\n    return new Iterator(function () {\n      if (i === size) {\n        return iteratorDone();\n      }\n      var v = value;\n      value += reverse ? -step : step;\n      return iteratorValue(type, reverse ? size - ++i : i++, v);\n    });\n  };\n\n  Range.prototype.equals = function equals (other) {\n    return other instanceof Range\n      ? this._start === other._start &&\n          this._end === other._end &&\n          this._step === other._step\n      : deepEqual(this, other);\n  };\n\n  return Range;\n}(IndexedSeq));\n\nvar EMPTY_RANGE;\n\n// Note: all of these methods are deprecated.\nCollection.isIterable = isCollection;\nCollection.isKeyed = isKeyed;\nCollection.isIndexed = isIndexed;\nCollection.isAssociative = isAssociative;\nCollection.isOrdered = isOrdered;\n\nCollection.Iterator = Iterator;\n\nmixin(Collection, {\n  // ### Conversion to other types\n\n  toArray: function toArray() {\n    assertNotInfinite(this.size);\n    var array = new Array(this.size || 0);\n    this.valueSeq().__iterate(function (v, i) {\n      array[i] = v;\n    });\n    return array;\n  },\n\n  toIndexedSeq: function toIndexedSeq() {\n    return new ToIndexedSequence(this);\n  },\n\n  toJS: function toJS$1() {\n    return this.toSeq().map(toJS).toJSON();\n  },\n\n  toKeyedSeq: function toKeyedSeq() {\n    return new ToKeyedSequence(this, true);\n  },\n\n  toMap: function toMap() {\n    // Use Late Binding here to solve the circular dependency.\n    return Map(this.toKeyedSeq());\n  },\n\n  toObject: function toObject() {\n    assertNotInfinite(this.size);\n    var object = {};\n    this.__iterate(function (v, k) {\n      object[k] = v;\n    });\n    return object;\n  },\n\n  toOrderedMap: function toOrderedMap() {\n    // Use Late Binding here to solve the circular dependency.\n    return OrderedMap(this.toKeyedSeq());\n  },\n\n  toOrderedSet: function toOrderedSet() {\n    // Use Late Binding here to solve the circular dependency.\n    return OrderedSet(isKeyed(this) ? this.valueSeq() : this);\n  },\n\n  toSet: function toSet() {\n    // Use Late Binding here to solve the circular dependency.\n    return Set(isKeyed(this) ? this.valueSeq() : this);\n  },\n\n  toSetSeq: function toSetSeq() {\n    return new ToSetSequence(this);\n  },\n\n  toSeq: function toSeq() {\n    return isIndexed(this)\n      ? this.toIndexedSeq()\n      : isKeyed(this) ? this.toKeyedSeq() : this.toSetSeq();\n  },\n\n  toStack: function toStack() {\n    // Use Late Binding here to solve the circular dependency.\n    return Stack(isKeyed(this) ? this.valueSeq() : this);\n  },\n\n  toList: function toList() {\n    // Use Late Binding here to solve the circular dependency.\n    return List(isKeyed(this) ? this.valueSeq() : this);\n  },\n\n  // ### Common JavaScript methods and properties\n\n  toString: function toString() {\n    return '[Collection]';\n  },\n\n  __toString: function __toString(head, tail) {\n    if (this.size === 0) {\n      return head + tail;\n    }\n    return head +\n      ' ' +\n      this.toSeq().map(this.__toStringMapper).join(', ') +\n      ' ' +\n      tail;\n  },\n\n  // ### ES6 Collection methods (ES6 Array and Map)\n\n  concat: function concat() {\n    var values = [], len = arguments.length;\n    while ( len-- ) values[ len ] = arguments[ len ];\n\n    return reify(this, concatFactory(this, values));\n  },\n\n  includes: function includes(searchValue) {\n    return this.some(function (value) { return is(value, searchValue); });\n  },\n\n  entries: function entries() {\n    return this.__iterator(ITERATE_ENTRIES);\n  },\n\n  every: function every(predicate, context) {\n    assertNotInfinite(this.size);\n    var returnValue = true;\n    this.__iterate(function (v, k, c) {\n      if (!predicate.call(context, v, k, c)) {\n        returnValue = false;\n        return false;\n      }\n    });\n    return returnValue;\n  },\n\n  filter: function filter(predicate, context) {\n    return reify(this, filterFactory(this, predicate, context, true));\n  },\n\n  find: function find(predicate, context, notSetValue) {\n    var entry = this.findEntry(predicate, context);\n    return entry ? entry[1] : notSetValue;\n  },\n\n  forEach: function forEach(sideEffect, context) {\n    assertNotInfinite(this.size);\n    return this.__iterate(context ? sideEffect.bind(context) : sideEffect);\n  },\n\n  join: function join(separator) {\n    assertNotInfinite(this.size);\n    separator = separator !== undefined ? '' + separator : ',';\n    var joined = '';\n    var isFirst = true;\n    this.__iterate(function (v) {\n      isFirst ? (isFirst = false) : (joined += separator);\n      joined += v !== null && v !== undefined ? v.toString() : '';\n    });\n    return joined;\n  },\n\n  keys: function keys() {\n    return this.__iterator(ITERATE_KEYS);\n  },\n\n  map: function map(mapper, context) {\n    return reify(this, mapFactory(this, mapper, context));\n  },\n\n  reduce: function reduce$1(reducer, initialReduction, context) {\n    return reduce(\n      this,\n      reducer,\n      initialReduction,\n      context,\n      arguments.length < 2,\n      false\n    );\n  },\n\n  reduceRight: function reduceRight(reducer, initialReduction, context) {\n    return reduce(\n      this,\n      reducer,\n      initialReduction,\n      context,\n      arguments.length < 2,\n      true\n    );\n  },\n\n  reverse: function reverse() {\n    return reify(this, reverseFactory(this, true));\n  },\n\n  slice: function slice(begin, end) {\n    return reify(this, sliceFactory(this, begin, end, true));\n  },\n\n  some: function some(predicate, context) {\n    return !this.every(not(predicate), context);\n  },\n\n  sort: function sort(comparator) {\n    return reify(this, sortFactory(this, comparator));\n  },\n\n  values: function values() {\n    return this.__iterator(ITERATE_VALUES);\n  },\n\n  // ### More sequential methods\n\n  butLast: function butLast() {\n    return this.slice(0, -1);\n  },\n\n  isEmpty: function isEmpty() {\n    return this.size !== undefined ? this.size === 0 : !this.some(function () { return true; });\n  },\n\n  count: function count(predicate, context) {\n    return ensureSize(\n      predicate ? this.toSeq().filter(predicate, context) : this\n    );\n  },\n\n  countBy: function countBy(grouper, context) {\n    return countByFactory(this, grouper, context);\n  },\n\n  equals: function equals(other) {\n    return deepEqual(this, other);\n  },\n\n  entrySeq: function entrySeq() {\n    var collection = this;\n    if (collection._cache) {\n      // We cache as an entries array, so we can just return the cache!\n      return new ArraySeq(collection._cache);\n    }\n    var entriesSequence = collection.toSeq().map(entryMapper).toIndexedSeq();\n    entriesSequence.fromEntrySeq = function () { return collection.toSeq(); };\n\n    // Entries are plain Array, which do not define toJS, so it must\n    // manually converts keys and values before conversion.\n    entriesSequence.toJS = function() {\n      return this.map(function (entry) { return [toJS(entry[0]), toJS(entry[1])]; }).toJSON();\n    };\n\n    return entriesSequence;\n  },\n\n  filterNot: function filterNot(predicate, context) {\n    return this.filter(not(predicate), context);\n  },\n\n  findEntry: function findEntry(predicate, context, notSetValue) {\n    var found = notSetValue;\n    this.__iterate(function (v, k, c) {\n      if (predicate.call(context, v, k, c)) {\n        found = [k, v];\n        return false;\n      }\n    });\n    return found;\n  },\n\n  findKey: function findKey(predicate, context) {\n    var entry = this.findEntry(predicate, context);\n    return entry && entry[0];\n  },\n\n  findLast: function findLast(predicate, context, notSetValue) {\n    return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);\n  },\n\n  findLastEntry: function findLastEntry(predicate, context, notSetValue) {\n    return this.toKeyedSeq()\n      .reverse()\n      .findEntry(predicate, context, notSetValue);\n  },\n\n  findLastKey: function findLastKey(predicate, context) {\n    return this.toKeyedSeq().reverse().findKey(predicate, context);\n  },\n\n  first: function first() {\n    return this.find(returnTrue);\n  },\n\n  flatMap: function flatMap(mapper, context) {\n    return reify(this, flatMapFactory(this, mapper, context));\n  },\n\n  flatten: function flatten(depth) {\n    return reify(this, flattenFactory(this, depth, true));\n  },\n\n  fromEntrySeq: function fromEntrySeq() {\n    return new FromEntriesSequence(this);\n  },\n\n  get: function get(searchKey, notSetValue) {\n    return this.find(function (_, key) { return is(key, searchKey); }, undefined, notSetValue);\n  },\n\n  getIn: function getIn(searchKeyPath, notSetValue) {\n    var nested = this;\n    var keyPath = coerceKeyPath(searchKeyPath);\n    var i = 0;\n    while (i !== keyPath.length) {\n      if (!nested || !nested.get) {\n        throw new TypeError(\n          'Invalid keyPath: Value at [' +\n            keyPath.slice(0, i).map(quoteString) +\n            '] does not have a .get() method: ' +\n            nested\n        );\n      }\n      nested = nested.get(keyPath[i++], NOT_SET);\n      if (nested === NOT_SET) {\n        return notSetValue;\n      }\n    }\n    return nested;\n    // var step;\n    // while (!(step = iter.next()).done) {\n    //   var key = step.value;\n    //   nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;\n    //   if (nested === NOT_SET) {\n    //     return notSetValue;\n    //   }\n    // }\n    // return nested;\n  },\n\n  groupBy: function groupBy(grouper, context) {\n    return groupByFactory(this, grouper, context);\n  },\n\n  has: function has(searchKey) {\n    return this.get(searchKey, NOT_SET) !== NOT_SET;\n  },\n\n  hasIn: function hasIn(searchKeyPath) {\n    return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;\n  },\n\n  isSubset: function isSubset(iter) {\n    iter = typeof iter.includes === 'function' ? iter : Collection(iter);\n    return this.every(function (value) { return iter.includes(value); });\n  },\n\n  isSuperset: function isSuperset(iter) {\n    iter = typeof iter.isSubset === 'function' ? iter : Collection(iter);\n    return iter.isSubset(this);\n  },\n\n  keyOf: function keyOf(searchValue) {\n    return this.findKey(function (value) { return is(value, searchValue); });\n  },\n\n  keySeq: function keySeq() {\n    return this.toSeq().map(keyMapper).toIndexedSeq();\n  },\n\n  last: function last() {\n    return this.toSeq().reverse().first();\n  },\n\n  lastKeyOf: function lastKeyOf(searchValue) {\n    return this.toKeyedSeq().reverse().keyOf(searchValue);\n  },\n\n  max: function max(comparator) {\n    return maxFactory(this, comparator);\n  },\n\n  maxBy: function maxBy(mapper, comparator) {\n    return maxFactory(this, comparator, mapper);\n  },\n\n  min: function min(comparator) {\n    return maxFactory(\n      this,\n      comparator ? neg(comparator) : defaultNegComparator\n    );\n  },\n\n  minBy: function minBy(mapper, comparator) {\n    return maxFactory(\n      this,\n      comparator ? neg(comparator) : defaultNegComparator,\n      mapper\n    );\n  },\n\n  rest: function rest() {\n    return this.slice(1);\n  },\n\n  skip: function skip(amount) {\n    return amount === 0 ? this : this.slice(Math.max(0, amount));\n  },\n\n  skipLast: function skipLast(amount) {\n    return amount === 0 ? this : this.slice(0, -Math.max(0, amount));\n  },\n\n  skipWhile: function skipWhile(predicate, context) {\n    return reify(this, skipWhileFactory(this, predicate, context, true));\n  },\n\n  skipUntil: function skipUntil(predicate, context) {\n    return this.skipWhile(not(predicate), context);\n  },\n\n  sortBy: function sortBy(mapper, comparator) {\n    return reify(this, sortFactory(this, comparator, mapper));\n  },\n\n  take: function take(amount) {\n    return this.slice(0, Math.max(0, amount));\n  },\n\n  takeLast: function takeLast(amount) {\n    return this.slice(-Math.max(0, amount));\n  },\n\n  takeWhile: function takeWhile(predicate, context) {\n    return reify(this, takeWhileFactory(this, predicate, context));\n  },\n\n  takeUntil: function takeUntil(predicate, context) {\n    return this.takeWhile(not(predicate), context);\n  },\n\n  update: function update(fn) {\n    return fn(this);\n  },\n\n  valueSeq: function valueSeq() {\n    return this.toIndexedSeq();\n  },\n\n  // ### Hashable Object\n\n  hashCode: function hashCode() {\n    return this.__hash || (this.__hash = hashCollection(this));\n  }\n\n  // ### Internal\n\n  // abstract __iterate(fn, reverse)\n\n  // abstract __iterator(type, reverse)\n});\n\nvar CollectionPrototype = Collection.prototype;\nCollectionPrototype[IS_ITERABLE_SENTINEL] = true;\nCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.values;\nCollectionPrototype.toJSON = CollectionPrototype.toArray;\nCollectionPrototype.__toStringMapper = quoteString;\nCollectionPrototype.inspect = (CollectionPrototype.toSource = function() {\n  return this.toString();\n});\nCollectionPrototype.chain = CollectionPrototype.flatMap;\nCollectionPrototype.contains = CollectionPrototype.includes;\n\nmixin(KeyedCollection, {\n  // ### More sequential methods\n\n  flip: function flip() {\n    return reify(this, flipFactory(this));\n  },\n\n  mapEntries: function mapEntries(mapper, context) {\n    var this$1 = this;\n\n    var iterations = 0;\n    return reify(\n      this,\n      this.toSeq()\n        .map(function (v, k) { return mapper.call(context, [k, v], iterations++, this$1); })\n        .fromEntrySeq()\n    );\n  },\n\n  mapKeys: function mapKeys(mapper, context) {\n    var this$1 = this;\n\n    return reify(\n      this,\n      this.toSeq().flip().map(function (k, v) { return mapper.call(context, k, v, this$1); }).flip()\n    );\n  }\n});\n\nvar KeyedCollectionPrototype = KeyedCollection.prototype;\nKeyedCollectionPrototype[IS_KEYED_SENTINEL] = true;\nKeyedCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;\nKeyedCollectionPrototype.toJSON = CollectionPrototype.toObject;\nKeyedCollectionPrototype.__toStringMapper = function (v, k) { return quoteString(k) + ': ' + quoteString(v); };\n\nmixin(IndexedCollection, {\n  // ### Conversion to other types\n\n  toKeyedSeq: function toKeyedSeq() {\n    return new ToKeyedSequence(this, false);\n  },\n\n  // ### ES6 Collection methods (ES6 Array and Map)\n\n  filter: function filter(predicate, context) {\n    return reify(this, filterFactory(this, predicate, context, false));\n  },\n\n  findIndex: function findIndex(predicate, context) {\n    var entry = this.findEntry(predicate, context);\n    return entry ? entry[0] : -1;\n  },\n\n  indexOf: function indexOf(searchValue) {\n    var key = this.keyOf(searchValue);\n    return key === undefined ? -1 : key;\n  },\n\n  lastIndexOf: function lastIndexOf(searchValue) {\n    var key = this.lastKeyOf(searchValue);\n    return key === undefined ? -1 : key;\n  },\n\n  reverse: function reverse() {\n    return reify(this, reverseFactory(this, false));\n  },\n\n  slice: function slice(begin, end) {\n    return reify(this, sliceFactory(this, begin, end, false));\n  },\n\n  splice: function splice(index, removeNum /*, ...values*/) {\n    var numArgs = arguments.length;\n    removeNum = Math.max(removeNum || 0, 0);\n    if (numArgs === 0 || (numArgs === 2 && !removeNum)) {\n      return this;\n    }\n    // If index is negative, it should resolve relative to the size of the\n    // collection. However size may be expensive to compute if not cached, so\n    // only call count() if the number is in fact negative.\n    index = resolveBegin(index, index < 0 ? this.count() : this.size);\n    var spliced = this.slice(0, index);\n    return reify(\n      this,\n      numArgs === 1\n        ? spliced\n        : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))\n    );\n  },\n\n  // ### More collection methods\n\n  findLastIndex: function findLastIndex(predicate, context) {\n    var entry = this.findLastEntry(predicate, context);\n    return entry ? entry[0] : -1;\n  },\n\n  first: function first() {\n    return this.get(0);\n  },\n\n  flatten: function flatten(depth) {\n    return reify(this, flattenFactory(this, depth, false));\n  },\n\n  get: function get(index, notSetValue) {\n    index = wrapIndex(this, index);\n    return index < 0 ||\n      (this.size === Infinity || (this.size !== undefined && index > this.size))\n      ? notSetValue\n      : this.find(function (_, key) { return key === index; }, undefined, notSetValue);\n  },\n\n  has: function has(index) {\n    index = wrapIndex(this, index);\n    return index >= 0 &&\n      (this.size !== undefined\n        ? this.size === Infinity || index < this.size\n        : this.indexOf(index) !== -1);\n  },\n\n  interpose: function interpose(separator) {\n    return reify(this, interposeFactory(this, separator));\n  },\n\n  interleave: function interleave(/*...collections*/) {\n    var collections = [this].concat(arrCopy(arguments));\n    var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, collections);\n    var interleaved = zipped.flatten(true);\n    if (zipped.size) {\n      interleaved.size = zipped.size * collections.length;\n    }\n    return reify(this, interleaved);\n  },\n\n  keySeq: function keySeq() {\n    return Range(0, this.size);\n  },\n\n  last: function last() {\n    return this.get(-1);\n  },\n\n  skipWhile: function skipWhile(predicate, context) {\n    return reify(this, skipWhileFactory(this, predicate, context, false));\n  },\n\n  zip: function zip(/*, ...collections */) {\n    var collections = [this].concat(arrCopy(arguments));\n    return reify(this, zipWithFactory(this, defaultZipper, collections));\n  },\n\n  zipWith: function zipWith(zipper /*, ...collections */) {\n    var collections = arrCopy(arguments);\n    collections[0] = this;\n    return reify(this, zipWithFactory(this, zipper, collections));\n  }\n});\n\nvar IndexedCollectionPrototype = IndexedCollection.prototype;\nIndexedCollectionPrototype[IS_INDEXED_SENTINEL] = true;\nIndexedCollectionPrototype[IS_ORDERED_SENTINEL] = true;\n\nmixin(SetCollection, {\n  // ### ES6 Collection methods (ES6 Array and Map)\n\n  get: function get(value, notSetValue) {\n    return this.has(value) ? value : notSetValue;\n  },\n\n  includes: function includes(value) {\n    return this.has(value);\n  },\n\n  // ### More sequential methods\n\n  keySeq: function keySeq() {\n    return this.valueSeq();\n  }\n});\n\nSetCollection.prototype.has = CollectionPrototype.includes;\nSetCollection.prototype.contains = SetCollection.prototype.includes;\n\n// Mixin subclasses\n\nmixin(KeyedSeq, KeyedCollection.prototype);\nmixin(IndexedSeq, IndexedCollection.prototype);\nmixin(SetSeq, SetCollection.prototype);\n\n// #pragma Helper functions\n\nfunction reduce(collection, reducer, reduction, context, useFirst, reverse) {\n  assertNotInfinite(collection.size);\n  collection.__iterate(\n    function (v, k, c) {\n      if (useFirst) {\n        useFirst = false;\n        reduction = v;\n      } else {\n        reduction = reducer.call(context, reduction, v, k, c);\n      }\n    },\n    reverse\n  );\n  return reduction;\n}\n\nfunction keyMapper(v, k) {\n  return k;\n}\n\nfunction entryMapper(v, k) {\n  return [k, v];\n}\n\nfunction toJS(value) {\n  return value && typeof value.toJS === 'function' ? value.toJS() : value;\n}\n\nfunction not(predicate) {\n  return function() {\n    return !predicate.apply(this, arguments);\n  };\n}\n\nfunction neg(predicate) {\n  return function() {\n    return -predicate.apply(this, arguments);\n  };\n}\n\nfunction defaultZipper() {\n  return arrCopy(arguments);\n}\n\nfunction defaultNegComparator(a, b) {\n  return a < b ? 1 : a > b ? -1 : 0;\n}\n\nfunction hashCollection(collection) {\n  if (collection.size === Infinity) {\n    return 0;\n  }\n  var ordered = isOrdered(collection);\n  var keyed = isKeyed(collection);\n  var h = ordered ? 1 : 0;\n  var size = collection.__iterate(\n    keyed\n      ? ordered\n          ? function (v, k) {\n              h = 31 * h + hashMerge(hash(v), hash(k)) | 0;\n            }\n          : function (v, k) {\n              h = h + hashMerge(hash(v), hash(k)) | 0;\n            }\n      : ordered\n          ? function (v) {\n              h = 31 * h + hash(v) | 0;\n            }\n          : function (v) {\n              h = h + hash(v) | 0;\n            }\n  );\n  return murmurHashOfSize(size, h);\n}\n\nfunction murmurHashOfSize(size, h) {\n  h = imul(h, 0xcc9e2d51);\n  h = imul(h << 15 | h >>> -15, 0x1b873593);\n  h = imul(h << 13 | h >>> -13, 5);\n  h = (h + 0xe6546b64 | 0) ^ size;\n  h = imul(h ^ h >>> 16, 0x85ebca6b);\n  h = imul(h ^ h >>> 13, 0xc2b2ae35);\n  h = smi(h ^ h >>> 16);\n  return h;\n}\n\nfunction hashMerge(a, b) {\n  return a ^ b + 0x9e3779b9 + (a << 6) + (a >> 2) | 0; // int\n}\n\nvar OrderedSet = (function (Set$$1) {\n  function OrderedSet(value) {\n    return value === null || value === undefined\n      ? emptyOrderedSet()\n      : isOrderedSet(value)\n          ? value\n          : emptyOrderedSet().withMutations(function (set) {\n              var iter = SetCollection(value);\n              assertNotInfinite(iter.size);\n              iter.forEach(function (v) { return set.add(v); });\n            });\n  }\n\n  if ( Set$$1 ) OrderedSet.__proto__ = Set$$1;\n  OrderedSet.prototype = Object.create( Set$$1 && Set$$1.prototype );\n  OrderedSet.prototype.constructor = OrderedSet;\n\n  OrderedSet.of = function of (/*...values*/) {\n    return this(arguments);\n  };\n\n  OrderedSet.fromKeys = function fromKeys (value) {\n    return this(KeyedCollection(value).keySeq());\n  };\n\n  OrderedSet.prototype.toString = function toString () {\n    return this.__toString('OrderedSet {', '}');\n  };\n\n  return OrderedSet;\n}(Set));\n\nfunction isOrderedSet(maybeOrderedSet) {\n  return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);\n}\n\nOrderedSet.isOrderedSet = isOrderedSet;\n\nvar OrderedSetPrototype = OrderedSet.prototype;\nOrderedSetPrototype[IS_ORDERED_SENTINEL] = true;\nOrderedSetPrototype.zip = IndexedCollectionPrototype.zip;\nOrderedSetPrototype.zipWith = IndexedCollectionPrototype.zipWith;\n\nOrderedSetPrototype.__empty = emptyOrderedSet;\nOrderedSetPrototype.__make = makeOrderedSet;\n\nfunction makeOrderedSet(map, ownerID) {\n  var set = Object.create(OrderedSetPrototype);\n  set.size = map ? map.size : 0;\n  set._map = map;\n  set.__ownerID = ownerID;\n  return set;\n}\n\nvar EMPTY_ORDERED_SET;\nfunction emptyOrderedSet() {\n  return EMPTY_ORDERED_SET ||\n    (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));\n}\n\nvar Record = function Record(defaultValues, name) {\n  var hasInitialized;\n\n  var RecordType = function Record(values) {\n    var this$1 = this;\n\n    if (values instanceof RecordType) {\n      return values;\n    }\n    if (!(this instanceof RecordType)) {\n      return new RecordType(values);\n    }\n    if (!hasInitialized) {\n      hasInitialized = true;\n      var keys = Object.keys(defaultValues);\n      var indices = (RecordTypePrototype._indices = {});\n      RecordTypePrototype._name = name;\n      RecordTypePrototype._keys = keys;\n      RecordTypePrototype._defaultValues = defaultValues;\n      for (var i = 0; i < keys.length; i++) {\n        var propName = keys[i];\n        indices[propName] = i;\n        if (RecordTypePrototype[propName]) {\n          /* eslint-disable no-console */\n          typeof console === 'object' &&\n            console.warn &&\n            console.warn(\n              'Cannot define ' +\n                recordName(this$1) +\n                ' with property \"' +\n                propName +\n                '\" since that property name is part of the Record API.'\n            );\n          /* eslint-enable no-console */\n        } else {\n          setProp(RecordTypePrototype, propName);\n        }\n      }\n    }\n    this.__ownerID = undefined;\n    this._values = List().withMutations(function (l) {\n      l.setSize(this$1._keys.length);\n      KeyedCollection(values).forEach(function (v, k) {\n        l.set(this$1._indices[k], v === this$1._defaultValues[k] ? undefined : v);\n      });\n    });\n  };\n\n  var RecordTypePrototype = (RecordType.prototype = Object.create(\n    RecordPrototype\n  ));\n  RecordTypePrototype.constructor = RecordType;\n\n  return RecordType;\n};\n\nRecord.prototype.toString = function toString () {\n    var this$1 = this;\n\n  var str = recordName(this) + ' { ';\n  var keys = this._keys;\n  var k;\n  for (var i = 0, l = keys.length; i !== l; i++) {\n    k = keys[i];\n    str += (i ? ', ' : '') + k + ': ' + quoteString(this$1.get(k));\n  }\n  return str + ' }';\n};\n\nRecord.prototype.equals = function equals (other) {\n  return this === other ||\n    (this._keys === other._keys && recordSeq(this).equals(recordSeq(other)));\n};\n\nRecord.prototype.hashCode = function hashCode () {\n  return recordSeq(this).hashCode();\n};\n\n// @pragma Access\n\nRecord.prototype.has = function has (k) {\n  return this._indices.hasOwnProperty(k);\n};\n\nRecord.prototype.get = function get (k, notSetValue) {\n  if (!this.has(k)) {\n    return notSetValue;\n  }\n  var index = this._indices[k];\n  var value = this._values.get(index);\n  return value === undefined ? this._defaultValues[k] : value;\n};\n\n// @pragma Modification\n\nRecord.prototype.set = function set (k, v) {\n  if (this.has(k)) {\n    var newValues = this._values.set(\n      this._indices[k],\n      v === this._defaultValues[k] ? undefined : v\n    );\n    if (newValues !== this._values && !this.__ownerID) {\n      return makeRecord(this, newValues);\n    }\n  }\n  return this;\n};\n\nRecord.prototype.remove = function remove (k) {\n  return this.set(k);\n};\n\nRecord.prototype.clear = function clear () {\n  var newValues = this._values.clear().setSize(this._keys.length);\n  return this.__ownerID ? this : makeRecord(this, newValues);\n};\n\nRecord.prototype.wasAltered = function wasAltered () {\n  return this._values.wasAltered();\n};\n\nRecord.prototype.toSeq = function toSeq () {\n  return recordSeq(this);\n};\n\nRecord.prototype.toJS = function toJS () {\n  return recordSeq(this).toJS();\n};\n\nRecord.prototype.__iterator = function __iterator (type, reverse) {\n  return recordSeq(this).__iterator(type, reverse);\n};\n\nRecord.prototype.__iterate = function __iterate (fn, reverse) {\n  return recordSeq(this).__iterate(fn, reverse);\n};\n\nRecord.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n  if (ownerID === this.__ownerID) {\n    return this;\n  }\n  var newValues = this._values.__ensureOwner(ownerID);\n  if (!ownerID) {\n    this.__ownerID = ownerID;\n    this._values = newValues;\n    return this;\n  }\n  return makeRecord(this, newValues, ownerID);\n};\n\nRecord.isRecord = isRecord;\nRecord.getDescriptiveName = recordName;\nvar RecordPrototype = Record.prototype;\nRecordPrototype[IS_RECORD_SENTINEL] = true;\nRecordPrototype[DELETE] = RecordPrototype.remove;\nRecordPrototype.getIn = CollectionPrototype.getIn;\nRecordPrototype.hasIn = CollectionPrototype.hasIn;\nRecordPrototype.merge = MapPrototype.merge;\nRecordPrototype.mergeWith = MapPrototype.mergeWith;\nRecordPrototype.mergeIn = MapPrototype.mergeIn;\nRecordPrototype.mergeDeep = MapPrototype.mergeDeep;\nRecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;\nRecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\nRecordPrototype.setIn = MapPrototype.setIn;\nRecordPrototype.update = MapPrototype.update;\nRecordPrototype.updateIn = MapPrototype.updateIn;\nRecordPrototype.withMutations = MapPrototype.withMutations;\nRecordPrototype.asMutable = MapPrototype.asMutable;\nRecordPrototype.asImmutable = MapPrototype.asImmutable;\nRecordPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;\nRecordPrototype.toJSON = (RecordPrototype.toObject = CollectionPrototype.toObject);\nRecordPrototype.inspect = (RecordPrototype.toSource = CollectionPrototype.toSource);\n\nfunction makeRecord(likeRecord, values, ownerID) {\n  var record = Object.create(Object.getPrototypeOf(likeRecord));\n  record._values = values;\n  record.__ownerID = ownerID;\n  return record;\n}\n\nfunction recordName(record) {\n  return record._name || record.constructor.name || 'Record';\n}\n\nfunction recordSeq(record) {\n  return keyedSeqFromValue(record._keys.map(function (k) { return [k, record.get(k)]; }));\n}\n\nfunction setProp(prototype, name) {\n  try {\n    Object.defineProperty(prototype, name, {\n      get: function() {\n        return this.get(name);\n      },\n      set: function(value) {\n        invariant(this.__ownerID, 'Cannot set on an immutable record.');\n        this.set(name, value);\n      }\n    });\n  } catch (error) {\n    // Object.defineProperty failed. Probably IE8.\n  }\n}\n\n/**\n * Returns a lazy Seq of `value` repeated `times` times. When `times` is\n * undefined, returns an infinite sequence of `value`.\n */\nvar Repeat = (function (IndexedSeq$$1) {\n  function Repeat(value, times) {\n    if (!(this instanceof Repeat)) {\n      return new Repeat(value, times);\n    }\n    this._value = value;\n    this.size = times === undefined ? Infinity : Math.max(0, times);\n    if (this.size === 0) {\n      if (EMPTY_REPEAT) {\n        return EMPTY_REPEAT;\n      }\n      EMPTY_REPEAT = this;\n    }\n  }\n\n  if ( IndexedSeq$$1 ) Repeat.__proto__ = IndexedSeq$$1;\n  Repeat.prototype = Object.create( IndexedSeq$$1 && IndexedSeq$$1.prototype );\n  Repeat.prototype.constructor = Repeat;\n\n  Repeat.prototype.toString = function toString () {\n    if (this.size === 0) {\n      return 'Repeat []';\n    }\n    return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';\n  };\n\n  Repeat.prototype.get = function get (index, notSetValue) {\n    return this.has(index) ? this._value : notSetValue;\n  };\n\n  Repeat.prototype.includes = function includes (searchValue) {\n    return is(this._value, searchValue);\n  };\n\n  Repeat.prototype.slice = function slice (begin, end) {\n    var size = this.size;\n    return wholeSlice(begin, end, size)\n      ? this\n      : new Repeat(\n          this._value,\n          resolveEnd(end, size) - resolveBegin(begin, size)\n        );\n  };\n\n  Repeat.prototype.reverse = function reverse () {\n    return this;\n  };\n\n  Repeat.prototype.indexOf = function indexOf (searchValue) {\n    if (is(this._value, searchValue)) {\n      return 0;\n    }\n    return -1;\n  };\n\n  Repeat.prototype.lastIndexOf = function lastIndexOf (searchValue) {\n    if (is(this._value, searchValue)) {\n      return this.size;\n    }\n    return -1;\n  };\n\n  Repeat.prototype.__iterate = function __iterate (fn, reverse) {\n    var this$1 = this;\n\n    var size = this.size;\n    var i = 0;\n    while (i !== size) {\n      if (fn(this$1._value, reverse ? size - ++i : i++, this$1) === false) {\n        break;\n      }\n    }\n    return i;\n  };\n\n  Repeat.prototype.__iterator = function __iterator (type, reverse) {\n    var this$1 = this;\n\n    var size = this.size;\n    var i = 0;\n    return new Iterator(\n      function () { return i === size\n          ? iteratorDone()\n          : iteratorValue(type, reverse ? size - ++i : i++, this$1._value); }\n    );\n  };\n\n  Repeat.prototype.equals = function equals (other) {\n    return other instanceof Repeat\n      ? is(this._value, other._value)\n      : deepEqual(other);\n  };\n\n  return Repeat;\n}(IndexedSeq));\n\nvar EMPTY_REPEAT;\n\nvar Immutable = {\n  Collection: Collection,\n  // Note: Iterable is deprecated\n  Iterable: Collection,\n\n  Seq: Seq,\n  Map: Map,\n  OrderedMap: OrderedMap,\n  List: List,\n  Stack: Stack,\n  Set: Set,\n  OrderedSet: OrderedSet,\n\n  Record: Record,\n  Range: Range,\n  Repeat: Repeat,\n\n  is: is,\n  fromJS: fromJS,\n  hash: hash,\n\n  isImmutable: isImmutable,\n  isCollection: isCollection,\n  isKeyed: isKeyed,\n  isIndexed: isIndexed,\n  isAssociative: isAssociative,\n  isOrdered: isOrdered,\n  isValueObject: isValueObject\n};\n\n// Note: Iterable is deprecated\nvar Iterable = Collection;\n\nexports['default'] = Immutable;\nexports.Collection = Collection;\nexports.Iterable = Iterable;\nexports.Seq = Seq;\nexports.Map = Map;\nexports.OrderedMap = OrderedMap;\nexports.List = List;\nexports.Stack = Stack;\nexports.Set = Set;\nexports.OrderedSet = OrderedSet;\nexports.Record = Record;\nexports.Range = Range;\nexports.Repeat = Repeat;\nexports.is = is;\nexports.fromJS = fromJS;\nexports.hash = hash;\nexports.isImmutable = isImmutable;\nexports.isCollection = isCollection;\nexports.isKeyed = isKeyed;\nexports.isIndexed = isIndexed;\nexports.isAssociative = isAssociative;\nexports.isOrdered = isOrdered;\nexports.isValueObject = isValueObject;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n\n// WEBPACK FOOTER //\n// ../~/ibm-shopping-list-model/~/immutable/dist/immutable.js","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  return bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\nmodule.exports = bytesToUuid;\n\n\n\n// WEBPACK FOOTER //\n// ../~/uuid/lib/bytesToUuid.js","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\nvar rng;\n\nvar crypto = global.crypto || global.msCrypto; // for IE 11\nif (crypto && crypto.getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n  rng = function whatwgRNG() {\n    crypto.getRandomValues(rnds8);\n    return rnds8;\n  };\n}\n\nif (!rng) {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n  rng = function() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n\nmodule.exports = rng;\n\n\n\n// WEBPACK FOOTER //\n// ../~/uuid/lib/rng-browser.js","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n\n// WEBPACK FOOTER //\n// /usr/local/lib/~/preact-cli/~/events/events.js","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n// WEBPACK FOOTER //\n// (webpack)/buildin/global.js","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\n// random #'s we need to init node and clockseq\nvar _seedBytes = rng();\n\n// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\nvar _nodeId = [\n  _seedBytes[0] | 0x01,\n  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n];\n\n// Per 4.2.2, randomize (14 bit) clockseq\nvar _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n// Previous uuid creation time\nvar _lastMSecs = 0, _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  var node = options.node || _nodeId;\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;\n\n\n\n// WEBPACK FOOTER //\n// ../~/uuid/v1.js","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options == 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n\n\n\n// WEBPACK FOOTER //\n// ../~/uuid/v4.js","/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window && typeof window.process !== 'undefined' && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document && 'WebkitAppearance' in document.documentElement.style) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window && window.console && (console.firebug || (console.exception && console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n\n\n// WEBPACK FOOTER //\n// ../~/debug/src/browser.js","import uuidV4 from 'uuid';\nimport Promise from 'pouchdb-promise';\nimport getArguments from 'argsarray';\nimport { Map } from 'pouchdb-collections';\nimport { EventEmitter } from 'events';\nimport inherits from 'inherits';\nimport immediate from 'immediate';\nimport { BAD_REQUEST, INVALID_ID, MISSING_ID, RESERVED_ID, createError } from 'pouchdb-errors';\n\nfunction isBinaryObject(object) {\n  return (typeof ArrayBuffer !== 'undefined' && object instanceof ArrayBuffer) ||\n    (typeof Blob !== 'undefined' && object instanceof Blob);\n}\n\nfunction cloneArrayBuffer(buff) {\n  if (typeof buff.slice === 'function') {\n    return buff.slice(0);\n  }\n  // IE10-11 slice() polyfill\n  var target = new ArrayBuffer(buff.byteLength);\n  var targetArray = new Uint8Array(target);\n  var sourceArray = new Uint8Array(buff);\n  targetArray.set(sourceArray);\n  return target;\n}\n\nfunction cloneBinaryObject(object) {\n  if (object instanceof ArrayBuffer) {\n    return cloneArrayBuffer(object);\n  }\n  var size = object.size;\n  var type = object.type;\n  // Blob\n  if (typeof object.slice === 'function') {\n    return object.slice(0, size, type);\n  }\n  // PhantomJS slice() replacement\n  return object.webkitSlice(0, size, type);\n}\n\n// most of this is borrowed from lodash.isPlainObject:\n// https://github.com/fis-components/lodash.isplainobject/\n// blob/29c358140a74f252aeb08c9eb28bef86f2217d4a/index.js\n\nvar funcToString = Function.prototype.toString;\nvar objectCtorString = funcToString.call(Object);\n\nfunction isPlainObject(value) {\n  var proto = Object.getPrototypeOf(value);\n  /* istanbul ignore if */\n  if (proto === null) { // not sure when this happens, but I guess it can\n    return true;\n  }\n  var Ctor = proto.constructor;\n  return (typeof Ctor == 'function' &&\n    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);\n}\n\nfunction clone(object) {\n  var newObject;\n  var i;\n  var len;\n\n  if (!object || typeof object !== 'object') {\n    return object;\n  }\n\n  if (Array.isArray(object)) {\n    newObject = [];\n    for (i = 0, len = object.length; i < len; i++) {\n      newObject[i] = clone(object[i]);\n    }\n    return newObject;\n  }\n\n  // special case: to avoid inconsistencies between IndexedDB\n  // and other backends, we automatically stringify Dates\n  if (object instanceof Date) {\n    return object.toISOString();\n  }\n\n  if (isBinaryObject(object)) {\n    return cloneBinaryObject(object);\n  }\n\n  if (!isPlainObject(object)) {\n    return object; // don't clone objects like Workers\n  }\n\n  newObject = {};\n  for (i in object) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(object, i)) {\n      var value = clone(object[i]);\n      if (typeof value !== 'undefined') {\n        newObject[i] = value;\n      }\n    }\n  }\n  return newObject;\n}\n\nfunction once(fun) {\n  var called = false;\n  return getArguments(function (args) {\n    /* istanbul ignore if */\n    if (called) {\n      // this is a smoke test and should never actually happen\n      throw new Error('once called more than once');\n    } else {\n      called = true;\n      fun.apply(this, args);\n    }\n  });\n}\n\nfunction toPromise(func) {\n  //create the function we will be returning\n  return getArguments(function (args) {\n    // Clone arguments\n    args = clone(args);\n    var self = this;\n    // if the last argument is a function, assume its a callback\n    var usedCB = (typeof args[args.length - 1] === 'function') ? args.pop() : false;\n    var promise = new Promise(function (fulfill, reject) {\n      var resp;\n      try {\n        var callback = once(function (err, mesg) {\n          if (err) {\n            reject(err);\n          } else {\n            fulfill(mesg);\n          }\n        });\n        // create a callback for this invocation\n        // apply the function in the orig context\n        args.push(callback);\n        resp = func.apply(self, args);\n        if (resp && typeof resp.then === 'function') {\n          fulfill(resp);\n        }\n      } catch (e) {\n        reject(e);\n      }\n    });\n    // if there is a callback, call it back\n    if (usedCB) {\n      promise.then(function (result) {\n        usedCB(null, result);\n      }, usedCB);\n    }\n    return promise;\n  });\n}\n\nfunction logApiCall(self, name, args) {\n  /* istanbul ignore if */\n  if (self.constructor.listeners('debug').length) {\n    var logArgs = ['api', self.name, name];\n    for (var i = 0; i < args.length - 1; i++) {\n      logArgs.push(args[i]);\n    }\n    self.constructor.emit('debug', logArgs);\n\n    // override the callback itself to log the response\n    var origCallback = args[args.length - 1];\n    args[args.length - 1] = function (err, res) {\n      var responseArgs = ['api', self.name, name];\n      responseArgs = responseArgs.concat(\n        err ? ['error', err] : ['success', res]\n      );\n      self.constructor.emit('debug', responseArgs);\n      origCallback(err, res);\n    };\n  }\n}\n\nfunction adapterFun(name, callback) {\n  return toPromise(getArguments(function (args) {\n    if (this._closed) {\n      return Promise.reject(new Error('database is closed'));\n    }\n    if (this._destroyed) {\n      return Promise.reject(new Error('database is destroyed'));\n    }\n    var self = this;\n    logApiCall(self, name, args);\n    if (!this.taskqueue.isReady) {\n      return new Promise(function (fulfill, reject) {\n        self.taskqueue.addTask(function (failed) {\n          if (failed) {\n            reject(failed);\n          } else {\n            fulfill(self[name].apply(self, args));\n          }\n        });\n      });\n    }\n    return callback.apply(this, args);\n  }));\n}\n\n// like underscore/lodash _.pick()\nfunction pick(obj, arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var prop = arr[i];\n    if (prop in obj) {\n      res[prop] = obj[prop];\n    }\n  }\n  return res;\n}\n\n// Most browsers throttle concurrent requests at 6, so it's silly\n// to shim _bulk_get by trying to launch potentially hundreds of requests\n// and then letting the majority time out. We can handle this ourselves.\nvar MAX_NUM_CONCURRENT_REQUESTS = 6;\n\nfunction identityFunction(x) {\n  return x;\n}\n\nfunction formatResultForOpenRevsGet(result) {\n  return [{\n    ok: result\n  }];\n}\n\n// shim for P/CouchDB adapters that don't directly implement _bulk_get\nfunction bulkGet(db, opts, callback) {\n  var requests = opts.docs;\n\n  // consolidate into one request per doc if possible\n  var requestsById = new Map();\n  requests.forEach(function (request) {\n    if (requestsById.has(request.id)) {\n      requestsById.get(request.id).push(request);\n    } else {\n      requestsById.set(request.id, [request]);\n    }\n  });\n\n  var numDocs = requestsById.size;\n  var numDone = 0;\n  var perDocResults = new Array(numDocs);\n\n  function collapseResultsAndFinish() {\n    var results = [];\n    perDocResults.forEach(function (res) {\n      res.docs.forEach(function (info) {\n        results.push({\n          id: res.id,\n          docs: [info]\n        });\n      });\n    });\n    callback(null, {results: results});\n  }\n\n  function checkDone() {\n    if (++numDone === numDocs) {\n      collapseResultsAndFinish();\n    }\n  }\n\n  function gotResult(docIndex, id, docs) {\n    perDocResults[docIndex] = {id: id, docs: docs};\n    checkDone();\n  }\n\n  var allRequests = [];\n  requestsById.forEach(function (value, key) {\n    allRequests.push(key);\n  });\n\n  var i = 0;\n\n  function nextBatch() {\n\n    if (i >= allRequests.length) {\n      return;\n    }\n\n    var upTo = Math.min(i + MAX_NUM_CONCURRENT_REQUESTS, allRequests.length);\n    var batch = allRequests.slice(i, upTo);\n    processBatch(batch, i);\n    i += batch.length;\n  }\n\n  function processBatch(batch, offset) {\n    batch.forEach(function (docId, j) {\n      var docIdx = offset + j;\n      var docRequests = requestsById.get(docId);\n\n      // just use the first request as the \"template\"\n      // TODO: The _bulk_get API allows for more subtle use cases than this,\n      // but for now it is unlikely that there will be a mix of different\n      // \"atts_since\" or \"attachments\" in the same request, since it's just\n      // replicate.js that is using this for the moment.\n      // Also, atts_since is aspirational, since we don't support it yet.\n      var docOpts = pick(docRequests[0], ['atts_since', 'attachments']);\n      docOpts.open_revs = docRequests.map(function (request) {\n        // rev is optional, open_revs disallowed\n        return request.rev;\n      });\n\n      // remove falsey / undefined revisions\n      docOpts.open_revs = docOpts.open_revs.filter(identityFunction);\n\n      var formatResult = identityFunction;\n\n      if (docOpts.open_revs.length === 0) {\n        delete docOpts.open_revs;\n\n        // when fetching only the \"winning\" leaf,\n        // transform the result so it looks like an open_revs\n        // request\n        formatResult = formatResultForOpenRevsGet;\n      }\n\n      // globally-supplied options\n      ['revs', 'attachments', 'binary', 'ajax', 'latest'].forEach(function (param) {\n        if (param in opts) {\n          docOpts[param] = opts[param];\n        }\n      });\n      db.get(docId, docOpts, function (err, res) {\n        var result;\n        /* istanbul ignore if */\n        if (err) {\n          result = [{error: err}];\n        } else {\n          result = formatResult(res);\n        }\n        gotResult(docIdx, docId, result);\n        nextBatch();\n      });\n    });\n  }\n\n  nextBatch();\n\n}\n\nfunction isChromeApp() {\n  return (typeof chrome !== \"undefined\" &&\n    typeof chrome.storage !== \"undefined\" &&\n    typeof chrome.storage.local !== \"undefined\");\n}\n\nvar hasLocal;\n\nif (isChromeApp()) {\n  hasLocal = false;\n} else {\n  try {\n    localStorage.setItem('_pouch_check_localstorage', 1);\n    hasLocal = !!localStorage.getItem('_pouch_check_localstorage');\n  } catch (e) {\n    hasLocal = false;\n  }\n}\n\nfunction hasLocalStorage() {\n  return hasLocal;\n}\n\n// Custom nextTick() shim for browsers. In node, this will just be process.nextTick(). We\n// avoid using process.nextTick() directly because the polyfill is very large and we don't\n// need all of it (see: https://github.com/defunctzombie/node-process).\n// \"immediate\" 3.0.8 is used by lie, and it's a smaller version of the latest \"immediate\"\n// package, so it's the one we use.\n// When we use nextTick() in our codebase, we only care about not releasing Zalgo\n// (see: http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony).\n// Microtask vs macrotask doesn't matter to us. So we're free to use the fastest\n// (least latency) option, which is \"immediate\" due to use of microtasks.\n// All of our nextTicks are isolated to this one function so we can easily swap out one\n// implementation for another.\n\ninherits(Changes, EventEmitter);\n\n/* istanbul ignore next */\nfunction attachBrowserEvents(self) {\n  if (isChromeApp()) {\n    chrome.storage.onChanged.addListener(function (e) {\n      // make sure it's event addressed to us\n      if (e.db_name != null) {\n        //object only has oldValue, newValue members\n        self.emit(e.dbName.newValue);\n      }\n    });\n  } else if (hasLocalStorage()) {\n    if (typeof addEventListener !== 'undefined') {\n      addEventListener(\"storage\", function (e) {\n        self.emit(e.key);\n      });\n    } else { // old IE\n      window.attachEvent(\"storage\", function (e) {\n        self.emit(e.key);\n      });\n    }\n  }\n}\n\nfunction Changes() {\n  EventEmitter.call(this);\n  this._listeners = {};\n\n  attachBrowserEvents(this);\n}\nChanges.prototype.addListener = function (dbName, id, db, opts) {\n  /* istanbul ignore if */\n  if (this._listeners[id]) {\n    return;\n  }\n  var self = this;\n  var inprogress = false;\n  function eventFunction() {\n    /* istanbul ignore if */\n    if (!self._listeners[id]) {\n      return;\n    }\n    if (inprogress) {\n      inprogress = 'waiting';\n      return;\n    }\n    inprogress = true;\n    var changesOpts = pick(opts, [\n      'style', 'include_docs', 'attachments', 'conflicts', 'filter',\n      'doc_ids', 'view', 'since', 'query_params', 'binary'\n    ]);\n\n    /* istanbul ignore next */\n    function onError() {\n      inprogress = false;\n    }\n\n    db.changes(changesOpts).on('change', function (c) {\n      if (c.seq > opts.since && !opts.cancelled) {\n        opts.since = c.seq;\n        opts.onChange(c);\n      }\n    }).on('complete', function () {\n      if (inprogress === 'waiting') {\n        immediate(eventFunction);\n      }\n      inprogress = false;\n    }).on('error', onError);\n  }\n  this._listeners[id] = eventFunction;\n  this.on(dbName, eventFunction);\n};\n\nChanges.prototype.removeListener = function (dbName, id) {\n  /* istanbul ignore if */\n  if (!(id in this._listeners)) {\n    return;\n  }\n  EventEmitter.prototype.removeListener.call(this, dbName,\n    this._listeners[id]);\n  delete this._listeners[id];\n};\n\n\n/* istanbul ignore next */\nChanges.prototype.notifyLocalWindows = function (dbName) {\n  //do a useless change on a storage thing\n  //in order to get other windows's listeners to activate\n  if (isChromeApp()) {\n    chrome.storage.local.set({dbName: dbName});\n  } else if (hasLocalStorage()) {\n    localStorage[dbName] = (localStorage[dbName] === \"a\") ? \"b\" : \"a\";\n  }\n};\n\nChanges.prototype.notify = function (dbName) {\n  this.emit(dbName);\n  this.notifyLocalWindows(dbName);\n};\n\nfunction guardedConsole(method) {\n  /* istanbul ignore else */\n  if (console !== 'undefined' && method in console) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    console[method].apply(console, args);\n  }\n}\n\nfunction randomNumber(min, max) {\n  var maxTimeout = 600000; // Hard-coded default of 10 minutes\n  min = parseInt(min, 10) || 0;\n  max = parseInt(max, 10);\n  if (max !== max || max <= min) {\n    max = (min || 1) << 1; //doubling\n  } else {\n    max = max + 1;\n  }\n  // In order to not exceed maxTimeout, pick a random value between half of maxTimeout and maxTimeout\n  if (max > maxTimeout) {\n    min = maxTimeout >> 1; // divide by two\n    max = maxTimeout;\n  }\n  var ratio = Math.random();\n  var range = max - min;\n\n  return ~~(range * ratio + min); // ~~ coerces to an int, but fast.\n}\n\nfunction defaultBackOff(min) {\n  var max = 0;\n  if (!min) {\n    max = 2000;\n  }\n  return randomNumber(min, max);\n}\n\n// designed to give info to browser users, who are disturbed\n// when they see http errors in the console\nfunction explainError(status, str) {\n  guardedConsole('info', 'The above ' + status + ' is totally normal. ' + str);\n}\n\nvar assign;\n{\n  if (typeof Object.assign === 'function') {\n    assign = Object.assign;\n  } else {\n    // lite Object.assign polyfill based on\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n    assign = function (target) {\n      var to = Object(target);\n\n      for (var index = 1; index < arguments.length; index++) {\n        var nextSource = arguments[index];\n\n        if (nextSource != null) { // Skip over if undefined or null\n          for (var nextKey in nextSource) {\n            // Avoid bugs when hasOwnProperty is shadowed\n            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n              to[nextKey] = nextSource[nextKey];\n            }\n          }\n        }\n      }\n      return to;\n    };\n  }\n}\n\nvar assign$1 = assign;\n\nfunction tryFilter(filter, doc, req) {\n  try {\n    return !filter(doc, req);\n  } catch (err) {\n    var msg = 'Filter function threw: ' + err.toString();\n    return createError(BAD_REQUEST, msg);\n  }\n}\n\nfunction filterChange(opts) {\n  var req = {};\n  var hasFilter = opts.filter && typeof opts.filter === 'function';\n  req.query = opts.query_params;\n\n  return function filter(change) {\n    if (!change.doc) {\n      // CSG sends events on the changes feed that don't have documents,\n      // this hack makes a whole lot of existing code robust.\n      change.doc = {};\n    }\n\n    var filterReturn = hasFilter && tryFilter(opts.filter, change.doc, req);\n\n    if (typeof filterReturn === 'object') {\n      return filterReturn;\n    }\n\n    if (filterReturn) {\n      return false;\n    }\n\n    if (!opts.include_docs) {\n      delete change.doc;\n    } else if (!opts.attachments) {\n      for (var att in change.doc._attachments) {\n        /* istanbul ignore else */\n        if (change.doc._attachments.hasOwnProperty(att)) {\n          change.doc._attachments[att].stub = true;\n        }\n      }\n    }\n    return true;\n  };\n}\n\nfunction flatten(arrs) {\n  var res = [];\n  for (var i = 0, len = arrs.length; i < len; i++) {\n    res = res.concat(arrs[i]);\n  }\n  return res;\n}\n\n// shim for Function.prototype.name,\n// for browsers that don't support it like IE\n\n/* istanbul ignore next */\nfunction f() {}\n\nvar hasName = f.name;\nvar res;\n\n// We dont run coverage in IE\n/* istanbul ignore else */\nif (hasName) {\n  res = function (fun) {\n    return fun.name;\n  };\n} else {\n  res = function (fun) {\n    return fun.toString().match(/^\\s*function\\s*(\\S*)\\s*\\(/)[1];\n  };\n}\n\nvar res$1 = res;\n\n// Determine id an ID is valid\n//   - invalid IDs begin with an underescore that does not begin '_design' or\n//     '_local'\n//   - any other string value is a valid id\n// Returns the specific error object for each case\nfunction invalidIdError(id) {\n  var err;\n  if (!id) {\n    err = createError(MISSING_ID);\n  } else if (typeof id !== 'string') {\n    err = createError(INVALID_ID);\n  } else if (/^_/.test(id) && !(/^_(design|local)/).test(id)) {\n    err = createError(RESERVED_ID);\n  }\n  if (err) {\n    throw err;\n  }\n}\n\nfunction isCordova() {\n  return (typeof cordova !== \"undefined\" ||\n  typeof PhoneGap !== \"undefined\" ||\n  typeof phonegap !== \"undefined\");\n}\n\n// Checks if a PouchDB object is \"remote\" or not. This is\n// designed to opt-in to certain optimizations, such as\n// avoiding checks for \"dependentDbs\" and other things that\n// we know only apply to local databases. In general, \"remote\"\n// should be true for the http adapter, and for third-party\n// adapters with similar expensive boundaries to cross for\n// every API call, such as socket-pouch and worker-pouch.\n// Previously, this was handled via db.type() === 'http'\n// which is now deprecated.\n\nfunction isRemote(db) {\n  if (typeof db._remote === 'boolean') {\n    return db._remote;\n  }\n  /* istanbul ignore next */\n  if (typeof db.type === 'function') {\n    guardedConsole('warn',\n      'db.type() is deprecated and will be removed in ' +\n      'a future version of PouchDB');\n    return db.type() === 'http';\n  }\n  /* istanbul ignore next */\n  return false;\n}\n\nfunction listenerCount(ee, type) {\n  return 'listenerCount' in ee ? ee.listenerCount(type) :\n                                 EventEmitter.listenerCount(ee, type);\n}\n\nfunction parseDesignDocFunctionName(s) {\n  if (!s) {\n    return null;\n  }\n  var parts = s.split('/');\n  if (parts.length === 2) {\n    return parts;\n  }\n  if (parts.length === 1) {\n    return [s, s];\n  }\n  return null;\n}\n\nfunction normalizeDesignDocFunctionName(s) {\n  var normalized = parseDesignDocFunctionName(s);\n  return normalized ? normalized.join('/') : null;\n}\n\n// originally parseUri 1.2.2, now patched by us\n// (c) Steven Levithan <stevenlevithan.com>\n// MIT License\nvar keys = [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\",\n    \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"];\nvar qName =\"queryKey\";\nvar qParser = /(?:^|&)([^&=]*)=?([^&]*)/g;\n\n// use the \"loose\" parser\n/* eslint maxlen: 0, no-useless-escape: 0 */\nvar parser = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\nfunction parseUri(str) {\n  var m = parser.exec(str);\n  var uri = {};\n  var i = 14;\n\n  while (i--) {\n    var key = keys[i];\n    var value = m[i] || \"\";\n    var encoded = ['user', 'password'].indexOf(key) !== -1;\n    uri[key] = encoded ? decodeURIComponent(value) : value;\n  }\n\n  uri[qName] = {};\n  uri[keys[12]].replace(qParser, function ($0, $1, $2) {\n    if ($1) {\n      uri[qName][$1] = $2;\n    }\n  });\n\n  return uri;\n}\n\n// Based on https://github.com/alexdavid/scope-eval v0.0.3\n// (source: https://unpkg.com/scope-eval@0.0.3/scope_eval.js)\n// This is basically just a wrapper around new Function()\n\nfunction scopeEval(source, scope) {\n  var keys = [];\n  var values = [];\n  for (var key in scope) {\n    if (scope.hasOwnProperty(key)) {\n      keys.push(key);\n      values.push(scope[key]);\n    }\n  }\n  keys.push(source);\n  return Function.apply(null, keys).apply(null, values);\n}\n\n// this is essentially the \"update sugar\" function from daleharvey/pouchdb#1388\n// the diffFun tells us what delta to apply to the doc.  it either returns\n// the doc, or false if it doesn't need to do an update after all\nfunction upsert(db, docId, diffFun) {\n  return new Promise(function (fulfill, reject) {\n    db.get(docId, function (err, doc) {\n      if (err) {\n        /* istanbul ignore next */\n        if (err.status !== 404) {\n          return reject(err);\n        }\n        doc = {};\n      }\n\n      // the user might change the _rev, so save it for posterity\n      var docRev = doc._rev;\n      var newDoc = diffFun(doc);\n\n      if (!newDoc) {\n        // if the diffFun returns falsy, we short-circuit as\n        // an optimization\n        return fulfill({updated: false, rev: docRev});\n      }\n\n      // users aren't allowed to modify these values,\n      // so reset them here\n      newDoc._id = docId;\n      newDoc._rev = docRev;\n      fulfill(tryAndPut(db, newDoc, diffFun));\n    });\n  });\n}\n\nfunction tryAndPut(db, doc, diffFun) {\n  return db.put(doc).then(function (res) {\n    return {\n      updated: true,\n      rev: res.rev\n    };\n  }, function (err) {\n    /* istanbul ignore next */\n    if (err.status !== 409) {\n      throw err;\n    }\n    return upsert(db, doc._id, diffFun);\n  });\n}\n\nfunction rev() {\n  return uuidV4.v4().replace(/-/g, '').toLowerCase();\n}\n\nvar uuid = uuidV4.v4;\n\nexport { adapterFun, assign$1 as assign, bulkGet as bulkGetShim, Changes as changesHandler, clone, defaultBackOff, explainError, filterChange, flatten, res$1 as functionName, guardedConsole, hasLocalStorage, invalidIdError, isChromeApp, isCordova, isRemote, listenerCount, immediate as nextTick, normalizeDesignDocFunctionName as normalizeDdocFunctionName, once, parseDesignDocFunctionName as parseDdocFunctionName, parseUri, pick, rev, scopeEval, toPromise, upsert, uuid };\n\n\n\n// WEBPACK FOOTER //\n// ../~/pouchdb-utils/lib/index-browser.es.js","'use strict';\n\nvar _preact = require('preact');\n\nif (process.env.NODE_ENV === 'development') {\n\trequire('preact/devtools');\n} else if ('serviceWorker' in navigator && location.protocol === 'https:') {\n\tnavigator.serviceWorker.register('/sw.js');\n}\n\nconst interopDefault = m => m && m.default || m;\n\nlet app = interopDefault(require('preact-cli-entrypoint'));\n\nif (typeof app === 'function') {\n\tlet root = document.body.firstElementChild;\n\n\tlet init = () => {\n\t\tlet app = interopDefault(require('preact-cli-entrypoint'));\n\t\troot = (0, _preact.render)((0, _preact.h)(app), document.body, root);\n\t};\n\n\tif (module.hot) module.hot.accept('preact-cli-entrypoint', init);\n\n\tinit();\n}\n\n\n// WEBPACK FOOTER //\n// /usr/local/lib/~/preact-cli/lib/lib/entry.js","var v1 = require('./v1');\nvar v4 = require('./v4');\n\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\n\nmodule.exports = uuid;\n\n\n\n// WEBPACK FOOTER //\n// ../~/uuid/index.js","import inherits from 'inherits';\n\ninherits(PouchError, Error);\n\nfunction PouchError(status, error, reason) {\n  Error.call(this, reason);\n  this.status = status;\n  this.name = error;\n  this.message = reason;\n  this.error = true;\n}\n\nPouchError.prototype.toString = function () {\n  return JSON.stringify({\n    status: this.status,\n    name: this.name,\n    message: this.message,\n    reason: this.reason\n  });\n};\n\nvar UNAUTHORIZED = new PouchError(401, 'unauthorized', \"Name or password is incorrect.\");\nvar MISSING_BULK_DOCS = new PouchError(400, 'bad_request', \"Missing JSON list of 'docs'\");\nvar MISSING_DOC = new PouchError(404, 'not_found', 'missing');\nvar REV_CONFLICT = new PouchError(409, 'conflict', 'Document update conflict');\nvar INVALID_ID = new PouchError(400, 'bad_request', '_id field must contain a string');\nvar MISSING_ID = new PouchError(412, 'missing_id', '_id is required for puts');\nvar RESERVED_ID = new PouchError(400, 'bad_request', 'Only reserved document ids may start with underscore.');\nvar NOT_OPEN = new PouchError(412, 'precondition_failed', 'Database not open');\nvar UNKNOWN_ERROR = new PouchError(500, 'unknown_error', 'Database encountered an unknown error');\nvar BAD_ARG = new PouchError(500, 'badarg', 'Some query argument is invalid');\nvar INVALID_REQUEST = new PouchError(400, 'invalid_request', 'Request was invalid');\nvar QUERY_PARSE_ERROR = new PouchError(400, 'query_parse_error', 'Some query parameter is invalid');\nvar DOC_VALIDATION = new PouchError(500, 'doc_validation', 'Bad special document member');\nvar BAD_REQUEST = new PouchError(400, 'bad_request', 'Something wrong with the request');\nvar NOT_AN_OBJECT = new PouchError(400, 'bad_request', 'Document must be a JSON object');\nvar DB_MISSING = new PouchError(404, 'not_found', 'Database not found');\nvar IDB_ERROR = new PouchError(500, 'indexed_db_went_bad', 'unknown');\nvar WSQ_ERROR = new PouchError(500, 'web_sql_went_bad', 'unknown');\nvar LDB_ERROR = new PouchError(500, 'levelDB_went_went_bad', 'unknown');\nvar FORBIDDEN = new PouchError(403, 'forbidden', 'Forbidden by design doc validate_doc_update function');\nvar INVALID_REV = new PouchError(400, 'bad_request', 'Invalid rev format');\nvar FILE_EXISTS = new PouchError(412, 'file_exists', 'The database could not be created, the file already exists.');\nvar MISSING_STUB = new PouchError(412, 'missing_stub', 'A pre-existing attachment stub wasn\\'t found');\nvar INVALID_URL = new PouchError(413, 'invalid_url', 'Provided URL is invalid');\n\nfunction createError(error, reason) {\n  function CustomPouchError(reason) {\n    // inherit error properties from our parent error manually\n    // so as to allow proper JSON parsing.\n    /* jshint ignore:start */\n    for (var p in error) {\n      if (typeof error[p] !== 'function') {\n        this[p] = error[p];\n      }\n    }\n    /* jshint ignore:end */\n    if (reason !== undefined) {\n      this.reason = reason;\n    }\n  }\n  CustomPouchError.prototype = PouchError.prototype;\n  return new CustomPouchError(reason);\n}\n\nfunction generateErrorFromResponse(err) {\n\n  if (typeof err !== 'object') {\n    var data = err;\n    err = UNKNOWN_ERROR;\n    err.data = data;\n  }\n\n  if ('error' in err && err.error === 'conflict') {\n    err.name = 'conflict';\n    err.status = 409;\n  }\n\n  if (!('name' in err)) {\n    err.name = err.error || 'unknown';\n  }\n\n  if (!('status' in err)) {\n    err.status = 500;\n  }\n\n  if (!('message' in err)) {\n    err.message = err.message || err.reason;\n  }\n\n  return err;\n}\n\nexport { UNAUTHORIZED, MISSING_BULK_DOCS, MISSING_DOC, REV_CONFLICT, INVALID_ID, MISSING_ID, RESERVED_ID, NOT_OPEN, UNKNOWN_ERROR, BAD_ARG, INVALID_REQUEST, QUERY_PARSE_ERROR, DOC_VALIDATION, BAD_REQUEST, NOT_AN_OBJECT, DB_MISSING, WSQ_ERROR, LDB_ERROR, FORBIDDEN, INVALID_REV, FILE_EXISTS, MISSING_STUB, IDB_ERROR, INVALID_URL, createError, generateErrorFromResponse };\n\n\n\n// WEBPACK FOOTER //\n// ../~/pouchdb-errors/lib/index.es.js","import Promise from 'pouchdb-promise';\nimport { Map, Set } from 'pouchdb-collections';\nimport { flatten, guardedConsole, isRemote, nextTick, upsert } from 'pouchdb-utils';\nimport { base64StringToBlobOrBuffer } from 'pouchdb-binary-utils';\nimport { collate, normalizeKey, parseIndexableString, toIndexableString } from 'pouchdb-collate';\nimport { stringMd5 } from 'pouchdb-md5';\nimport { BuiltInError, NotFoundError, QueryParseError, callbackify, fin, mapToKeysArray, promisedCallback, sequentialize, uniq } from 'pouchdb-mapreduce-utils';\n\n/*\n * Simple task queue to sequentialize actions. Assumes\n * callbacks will eventually fire (once).\n */\n\n\nfunction TaskQueue() {\n  this.promise = new Promise(function (fulfill) {fulfill(); });\n}\nTaskQueue.prototype.add = function (promiseFactory) {\n  this.promise = this.promise.catch(function () {\n    // just recover\n  }).then(function () {\n    return promiseFactory();\n  });\n  return this.promise;\n};\nTaskQueue.prototype.finish = function () {\n  return this.promise;\n};\n\nfunction stringify(input) {\n  if (!input) {\n    return 'undefined'; // backwards compat for empty reduce\n  }\n  // for backwards compat with mapreduce, functions/strings are stringified\n  // as-is. everything else is JSON-stringified.\n  switch (typeof input) {\n    case 'function':\n      // e.g. a mapreduce map\n      return input.toString();\n    case 'string':\n      // e.g. a mapreduce built-in _reduce function\n      return input.toString();\n    default:\n      // e.g. a JSON object in the case of mango queries\n      return JSON.stringify(input);\n  }\n}\n\n/* create a string signature for a view so we can cache it and uniq it */\nfunction createViewSignature(mapFun, reduceFun) {\n  // the \"undefined\" part is for backwards compatibility\n  return stringify(mapFun) + stringify(reduceFun) + 'undefined';\n}\n\nfunction createView(sourceDB, viewName, mapFun, reduceFun, temporary, localDocName) {\n  var viewSignature = createViewSignature(mapFun, reduceFun);\n\n  var cachedViews;\n  if (!temporary) {\n    // cache this to ensure we don't try to update the same view twice\n    cachedViews = sourceDB._cachedViews = sourceDB._cachedViews || {};\n    if (cachedViews[viewSignature]) {\n      return cachedViews[viewSignature];\n    }\n  }\n\n  var promiseForView = sourceDB.info().then(function (info) {\n\n    var depDbName = info.db_name + '-mrview-' +\n      (temporary ? 'temp' : stringMd5(viewSignature));\n\n    // save the view name in the source db so it can be cleaned up if necessary\n    // (e.g. when the _design doc is deleted, remove all associated view data)\n    function diffFunction(doc) {\n      doc.views = doc.views || {};\n      var fullViewName = viewName;\n      if (fullViewName.indexOf('/') === -1) {\n        fullViewName = viewName + '/' + viewName;\n      }\n      var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};\n      /* istanbul ignore if */\n      if (depDbs[depDbName]) {\n        return; // no update necessary\n      }\n      depDbs[depDbName] = true;\n      return doc;\n    }\n    return upsert(sourceDB, '_local/' + localDocName, diffFunction).then(function () {\n      return sourceDB.registerDependentDatabase(depDbName).then(function (res) {\n        var db = res.db;\n        db.auto_compaction = true;\n        var view = {\n          name: depDbName,\n          db: db,\n          sourceDB: sourceDB,\n          adapter: sourceDB.adapter,\n          mapFun: mapFun,\n          reduceFun: reduceFun\n        };\n        return view.db.get('_local/lastSeq').catch(function (err) {\n          /* istanbul ignore if */\n          if (err.status !== 404) {\n            throw err;\n          }\n        }).then(function (lastSeqDoc) {\n          view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;\n          if (cachedViews) {\n            view.db.once('destroyed', function () {\n              delete cachedViews[viewSignature];\n            });\n          }\n          return view;\n        });\n      });\n    });\n  });\n\n  if (cachedViews) {\n    cachedViews[viewSignature] = promiseForView;\n  }\n  return promiseForView;\n}\n\nvar persistentQueues = {};\nvar tempViewQueue = new TaskQueue();\nvar CHANGES_BATCH_SIZE = 50;\n\nfunction parseViewName(name) {\n  // can be either 'ddocname/viewname' or just 'viewname'\n  // (where the ddoc name is the same)\n  return name.indexOf('/') === -1 ? [name, name] : name.split('/');\n}\n\nfunction isGenOne(changes) {\n  // only return true if the current change is 1-\n  // and there are no other leafs\n  return changes.length === 1 && /^1-/.test(changes[0].rev);\n}\n\nfunction emitError(db, e) {\n  try {\n    db.emit('error', e);\n  } catch (err) {\n    guardedConsole('error',\n      'The user\\'s map/reduce function threw an uncaught error.\\n' +\n      'You can debug this error by doing:\\n' +\n      'myDatabase.on(\\'error\\', function (err) { debugger; });\\n' +\n      'Please double-check your map/reduce function.');\n    guardedConsole('error', e);\n  }\n}\n\n/**\n * Returns an \"abstract\" mapreduce object of the form:\n *\n *   {\n *     query: queryFun,\n *     viewCleanup: viewCleanupFun\n *   }\n *\n * Arguments are:\n *\n * localDoc: string\n *   This is for the local doc that gets saved in order to track the\n *   \"dependent\" DBs and clean them up for viewCleanup. It should be\n *   unique, so that indexer plugins don't collide with each other.\n * mapper: function (mapFunDef, emit)\n *   Returns a map function based on the mapFunDef, which in the case of\n *   normal map/reduce is just the de-stringified function, but may be\n *   something else, such as an object in the case of pouchdb-find.\n * reducer: function (reduceFunDef)\n *   Ditto, but for reducing. Modules don't have to support reducing\n *   (e.g. pouchdb-find).\n * ddocValidator: function (ddoc, viewName)\n *   Throws an error if the ddoc or viewName is not valid.\n *   This could be a way to communicate to the user that the configuration for the\n *   indexer is invalid.\n */\nfunction createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator) {\n\n  function tryMap(db, fun, doc) {\n    // emit an event if there was an error thrown by a map function.\n    // putting try/catches in a single function also avoids deoptimizations.\n    try {\n      fun(doc);\n    } catch (e) {\n      emitError(db, e);\n    }\n  }\n\n  function tryReduce(db, fun, keys, values, rereduce) {\n    // same as above, but returning the result or an error. there are two separate\n    // functions to avoid extra memory allocations since the tryCode() case is used\n    // for custom map functions (common) vs this function, which is only used for\n    // custom reduce functions (rare)\n    try {\n      return {output : fun(keys, values, rereduce)};\n    } catch (e) {\n      emitError(db, e);\n      return {error: e};\n    }\n  }\n\n  function sortByKeyThenValue(x, y) {\n    var keyCompare = collate(x.key, y.key);\n    return keyCompare !== 0 ? keyCompare : collate(x.value, y.value);\n  }\n\n  function sliceResults(results, limit, skip) {\n    skip = skip || 0;\n    if (typeof limit === 'number') {\n      return results.slice(skip, limit + skip);\n    } else if (skip > 0) {\n      return results.slice(skip);\n    }\n    return results;\n  }\n\n  function rowToDocId(row) {\n    var val = row.value;\n    // Users can explicitly specify a joined doc _id, or it\n    // defaults to the doc _id that emitted the key/value.\n    var docId = (val && typeof val === 'object' && val._id) || row.id;\n    return docId;\n  }\n\n  function readAttachmentsAsBlobOrBuffer(res) {\n    res.rows.forEach(function (row) {\n      var atts = row.doc && row.doc._attachments;\n      if (!atts) {\n        return;\n      }\n      Object.keys(atts).forEach(function (filename) {\n        var att = atts[filename];\n        atts[filename].data = base64StringToBlobOrBuffer(att.data, att.content_type);\n      });\n    });\n  }\n\n  function postprocessAttachments(opts) {\n    return function (res) {\n      if (opts.include_docs && opts.attachments && opts.binary) {\n        readAttachmentsAsBlobOrBuffer(res);\n      }\n      return res;\n    };\n  }\n\n  function addHttpParam(paramName, opts, params, asJson) {\n    // add an http param from opts to params, optionally json-encoded\n    var val = opts[paramName];\n    if (typeof val !== 'undefined') {\n      if (asJson) {\n        val = encodeURIComponent(JSON.stringify(val));\n      }\n      params.push(paramName + '=' + val);\n    }\n  }\n\n  function coerceInteger(integerCandidate) {\n    if (typeof integerCandidate !== 'undefined') {\n      var asNumber = Number(integerCandidate);\n      // prevents e.g. '1foo' or '1.1' being coerced to 1\n      if (!isNaN(asNumber) && asNumber === parseInt(integerCandidate, 10)) {\n        return asNumber;\n      } else {\n        return integerCandidate;\n      }\n    }\n  }\n\n  function coerceOptions(opts) {\n    opts.group_level = coerceInteger(opts.group_level);\n    opts.limit = coerceInteger(opts.limit);\n    opts.skip = coerceInteger(opts.skip);\n    return opts;\n  }\n\n  function checkPositiveInteger(number) {\n    if (number) {\n      if (typeof number !== 'number') {\n        return  new QueryParseError('Invalid value for integer: \"' +\n          number + '\"');\n      }\n      if (number < 0) {\n        return new QueryParseError('Invalid value for positive integer: ' +\n          '\"' + number + '\"');\n      }\n    }\n  }\n\n  function checkQueryParseError(options, fun) {\n    var startkeyName = options.descending ? 'endkey' : 'startkey';\n    var endkeyName = options.descending ? 'startkey' : 'endkey';\n\n    if (typeof options[startkeyName] !== 'undefined' &&\n      typeof options[endkeyName] !== 'undefined' &&\n      collate(options[startkeyName], options[endkeyName]) > 0) {\n      throw new QueryParseError('No rows can match your key range, ' +\n        'reverse your start_key and end_key or set {descending : true}');\n    } else if (fun.reduce && options.reduce !== false) {\n      if (options.include_docs) {\n        throw new QueryParseError('{include_docs:true} is invalid for reduce');\n      } else if (options.keys && options.keys.length > 1 &&\n        !options.group && !options.group_level) {\n        throw new QueryParseError('Multi-key fetches for reduce views must use ' +\n          '{group: true}');\n      }\n    }\n    ['group_level', 'limit', 'skip'].forEach(function (optionName) {\n      var error = checkPositiveInteger(options[optionName]);\n      if (error) {\n        throw error;\n      }\n    });\n  }\n\n  function httpQuery(db, fun, opts) {\n    // List of parameters to add to the PUT request\n    var params = [];\n    var body;\n    var method = 'GET';\n\n    // If opts.reduce exists and is defined, then add it to the list\n    // of parameters.\n    // If reduce=false then the results are that of only the map function\n    // not the final result of map and reduce.\n    addHttpParam('reduce', opts, params);\n    addHttpParam('include_docs', opts, params);\n    addHttpParam('attachments', opts, params);\n    addHttpParam('limit', opts, params);\n    addHttpParam('descending', opts, params);\n    addHttpParam('group', opts, params);\n    addHttpParam('group_level', opts, params);\n    addHttpParam('skip', opts, params);\n    addHttpParam('stale', opts, params);\n    addHttpParam('conflicts', opts, params);\n    addHttpParam('startkey', opts, params, true);\n    addHttpParam('start_key', opts, params, true);\n    addHttpParam('endkey', opts, params, true);\n    addHttpParam('end_key', opts, params, true);\n    addHttpParam('inclusive_end', opts, params);\n    addHttpParam('key', opts, params, true);\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    params = params === '' ? '' : '?' + params;\n\n    // If keys are supplied, issue a POST to circumvent GET query string limits\n    // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\n    if (typeof opts.keys !== 'undefined') {\n      var MAX_URL_LENGTH = 2000;\n      // according to http://stackoverflow.com/a/417184/680742,\n      // the de facto URL length limit is 2000 characters\n\n      var keysAsString =\n        'keys=' + encodeURIComponent(JSON.stringify(opts.keys));\n      if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {\n        // If the keys are short enough, do a GET. we do this to work around\n        // Safari not understanding 304s on POSTs (see pouchdb/pouchdb#1239)\n        params += (params[0] === '?' ? '&' : '?') + keysAsString;\n      } else {\n        method = 'POST';\n        if (typeof fun === 'string') {\n          body = {keys: opts.keys};\n        } else { // fun is {map : mapfun}, so append to this\n          fun.keys = opts.keys;\n        }\n      }\n    }\n\n    // We are referencing a query defined in the design doc\n    if (typeof fun === 'string') {\n      var parts = parseViewName(fun);\n      return db.request({\n        method: method,\n        url: '_design/' + parts[0] + '/_view/' + parts[1] + params,\n        body: body\n      }).then(\n        /* istanbul ignore next */\n        function (result) {\n          // fail the entire request if the result contains an error\n          result.rows.forEach(function (row) {\n            if (row.value && row.value.error && row.value.error === \"builtin_reduce_error\") {\n              throw new Error(row.reason);\n            }\n          });\n\n          return result;\n      })\n      .then(postprocessAttachments(opts));\n    }\n\n    // We are using a temporary view, terrible for performance, good for testing\n    body = body || {};\n    Object.keys(fun).forEach(function (key) {\n      if (Array.isArray(fun[key])) {\n        body[key] = fun[key];\n      } else {\n        body[key] = fun[key].toString();\n      }\n    });\n    return db.request({\n      method: 'POST',\n      url: '_temp_view' + params,\n      body: body\n    }).then(postprocessAttachments(opts));\n  }\n\n  // custom adapters can define their own api._query\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customQuery(db, fun, opts) {\n    return new Promise(function (resolve, reject) {\n      db._query(fun, opts, function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  // custom adapters can define their own api._viewCleanup\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customViewCleanup(db) {\n    return new Promise(function (resolve, reject) {\n      db._viewCleanup(function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  function defaultsTo(value) {\n    return function (reason) {\n      /* istanbul ignore else */\n      if (reason.status === 404) {\n        return value;\n      } else {\n        throw reason;\n      }\n    };\n  }\n\n  // returns a promise for a list of docs to update, based on the input docId.\n  // the order doesn't matter, because post-3.2.0, bulkDocs\n  // is an atomic operation in all three adapters.\n  function getDocsToPersist(docId, view, docIdsToChangesAndEmits) {\n    var metaDocId = '_local/doc_' + docId;\n    var defaultMetaDoc = {_id: metaDocId, keys: []};\n    var docData = docIdsToChangesAndEmits.get(docId);\n    var indexableKeysToKeyValues = docData[0];\n    var changes = docData[1];\n\n    function getMetaDoc() {\n      if (isGenOne(changes)) {\n        // generation 1, so we can safely assume initial state\n        // for performance reasons (avoids unnecessary GETs)\n        return Promise.resolve(defaultMetaDoc);\n      }\n      return view.db.get(metaDocId).catch(defaultsTo(defaultMetaDoc));\n    }\n\n    function getKeyValueDocs(metaDoc) {\n      if (!metaDoc.keys.length) {\n        // no keys, no need for a lookup\n        return Promise.resolve({rows: []});\n      }\n      return view.db.allDocs({\n        keys: metaDoc.keys,\n        include_docs: true\n      });\n    }\n\n    function processKeyValueDocs(metaDoc, kvDocsRes) {\n      var kvDocs = [];\n      var oldKeys = new Set();\n\n      for (var i = 0, len = kvDocsRes.rows.length; i < len; i++) {\n        var row = kvDocsRes.rows[i];\n        var doc = row.doc;\n        if (!doc) { // deleted\n          continue;\n        }\n        kvDocs.push(doc);\n        oldKeys.add(doc._id);\n        doc._deleted = !indexableKeysToKeyValues.has(doc._id);\n        if (!doc._deleted) {\n          var keyValue = indexableKeysToKeyValues.get(doc._id);\n          if ('value' in keyValue) {\n            doc.value = keyValue.value;\n          }\n        }\n      }\n      var newKeys = mapToKeysArray(indexableKeysToKeyValues);\n      newKeys.forEach(function (key) {\n        if (!oldKeys.has(key)) {\n          // new doc\n          var kvDoc = {\n            _id: key\n          };\n          var keyValue = indexableKeysToKeyValues.get(key);\n          if ('value' in keyValue) {\n            kvDoc.value = keyValue.value;\n          }\n          kvDocs.push(kvDoc);\n        }\n      });\n      metaDoc.keys = uniq(newKeys.concat(metaDoc.keys));\n      kvDocs.push(metaDoc);\n\n      return kvDocs;\n    }\n\n    return getMetaDoc().then(function (metaDoc) {\n      return getKeyValueDocs(metaDoc).then(function (kvDocsRes) {\n        return processKeyValueDocs(metaDoc, kvDocsRes);\n      });\n    });\n  }\n\n  // updates all emitted key/value docs and metaDocs in the mrview database\n  // for the given batch of documents from the source database\n  function saveKeyValues(view, docIdsToChangesAndEmits, seq) {\n    var seqDocId = '_local/lastSeq';\n    return view.db.get(seqDocId)\n      .catch(defaultsTo({_id: seqDocId, seq: 0}))\n      .then(function (lastSeqDoc) {\n        var docIds = mapToKeysArray(docIdsToChangesAndEmits);\n        return Promise.all(docIds.map(function (docId) {\n          return getDocsToPersist(docId, view, docIdsToChangesAndEmits);\n        })).then(function (listOfDocsToPersist) {\n          var docsToPersist = flatten(listOfDocsToPersist);\n          lastSeqDoc.seq = seq;\n          docsToPersist.push(lastSeqDoc);\n          // write all docs in a single operation, update the seq once\n          return view.db.bulkDocs({docs : docsToPersist});\n        });\n      });\n  }\n\n  function getQueue(view) {\n    var viewName = typeof view === 'string' ? view : view.name;\n    var queue = persistentQueues[viewName];\n    if (!queue) {\n      queue = persistentQueues[viewName] = new TaskQueue();\n    }\n    return queue;\n  }\n\n  function updateView(view) {\n    return sequentialize(getQueue(view), function () {\n      return updateViewInQueue(view);\n    })();\n  }\n\n  function updateViewInQueue(view) {\n    // bind the emit function once\n    var mapResults;\n    var doc;\n\n    function emit(key, value) {\n      var output = {id: doc._id, key: normalizeKey(key)};\n      // Don't explicitly store the value unless it's defined and non-null.\n      // This saves on storage space, because often people don't use it.\n      if (typeof value !== 'undefined' && value !== null) {\n        output.value = normalizeKey(value);\n      }\n      mapResults.push(output);\n    }\n\n    var mapFun = mapper(view.mapFun, emit);\n\n    var currentSeq = view.seq || 0;\n\n    function processChange(docIdsToChangesAndEmits, seq) {\n      return function () {\n        return saveKeyValues(view, docIdsToChangesAndEmits, seq);\n      };\n    }\n\n    var queue = new TaskQueue();\n\n    function processNextBatch() {\n      return view.sourceDB.changes({\n        conflicts: true,\n        include_docs: true,\n        style: 'all_docs',\n        since: currentSeq,\n        limit: CHANGES_BATCH_SIZE\n      }).then(processBatch);\n    }\n\n    function processBatch(response) {\n      var results = response.results;\n      if (!results.length) {\n        return;\n      }\n      var docIdsToChangesAndEmits = createDocIdsToChangesAndEmits(results);\n      queue.add(processChange(docIdsToChangesAndEmits, currentSeq));\n      if (results.length < CHANGES_BATCH_SIZE) {\n        return;\n      }\n      return processNextBatch();\n    }\n\n    function createDocIdsToChangesAndEmits(results) {\n      var docIdsToChangesAndEmits = new Map();\n      for (var i = 0, len = results.length; i < len; i++) {\n        var change = results[i];\n        if (change.doc._id[0] !== '_') {\n          mapResults = [];\n          doc = change.doc;\n\n          if (!doc._deleted) {\n            tryMap(view.sourceDB, mapFun, doc);\n          }\n          mapResults.sort(sortByKeyThenValue);\n\n          var indexableKeysToKeyValues = createIndexableKeysToKeyValues(mapResults);\n          docIdsToChangesAndEmits.set(change.doc._id, [\n            indexableKeysToKeyValues,\n            change.changes\n          ]);\n        }\n        currentSeq = change.seq;\n      }\n      return docIdsToChangesAndEmits;\n    }\n\n    function createIndexableKeysToKeyValues(mapResults) {\n      var indexableKeysToKeyValues = new Map();\n      var lastKey;\n      for (var i = 0, len = mapResults.length; i < len; i++) {\n        var emittedKeyValue = mapResults[i];\n        var complexKey = [emittedKeyValue.key, emittedKeyValue.id];\n        if (i > 0 && collate(emittedKeyValue.key, lastKey) === 0) {\n          complexKey.push(i); // dup key+id, so make it unique\n        }\n        indexableKeysToKeyValues.set(toIndexableString(complexKey), emittedKeyValue);\n        lastKey = emittedKeyValue.key;\n      }\n      return indexableKeysToKeyValues;\n    }\n\n    return processNextBatch().then(function () {\n      return queue.finish();\n    }).then(function () {\n      view.seq = currentSeq;\n    });\n  }\n\n  function reduceView(view, results, options) {\n    if (options.group_level === 0) {\n      delete options.group_level;\n    }\n\n    var shouldGroup = options.group || options.group_level;\n\n    var reduceFun = reducer(view.reduceFun);\n\n    var groups = [];\n    var lvl = isNaN(options.group_level) ? Number.POSITIVE_INFINITY :\n      options.group_level;\n    results.forEach(function (e) {\n      var last = groups[groups.length - 1];\n      var groupKey = shouldGroup ? e.key : null;\n\n      // only set group_level for array keys\n      if (shouldGroup && Array.isArray(groupKey)) {\n        groupKey = groupKey.slice(0, lvl);\n      }\n\n      if (last && collate(last.groupKey, groupKey) === 0) {\n        last.keys.push([e.key, e.id]);\n        last.values.push(e.value);\n        return;\n      }\n      groups.push({\n        keys: [[e.key, e.id]],\n        values: [e.value],\n        groupKey: groupKey\n      });\n    });\n    results = [];\n    for (var i = 0, len = groups.length; i < len; i++) {\n      var e = groups[i];\n      var reduceTry = tryReduce(view.sourceDB, reduceFun, e.keys, e.values, false);\n      if (reduceTry.error && reduceTry.error instanceof BuiltInError) {\n        // CouchDB returns an error if a built-in errors out\n        throw reduceTry.error;\n      }\n      results.push({\n        // CouchDB just sets the value to null if a non-built-in errors out\n        value: reduceTry.error ? null : reduceTry.output,\n        key: e.groupKey\n      });\n    }\n    // no total_rows/offset when reducing\n    return {rows: sliceResults(results, options.limit, options.skip)};\n  }\n\n  function queryView(view, opts) {\n    return sequentialize(getQueue(view), function () {\n      return queryViewInQueue(view, opts);\n    })();\n  }\n\n  function queryViewInQueue(view, opts) {\n    var totalRows;\n    var shouldReduce = view.reduceFun && opts.reduce !== false;\n    var skip = opts.skip || 0;\n    if (typeof opts.keys !== 'undefined' && !opts.keys.length) {\n      // equivalent query\n      opts.limit = 0;\n      delete opts.keys;\n    }\n\n    function fetchFromView(viewOpts) {\n      viewOpts.include_docs = true;\n      return view.db.allDocs(viewOpts).then(function (res) {\n        totalRows = res.total_rows;\n        return res.rows.map(function (result) {\n\n          // implicit migration - in older versions of PouchDB,\n          // we explicitly stored the doc as {id: ..., key: ..., value: ...}\n          // this is tested in a migration test\n          /* istanbul ignore next */\n          if ('value' in result.doc && typeof result.doc.value === 'object' &&\n            result.doc.value !== null) {\n            var keys = Object.keys(result.doc.value).sort();\n            // this detection method is not perfect, but it's unlikely the user\n            // emitted a value which was an object with these 3 exact keys\n            var expectedKeys = ['id', 'key', 'value'];\n            if (!(keys < expectedKeys || keys > expectedKeys)) {\n              return result.doc.value;\n            }\n          }\n\n          var parsedKeyAndDocId = parseIndexableString(result.doc._id);\n          return {\n            key: parsedKeyAndDocId[0],\n            id: parsedKeyAndDocId[1],\n            value: ('value' in result.doc ? result.doc.value : null)\n          };\n        });\n      });\n    }\n\n    function onMapResultsReady(rows) {\n      var finalResults;\n      if (shouldReduce) {\n        finalResults = reduceView(view, rows, opts);\n      } else {\n        finalResults = {\n          total_rows: totalRows,\n          offset: skip,\n          rows: rows\n        };\n      }\n      if (opts.include_docs) {\n        var docIds = uniq(rows.map(rowToDocId));\n\n        return view.sourceDB.allDocs({\n          keys: docIds,\n          include_docs: true,\n          conflicts: opts.conflicts,\n          attachments: opts.attachments,\n          binary: opts.binary\n        }).then(function (allDocsRes) {\n          var docIdsToDocs = new Map();\n          allDocsRes.rows.forEach(function (row) {\n            docIdsToDocs.set(row.id, row.doc);\n          });\n          rows.forEach(function (row) {\n            var docId = rowToDocId(row);\n            var doc = docIdsToDocs.get(docId);\n            if (doc) {\n              row.doc = doc;\n            }\n          });\n          return finalResults;\n        });\n      } else {\n        return finalResults;\n      }\n    }\n\n    if (typeof opts.keys !== 'undefined') {\n      var keys = opts.keys;\n      var fetchPromises = keys.map(function (key) {\n        var viewOpts = {\n          startkey : toIndexableString([key]),\n          endkey   : toIndexableString([key, {}])\n        };\n        return fetchFromView(viewOpts);\n      });\n      return Promise.all(fetchPromises).then(flatten).then(onMapResultsReady);\n    } else { // normal query, no 'keys'\n      var viewOpts = {\n        descending : opts.descending\n      };\n      var startkey;\n      var endkey;\n      if ('start_key' in opts) {\n        startkey = opts.start_key;\n      }\n      if ('startkey' in opts) {\n        startkey = opts.startkey;\n      }\n      if ('end_key' in opts) {\n        endkey = opts.end_key;\n      }\n      if ('endkey' in opts) {\n        endkey = opts.endkey;\n      }\n      if (typeof startkey !== 'undefined') {\n        viewOpts.startkey = opts.descending ?\n          toIndexableString([startkey, {}]) :\n          toIndexableString([startkey]);\n      }\n      if (typeof endkey !== 'undefined') {\n        var inclusiveEnd = opts.inclusive_end !== false;\n        if (opts.descending) {\n          inclusiveEnd = !inclusiveEnd;\n        }\n\n        viewOpts.endkey = toIndexableString(\n          inclusiveEnd ? [endkey, {}] : [endkey]);\n      }\n      if (typeof opts.key !== 'undefined') {\n        var keyStart = toIndexableString([opts.key]);\n        var keyEnd = toIndexableString([opts.key, {}]);\n        if (viewOpts.descending) {\n          viewOpts.endkey = keyStart;\n          viewOpts.startkey = keyEnd;\n        } else {\n          viewOpts.startkey = keyStart;\n          viewOpts.endkey = keyEnd;\n        }\n      }\n      if (!shouldReduce) {\n        if (typeof opts.limit === 'number') {\n          viewOpts.limit = opts.limit;\n        }\n        viewOpts.skip = skip;\n      }\n      return fetchFromView(viewOpts).then(onMapResultsReady);\n    }\n  }\n\n  function httpViewCleanup(db) {\n    return db.request({\n      method: 'POST',\n      url: '_view_cleanup'\n    });\n  }\n\n  function localViewCleanup(db) {\n    return db.get('_local/' + localDocName).then(function (metaDoc) {\n      var docsToViews = new Map();\n      Object.keys(metaDoc.views).forEach(function (fullViewName) {\n        var parts = parseViewName(fullViewName);\n        var designDocName = '_design/' + parts[0];\n        var viewName = parts[1];\n        var views = docsToViews.get(designDocName);\n        if (!views) {\n          views = new Set();\n          docsToViews.set(designDocName, views);\n        }\n        views.add(viewName);\n      });\n      var opts = {\n        keys : mapToKeysArray(docsToViews),\n        include_docs : true\n      };\n      return db.allDocs(opts).then(function (res) {\n        var viewsToStatus = {};\n        res.rows.forEach(function (row) {\n          var ddocName = row.key.substring(8); // cuts off '_design/'\n          docsToViews.get(row.key).forEach(function (viewName) {\n            var fullViewName = ddocName + '/' + viewName;\n            /* istanbul ignore if */\n            if (!metaDoc.views[fullViewName]) {\n              // new format, without slashes, to support PouchDB 2.2.0\n              // migration test in pouchdb's browser.migration.js verifies this\n              fullViewName = viewName;\n            }\n            var viewDBNames = Object.keys(metaDoc.views[fullViewName]);\n            // design doc deleted, or view function nonexistent\n            var statusIsGood = row.doc && row.doc.views &&\n              row.doc.views[viewName];\n            viewDBNames.forEach(function (viewDBName) {\n              viewsToStatus[viewDBName] =\n                viewsToStatus[viewDBName] || statusIsGood;\n            });\n          });\n        });\n        var dbsToDelete = Object.keys(viewsToStatus).filter(\n          function (viewDBName) { return !viewsToStatus[viewDBName]; });\n        var destroyPromises = dbsToDelete.map(function (viewDBName) {\n          return sequentialize(getQueue(viewDBName), function () {\n            return new db.constructor(viewDBName, db.__opts).destroy();\n          })();\n        });\n        return Promise.all(destroyPromises).then(function () {\n          return {ok: true};\n        });\n      });\n    }, defaultsTo({ok: true}));\n  }\n\n  function queryPromised(db, fun, opts) {\n    /* istanbul ignore next */\n    if (typeof db._query === 'function') {\n      return customQuery(db, fun, opts);\n    }\n    if (isRemote(db)) {\n      return httpQuery(db, fun, opts);\n    }\n\n    if (typeof fun !== 'string') {\n      // temp_view\n      checkQueryParseError(opts, fun);\n\n      tempViewQueue.add(function () {\n        var createViewPromise = createView(\n          /* sourceDB */ db,\n          /* viewName */ 'temp_view/temp_view',\n          /* mapFun */ fun.map,\n          /* reduceFun */ fun.reduce,\n          /* temporary */ true,\n          /* localDocName */ localDocName);\n        return createViewPromise.then(function (view) {\n          return fin(updateView(view).then(function () {\n            return queryView(view, opts);\n          }), function () {\n            return view.db.destroy();\n          });\n        });\n      });\n      return tempViewQueue.finish();\n    } else {\n      // persistent view\n      var fullViewName = fun;\n      var parts = parseViewName(fullViewName);\n      var designDocName = parts[0];\n      var viewName = parts[1];\n      return db.get('_design/' + designDocName).then(function (doc) {\n        var fun = doc.views && doc.views[viewName];\n\n        if (!fun) {\n          // basic validator; it's assumed that every subclass would want this\n          throw new NotFoundError('ddoc ' + doc._id + ' has no view named ' +\n            viewName);\n        }\n\n        ddocValidator(doc, viewName);\n        checkQueryParseError(opts, fun);\n\n        var createViewPromise = createView(\n          /* sourceDB */ db,\n          /* viewName */ fullViewName,\n          /* mapFun */ fun.map,\n          /* reduceFun */ fun.reduce,\n          /* temporary */ false,\n          /* localDocName */ localDocName);\n        return createViewPromise.then(function (view) {\n          if (opts.stale === 'ok' || opts.stale === 'update_after') {\n            if (opts.stale === 'update_after') {\n              nextTick(function () {\n                updateView(view);\n              });\n            }\n            return queryView(view, opts);\n          } else { // stale not ok\n            return updateView(view).then(function () {\n              return queryView(view, opts);\n            });\n          }\n        });\n      });\n    }\n  }\n\n  function abstractQuery(fun, opts, callback) {\n    var db = this;\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = opts ? coerceOptions(opts) : {};\n\n    if (typeof fun === 'function') {\n      fun = {map : fun};\n    }\n\n    var promise = Promise.resolve().then(function () {\n      return queryPromised(db, fun, opts);\n    });\n    promisedCallback(promise, callback);\n    return promise;\n  }\n\n  var abstractViewCleanup = callbackify(function () {\n    var db = this;\n    /* istanbul ignore next */\n    if (typeof db._viewCleanup === 'function') {\n      return customViewCleanup(db);\n    }\n    if (isRemote(db)) {\n      return httpViewCleanup(db);\n    }\n    return localViewCleanup(db);\n  });\n\n  return {\n    query: abstractQuery,\n    viewCleanup: abstractViewCleanup\n  };\n}\n\nexport default createAbstractMapReduce;\n\n\n\n// WEBPACK FOOTER //\n// ../~/pouchdb-abstract-mapreduce/lib/index.es.js","function mangle(key) {\n  return '$' + key;\n}\nfunction unmangle(key) {\n  return key.substring(1);\n}\nfunction Map$1() {\n  this._store = {};\n}\nMap$1.prototype.get = function (key) {\n  var mangled = mangle(key);\n  return this._store[mangled];\n};\nMap$1.prototype.set = function (key, value) {\n  var mangled = mangle(key);\n  this._store[mangled] = value;\n  return true;\n};\nMap$1.prototype.has = function (key) {\n  var mangled = mangle(key);\n  return mangled in this._store;\n};\nMap$1.prototype.delete = function (key) {\n  var mangled = mangle(key);\n  var res = mangled in this._store;\n  delete this._store[mangled];\n  return res;\n};\nMap$1.prototype.forEach = function (cb) {\n  var keys = Object.keys(this._store);\n  for (var i = 0, len = keys.length; i < len; i++) {\n    var key = keys[i];\n    var value = this._store[key];\n    key = unmangle(key);\n    cb(value, key);\n  }\n};\nObject.defineProperty(Map$1.prototype, 'size', {\n  get: function () {\n    return Object.keys(this._store).length;\n  }\n});\n\nfunction Set$1(array) {\n  this._store = new Map$1();\n\n  // init with an array\n  if (array && Array.isArray(array)) {\n    for (var i = 0, len = array.length; i < len; i++) {\n      this.add(array[i]);\n    }\n  }\n}\nSet$1.prototype.add = function (key) {\n  return this._store.set(key, true);\n};\nSet$1.prototype.has = function (key) {\n  return this._store.has(key);\n};\nSet$1.prototype.forEach = function (cb) {\n  this._store.forEach(function (value, key) {\n    cb(key);\n  });\n};\nObject.defineProperty(Set$1.prototype, 'size', {\n  get: function () {\n    return this._store.size;\n  }\n});\n\n/* global Map,Set,Symbol */\n// Based on https://kangax.github.io/compat-table/es6/ we can sniff out\n// incomplete Map/Set implementations which would otherwise cause our tests to fail.\n// Notably they fail in IE11 and iOS 8.4, which this prevents.\nfunction supportsMapAndSet() {\n  if (typeof Symbol === 'undefined' || typeof Map === 'undefined' || typeof Set === 'undefined') {\n    return false;\n  }\n  var prop = Object.getOwnPropertyDescriptor(Map, Symbol.species);\n  return prop && 'get' in prop && Map[Symbol.species] === Map;\n}\n\n// based on https://github.com/montagejs/collections\n/* global Map,Set */\n\nvar ExportedSet;\nvar ExportedMap;\n\n{\n  if (supportsMapAndSet()) { // prefer built-in Map/Set\n    ExportedSet = Set;\n    ExportedMap = Map;\n  } else { // fall back to our polyfill\n    ExportedSet = Set$1;\n    ExportedMap = Map$1;\n  }\n}\n\nexport { ExportedSet as Set, ExportedMap as Map };\n\n\n\n// WEBPACK FOOTER //\n// ../~/pouchdb-collections/lib/index.es.js","import { assign, clone, isRemote, toPromise, upsert } from 'pouchdb-utils';\nimport Promise from 'pouchdb-promise';\nimport { compare, filterInMemoryFields, getFieldFromDoc, getKey, getValue, massageSelector, parseField, setFieldInDoc } from 'pouchdb-selector-core';\nimport abstractMapReduce from 'pouchdb-abstract-mapreduce';\nimport { collate } from 'pouchdb-collate';\nimport { stringMd5 } from 'pouchdb-md5';\n\n// we restucture the supplied JSON considerably, because the official\n// Mango API is very particular about a lot of this stuff, but we like\n// to be liberal with what we accept in order to prevent mental\n// breakdowns in our users\nfunction massageCreateIndexRequest(requestDef) {\n  requestDef = clone(requestDef);\n\n  if (!requestDef.index) {\n    requestDef.index = {};\n  }\n\n  ['type', 'name', 'ddoc'].forEach(function (key) {\n    if (requestDef.index[key]) {\n      requestDef[key] = requestDef.index[key];\n      delete requestDef.index[key];\n    }\n  });\n\n  if (requestDef.fields) {\n    requestDef.index.fields = requestDef.fields;\n    delete requestDef.fields;\n  }\n\n  if (!requestDef.type) {\n    requestDef.type = 'json';\n  }\n  return requestDef;\n}\n\nfunction createIndex(db, requestDef, callback) {\n  requestDef = massageCreateIndexRequest(requestDef);\n\n  db.request({\n    method: 'POST',\n    url: '_index',\n    body: requestDef\n  }, callback);\n}\n\nfunction find(db, requestDef, callback) {\n  db.request({\n    method: 'POST',\n    url: '_find',\n    body: requestDef\n  }, callback);\n}\n\nfunction explain(db, requestDef, callback) {\n  db.request({\n    method: 'POST',\n    url: '_explain',\n    body: requestDef\n  }, callback);\n}\n\nfunction getIndexes(db, callback) {\n  db.request({\n    method: 'GET',\n    url: '_index'\n  }, callback);\n}\n\nfunction deleteIndex(db, indexDef, callback) {\n\n\n  var ddoc = indexDef.ddoc;\n  var type = indexDef.type || 'json';\n  var name = indexDef.name;\n\n  if (!ddoc) {\n    return callback(new Error('you must provide an index\\'s ddoc'));\n  }\n\n  if (!name) {\n    return callback(new Error('you must provide an index\\'s name'));\n  }\n\n  var url = '_index/' + [ddoc, type, name].map(encodeURIComponent).join('/');\n\n  db.request({\n    method: 'DELETE',\n    url: url\n  }, callback);\n}\n\nfunction getArguments(fun) {\n  return function () {\n    var len = arguments.length;\n    var args = new Array(len);\n    var i = -1;\n    while (++i < len) {\n      args[i] = arguments[i];\n    }\n    return fun.call(this, args);\n  };\n}\nfunction callbackify(fun) {\n  return getArguments(function (args) {\n    var cb = args.pop();\n    var promise = fun.apply(this, args);\n    promisedCallback(promise, cb);\n    return promise;\n  });\n}\n\nfunction promisedCallback(promise, callback) {\n  promise.then(function (res) {\n    process.nextTick(function () {\n      callback(null, res);\n    });\n  }, function (reason) {\n    process.nextTick(function () {\n      callback(reason);\n    });\n  });\n  return promise;\n}\n\nvar flatten = getArguments(function (args) {\n  var res = [];\n  for (var i = 0, len = args.length; i < len; i++) {\n    var subArr = args[i];\n    if (Array.isArray(subArr)) {\n      res = res.concat(flatten.apply(null, subArr));\n    } else {\n      res.push(subArr);\n    }\n  }\n  return res;\n});\n\nfunction mergeObjects(arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    res = assign(res, arr[i]);\n  }\n  return res;\n}\n\n// Selects a list of fields defined in dot notation from one doc\n// and copies them to a new doc. Like underscore _.pick but supports nesting.\nfunction pick(obj, arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var parsedField = parseField(arr[i]);\n    var value = getFieldFromDoc(obj, parsedField);\n    if (typeof value !== 'undefined') {\n      setFieldInDoc(res, parsedField, value);\n    }\n  }\n  return res;\n}\n\n// e.g. ['a'], ['a', 'b'] is true, but ['b'], ['a', 'b'] is false\nfunction oneArrayIsSubArrayOfOther(left, right) {\n\n  for (var i = 0, len = Math.min(left.length, right.length); i < len; i++) {\n    if (left[i] !== right[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// e.g.['a', 'b', 'c'], ['a', 'b'] is false\nfunction oneArrayIsStrictSubArrayOfOther(left, right) {\n\n  if (left.length > right.length) {\n    return false;\n  }\n\n  return oneArrayIsSubArrayOfOther(left, right);\n}\n\n// same as above, but treat the left array as an unordered set\n// e.g. ['b', 'a'], ['a', 'b', 'c'] is true, but ['c'], ['a', 'b', 'c'] is false\nfunction oneSetIsSubArrayOfOther(left, right) {\n  left = left.slice();\n  for (var i = 0, len = right.length; i < len; i++) {\n    var field = right[i];\n    if (!left.length) {\n      break;\n    }\n    var leftIdx = left.indexOf(field);\n    if (leftIdx === -1) {\n      return false;\n    } else {\n      left.splice(leftIdx, 1);\n    }\n  }\n  return true;\n}\n\nfunction arrayToObject(arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    res[arr[i]] = true;\n  }\n  return res;\n}\n\nfunction max(arr, fun) {\n  var max = null;\n  var maxScore = -1;\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var element = arr[i];\n    var score = fun(element);\n    if (score > maxScore) {\n      maxScore = score;\n      max = element;\n    }\n  }\n  return max;\n}\n\nfunction arrayEquals(arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n  for (var i = 0, len = arr1.length; i < len; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction uniq(arr) {\n  var obj = {};\n  for (var i = 0; i < arr.length; i++) {\n    obj['$' + arr[i]] = true;\n  }\n  return Object.keys(obj).map(function (key) {\n    return key.substring(1);\n  });\n}\n\n//\n// One thing about these mappers:\n//\n// Per the advice of John-David Dalton (http://youtu.be/NthmeLEhDDM),\n// what you want to do in this case is optimize for the smallest possible\n// function, since that's the thing that gets run over and over again.\n//\n// This code would be a lot simpler if all the if/elses were inside\n// the function, but it would also be a lot less performant.\n//\n\n\nfunction createDeepMultiMapper(fields, emit) {\n  return function (doc) {\n    var toEmit = [];\n    for (var i = 0, iLen = fields.length; i < iLen; i++) {\n      var parsedField = parseField(fields[i]);\n      var value = doc;\n      for (var j = 0, jLen = parsedField.length; j < jLen; j++) {\n        var key = parsedField[j];\n        value = value[key];\n        if (!value) {\n          return; // don't emit\n        }\n      }\n      toEmit.push(value);\n    }\n    emit(toEmit);\n  };\n}\n\nfunction createDeepSingleMapper(field, emit) {\n  var parsedField = parseField(field);\n  return function (doc) {\n    var value = doc;\n    for (var i = 0, len = parsedField.length; i < len; i++) {\n      var key = parsedField[i];\n      value = value[key];\n      if (!value) {\n        return; // do nothing\n      }\n    }\n    emit(value);\n  };\n}\n\nfunction createShallowSingleMapper(field, emit) {\n  return function (doc) {\n    emit(doc[field]);\n  };\n}\n\nfunction createShallowMultiMapper(fields, emit) {\n  return function (doc) {\n    var toEmit = [];\n    for (var i = 0, len = fields.length; i < len; i++) {\n      toEmit.push(doc[fields[i]]);\n    }\n    emit(toEmit);\n  };\n}\n\nfunction checkShallow(fields) {\n  for (var i = 0, len = fields.length; i < len; i++) {\n    var field = fields[i];\n    if (field.indexOf('.') !== -1) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction createMapper(fields, emit) {\n  var isShallow = checkShallow(fields);\n  var isSingle = fields.length === 1;\n\n  // notice we try to optimize for the most common case,\n  // i.e. single shallow indexes\n  if (isShallow) {\n    if (isSingle) {\n      return createShallowSingleMapper(fields[0], emit);\n    } else { // multi\n      return createShallowMultiMapper(fields, emit);\n    }\n  } else { // deep\n    if (isSingle) {\n      return createDeepSingleMapper(fields[0], emit);\n    } else { // multi\n      return createDeepMultiMapper(fields, emit);\n    }\n  }\n}\n\nfunction mapper(mapFunDef, emit) {\n  // mapFunDef is a list of fields\n\n  var fields = Object.keys(mapFunDef.fields);\n\n  return createMapper(fields, emit);\n}\n\n/* istanbul ignore next */\nfunction reducer(/*reduceFunDef*/) {\n  throw new Error('reduce not supported');\n}\n\nfunction ddocValidator(ddoc, viewName) {\n  var view = ddoc.views[viewName];\n  // This doesn't actually need to be here apparently, but\n  // I feel safer keeping it.\n  /* istanbul ignore if */\n  if (!view.map || !view.map.fields) {\n    throw new Error('ddoc ' + ddoc._id +' with view ' + viewName +\n      ' doesn\\'t have map.fields defined. ' +\n      'maybe it wasn\\'t created by this plugin?');\n  }\n}\n\nvar abstractMapper = abstractMapReduce(\n  /* localDocName */ 'indexes',\n  mapper,\n  reducer,\n  ddocValidator\n);\n\n// normalize the \"sort\" value\nfunction massageSort(sort) {\n  if (!Array.isArray(sort)) {\n    throw new Error('invalid sort json - should be an array');\n  }\n  return sort.map(function (sorting) {\n    if (typeof sorting === 'string') {\n      var obj = {};\n      obj[sorting] = 'asc';\n      return obj;\n    } else {\n      return sorting;\n    }\n  });\n}\n\nfunction massageUseIndex(useIndex) {\n  var cleanedUseIndex = [];\n  if (typeof useIndex === 'string') {\n    cleanedUseIndex.push(useIndex);\n  } else {\n    cleanedUseIndex = useIndex;\n  }\n\n  return cleanedUseIndex.map(function (name) {\n    return name.replace('_design/', '');\n  });\n}\n\nfunction massageIndexDef(indexDef) {\n  indexDef.fields = indexDef.fields.map(function (field) {\n    if (typeof field === 'string') {\n      var obj = {};\n      obj[field] = 'asc';\n      return obj;\n    }\n    return field;\n  });\n  return indexDef;\n}\n\nfunction getKeyFromDoc(doc, index) {\n  var res = [];\n  for (var i = 0; i < index.def.fields.length; i++) {\n    var field = getKey(index.def.fields[i]);\n    res.push(doc[field]);\n  }\n  return res;\n}\n\n// have to do this manually because REASONS. I don't know why\n// CouchDB didn't implement inclusive_start\nfunction filterInclusiveStart(rows, targetValue, index) {\n  var indexFields = index.def.fields;\n  for (var i = 0, len = rows.length; i < len; i++) {\n    var row = rows[i];\n\n    // shave off any docs at the beginning that are <= the\n    // target value\n\n    var docKey = getKeyFromDoc(row.doc, index);\n    if (indexFields.length === 1) {\n      docKey = docKey[0]; // only one field, not multi-field\n    } else { // more than one field in index\n      // in the case where e.g. the user is searching {$gt: {a: 1}}\n      // but the index is [a, b], then we need to shorten the doc key\n      while (docKey.length > targetValue.length) {\n        docKey.pop();\n      }\n    }\n    //ABS as we just looking for values that don't match\n    if (Math.abs(collate(docKey, targetValue)) > 0) {\n      // no need to filter any further; we're past the key\n      break;\n    }\n  }\n  return i > 0 ? rows.slice(i) : rows;\n}\n\nfunction reverseOptions(opts) {\n  var newOpts = clone(opts);\n  delete newOpts.startkey;\n  delete newOpts.endkey;\n  delete newOpts.inclusive_start;\n  delete newOpts.inclusive_end;\n\n  if ('endkey' in opts) {\n    newOpts.startkey = opts.endkey;\n  }\n  if ('startkey' in opts) {\n    newOpts.endkey = opts.startkey;\n  }\n  if ('inclusive_start' in opts) {\n    newOpts.inclusive_end = opts.inclusive_start;\n  }\n  if ('inclusive_end' in opts) {\n    newOpts.inclusive_start = opts.inclusive_end;\n  }\n  return newOpts;\n}\n\nfunction validateIndex(index) {\n  var ascFields = index.fields.filter(function (field) {\n    return getValue(field) === 'asc';\n  });\n  if (ascFields.length !== 0 && ascFields.length !== index.fields.length) {\n    throw new Error('unsupported mixed sorting');\n  }\n}\n\nfunction validateSort(requestDef, index) {\n  if (index.defaultUsed && requestDef.sort) {\n    var noneIdSorts = requestDef.sort.filter(function (sortItem) {\n      return Object.keys(sortItem)[0] !== '_id';\n    }).map(function (sortItem) {\n      return Object.keys(sortItem)[0];\n    });\n\n    if (noneIdSorts.length > 0) {\n      throw new Error('Cannot sort on field(s) \"' + noneIdSorts.join(',') +\n      '\" when using the default index');\n    }\n  }\n\n  if (index.defaultUsed) {\n    return;\n  }\n}\n\nfunction validateFindRequest(requestDef) {\n  if (typeof requestDef.selector !== 'object') {\n    throw new Error('you must provide a selector when you find()');\n  }\n\n  /*var selectors = requestDef.selector['$and'] || [requestDef.selector];\n  for (var i = 0; i < selectors.length; i++) {\n    var selector = selectors[i];\n    var keys = Object.keys(selector);\n    if (keys.length === 0) {\n      throw new Error('invalid empty selector');\n    }\n    //var selection = selector[keys[0]];\n    /*if (Object.keys(selection).length !== 1) {\n      throw new Error('invalid selector: ' + JSON.stringify(selection) +\n        ' - it must have exactly one key/value');\n    }\n  }*/\n}\n\n// determine the maximum number of fields\n// we're going to need to query, e.g. if the user\n// has selection ['a'] and sorting ['a', 'b'], then we\n// need to use the longer of the two: ['a', 'b']\nfunction getUserFields(selector, sort) {\n  var selectorFields = Object.keys(selector);\n  var sortFields = sort? sort.map(getKey) : [];\n  var userFields;\n  if (selectorFields.length >= sortFields.length) {\n    userFields = selectorFields;\n  } else {\n    userFields = sortFields;\n  }\n\n  if (sortFields.length === 0) {\n    return {\n      fields: userFields\n    };\n  }\n\n  // sort according to the user's preferred sorting\n  userFields = userFields.sort(function (left, right) {\n    var leftIdx = sortFields.indexOf(left);\n    if (leftIdx === -1) {\n      leftIdx = Number.MAX_VALUE;\n    }\n    var rightIdx = sortFields.indexOf(right);\n    if (rightIdx === -1) {\n      rightIdx = Number.MAX_VALUE;\n    }\n    return leftIdx < rightIdx ? -1 : leftIdx > rightIdx ? 1 : 0;\n  });\n\n  return {\n    fields: userFields,\n    sortOrder: sort.map(getKey)\n  };\n}\n\nfunction createIndex$1(db, requestDef) {\n  requestDef = massageCreateIndexRequest(requestDef);\n  var originalIndexDef = clone(requestDef.index);\n  requestDef.index = massageIndexDef(requestDef.index);\n\n  validateIndex(requestDef.index);\n\n  // calculating md5 is expensive - memoize and only\n  // run if required\n  var md5;\n  function getMd5() {\n    return md5 || (md5 = stringMd5(JSON.stringify(requestDef)));\n  }\n\n  var viewName = requestDef.name || ('idx-' + getMd5());\n\n  var ddocName = requestDef.ddoc || ('idx-' + getMd5());\n  var ddocId = '_design/' + ddocName;\n\n  var hasInvalidLanguage = false;\n  var viewExists = false;\n\n  function updateDdoc(doc) {\n    if (doc._rev && doc.language !== 'query') {\n      hasInvalidLanguage = true;\n    }\n    doc.language = 'query';\n    doc.views = doc.views || {};\n\n    viewExists = !!doc.views[viewName];\n\n    if (viewExists) {\n      return false;\n    }\n\n    doc.views[viewName] = {\n      map: {\n        fields: mergeObjects(requestDef.index.fields)\n      },\n      reduce: '_count',\n      options: {\n        def: originalIndexDef\n      }\n    };\n\n    return doc;\n  }\n\n  db.constructor.emit('debug', ['find', 'creating index', ddocId]);\n\n  return upsert(db, ddocId, updateDdoc).then(function () {\n    if (hasInvalidLanguage) {\n      throw new Error('invalid language for ddoc with id \"' +\n      ddocId +\n      '\" (should be \"query\")');\n    }\n  }).then(function () {\n    // kick off a build\n    // TODO: abstract-pouchdb-mapreduce should support auto-updating\n    // TODO: should also use update_after, but pouchdb/pouchdb#3415 blocks me\n    var signature = ddocName + '/' + viewName;\n    return abstractMapper.query.call(db, signature, {\n      limit: 0,\n      reduce: false\n    }).then(function () {\n      return {\n        id: ddocId,\n        name: viewName,\n        result: viewExists ? 'exists' : 'created'\n      };\n    });\n  });\n}\n\nfunction getIndexes$1(db) {\n  // just search through all the design docs and filter in-memory.\n  // hopefully there aren't that many ddocs.\n  return db.allDocs({\n    startkey: '_design/',\n    endkey: '_design/\\uffff',\n    include_docs: true\n  }).then(function (allDocsRes) {\n    var res = {\n      indexes: [{\n        ddoc: null,\n        name: '_all_docs',\n        type: 'special',\n        def: {\n          fields: [{_id: 'asc'}]\n        }\n      }]\n    };\n\n    res.indexes = flatten(res.indexes, allDocsRes.rows.filter(function (row) {\n      return row.doc.language === 'query';\n    }).map(function (row) {\n      var viewNames = row.doc.views !== undefined ? Object.keys(row.doc.views) : [];\n\n      return viewNames.map(function (viewName) {\n        var view = row.doc.views[viewName];\n        return {\n          ddoc: row.id,\n          name: viewName,\n          type: 'json',\n          def: massageIndexDef(view.options.def)\n        };\n      });\n    }));\n\n    // these are sorted by view name for some reason\n    res.indexes.sort(function (left, right) {\n      return compare(left.name, right.name);\n    });\n    res.total_rows = res.indexes.length;\n    return res;\n  });\n}\n\n// couchdb lowest collation value\nvar COLLATE_LO = null;\n\n// couchdb highest collation value (TODO: well not really, but close enough amirite)\nvar COLLATE_HI = {\"\\uffff\": {}};\n\n// couchdb second-lowest collation value\n\nfunction checkFieldInIndex(index, field) {\n  var indexFields = index.def.fields.map(getKey);\n  for (var i = 0, len = indexFields.length; i < len; i++) {\n    var indexField = indexFields[i];\n    if (field === indexField) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// so when you do e.g. $eq/$eq, we can do it entirely in the database.\n// but when you do e.g. $gt/$eq, the first part can be done\n// in the database, but the second part has to be done in-memory,\n// because $gt has forced us to lose precision.\n// so that's what this determines\nfunction userOperatorLosesPrecision(selector, field) {\n  var matcher = selector[field];\n  var userOperator = getKey(matcher);\n\n  return userOperator !== '$eq';\n}\n\n// sort the user fields by their position in the index,\n// if they're in the index\nfunction sortFieldsByIndex(userFields, index) {\n  var indexFields = index.def.fields.map(getKey);\n\n  return userFields.slice().sort(function (a, b) {\n    var aIdx = indexFields.indexOf(a);\n    var bIdx = indexFields.indexOf(b);\n    if (aIdx === -1) {\n      aIdx = Number.MAX_VALUE;\n    }\n    if (bIdx === -1) {\n      bIdx = Number.MAX_VALUE;\n    }\n    return compare(aIdx, bIdx);\n  });\n}\n\n// first pass to try to find fields that will need to be sorted in-memory\nfunction getBasicInMemoryFields(index, selector, userFields) {\n\n  userFields = sortFieldsByIndex(userFields, index);\n\n  // check if any of the user selectors lose precision\n  var needToFilterInMemory = false;\n  for (var i = 0, len = userFields.length; i < len; i++) {\n    var field = userFields[i];\n    if (needToFilterInMemory || !checkFieldInIndex(index, field)) {\n      return userFields.slice(i);\n    }\n    if (i < len - 1 && userOperatorLosesPrecision(selector, field)) {\n      needToFilterInMemory = true;\n    }\n  }\n  return [];\n}\n\nfunction getInMemoryFieldsFromNe(selector) {\n  var fields = [];\n  Object.keys(selector).forEach(function (field) {\n    var matcher = selector[field];\n    Object.keys(matcher).forEach(function (operator) {\n      if (operator === '$ne') {\n        fields.push(field);\n      }\n    });\n  });\n  return fields;\n}\n\nfunction getInMemoryFields(coreInMemoryFields, index, selector, userFields) {\n  var result = flatten(\n    // in-memory fields reported as necessary by the query planner\n    coreInMemoryFields,\n    // combine with another pass that checks for any we may have missed\n    getBasicInMemoryFields(index, selector, userFields),\n    // combine with another pass that checks for $ne's\n    getInMemoryFieldsFromNe(selector)\n  );\n\n  return sortFieldsByIndex(uniq(result), index);\n}\n\n// check that at least one field in the user's query is represented\n// in the index. order matters in the case of sorts\nfunction checkIndexFieldsMatch(indexFields, sortOrder, fields) {\n  if (sortOrder) {\n    // array has to be a strict subarray of index array. furthermore,\n    // the sortOrder fields need to all be represented in the index\n    var sortMatches = oneArrayIsStrictSubArrayOfOther(sortOrder, indexFields);\n    var selectorMatches = oneArrayIsSubArrayOfOther(fields, indexFields);\n\n    return sortMatches && selectorMatches;\n  }\n\n  // all of the user's specified fields still need to be\n  // on the left side of the index array, although the order\n  // doesn't matter\n  return oneSetIsSubArrayOfOther(fields, indexFields);\n}\n\nvar logicalMatchers = ['$eq', '$gt', '$gte', '$lt', '$lte'];\nfunction isNonLogicalMatcher(matcher) {\n  return logicalMatchers.indexOf(matcher) === -1;\n}\n\n// check all the index fields for usages of '$ne'\n// e.g. if the user queries {foo: {$ne: 'foo'}, bar: {$eq: 'bar'}},\n// then we can neither use an index on ['foo'] nor an index on\n// ['foo', 'bar'], but we can use an index on ['bar'] or ['bar', 'foo']\nfunction checkFieldsLogicallySound(indexFields, selector) {\n  var firstField = indexFields[0];\n  var matcher = selector[firstField];\n\n  if (typeof matcher === 'undefined') {\n    return true;\n  }\n\n  var hasLogicalOperator = Object.keys(matcher).some(function (matcherKey) {\n    return !(isNonLogicalMatcher(matcherKey));\n  });\n\n  if (!hasLogicalOperator) {\n    return false;\n  }\n\n  var isInvalidNe = Object.keys(matcher).length === 1 &&\n    getKey(matcher) === '$ne';\n\n  return !isInvalidNe;\n}\n\nfunction checkIndexMatches(index, sortOrder, fields, selector) {\n\n  var indexFields = index.def.fields.map(getKey);\n\n  var fieldsMatch = checkIndexFieldsMatch(indexFields, sortOrder, fields);\n\n  if (!fieldsMatch) {\n    return false;\n  }\n\n  return checkFieldsLogicallySound(indexFields, selector);\n}\n\n//\n// the algorithm is very simple:\n// take all the fields the user supplies, and if those fields\n// are a strict subset of the fields in some index,\n// then use that index\n//\n//\nfunction findMatchingIndexes(selector, userFields, sortOrder, indexes) {\n\n  return indexes.reduce(function (res, index) {\n    var indexMatches = checkIndexMatches(index, sortOrder, userFields, selector);\n    if (indexMatches) {\n      res.push(index);\n    }\n    return res;\n  }, []);\n}\n\n// find the best index, i.e. the one that matches the most fields\n// in the user's query\nfunction findBestMatchingIndex(selector, userFields, sortOrder, indexes, useIndex) {\n\n  var matchingIndexes = findMatchingIndexes(selector, userFields, sortOrder, indexes);\n\n  if (matchingIndexes.length === 0) {\n    if (useIndex) {\n      throw {\n        error: \"no_usable_index\",\n        message: \"There is no index available for this selector.\"\n      };\n    }\n    //return `all_docs` as a default index;\n    //I'm assuming that _all_docs is always first\n    var defaultIndex = indexes[0];\n    defaultIndex.defaultUsed = true;\n    return defaultIndex;\n  }\n  if (matchingIndexes.length === 1 && !useIndex) {\n    return matchingIndexes[0];\n  }\n\n  var userFieldsMap = arrayToObject(userFields);\n\n  function scoreIndex(index) {\n    var indexFields = index.def.fields.map(getKey);\n    var score = 0;\n    for (var i = 0, len = indexFields.length; i < len; i++) {\n      var indexField = indexFields[i];\n      if (userFieldsMap[indexField]) {\n        score++;\n      }\n    }\n    return score;\n  }\n\n  if (useIndex) {\n    var useIndexDdoc = '_design/' + useIndex[0];\n    var useIndexName = useIndex.length === 2 ? useIndex[1] : false;\n    var index = matchingIndexes.find(function (index) {\n      if (useIndexName && index.ddoc === useIndexDdoc && useIndexName === index.name) {\n        return true;\n      }\n\n      if (index.ddoc === useIndexDdoc) {\n        return true;\n      }\n\n      return false;\n    });\n\n    if (!index) {\n      throw {\n        error: \"unknown_error\",\n        message: \"Could not find that index or could not use that index for the query\"\n      };\n    }\n    return index;\n  }\n\n  return max(matchingIndexes, scoreIndex);\n}\n\nfunction getSingleFieldQueryOptsFor(userOperator, userValue) {\n  switch (userOperator) {\n    case '$eq':\n      return {key: userValue};\n    case '$lte':\n      return {endkey: userValue};\n    case '$gte':\n      return {startkey: userValue};\n    case '$lt':\n      return {\n        endkey: userValue,\n        inclusive_end: false\n      };\n    case '$gt':\n      return {\n        startkey: userValue,\n        inclusive_start: false\n      };\n  }\n}\n\nfunction getSingleFieldCoreQueryPlan(selector, index) {\n  var field = getKey(index.def.fields[0]);\n  //ignoring this because the test to exercise the branch is skipped at the moment\n  /* istanbul ignore next */\n  var matcher = selector[field] || {};\n  var inMemoryFields = [];\n\n  var userOperators = Object.keys(matcher);\n\n  var combinedOpts;\n\n  userOperators.forEach(function (userOperator) {\n\n    if (isNonLogicalMatcher(userOperator)) {\n      inMemoryFields.push(field);\n      return;\n    }\n\n    var userValue = matcher[userOperator];\n\n    var newQueryOpts = getSingleFieldQueryOptsFor(userOperator, userValue);\n\n    if (combinedOpts) {\n      combinedOpts = mergeObjects([combinedOpts, newQueryOpts]);\n    } else {\n      combinedOpts = newQueryOpts;\n    }\n  });\n\n  return {\n    queryOpts: combinedOpts,\n    inMemoryFields: inMemoryFields\n  };\n}\n\nfunction getMultiFieldCoreQueryPlan(userOperator, userValue) {\n  switch (userOperator) {\n    case '$eq':\n      return {\n        startkey: userValue,\n        endkey: userValue\n      };\n    case '$lte':\n      return {\n        endkey: userValue\n      };\n    case '$gte':\n      return {\n        startkey: userValue\n      };\n    case '$lt':\n      return {\n        endkey: userValue,\n        inclusive_end: false\n      };\n    case '$gt':\n      return {\n        startkey: userValue,\n        inclusive_start: false\n      };\n  }\n}\n\nfunction getMultiFieldQueryOpts(selector, index) {\n\n  var indexFields = index.def.fields.map(getKey);\n\n  var inMemoryFields = [];\n  var startkey = [];\n  var endkey = [];\n  var inclusiveStart;\n  var inclusiveEnd;\n\n\n  function finish(i) {\n\n    if (inclusiveStart !== false) {\n      startkey.push(COLLATE_LO);\n    }\n    if (inclusiveEnd !== false) {\n      endkey.push(COLLATE_HI);\n    }\n    // keep track of the fields where we lost specificity,\n    // and therefore need to filter in-memory\n    inMemoryFields = indexFields.slice(i);\n  }\n\n  for (var i = 0, len = indexFields.length; i < len; i++) {\n    var indexField = indexFields[i];\n\n    var matcher = selector[indexField];\n\n    if (!matcher || !Object.keys(matcher).length) { // fewer fields in user query than in index\n      finish(i);\n      break;\n    } else if (i > 0) {\n      if (Object.keys(matcher).some(isNonLogicalMatcher)) { // non-logical are ignored\n        finish(i);\n        break;\n      }\n      var usingGtlt = (\n        '$gt' in matcher || '$gte' in matcher ||\n        '$lt' in matcher || '$lte' in matcher);\n      var previousKeys = Object.keys(selector[indexFields[i - 1]]);\n      var previousWasEq = arrayEquals(previousKeys, ['$eq']);\n      var previousWasSame = arrayEquals(previousKeys, Object.keys(matcher));\n      var gtltLostSpecificity = usingGtlt && !previousWasEq && !previousWasSame;\n      if (gtltLostSpecificity) {\n        finish(i);\n        break;\n      }\n    }\n\n    var userOperators = Object.keys(matcher);\n\n    var combinedOpts = null;\n\n    for (var j = 0; j < userOperators.length; j++) {\n      var userOperator = userOperators[j];\n      var userValue = matcher[userOperator];\n\n      var newOpts = getMultiFieldCoreQueryPlan(userOperator, userValue);\n\n      if (combinedOpts) {\n        combinedOpts = mergeObjects([combinedOpts, newOpts]);\n      } else {\n        combinedOpts = newOpts;\n      }\n    }\n\n    startkey.push('startkey' in combinedOpts ? combinedOpts.startkey : COLLATE_LO);\n    endkey.push('endkey' in combinedOpts ? combinedOpts.endkey : COLLATE_HI);\n    if ('inclusive_start' in combinedOpts) {\n      inclusiveStart = combinedOpts.inclusive_start;\n    }\n    if ('inclusive_end' in combinedOpts) {\n      inclusiveEnd = combinedOpts.inclusive_end;\n    }\n  }\n\n  var res = {\n    startkey: startkey,\n    endkey: endkey\n  };\n\n  if (typeof inclusiveStart !== 'undefined') {\n    res.inclusive_start = inclusiveStart;\n  }\n  if (typeof inclusiveEnd !== 'undefined') {\n    res.inclusive_end = inclusiveEnd;\n  }\n\n  return {\n    queryOpts: res,\n    inMemoryFields: inMemoryFields\n  };\n}\n\nfunction getDefaultQueryPlan(selector) {\n  //using default index, so all fields need to be done in memory\n  return {\n    queryOpts: {startkey: null},\n    inMemoryFields: [Object.keys(selector)]\n  };\n}\n\nfunction getCoreQueryPlan(selector, index) {\n  if (index.defaultUsed) {\n    return getDefaultQueryPlan(selector, index);\n  }\n\n  if (index.def.fields.length === 1) {\n    // one field in index, so the value was indexed as a singleton\n    return getSingleFieldCoreQueryPlan(selector, index);\n  }\n  // else index has multiple fields, so the value was indexed as an array\n  return getMultiFieldQueryOpts(selector, index);\n}\n\nfunction planQuery(request, indexes) {\n\n  var selector = request.selector;\n  var sort = request.sort;\n\n  var userFieldsRes = getUserFields(selector, sort);\n\n  var userFields = userFieldsRes.fields;\n  var sortOrder = userFieldsRes.sortOrder;\n  var index = findBestMatchingIndex(selector, userFields, sortOrder, indexes, request.use_index);\n\n  var coreQueryPlan = getCoreQueryPlan(selector, index);\n  var queryOpts = coreQueryPlan.queryOpts;\n  var coreInMemoryFields = coreQueryPlan.inMemoryFields;\n\n  var inMemoryFields = getInMemoryFields(coreInMemoryFields, index, selector, userFields);\n\n  var res = {\n    queryOpts: queryOpts,\n    index: index,\n    inMemoryFields: inMemoryFields\n  };\n  return res;\n}\n\nfunction indexToSignature(index) {\n  // remove '_design/'\n  return index.ddoc.substring(8) + '/' + index.name;\n}\n\nfunction doAllDocs(db, originalOpts) {\n  var opts = clone(originalOpts);\n\n  // CouchDB responds in weird ways when you provide a non-string to _id;\n  // we mimic the behavior for consistency. See issue66 tests for details.\n\n  if (opts.descending) {\n    if ('endkey' in opts && typeof opts.endkey !== 'string') {\n      opts.endkey = '';\n    }\n    if ('startkey' in opts && typeof opts.startkey !== 'string') {\n      opts.limit = 0;\n    }\n  } else {\n    if ('startkey' in opts && typeof opts.startkey !== 'string') {\n      opts.startkey = '';\n    }\n    if ('endkey' in opts && typeof opts.endkey !== 'string') {\n      opts.limit = 0;\n    }\n  }\n  if ('key' in opts && typeof opts.key !== 'string') {\n    opts.limit = 0;\n  }\n\n  return db.allDocs(opts)\n  .then(function (res) {\n    // filter out any design docs that _all_docs might return\n    res.rows = res.rows.filter(function (row) {\n      return !/^_design\\//.test(row.id);\n    });\n    return res;\n  });\n}\n\nfunction find$1(db, requestDef, explain) {\n  if (requestDef.selector) {\n    requestDef.selector = massageSelector(requestDef.selector);\n  }\n\n  if (requestDef.sort) {\n    requestDef.sort = massageSort(requestDef.sort);\n  }\n\n  if (requestDef.use_index) {\n    requestDef.use_index = massageUseIndex(requestDef.use_index);\n  }\n\n  validateFindRequest(requestDef);\n\n  return getIndexes$1(db).then(function (getIndexesRes) {\n\n    db.constructor.emit('debug', ['find', 'planning query', requestDef]);\n    var queryPlan = planQuery(requestDef, getIndexesRes.indexes);\n    db.constructor.emit('debug', ['find', 'query plan', queryPlan]);\n\n    var indexToUse = queryPlan.index;\n\n    validateSort(requestDef, indexToUse);\n\n    var opts = assign({\n      include_docs: true,\n      reduce: false\n    }, queryPlan.queryOpts);\n\n    if ('startkey' in opts && 'endkey' in opts &&\n        collate(opts.startkey, opts.endkey) > 0) {\n      // can't possibly return any results, startkey > endkey\n      return {docs: []};\n    }\n\n    var isDescending = requestDef.sort &&\n      typeof requestDef.sort[0] !== 'string' &&\n      getValue(requestDef.sort[0]) === 'desc';\n\n    if (isDescending) {\n      // either all descending or all ascending\n      opts.descending = true;\n      opts = reverseOptions(opts);\n    }\n\n    if (!queryPlan.inMemoryFields.length) {\n      // no in-memory filtering necessary, so we can let the\n      // database do the limit/skip for us\n      if ('limit' in requestDef) {\n        opts.limit = requestDef.limit;\n      }\n      if ('skip' in requestDef) {\n        opts.skip = requestDef.skip;\n      }\n    }\n\n    if (explain) {\n      return Promise.resolve(queryPlan, opts);\n    }\n\n    return Promise.resolve().then(function () {\n      if (indexToUse.name === '_all_docs') {\n        return doAllDocs(db, opts);\n      } else {\n        var signature = indexToSignature(indexToUse);\n        return abstractMapper.query.call(db, signature, opts);\n      }\n    }).then(function (res) {\n      if (opts.inclusive_start === false) {\n        // may have to manually filter the first one,\n        // since couchdb has no true inclusive_start option\n        res.rows = filterInclusiveStart(res.rows, opts.startkey, indexToUse);\n      }\n\n      if (queryPlan.inMemoryFields.length) {\n        // need to filter some stuff in-memory\n        res.rows = filterInMemoryFields(res.rows, requestDef, queryPlan.inMemoryFields);\n      }\n\n      var resp = {\n        docs: res.rows.map(function (row) {\n          var doc = row.doc;\n          if (requestDef.fields) {\n            return pick(doc, requestDef.fields);\n          }\n          return doc;\n        })\n      };\n\n      if (indexToUse.defaultUsed) {\n        resp.warning = 'no matching index found, create an index to optimize query time';\n      }\n\n      return resp;\n    });\n  });\n}\n\nfunction explain$1(db, requestDef) {\n  return find$1(db, requestDef, true)\n  .then(function (queryPlan) {\n    return {\n      dbname: db.name,\n      index: queryPlan.index,\n      selector: requestDef.selector,\n      range: {\n        start_key: queryPlan.queryOpts.startkey,\n        end_key: queryPlan.queryOpts.endkey,\n      },\n      opts: {\n        use_index: requestDef.use_index || [],\n        bookmark: \"nil\", //hardcoded to match CouchDB since its not supported,\n        limit: requestDef.limit,\n        skip: requestDef.skip,\n        sort: requestDef.sort || {},\n        fields: requestDef.fields,\n        conflicts: false, //hardcoded to match CouchDB since its not supported,\n        r: [49], // hardcoded to match CouchDB since its not support\n      },\n      limit: requestDef.limit,\n      skip: requestDef.skip || 0,\n      fields: requestDef.fields,\n    };\n  });\n}\n\nfunction deleteIndex$1(db, index) {\n\n  if (!index.ddoc) {\n    throw new Error('you must supply an index.ddoc when deleting');\n  }\n\n  if (!index.name) {\n    throw new Error('you must supply an index.name when deleting');\n  }\n\n  var docId = index.ddoc;\n  var viewName = index.name;\n\n  function deltaFun(doc) {\n    if (Object.keys(doc.views).length === 1 && doc.views[viewName]) {\n      // only one view in this ddoc, delete the whole ddoc\n      return {_id: docId, _deleted: true};\n    }\n    // more than one view here, just remove the view\n    delete doc.views[viewName];\n    return doc;\n  }\n\n  return upsert(db, docId, deltaFun).then(function () {\n    return abstractMapper.viewCleanup.apply(db);\n  }).then(function () {\n    return {ok: true};\n  });\n}\n\nvar createIndexAsCallback = callbackify(createIndex$1);\nvar findAsCallback = callbackify(find$1);\nvar explainAsCallback = callbackify(explain$1);\nvar getIndexesAsCallback = callbackify(getIndexes$1);\nvar deleteIndexAsCallback = callbackify(deleteIndex$1);\n\nvar plugin = {};\nplugin.createIndex = toPromise(function (requestDef, callback) {\n\n  if (typeof requestDef !== 'object') {\n    return callback(new Error('you must provide an index to create'));\n  }\n\n  var createIndex$$1 = isRemote(this) ?\n    createIndex : createIndexAsCallback;\n  createIndex$$1(this, requestDef, callback);\n});\n\nplugin.find = toPromise(function (requestDef, callback) {\n\n  if (typeof callback === 'undefined') {\n    callback = requestDef;\n    requestDef = undefined;\n  }\n\n  if (typeof requestDef !== 'object') {\n    return callback(new Error('you must provide search parameters to find()'));\n  }\n\n  var find$$1 = isRemote(this) ? find : findAsCallback;\n  find$$1(this, requestDef, callback);\n});\n\nplugin.explain = toPromise(function (requestDef, callback) {\n\n  if (typeof callback === 'undefined') {\n    callback = requestDef;\n    requestDef = undefined;\n  }\n\n  if (typeof requestDef !== 'object') {\n    return callback(new Error('you must provide search parameters to explain()'));\n  }\n\n  var find$$1 = isRemote(this) ? explain : explainAsCallback;\n  find$$1(this, requestDef, callback);\n});\n\nplugin.getIndexes = toPromise(function (callback) {\n\n  var getIndexes$$1 = isRemote(this) ? getIndexes : getIndexesAsCallback;\n  getIndexes$$1(this, callback);\n});\n\nplugin.deleteIndex = toPromise(function (indexDef, callback) {\n\n  if (typeof indexDef !== 'object') {\n    return callback(new Error('you must provide an index to delete'));\n  }\n\n  var deleteIndex$$1 = isRemote(this) ?\n    deleteIndex : deleteIndexAsCallback;\n  deleteIndex$$1(this, indexDef, callback);\n});\n\nexport default plugin;\n\n\n\n// WEBPACK FOOTER //\n// ../~/pouchdb-find/lib/index-browser.es.js","'use strict';\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nvar scheduleDrain;\n\n{\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n    scheduleDrain = function () {\n      element.data = (called = ++called % 2);\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n    scheduleDrain = function () {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function () {\n\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function () {\n      setTimeout(nextTick, 0);\n    };\n  }\n}\n\nvar draining;\nvar queue = [];\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n    while (++i < len) {\n      oldQueue[i]();\n    }\n    len = queue.length;\n  }\n  draining = false;\n}\n\nmodule.exports = immediate;\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../~/immediate/lib/browser.js","\"use strict\";\n\nconst { ShoppingListRepository } = require(\"./ShoppingListRepository\");\nconst { ShoppingListFactory } = require(\"./ShoppingListFactory\");\nconst { Record } = require(\"immutable\");\n\nclass ShoppingListRepositoryPouchDB extends ShoppingListRepository {\n\n  constructor(db) {\n    super();\n    this.db = db;\n    this._shoppingListFactory = new ShoppingListFactory();\n  }\n\n  _guardShoppingList(shoppingList) {\n    if (!Record.isRecord(shoppingList)) {\n      throw new Error(\"Shopping List must be a Record\");\n    }\n    if (shoppingList._id === undefined) {\n      throw new Error(\"Shopping List _id must be set\");\n    }\n    if (shoppingList.type != \"list\") {\n      throw new Error(\"Shopping List type must be list\");\n    }\n  }\n\n  _guardShoppingListItem(shoppingListItem) {\n    if (!Record.isRecord(shoppingListItem)) {\n      throw new Error(\"Shopping List Item must be a Record\");\n    }\n    if (shoppingListItem._id === undefined) {\n      throw new Error(\"Shopping List Item _id must be set\");\n    }\n    if (shoppingListItem.type != \"item\") {\n      throw new Error(\"Shopping List Item type must be item\");\n    }\n  }\n\n  _guardRequest(request) {\n    if (!request) {\n      throw new Error(\"Request must be defined\");\n    }\n    if (!request.selector) {\n      throw new Error(\"Request must have a selector property\");\n    }\n    if (!request.selector.type) {\n      throw new Error(\"Request selector must have a type property\");\n    }\n  }\n\n  _guardShoppingListRequest(request) {\n    this._guardRequest(request);\n    if (request.selector.type != \"list\") {\n      throw new Error(\"Request selector must have a type property with a value of 'list'\");\n    }\n  }\n\n  _guardShoppingListItemRequest(request) {\n    this._guardRequest(request);\n    if (request.selector.type != \"item\") {\n      throw new Error(\"Request selector must have a type property with a value of 'item'\");\n    }\n  }\n\n  _put(record) {\n    const updatedAt = new Date().toISOString();\n    if (!record._rev) {\n      record = record.mergeDeep({\n        createdAt: updatedAt\n      });\n    }\n    record = record.mergeDeep({\n      updatedAt: updatedAt\n    });\n    return this.db.put(record.toJSON()).then(result => {\n      return record.mergeDeep({\n        _id: result.id,\n        _rev: result.rev\n      });\n    });\n  }\n\n  _get(id) {\n    return this.db.get(id);\n  }\n\n  _delete(record) {\n    const updatedAt = new Date().toISOString();\n    record = record.mergeDeep({\n      _deleted: true,\n      updatedAt: updatedAt\n    });\n    return this.db.put(record.toJSON()).then(result => {\n      return record.mergeDeep({\n        _rev: result.rev\n      });\n    });\n  }\n\n  _ensureIndexOfType() {\n    return this.db.createIndex({\n      index: {\n        fields: [\"type\"]\n      }\n    });\n  }\n\n  _ensureIndexOfTypeAndList() {\n    return this.db.createIndex({\n      index: {\n        fields: [\"type\", \"list\"]\n      }\n    });\n  }\n\n  _ensureIndexOfTypeAndChecked() {\n    return this.db.createIndex({\n      index: {\n        fields: [\"type\", \"checked\"]\n      }\n    });\n  }\n\n  _ensureIndexOfTypeAndListAndChecked() {\n    return this.db.createIndex({\n      index: {\n        fields: [\"type\", \"list\", \"checked\"]\n      }\n    });\n  }\n\n  ensureIndexes() {\n    return Promise.all([\n      this._ensureIndexOfType(),\n      this._ensureIndexOfTypeAndList(),\n      this._ensureIndexOfTypeAndChecked(),\n      this._ensureIndexOfTypeAndListAndChecked()\n    ]);\n  }\n\n  put(shoppingList) {\n    this._guardShoppingList(shoppingList);\n    return this._put(shoppingList);\n  }\n\n  putBulk(shoppingLists) {\n    let putLists = [];\n    shoppingLists.forEach(shoppingList => {\n      putLists.push(this.put(shoppingList));\n    });\n    return Promise.all(putLists).then(shoppingLists => {\n      return this._shoppingListFactory.newListOfShoppingLists(shoppingLists);\n    });\n  }\n\n  get(shoppingListId) {\n    return this._get(shoppingListId).then(doc => {\n      const shoppingList = this._shoppingListFactory.newShoppingList(doc);\n      this._guardShoppingList(shoppingList);\n      return shoppingList;\n    });\n  }\n\n  find(request = { selector: { type: \"list\" } }) {\n    this._guardShoppingListRequest(request);\n    return this.db.find(request).then(result => {\n      if (result.warning) {\n        console.warn(result.warning);\n      }\n      let listOfShoppingLists = this._shoppingListFactory.newListOfShoppingLists();\n      result.docs.forEach(doc => {\n        listOfShoppingLists = listOfShoppingLists.push(this._shoppingListFactory.newShoppingList(doc));\n      });\n      return listOfShoppingLists;\n    });\n  }\n\n  delete(shoppingList) {\n    this._guardShoppingList(shoppingList);\n    return this._delete(shoppingList).then(shoppingList => {\n      return this.deleteItemsBulkByFind({\n        selector: {\n          type: \"item\",\n          list: shoppingList._id\n        }\n      }).then(listOfShoppingListItems => {\n        return shoppingList;\n      });\n    });\n  }\n\n  putItem(shoppingListItem) {\n    this._guardShoppingListItem(shoppingListItem);\n    return this._put(shoppingListItem);\n  }\n\n  putItemsBulk(shoppingListItems) {\n    let putItems = [];\n    shoppingListItems.forEach(shoppingListItem => {\n      putItems.push(this.putItem(shoppingListItem));\n    });\n    return Promise.all(putItems).then(shoppingListItems => {\n      return this._shoppingListFactory.newListOfShoppingListItems(shoppingListItems);\n    });\n  }\n\n  getItem(shoppingListItemId) {\n    return this._get(shoppingListItemId).then(doc => {\n      const shoppingListItem = this._shoppingListFactory.newShoppingListItem(doc);\n      this._guardShoppingListItem(shoppingListItem);\n      return shoppingListItem;\n    });\n  }\n\n  findItems(request = { selector: { type: \"item\" } }) {\n    this._guardShoppingListItemRequest(request);\n    return this.db.find(request).then(result => {\n      if (result.warning) {\n        console.warn(result.warning);\n      }\n      let listOfShoppingListItems = this._shoppingListFactory.newListOfShoppingListItems();\n      result.docs.forEach(doc => {\n        listOfShoppingListItems = listOfShoppingListItems.push(this._shoppingListFactory.newShoppingListItem(doc));\n      });\n      return listOfShoppingListItems;\n    });\n  }\n\n  findItemsCountByList(request = { selector: { type: \"item\" }, fields: [ \"list\" ] }) {\n    if (request.fields && !request.fields.includes(\"list\")) {\n      throw new Error(\"Request must have a fields property that includes a value of 'list'\");\n    }\n    return this.findItems(request).then(listOfShoppingListItems => {\n      return listOfShoppingListItems.countBy(shoppingListItem => {\n        return shoppingListItem.list;\n      });\n    });\n  }\n\n  deleteItem(shoppingListItem) {\n    this._guardShoppingListItem(shoppingListItem);\n    return this._delete(shoppingListItem);\n  }\n\n  deleteItemsBulk(shoppingListItems) {\n    let deletedItems = [];\n    shoppingListItems.forEach(shoppingListItem => {\n      deletedItems.push(this.deleteItem(shoppingListItem));\n    });\n    return Promise.all(deletedItems).then(shoppingListItems => {\n      return this._shoppingListFactory.newListOfShoppingListItems(shoppingListItems);\n    });\n  }\n\n  deleteItemsBulkByFind(request = { selector: { type: \"item\" } }) {\n    if (request.fields) {\n      throw new Error(\"Request must not have a fields property\");\n    }\n    return this.findItems(request).then(listOfShoppingListItems => {\n      return this.deleteItemsBulk(listOfShoppingListItems);\n    });\n  }\n\n}\n\nexports.ShoppingListRepositoryPouchDB = ShoppingListRepositoryPouchDB;\n\n\n\n// WEBPACK FOOTER //\n// ../~/ibm-shopping-list-model/src/ShoppingListRepositoryPouchDB.js","exports.nextTick = function nextTick(fn) {\n\tsetTimeout(fn, 0);\n};\n\nexports.platform = exports.arch = \nexports.execPath = exports.title = 'browser';\nexports.pid = 1;\nexports.browser = true;\nexports.env = {};\nexports.argv = [];\n\nexports.binding = function (name) {\n\tthrow new Error('No such module. (Possibly not yet loaded)')\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    exports.cwd = function () { return cwd };\n    exports.chdir = function (dir) {\n        if (!path) path = require('path');\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n\nexports.exit = exports.kill = \nexports.umask = exports.dlopen = \nexports.uptime = exports.memoryUsage = \nexports.uvCounters = function() {};\nexports.features = {};\n\n\n\n// WEBPACK FOOTER //\n// /usr/local/lib/~/preact-cli/~/node-libs-browser/mock/process.js","'use strict';\nvar immediate = require('immediate');\n\n/* istanbul ignore next */\nfunction INTERNAL() {}\n\nvar handlers = {};\n\nvar REJECTED = ['REJECTED'];\nvar FULFILLED = ['FULFILLED'];\nvar PENDING = ['PENDING'];\n\nmodule.exports = Promise;\n\nfunction Promise(resolver) {\n  if (typeof resolver !== 'function') {\n    throw new TypeError('resolver must be a function');\n  }\n  this.state = PENDING;\n  this.queue = [];\n  this.outcome = void 0;\n  if (resolver !== INTERNAL) {\n    safelyResolveThenable(this, resolver);\n  }\n}\n\nPromise.prototype[\"catch\"] = function (onRejected) {\n  return this.then(null, onRejected);\n};\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n    typeof onRejected !== 'function' && this.state === REJECTED) {\n    return this;\n  }\n  var promise = new this.constructor(INTERNAL);\n  if (this.state !== PENDING) {\n    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n    unwrap(promise, resolver, this.outcome);\n  } else {\n    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n  }\n\n  return promise;\n};\nfunction QueueItem(promise, onFulfilled, onRejected) {\n  this.promise = promise;\n  if (typeof onFulfilled === 'function') {\n    this.onFulfilled = onFulfilled;\n    this.callFulfilled = this.otherCallFulfilled;\n  }\n  if (typeof onRejected === 'function') {\n    this.onRejected = onRejected;\n    this.callRejected = this.otherCallRejected;\n  }\n}\nQueueItem.prototype.callFulfilled = function (value) {\n  handlers.resolve(this.promise, value);\n};\nQueueItem.prototype.otherCallFulfilled = function (value) {\n  unwrap(this.promise, this.onFulfilled, value);\n};\nQueueItem.prototype.callRejected = function (value) {\n  handlers.reject(this.promise, value);\n};\nQueueItem.prototype.otherCallRejected = function (value) {\n  unwrap(this.promise, this.onRejected, value);\n};\n\nfunction unwrap(promise, func, value) {\n  immediate(function () {\n    var returnValue;\n    try {\n      returnValue = func(value);\n    } catch (e) {\n      return handlers.reject(promise, e);\n    }\n    if (returnValue === promise) {\n      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n    } else {\n      handlers.resolve(promise, returnValue);\n    }\n  });\n}\n\nhandlers.resolve = function (self, value) {\n  var result = tryCatch(getThen, value);\n  if (result.status === 'error') {\n    return handlers.reject(self, result.value);\n  }\n  var thenable = result.value;\n\n  if (thenable) {\n    safelyResolveThenable(self, thenable);\n  } else {\n    self.state = FULFILLED;\n    self.outcome = value;\n    var i = -1;\n    var len = self.queue.length;\n    while (++i < len) {\n      self.queue[i].callFulfilled(value);\n    }\n  }\n  return self;\n};\nhandlers.reject = function (self, error) {\n  self.state = REJECTED;\n  self.outcome = error;\n  var i = -1;\n  var len = self.queue.length;\n  while (++i < len) {\n    self.queue[i].callRejected(error);\n  }\n  return self;\n};\n\nfunction getThen(obj) {\n  // Make sure we only access the accessor once as required by the spec\n  var then = obj && obj.then;\n  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {\n    return function appyThen() {\n      then.apply(obj, arguments);\n    };\n  }\n}\n\nfunction safelyResolveThenable(self, thenable) {\n  // Either fulfill, reject or reject with error\n  var called = false;\n  function onError(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.reject(self, value);\n  }\n\n  function onSuccess(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.resolve(self, value);\n  }\n\n  function tryToUnwrap() {\n    thenable(onSuccess, onError);\n  }\n\n  var result = tryCatch(tryToUnwrap);\n  if (result.status === 'error') {\n    onError(result.value);\n  }\n}\n\nfunction tryCatch(func, value) {\n  var out = {};\n  try {\n    out.value = func(value);\n    out.status = 'success';\n  } catch (e) {\n    out.status = 'error';\n    out.value = e;\n  }\n  return out;\n}\n\nPromise.resolve = resolve;\nfunction resolve(value) {\n  if (value instanceof this) {\n    return value;\n  }\n  return handlers.resolve(new this(INTERNAL), value);\n}\n\nPromise.reject = reject;\nfunction reject(reason) {\n  var promise = new this(INTERNAL);\n  return handlers.reject(promise, reason);\n}\n\nPromise.all = all;\nfunction all(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var values = new Array(len);\n  var resolved = 0;\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    allResolver(iterable[i], i);\n  }\n  return promise;\n  function allResolver(value, i) {\n    self.resolve(value).then(resolveFromAll, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n    function resolveFromAll(outValue) {\n      values[i] = outValue;\n      if (++resolved === len && !called) {\n        called = true;\n        handlers.resolve(promise, values);\n      }\n    }\n  }\n}\n\nPromise.race = race;\nfunction race(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    resolver(iterable[i]);\n  }\n  return promise;\n  function resolver(value) {\n    self.resolve(value).then(function (response) {\n      if (!called) {\n        called = true;\n        handlers.resolve(promise, response);\n      }\n    }, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../~/lie/lib/browser.js","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n\n\n// WEBPACK FOOTER //\n// ../~/debug/src/debug.js"],"sourceRoot":""}